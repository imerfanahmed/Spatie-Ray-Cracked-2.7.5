"use strict";
var ST = Object.defineProperty;
var IT = (e, t, n) =>
  t in e
    ? ST(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
    : (e[t] = n);
var At = (e, t, n) => (IT(e, typeof t != "symbol" ? t + "" : t, n), n);
const xe = require("electron"),
  fI = require("node:os"),
  Gl = require("node:path"),
  pt = require("path"),
  hc = require("tty"),
  wr = require("util"),
  Xt = require("fs"),
  ha = require("net"),
  Hi = require("events"),
  Kr = require("stream"),
  mc = require("zlib"),
  ks = require("buffer"),
  dI = require("string_decoder"),
  X0 = require("querystring"),
  Ya = require("url"),
  Ws = require("http"),
  pr = require("crypto"),
  Fr = require("os"),
  $T = require("constants"),
  gc = require("assert"),
  Ql = require("child_process"),
  pI = require("https"),
  CT = require("tls"),
  RT = require("dns"),
  kT = require("node:crypto");
var Tn =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function Wl(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")
    ? e.default
    : e;
}
var Ug = { exports: {} },
  Fg = { exports: {} };
/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */ var TT = pt.relative,
  wi = LT,
  NT = process.cwd();
function hI(e, t) {
  for (
    var n = e.split(/[ ,]+/), r = String(t).toLowerCase(), i = 0;
    i < n.length;
    i++
  ) {
    var a = n[i];
    if (a && (a === "*" || a.toLowerCase() === r)) return !0;
  }
  return !1;
}
function OT(e, t, n) {
  var r = Object.getOwnPropertyDescriptor(e, t),
    i = r.value;
  return (
    (r.get = function () {
      return i;
    }),
    r.writable &&
      (r.set = function (s) {
        return (i = s);
      }),
    delete r.value,
    delete r.writable,
    Object.defineProperty(e, t, r),
    r
  );
}
function PT(e) {
  for (var t = "", n = 0; n < e; n++) t += ", arg" + n;
  return t.substr(2);
}
function DT(e) {
  var t = this.name + ": " + this.namespace;
  this.message && (t += " deprecated " + this.message);
  for (var n = 0; n < e.length; n++)
    t +=
      `
    at ` + e[n].toString();
  return t;
}
function LT(e) {
  if (!e) throw new TypeError("argument namespace is required");
  var t = jd(),
    n = Oo(t[1]),
    r = n[0];
  function i(a) {
    Zf.call(i, a);
  }
  return (
    (i._file = r),
    (i._ignored = UT(e)),
    (i._namespace = e),
    (i._traced = FT(e)),
    (i._warned = Object.create(null)),
    (i.function = qT),
    (i.property = GT),
    i
  );
}
function BT(e, t) {
  var n =
    typeof e.listenerCount != "function"
      ? e.listeners(t).length
      : e.listenerCount(t);
  return n > 0;
}
function UT(e) {
  if (process.noDeprecation) return !0;
  var t = process.env.NO_DEPRECATION || "";
  return hI(t, e);
}
function FT(e) {
  if (process.traceDeprecation) return !0;
  var t = process.env.TRACE_DEPRECATION || "";
  return hI(t, e);
}
function Zf(e, t) {
  var n = BT(process, "deprecation");
  if (!(!n && this._ignored)) {
    var r,
      i,
      a,
      s,
      o = 0,
      c = !1,
      l = jd(),
      f = this._file;
    for (
      t
        ? ((s = t), (a = Oo(l[1])), (a.name = s.name), (f = a[0]))
        : ((o = 2), (s = Oo(l[o])), (a = s));
      o < l.length;
      o++
    )
      if (((r = Oo(l[o])), (i = r[0]), i === f)) c = !0;
      else if (i === this._file) f = this._file;
      else if (c) break;
    var u = r ? s.join(":") + "__" + r.join(":") : void 0;
    if (!(u !== void 0 && u in this._warned)) {
      this._warned[u] = !0;
      var d = e;
      if ((d || (d = a === s || !a.name ? E1(s) : E1(a)), n)) {
        var p = mI(this._namespace, d, l.slice(o));
        process.emit("deprecation", p);
        return;
      }
      var h = process.stderr.isTTY ? MT : jT,
        m = h.call(this, d, r, l.slice(o));
      process.stderr.write(
        m +
          `
`,
        "utf8",
      );
    }
  }
}
function Oo(e) {
  var t = e.getFileName() || "<anonymous>",
    n = e.getLineNumber(),
    r = e.getColumnNumber();
  e.isEval() && (t = e.getEvalOrigin() + ", " + t);
  var i = [t, n, r];
  return (i.callSite = e), (i.name = e.getFunctionName()), i;
}
function E1(e) {
  var t = e.callSite,
    n = e.name;
  n || (n = "<anonymous@" + J0(e) + ">");
  var r = t.getThis(),
    i = r && t.getTypeName();
  return (
    i === "Object" && (i = void 0),
    i === "Function" && (i = r.name || i),
    i && t.getMethodName() ? i + "." + n : n
  );
}
function jT(e, t, n) {
  var r = new Date().toUTCString(),
    i = r + " " + this._namespace + " deprecated " + e;
  if (this._traced) {
    for (var a = 0; a < n.length; a++)
      i +=
        `
    at ` + n[a].toString();
    return i;
  }
  return t && (i += " at " + J0(t)), i;
}
function MT(e, t, n) {
  var r =
    "\x1B[36;1m" +
    this._namespace +
    "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" +
    e +
    "\x1B[39m";
  if (this._traced) {
    for (var i = 0; i < n.length; i++)
      r +=
        `
    \x1B[36mat ` +
        n[i].toString() +
        "\x1B[39m";
    return r;
  }
  return t && (r += " \x1B[36m" + J0(t) + "\x1B[39m"), r;
}
function J0(e) {
  return TT(NT, e[0]) + ":" + e[1] + ":" + e[2];
}
function jd() {
  var e = Error.stackTraceLimit,
    t = {},
    n = Error.prepareStackTrace;
  (Error.prepareStackTrace = HT),
    (Error.stackTraceLimit = Math.max(10, e)),
    Error.captureStackTrace(t);
  var r = t.stack.slice(1);
  return (Error.prepareStackTrace = n), (Error.stackTraceLimit = e), r;
}
function HT(e, t) {
  return t;
}
function qT(e, t) {
  if (typeof e != "function")
    throw new TypeError("argument fn must be a function");
  var n = PT(e.length),
    r = jd(),
    i = Oo(r[1]);
  i.name = e.name;
  var a = new Function(
    "fn",
    "log",
    "deprecate",
    "message",
    "site",
    `"use strict"
return function (` +
      n +
      `) {log.call(deprecate, message, site)
return fn.apply(this, arguments)
}`,
  )(e, Zf, this, t, i);
  return a;
}
function GT(e, t, n) {
  if (!e || (typeof e != "object" && typeof e != "function"))
    throw new TypeError("argument obj must be object");
  var r = Object.getOwnPropertyDescriptor(e, t);
  if (!r) throw new TypeError("must call property on owner object");
  if (!r.configurable) throw new TypeError("property must be configurable");
  var i = this,
    a = jd(),
    s = Oo(a[1]);
  (s.name = t), "value" in r && (r = OT(e, t));
  var o = r.get,
    c = r.set;
  typeof o == "function" &&
    (r.get = function () {
      return Zf.call(i, n, s), o.apply(this, arguments);
    }),
    typeof c == "function" &&
      (r.set = function () {
        return Zf.call(i, n, s), c.apply(this, arguments);
      }),
    Object.defineProperty(e, t, r);
}
function mI(e, t, n) {
  var r = new Error(),
    i;
  return (
    Object.defineProperty(r, "constructor", { value: mI }),
    Object.defineProperty(r, "message", {
      configurable: !0,
      enumerable: !1,
      value: t,
      writable: !0,
    }),
    Object.defineProperty(r, "name", {
      enumerable: !1,
      configurable: !0,
      value: "DeprecationError",
      writable: !0,
    }),
    Object.defineProperty(r, "namespace", {
      configurable: !0,
      enumerable: !1,
      value: e,
      writable: !0,
    }),
    Object.defineProperty(r, "stack", {
      configurable: !0,
      enumerable: !1,
      get: function () {
        return i !== void 0 ? i : (i = DT.call(this, n));
      },
      set: function (s) {
        i = s;
      },
    }),
    r
  );
}
var Nc = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */ var w1;
function qi() {
  if (w1) return Nc.exports;
  (w1 = 1), (Nc.exports = i), (Nc.exports.format = a), (Nc.exports.parse = s);
  var e = /\B(?=(\d{3})+(?!\d))/g,
    t = /(?:\.0*|(\.[^0]+)0+)$/,
    n = {
      b: 1,
      kb: 1024,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5),
    },
    r = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function i(o, c) {
    return typeof o == "string" ? s(o) : typeof o == "number" ? a(o, c) : null;
  }
  function a(o, c) {
    if (!Number.isFinite(o)) return null;
    var l = Math.abs(o),
      f = (c && c.thousandsSeparator) || "",
      u = (c && c.unitSeparator) || "",
      d = c && c.decimalPlaces !== void 0 ? c.decimalPlaces : 2,
      p = !!(c && c.fixedDecimals),
      h = (c && c.unit) || "";
    (!h || !n[h.toLowerCase()]) &&
      (l >= n.pb
        ? (h = "PB")
        : l >= n.tb
        ? (h = "TB")
        : l >= n.gb
        ? (h = "GB")
        : l >= n.mb
        ? (h = "MB")
        : l >= n.kb
        ? (h = "KB")
        : (h = "B"));
    var m = o / n[h.toLowerCase()],
      g = m.toFixed(d);
    return (
      p || (g = g.replace(t, "$1")),
      f &&
        (g = g
          .split(".")
          .map(function (v, y) {
            return y === 0 ? v.replace(e, f) : v;
          })
          .join(".")),
      g + u + h
    );
  }
  function s(o) {
    if (typeof o == "number" && !isNaN(o)) return o;
    if (typeof o != "string") return null;
    var c = r.exec(o),
      l,
      f = "b";
    return (
      c
        ? ((l = parseFloat(c[1])), (f = c[4].toLowerCase()))
        : ((l = parseInt(o, 10)), (f = "b")),
      isNaN(l) ? null : Math.floor(n[f] * l)
    );
  }
  return Nc.exports;
}
var Nu = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var x1;
function zs() {
  if (x1) return Nu;
  x1 = 1;
  var e =
      /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,
    t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,
    n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,
    r = /\\([\u000b\u0020-\u00ff])/g,
    i = /([\\"])/g,
    a = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  (Nu.format = s), (Nu.parse = o);
  function s(u) {
    if (!u || typeof u != "object")
      throw new TypeError("argument obj is required");
    var d = u.parameters,
      p = u.type;
    if (!p || !a.test(p)) throw new TypeError("invalid type");
    var h = p;
    if (d && typeof d == "object")
      for (var m, g = Object.keys(d).sort(), v = 0; v < g.length; v++) {
        if (((m = g[v]), !n.test(m)))
          throw new TypeError("invalid parameter name");
        h += "; " + m + "=" + l(d[m]);
      }
    return h;
  }
  function o(u) {
    if (!u) throw new TypeError("argument string is required");
    var d = typeof u == "object" ? c(u) : u;
    if (typeof d != "string")
      throw new TypeError("argument string is required to be a string");
    var p = d.indexOf(";"),
      h = p !== -1 ? d.slice(0, p).trim() : d.trim();
    if (!a.test(h)) throw new TypeError("invalid media type");
    var m = new f(h.toLowerCase());
    if (p !== -1) {
      var g, v, y;
      for (e.lastIndex = p; (v = e.exec(d)); ) {
        if (v.index !== p) throw new TypeError("invalid parameter format");
        (p += v[0].length),
          (g = v[1].toLowerCase()),
          (y = v[2]),
          y.charCodeAt(0) === 34 &&
            ((y = y.slice(1, -1)),
            y.indexOf("\\") !== -1 && (y = y.replace(r, "$1"))),
          (m.parameters[g] = y);
      }
      if (p !== d.length) throw new TypeError("invalid parameter format");
    }
    return m;
  }
  function c(u) {
    var d;
    if (
      (typeof u.getHeader == "function"
        ? (d = u.getHeader("content-type"))
        : typeof u.headers == "object" &&
          (d = u.headers && u.headers["content-type"]),
      typeof d != "string")
    )
      throw new TypeError("content-type header is missing from object");
    return d;
  }
  function l(u) {
    var d = String(u);
    if (n.test(d)) return d;
    if (d.length > 0 && !t.test(d))
      throw new TypeError("invalid parameter value");
    return '"' + d.replace(i, "\\$1") + '"';
  }
  function f(u) {
    (this.parameters = Object.create(null)), (this.type = u);
  }
  return Nu;
}
var gI = { exports: {} },
  Md = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? QT : WT);
function QT(e, t) {
  return (e.__proto__ = t), e;
}
function WT(e, t) {
  for (var n in t) Object.prototype.hasOwnProperty.call(e, n) || (e[n] = t[n]);
  return e;
}
const zT = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a Teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Too Early",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required",
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var Z0 = zT,
  Hd = Ei;
Ei.message = Z0;
Ei.code = KT(Z0);
Ei.codes = VT(Z0);
Ei.redirect = { 300: !0, 301: !0, 302: !0, 303: !0, 305: !0, 307: !0, 308: !0 };
Ei.empty = { 204: !0, 205: !0, 304: !0 };
Ei.retry = { 502: !0, 503: !0, 504: !0 };
function KT(e) {
  var t = {};
  return (
    Object.keys(e).forEach(function (r) {
      var i = e[r],
        a = Number(r);
      t[i.toLowerCase()] = a;
    }),
    t
  );
}
function VT(e) {
  return Object.keys(e).map(function (n) {
    return Number(n);
  });
}
function YT(e) {
  var t = e.toLowerCase();
  if (!Object.prototype.hasOwnProperty.call(Ei.code, t))
    throw new Error('invalid status message: "' + e + '"');
  return Ei.code[t];
}
function A1(e) {
  if (!Object.prototype.hasOwnProperty.call(Ei.message, e))
    throw new Error("invalid status code: " + e);
  return Ei.message[e];
}
function Ei(e) {
  if (typeof e == "number") return A1(e);
  if (typeof e != "string")
    throw new TypeError("code must be a number or string");
  var t = parseInt(e, 10);
  return isNaN(t) ? YT(e) : A1(t);
}
var jg = { exports: {} },
  Ou = { exports: {} },
  S1;
function XT() {
  return (
    S1 ||
      ((S1 = 1),
      typeof Object.create == "function"
        ? (Ou.exports = function (t, n) {
            n &&
              ((t.super_ = n),
              (t.prototype = Object.create(n.prototype, {
                constructor: {
                  value: t,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })));
          })
        : (Ou.exports = function (t, n) {
            if (n) {
              t.super_ = n;
              var r = function () {};
              (r.prototype = n.prototype),
                (t.prototype = new r()),
                (t.prototype.constructor = t);
            }
          })),
    Ou.exports
  );
}
try {
  var I1 = require("util");
  if (typeof I1.inherits != "function") throw "";
  jg.exports = I1.inherits;
} catch {
  jg.exports = XT();
}
var JT = jg.exports;
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var ZT = eN;
function eN(e) {
  return e
    .split(" ")
    .map(function (t) {
      return t.slice(0, 1).toUpperCase() + t.slice(1);
    })
    .join("")
    .replace(/[^ _0-9a-z]/gi, "");
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e) {
  var t = wi("http-errors"),
    n = Md,
    r = Hd,
    i = JT,
    a = ZT;
  (e.exports = o),
    (e.exports.HttpError = c()),
    (e.exports.isHttpError = f(e.exports.HttpError)),
    p(e.exports, r.codes, e.exports.HttpError);
  function s(m) {
    return +(String(m).charAt(0) + "00");
  }
  function o() {
    for (var m, g, v = 500, y = {}, _ = 0; _ < arguments.length; _++) {
      var E = arguments[_],
        R = typeof E;
      if (R === "object" && E instanceof Error)
        (m = E), (v = m.status || m.statusCode || v);
      else if (R === "number" && _ === 0) v = E;
      else if (R === "string") g = E;
      else if (R === "object") y = E;
      else
        throw new TypeError("argument #" + (_ + 1) + " unsupported type " + R);
    }
    typeof v == "number" &&
      (v < 400 || v >= 600) &&
      t("non-error status code; use only 4xx or 5xx status codes"),
      (typeof v != "number" || (!r.message[v] && (v < 400 || v >= 600))) &&
        (v = 500);
    var A = o[v] || o[s(v)];
    m ||
      ((m = A ? new A(g) : new Error(g || r.message[v])),
      Error.captureStackTrace(m, o)),
      (!A || !(m instanceof A) || m.status !== v) &&
        ((m.expose = v < 500), (m.status = m.statusCode = v));
    for (var I in y) I !== "status" && I !== "statusCode" && (m[I] = y[I]);
    return m;
  }
  function c() {
    function m() {
      throw new TypeError("cannot construct abstract class");
    }
    return i(m, Error), m;
  }
  function l(m, g, v) {
    var y = h(g);
    function _(E) {
      var R = E ?? r.message[v],
        A = new Error(R);
      return (
        Error.captureStackTrace(A, _),
        n(A, _.prototype),
        Object.defineProperty(A, "message", {
          enumerable: !0,
          configurable: !0,
          value: R,
          writable: !0,
        }),
        Object.defineProperty(A, "name", {
          enumerable: !1,
          configurable: !0,
          value: y,
          writable: !0,
        }),
        A
      );
    }
    return (
      i(_, m),
      d(_, y),
      (_.prototype.status = v),
      (_.prototype.statusCode = v),
      (_.prototype.expose = !0),
      _
    );
  }
  function f(m) {
    return function (v) {
      return !v || typeof v != "object"
        ? !1
        : v instanceof m
        ? !0
        : v instanceof Error &&
          typeof v.expose == "boolean" &&
          typeof v.statusCode == "number" &&
          v.status === v.statusCode;
    };
  }
  function u(m, g, v) {
    var y = h(g);
    function _(E) {
      var R = E ?? r.message[v],
        A = new Error(R);
      return (
        Error.captureStackTrace(A, _),
        n(A, _.prototype),
        Object.defineProperty(A, "message", {
          enumerable: !0,
          configurable: !0,
          value: R,
          writable: !0,
        }),
        Object.defineProperty(A, "name", {
          enumerable: !1,
          configurable: !0,
          value: y,
          writable: !0,
        }),
        A
      );
    }
    return (
      i(_, m),
      d(_, y),
      (_.prototype.status = v),
      (_.prototype.statusCode = v),
      (_.prototype.expose = !1),
      _
    );
  }
  function d(m, g) {
    var v = Object.getOwnPropertyDescriptor(m, "name");
    v && v.configurable && ((v.value = g), Object.defineProperty(m, "name", v));
  }
  function p(m, g, v) {
    g.forEach(function (_) {
      var E,
        R = a(r.message[_]);
      switch (s(_)) {
        case 400:
          E = l(v, R, _);
          break;
        case 500:
          E = u(v, R, _);
          break;
      }
      E && ((m[_] = E), (m[R] = E));
    });
  }
  function h(m) {
    return m.substr(-5) !== "Error" ? m + "Error" : m;
  }
})(gI);
var Gi = gI.exports,
  Mg = { exports: {} },
  Pu = { exports: {} },
  Du = { exports: {} },
  rh,
  $1;
function tN() {
  if ($1) return rh;
  $1 = 1;
  var e = 1e3,
    t = e * 60,
    n = t * 60,
    r = n * 24,
    i = r * 365.25;
  rh = function (l, f) {
    f = f || {};
    var u = typeof l;
    if (u === "string" && l.length > 0) return a(l);
    if (u === "number" && isNaN(l) === !1) return f.long ? o(l) : s(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(l),
    );
  };
  function a(l) {
    if (((l = String(l)), !(l.length > 100))) {
      var f =
        /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
          l,
        );
      if (f) {
        var u = parseFloat(f[1]),
          d = (f[2] || "ms").toLowerCase();
        switch (d) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return u * i;
          case "days":
          case "day":
          case "d":
            return u * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return u * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return u * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return u * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return u;
          default:
            return;
        }
      }
    }
  }
  function s(l) {
    return l >= r
      ? Math.round(l / r) + "d"
      : l >= n
      ? Math.round(l / n) + "h"
      : l >= t
      ? Math.round(l / t) + "m"
      : l >= e
      ? Math.round(l / e) + "s"
      : l + "ms";
  }
  function o(l) {
    return (
      c(l, r, "day") ||
      c(l, n, "hour") ||
      c(l, t, "minute") ||
      c(l, e, "second") ||
      l + " ms"
    );
  }
  function c(l, f, u) {
    if (!(l < f))
      return l < f * 1.5
        ? Math.floor(l / f) + " " + u
        : Math.ceil(l / f) + " " + u + "s";
  }
  return rh;
}
var C1;
function vI() {
  return (
    C1 ||
      ((C1 = 1),
      (function (e, t) {
        (t = e.exports = i.debug = i.default = i),
          (t.coerce = c),
          (t.disable = s),
          (t.enable = a),
          (t.enabled = o),
          (t.humanize = tN()),
          (t.names = []),
          (t.skips = []),
          (t.formatters = {});
        var n;
        function r(l) {
          var f = 0,
            u;
          for (u in l) (f = (f << 5) - f + l.charCodeAt(u)), (f |= 0);
          return t.colors[Math.abs(f) % t.colors.length];
        }
        function i(l) {
          function f() {
            if (f.enabled) {
              var u = f,
                d = +new Date(),
                p = d - (n || d);
              (u.diff = p), (u.prev = n), (u.curr = d), (n = d);
              for (
                var h = new Array(arguments.length), m = 0;
                m < h.length;
                m++
              )
                h[m] = arguments[m];
              (h[0] = t.coerce(h[0])),
                typeof h[0] != "string" && h.unshift("%O");
              var g = 0;
              (h[0] = h[0].replace(/%([a-zA-Z%])/g, function (y, _) {
                if (y === "%%") return y;
                g++;
                var E = t.formatters[_];
                if (typeof E == "function") {
                  var R = h[g];
                  (y = E.call(u, R)), h.splice(g, 1), g--;
                }
                return y;
              })),
                t.formatArgs.call(u, h);
              var v = f.log || t.log || console.log.bind(console);
              v.apply(u, h);
            }
          }
          return (
            (f.namespace = l),
            (f.enabled = t.enabled(l)),
            (f.useColors = t.useColors()),
            (f.color = r(l)),
            typeof t.init == "function" && t.init(f),
            f
          );
        }
        function a(l) {
          t.save(l), (t.names = []), (t.skips = []);
          for (
            var f = (typeof l == "string" ? l : "").split(/[\s,]+/),
              u = f.length,
              d = 0;
            d < u;
            d++
          )
            f[d] &&
              ((l = f[d].replace(/\*/g, ".*?")),
              l[0] === "-"
                ? t.skips.push(new RegExp("^" + l.substr(1) + "$"))
                : t.names.push(new RegExp("^" + l + "$")));
        }
        function s() {
          t.enable("");
        }
        function o(l) {
          var f, u;
          for (f = 0, u = t.skips.length; f < u; f++)
            if (t.skips[f].test(l)) return !1;
          for (f = 0, u = t.names.length; f < u; f++)
            if (t.names[f].test(l)) return !0;
          return !1;
        }
        function c(l) {
          return l instanceof Error ? l.stack || l.message : l;
        }
      })(Du, Du.exports)),
    Du.exports
  );
}
var R1;
function nN() {
  return (
    R1 ||
      ((R1 = 1),
      (function (e, t) {
        (t = e.exports = vI()),
          (t.log = i),
          (t.formatArgs = r),
          (t.save = a),
          (t.load = s),
          (t.useColors = n),
          (t.storage =
            typeof chrome < "u" && typeof chrome.storage < "u"
              ? chrome.storage.local
              : o()),
          (t.colors = [
            "lightseagreen",
            "forestgreen",
            "goldenrod",
            "dodgerblue",
            "darkorchid",
            "crimson",
          ]);
        function n() {
          return typeof window < "u" &&
            window.process &&
            window.process.type === "renderer"
            ? !0
            : (typeof document < "u" &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
                (typeof window < "u" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent
                    .toLowerCase()
                    .match(/applewebkit\/(\d+)/));
        }
        t.formatters.j = function (c) {
          try {
            return JSON.stringify(c);
          } catch (l) {
            return "[UnexpectedJSONParseError]: " + l.message;
          }
        };
        function r(c) {
          var l = this.useColors;
          if (
            ((c[0] =
              (l ? "%c" : "") +
              this.namespace +
              (l ? " %c" : " ") +
              c[0] +
              (l ? "%c " : " ") +
              "+" +
              t.humanize(this.diff)),
            !!l)
          ) {
            var f = "color: " + this.color;
            c.splice(1, 0, f, "color: inherit");
            var u = 0,
              d = 0;
            c[0].replace(/%[a-zA-Z%]/g, function (p) {
              p !== "%%" && (u++, p === "%c" && (d = u));
            }),
              c.splice(d, 0, f);
          }
        }
        function i() {
          return (
            typeof console == "object" &&
            console.log &&
            Function.prototype.apply.call(console.log, console, arguments)
          );
        }
        function a(c) {
          try {
            c == null ? t.storage.removeItem("debug") : (t.storage.debug = c);
          } catch {}
        }
        function s() {
          var c;
          try {
            c = t.storage.debug;
          } catch {}
          return (
            !c &&
              typeof process < "u" &&
              "env" in process &&
              (c = process.env.DEBUG),
            c
          );
        }
        t.enable(s());
        function o() {
          try {
            return window.localStorage;
          } catch {}
        }
      })(Pu, Pu.exports)),
    Pu.exports
  );
}
var Lu = { exports: {} },
  k1;
function rN() {
  return (
    k1 ||
      ((k1 = 1),
      (function (e, t) {
        var n = hc,
          r = wr;
        (t = e.exports = vI()),
          (t.init = d),
          (t.log = c),
          (t.formatArgs = o),
          (t.save = l),
          (t.load = f),
          (t.useColors = s),
          (t.colors = [6, 2, 3, 4, 5, 1]),
          (t.inspectOpts = Object.keys(process.env)
            .filter(function (p) {
              return /^debug_/i.test(p);
            })
            .reduce(function (p, h) {
              var m = h
                  .substring(6)
                  .toLowerCase()
                  .replace(/_([a-z])/g, function (v, y) {
                    return y.toUpperCase();
                  }),
                g = process.env[h];
              return (
                /^(yes|on|true|enabled)$/i.test(g)
                  ? (g = !0)
                  : /^(no|off|false|disabled)$/i.test(g)
                  ? (g = !1)
                  : g === "null"
                  ? (g = null)
                  : (g = Number(g)),
                (p[m] = g),
                p
              );
            }, {}));
        var i = parseInt(process.env.DEBUG_FD, 10) || 2;
        i !== 1 &&
          i !== 2 &&
          r.deprecate(
            function () {},
            "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)",
          )();
        var a = i === 1 ? process.stdout : i === 2 ? process.stderr : u(i);
        function s() {
          return "colors" in t.inspectOpts
            ? !!t.inspectOpts.colors
            : n.isatty(i);
        }
        (t.formatters.o = function (p) {
          return (
            (this.inspectOpts.colors = this.useColors),
            r
              .inspect(p, this.inspectOpts)
              .split(
                `
`,
              )
              .map(function (h) {
                return h.trim();
              })
              .join(" ")
          );
        }),
          (t.formatters.O = function (p) {
            return (
              (this.inspectOpts.colors = this.useColors),
              r.inspect(p, this.inspectOpts)
            );
          });
        function o(p) {
          var h = this.namespace,
            m = this.useColors;
          if (m) {
            var g = this.color,
              v = "  \x1B[3" + g + ";1m" + h + " \x1B[0m";
            (p[0] =
              v +
              p[0]
                .split(
                  `
`,
                )
                .join(
                  `
` + v,
                )),
              p.push("\x1B[3" + g + "m+" + t.humanize(this.diff) + "\x1B[0m");
          } else p[0] = new Date().toUTCString() + " " + h + " " + p[0];
        }
        function c() {
          return a.write(
            r.format.apply(r, arguments) +
              `
`,
          );
        }
        function l(p) {
          p == null ? delete process.env.DEBUG : (process.env.DEBUG = p);
        }
        function f() {
          return process.env.DEBUG;
        }
        function u(p) {
          var h,
            m = process.binding("tty_wrap");
          switch (m.guessHandleType(p)) {
            case "TTY":
              (h = new n.WriteStream(p)),
                (h._type = "tty"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            case "FILE":
              var g = Xt;
              (h = new g.SyncWriteStream(p, { autoClose: !1 })),
                (h._type = "fs");
              break;
            case "PIPE":
            case "TCP":
              var v = ha;
              (h = new v.Socket({ fd: p, readable: !1, writable: !0 })),
                (h.readable = !1),
                (h.read = null),
                (h._type = "pipe"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            default:
              throw new Error("Implement me. Unknown stream file type!");
          }
          return (h.fd = p), (h._isStdio = !0), h;
        }
        function d(p) {
          p.inspectOpts = {};
          for (var h = Object.keys(t.inspectOpts), m = 0; m < h.length; m++)
            p.inspectOpts[h[m]] = t.inspectOpts[h[m]];
        }
        t.enable(f());
      })(Lu, Lu.exports)),
    Lu.exports
  );
}
typeof process < "u" && process.type === "renderer"
  ? (Mg.exports = nN())
  : (Mg.exports = rN());
var ma = Mg.exports;
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var iN = Hi.EventEmitter,
  aN = Xt.ReadStream,
  yI = Kr,
  as = mc,
  ev = sN;
function sN(e, t) {
  return (
    dN(e) ? oN(e) : pN(e) ? lN(e) : uN(e) && e.destroy(),
    fN(e) && t && (e.removeAllListeners("error"), e.addListener("error", hN)),
    e
  );
}
function oN(e) {
  e.destroy(), typeof e.close == "function" && e.on("open", gN);
}
function cN(e) {
  if (e._hadError === !0) {
    var t = e._binding === null ? "_binding" : "_handle";
    e[t] = {
      close: function () {
        this[t] = null;
      },
    };
  }
  e.close();
}
function lN(e) {
  typeof e.destroy == "function"
    ? e._binding
      ? (e.destroy(),
        e._processing
          ? ((e._needDrain = !0), e.once("drain", mN))
          : e._binding.clear())
      : e._destroy && e._destroy !== yI.Transform.prototype._destroy
      ? e.destroy()
      : e._destroy && typeof e.close == "function"
      ? ((e.destroyed = !0), e.close())
      : e.destroy()
    : typeof e.close == "function" && cN(e);
}
function uN(e) {
  return e instanceof yI && typeof e.destroy == "function";
}
function fN(e) {
  return e instanceof iN;
}
function dN(e) {
  return e instanceof aN;
}
function pN(e) {
  return (
    e instanceof as.Gzip ||
    e instanceof as.Gunzip ||
    e instanceof as.Deflate ||
    e instanceof as.DeflateRaw ||
    e instanceof as.Inflate ||
    e instanceof as.InflateRaw ||
    e instanceof as.Unzip
  );
}
function hN() {}
function mN() {
  this._binding.clear();
}
function gN() {
  typeof this.fd == "number" && this.close();
}
var ih = { exports: {} },
  ah,
  T1;
function Xa() {
  if (T1) return ah;
  T1 = 1;
  var e = ks,
    t = e.Buffer,
    n = {},
    r;
  for (r in e)
    e.hasOwnProperty(r) &&
      (r === "SlowBuffer" || r === "Buffer" || (n[r] = e[r]));
  var i = (n.Buffer = {});
  for (r in t)
    t.hasOwnProperty(r) &&
      (r === "allocUnsafe" || r === "allocUnsafeSlow" || (i[r] = t[r]));
  if (
    ((n.Buffer.prototype = t.prototype),
    (!i.from || i.from === Uint8Array.from) &&
      (i.from = function (a, s, o) {
        if (typeof a == "number")
          throw new TypeError(
            'The "value" argument must not be of type number. Received type ' +
              typeof a,
          );
        if (a && typeof a.length > "u")
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
              typeof a,
          );
        return t(a, s, o);
      }),
    i.alloc ||
      (i.alloc = function (a, s, o) {
        if (typeof a != "number")
          throw new TypeError(
            'The "size" argument must be of type number. Received type ' +
              typeof a,
          );
        if (a < 0 || a >= 2 * (1 << 30))
          throw new RangeError(
            'The value "' + a + '" is invalid for option "size"',
          );
        var c = t(a);
        return (
          !s || s.length === 0
            ? c.fill(0)
            : typeof o == "string"
            ? c.fill(s, o)
            : c.fill(s),
          c
        );
      }),
    !n.kStringMaxLength)
  )
    try {
      n.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch {}
  return (
    n.constants ||
      ((n.constants = { MAX_LENGTH: n.kMaxLength }),
      n.kStringMaxLength &&
        (n.constants.MAX_STRING_LENGTH = n.kStringMaxLength)),
    (ah = n),
    ah
  );
}
var Bu = {},
  N1;
function vN() {
  if (N1) return Bu;
  N1 = 1;
  var e = "\uFEFF";
  Bu.PrependBOM = t;
  function t(r, i) {
    (this.encoder = r), (this.addBOM = !0);
  }
  (t.prototype.write = function (r) {
    return (
      this.addBOM && ((r = e + r), (this.addBOM = !1)), this.encoder.write(r)
    );
  }),
    (t.prototype.end = function () {
      return this.encoder.end();
    }),
    (Bu.StripBOM = n);
  function n(r, i) {
    (this.decoder = r), (this.pass = !1), (this.options = i || {});
  }
  return (
    (n.prototype.write = function (r) {
      var i = this.decoder.write(r);
      return (
        this.pass ||
          !i ||
          (i[0] === e &&
            ((i = i.slice(1)),
            typeof this.options.stripBOM == "function" &&
              this.options.stripBOM()),
          (this.pass = !0)),
        i
      );
    }),
    (n.prototype.end = function () {
      return this.decoder.end();
    }),
    Bu
  );
}
var sh = {},
  oh,
  O1;
function yN() {
  if (O1) return oh;
  O1 = 1;
  var e = Xa().Buffer;
  oh = {
    utf8: { type: "_internal", bomAware: !0 },
    cesu8: { type: "_internal", bomAware: !0 },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: !0 },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    _internal: t,
  };
  function t(c, l) {
    (this.enc = c.encodingName),
      (this.bomAware = c.bomAware),
      this.enc === "base64"
        ? (this.encoder = a)
        : this.enc === "cesu8" &&
          ((this.enc = "utf8"),
          (this.encoder = s),
          e.from("eda0bdedb2a9", "hex").toString() !== "💩" &&
            ((this.decoder = o),
            (this.defaultCharUnicode = l.defaultCharUnicode)));
  }
  (t.prototype.encoder = i), (t.prototype.decoder = r);
  var n = dI.StringDecoder;
  n.prototype.end || (n.prototype.end = function () {});
  function r(c, l) {
    n.call(this, l.enc);
  }
  r.prototype = n.prototype;
  function i(c, l) {
    this.enc = l.enc;
  }
  (i.prototype.write = function (c) {
    return e.from(c, this.enc);
  }),
    (i.prototype.end = function () {});
  function a(c, l) {
    this.prevStr = "";
  }
  (a.prototype.write = function (c) {
    c = this.prevStr + c;
    var l = c.length - (c.length % 4);
    return (
      (this.prevStr = c.slice(l)), (c = c.slice(0, l)), e.from(c, "base64")
    );
  }),
    (a.prototype.end = function () {
      return e.from(this.prevStr, "base64");
    });
  function s(c, l) {}
  (s.prototype.write = function (c) {
    for (var l = e.alloc(c.length * 3), f = 0, u = 0; u < c.length; u++) {
      var d = c.charCodeAt(u);
      d < 128
        ? (l[f++] = d)
        : d < 2048
        ? ((l[f++] = 192 + (d >>> 6)), (l[f++] = 128 + (d & 63)))
        : ((l[f++] = 224 + (d >>> 12)),
          (l[f++] = 128 + ((d >>> 6) & 63)),
          (l[f++] = 128 + (d & 63)));
    }
    return l.slice(0, f);
  }),
    (s.prototype.end = function () {});
  function o(c, l) {
    (this.acc = 0),
      (this.contBytes = 0),
      (this.accBytes = 0),
      (this.defaultCharUnicode = l.defaultCharUnicode);
  }
  return (
    (o.prototype.write = function (c) {
      for (
        var l = this.acc, f = this.contBytes, u = this.accBytes, d = "", p = 0;
        p < c.length;
        p++
      ) {
        var h = c[p];
        (h & 192) !== 128
          ? (f > 0 && ((d += this.defaultCharUnicode), (f = 0)),
            h < 128
              ? (d += String.fromCharCode(h))
              : h < 224
              ? ((l = h & 31), (f = 1), (u = 1))
              : h < 240
              ? ((l = h & 15), (f = 2), (u = 1))
              : (d += this.defaultCharUnicode))
          : f > 0
          ? ((l = (l << 6) | (h & 63)),
            f--,
            u++,
            f === 0 &&
              (u === 2 && l < 128 && l > 0
                ? (d += this.defaultCharUnicode)
                : u === 3 && l < 2048
                ? (d += this.defaultCharUnicode)
                : (d += String.fromCharCode(l))))
          : (d += this.defaultCharUnicode);
      }
      return (this.acc = l), (this.contBytes = f), (this.accBytes = u), d;
    }),
    (o.prototype.end = function () {
      var c = 0;
      return this.contBytes > 0 && (c += this.defaultCharUnicode), c;
    }),
    oh
  );
}
var Uu = {},
  P1;
function bN() {
  if (P1) return Uu;
  P1 = 1;
  var e = Xa().Buffer;
  Uu.utf16be = t;
  function t() {}
  (t.prototype.encoder = n),
    (t.prototype.decoder = r),
    (t.prototype.bomAware = !0);
  function n() {}
  (n.prototype.write = function (c) {
    for (var l = e.from(c, "ucs2"), f = 0; f < l.length; f += 2) {
      var u = l[f];
      (l[f] = l[f + 1]), (l[f + 1] = u);
    }
    return l;
  }),
    (n.prototype.end = function () {});
  function r() {
    this.overflowByte = -1;
  }
  (r.prototype.write = function (c) {
    if (c.length == 0) return "";
    var l = e.alloc(c.length + 1),
      f = 0,
      u = 0;
    for (
      this.overflowByte !== -1 &&
      ((l[0] = c[0]), (l[1] = this.overflowByte), (f = 1), (u = 2));
      f < c.length - 1;
      f += 2, u += 2
    )
      (l[u] = c[f + 1]), (l[u + 1] = c[f]);
    return (
      (this.overflowByte = f == c.length - 1 ? c[c.length - 1] : -1),
      l.slice(0, u).toString("ucs2")
    );
  }),
    (r.prototype.end = function () {}),
    (Uu.utf16 = i);
  function i(c, l) {
    this.iconv = l;
  }
  (i.prototype.encoder = a), (i.prototype.decoder = s);
  function a(c, l) {
    (c = c || {}),
      c.addBOM === void 0 && (c.addBOM = !0),
      (this.encoder = l.iconv.getEncoder("utf-16le", c));
  }
  (a.prototype.write = function (c) {
    return this.encoder.write(c);
  }),
    (a.prototype.end = function () {
      return this.encoder.end();
    });
  function s(c, l) {
    (this.decoder = null),
      (this.initialBytes = []),
      (this.initialBytesLen = 0),
      (this.options = c || {}),
      (this.iconv = l.iconv);
  }
  (s.prototype.write = function (c) {
    if (!this.decoder) {
      if (
        (this.initialBytes.push(c),
        (this.initialBytesLen += c.length),
        this.initialBytesLen < 16)
      )
        return "";
      var c = e.concat(this.initialBytes),
        l = o(c, this.options.defaultEncoding);
      (this.decoder = this.iconv.getDecoder(l, this.options)),
        (this.initialBytes.length = this.initialBytesLen = 0);
    }
    return this.decoder.write(c);
  }),
    (s.prototype.end = function () {
      if (!this.decoder) {
        var c = e.concat(this.initialBytes),
          l = o(c, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(l, this.options);
        var f = this.decoder.write(c),
          u = this.decoder.end();
        return u ? f + u : f;
      }
      return this.decoder.end();
    });
  function o(c, l) {
    var f = l || "utf-16le";
    if (c.length >= 2)
      if (c[0] == 254 && c[1] == 255) f = "utf-16be";
      else if (c[0] == 255 && c[1] == 254) f = "utf-16le";
      else {
        for (
          var u = 0, d = 0, p = Math.min(c.length - (c.length % 2), 64), h = 0;
          h < p;
          h += 2
        )
          c[h] === 0 && c[h + 1] !== 0 && d++,
            c[h] !== 0 && c[h + 1] === 0 && u++;
        d > u ? (f = "utf-16be") : d < u && (f = "utf-16le");
      }
    return f;
  }
  return Uu;
}
var Oc = {},
  D1;
function _N() {
  if (D1) return Oc;
  D1 = 1;
  var e = Xa().Buffer;
  (Oc.utf7 = t), (Oc.unicode11utf7 = "utf7");
  function t(m, g) {
    this.iconv = g;
  }
  (t.prototype.encoder = r),
    (t.prototype.decoder = i),
    (t.prototype.bomAware = !0);
  var n = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function r(m, g) {
    this.iconv = g.iconv;
  }
  (r.prototype.write = function (m) {
    return e.from(
      m.replace(
        n,
        function (g) {
          return (
            "+" +
            (g === "+"
              ? ""
              : this.iconv
                  .encode(g, "utf16-be")
                  .toString("base64")
                  .replace(/=+$/, "")) +
            "-"
          );
        }.bind(this),
      ),
    );
  }),
    (r.prototype.end = function () {});
  function i(m, g) {
    (this.iconv = g.iconv), (this.inBase64 = !1), (this.base64Accum = "");
  }
  for (var a = /[A-Za-z0-9\/+]/, s = [], o = 0; o < 256; o++)
    s[o] = a.test(String.fromCharCode(o));
  var c = "+".charCodeAt(0),
    l = "-".charCodeAt(0),
    f = "&".charCodeAt(0);
  (i.prototype.write = function (m) {
    for (
      var g = "", v = 0, y = this.inBase64, _ = this.base64Accum, E = 0;
      E < m.length;
      E++
    )
      if (!y)
        m[E] == c &&
          ((g += this.iconv.decode(m.slice(v, E), "ascii")),
          (v = E + 1),
          (y = !0));
      else if (!s[m[E]]) {
        if (E == v && m[E] == l) g += "+";
        else {
          var R = _ + m.slice(v, E).toString();
          g += this.iconv.decode(e.from(R, "base64"), "utf16-be");
        }
        m[E] != l && E--, (v = E + 1), (y = !1), (_ = "");
      }
    if (!y) g += this.iconv.decode(m.slice(v), "ascii");
    else {
      var R = _ + m.slice(v).toString(),
        A = R.length - (R.length % 8);
      (_ = R.slice(A)),
        (R = R.slice(0, A)),
        (g += this.iconv.decode(e.from(R, "base64"), "utf16-be"));
    }
    return (this.inBase64 = y), (this.base64Accum = _), g;
  }),
    (i.prototype.end = function () {
      var m = "";
      return (
        this.inBase64 &&
          this.base64Accum.length > 0 &&
          (m = this.iconv.decode(
            e.from(this.base64Accum, "base64"),
            "utf16-be",
          )),
        (this.inBase64 = !1),
        (this.base64Accum = ""),
        m
      );
    }),
    (Oc.utf7imap = u);
  function u(m, g) {
    this.iconv = g;
  }
  (u.prototype.encoder = d),
    (u.prototype.decoder = p),
    (u.prototype.bomAware = !0);
  function d(m, g) {
    (this.iconv = g.iconv),
      (this.inBase64 = !1),
      (this.base64Accum = e.alloc(6)),
      (this.base64AccumIdx = 0);
  }
  (d.prototype.write = function (m) {
    for (
      var g = this.inBase64,
        v = this.base64Accum,
        y = this.base64AccumIdx,
        _ = e.alloc(m.length * 5 + 10),
        E = 0,
        R = 0;
      R < m.length;
      R++
    ) {
      var A = m.charCodeAt(R);
      32 <= A && A <= 126
        ? (g &&
            (y > 0 &&
              ((E += _.write(
                v
                  .slice(0, y)
                  .toString("base64")
                  .replace(/\//g, ",")
                  .replace(/=+$/, ""),
                E,
              )),
              (y = 0)),
            (_[E++] = l),
            (g = !1)),
          g || ((_[E++] = A), A === f && (_[E++] = l)))
        : (g || ((_[E++] = f), (g = !0)),
          g &&
            ((v[y++] = A >> 8),
            (v[y++] = A & 255),
            y == v.length &&
              ((E += _.write(v.toString("base64").replace(/\//g, ","), E)),
              (y = 0))));
    }
    return (this.inBase64 = g), (this.base64AccumIdx = y), _.slice(0, E);
  }),
    (d.prototype.end = function () {
      var m = e.alloc(10),
        g = 0;
      return (
        this.inBase64 &&
          (this.base64AccumIdx > 0 &&
            ((g += m.write(
              this.base64Accum
                .slice(0, this.base64AccumIdx)
                .toString("base64")
                .replace(/\//g, ",")
                .replace(/=+$/, ""),
              g,
            )),
            (this.base64AccumIdx = 0)),
          (m[g++] = l),
          (this.inBase64 = !1)),
        m.slice(0, g)
      );
    });
  function p(m, g) {
    (this.iconv = g.iconv), (this.inBase64 = !1), (this.base64Accum = "");
  }
  var h = s.slice();
  return (
    (h[",".charCodeAt(0)] = !0),
    (p.prototype.write = function (m) {
      for (
        var g = "", v = 0, y = this.inBase64, _ = this.base64Accum, E = 0;
        E < m.length;
        E++
      )
        if (!y)
          m[E] == f &&
            ((g += this.iconv.decode(m.slice(v, E), "ascii")),
            (v = E + 1),
            (y = !0));
        else if (!h[m[E]]) {
          if (E == v && m[E] == l) g += "&";
          else {
            var R = _ + m.slice(v, E).toString().replace(/,/g, "/");
            g += this.iconv.decode(e.from(R, "base64"), "utf16-be");
          }
          m[E] != l && E--, (v = E + 1), (y = !1), (_ = "");
        }
      if (!y) g += this.iconv.decode(m.slice(v), "ascii");
      else {
        var R = _ + m.slice(v).toString().replace(/,/g, "/"),
          A = R.length - (R.length % 8);
        (_ = R.slice(A)),
          (R = R.slice(0, A)),
          (g += this.iconv.decode(e.from(R, "base64"), "utf16-be"));
      }
      return (this.inBase64 = y), (this.base64Accum = _), g;
    }),
    (p.prototype.end = function () {
      var m = "";
      return (
        this.inBase64 &&
          this.base64Accum.length > 0 &&
          (m = this.iconv.decode(
            e.from(this.base64Accum, "base64"),
            "utf16-be",
          )),
        (this.inBase64 = !1),
        (this.base64Accum = ""),
        m
      );
    }),
    Oc
  );
}
var ch = {},
  L1;
function EN() {
  if (L1) return ch;
  L1 = 1;
  var e = Xa().Buffer;
  ch._sbcs = t;
  function t(i, a) {
    if (!i) throw new Error("SBCS codec is called without the data.");
    if (!i.chars || (i.chars.length !== 128 && i.chars.length !== 256))
      throw new Error(
        "Encoding '" +
          i.type +
          "' has incorrect 'chars' (must be of len 128 or 256)",
      );
    if (i.chars.length === 128) {
      for (var s = "", o = 0; o < 128; o++) s += String.fromCharCode(o);
      i.chars = s + i.chars;
    }
    this.decodeBuf = e.from(i.chars, "ucs2");
    for (
      var c = e.alloc(65536, a.defaultCharSingleByte.charCodeAt(0)), o = 0;
      o < i.chars.length;
      o++
    )
      c[i.chars.charCodeAt(o)] = o;
    this.encodeBuf = c;
  }
  (t.prototype.encoder = n), (t.prototype.decoder = r);
  function n(i, a) {
    this.encodeBuf = a.encodeBuf;
  }
  (n.prototype.write = function (i) {
    for (var a = e.alloc(i.length), s = 0; s < i.length; s++)
      a[s] = this.encodeBuf[i.charCodeAt(s)];
    return a;
  }),
    (n.prototype.end = function () {});
  function r(i, a) {
    this.decodeBuf = a.decodeBuf;
  }
  return (
    (r.prototype.write = function (i) {
      for (
        var a = this.decodeBuf, s = e.alloc(i.length * 2), o = 0, c = 0, l = 0;
        l < i.length;
        l++
      )
        (o = i[l] * 2), (c = l * 2), (s[c] = a[o]), (s[c + 1] = a[o + 1]);
      return s.toString("ucs2");
    }),
    (r.prototype.end = function () {}),
    ch
  );
}
var lh, B1;
function wN() {
  return (
    B1 ||
      ((B1 = 1),
      (lh = {
        10029: "maccenteuro",
        maccenteuro: {
          type: "_sbcs",
          chars:
            "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ",
        },
        808: "cp808",
        ibm808: "cp808",
        cp808: {
          type: "_sbcs",
          chars:
            "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№€■ ",
        },
        mik: {
          type: "_sbcs",
          chars:
            "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя└┴┬├─┼╣║╚╔╩╦╠═╬┐░▒▓│┤№§╗╝┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ascii8bit: "ascii",
        usascii: "ascii",
        ansix34: "ascii",
        ansix341968: "ascii",
        ansix341986: "ascii",
        csascii: "ascii",
        cp367: "ascii",
        ibm367: "ascii",
        isoir6: "ascii",
        iso646us: "ascii",
        iso646irv: "ascii",
        us: "ascii",
        latin1: "iso88591",
        latin2: "iso88592",
        latin3: "iso88593",
        latin4: "iso88594",
        latin5: "iso88599",
        latin6: "iso885910",
        latin7: "iso885913",
        latin8: "iso885914",
        latin9: "iso885915",
        latin10: "iso885916",
        csisolatin1: "iso88591",
        csisolatin2: "iso88592",
        csisolatin3: "iso88593",
        csisolatin4: "iso88594",
        csisolatincyrillic: "iso88595",
        csisolatinarabic: "iso88596",
        csisolatingreek: "iso88597",
        csisolatinhebrew: "iso88598",
        csisolatin5: "iso88599",
        csisolatin6: "iso885910",
        l1: "iso88591",
        l2: "iso88592",
        l3: "iso88593",
        l4: "iso88594",
        l5: "iso88599",
        l6: "iso885910",
        l7: "iso885913",
        l8: "iso885914",
        l9: "iso885915",
        l10: "iso885916",
        isoir14: "iso646jp",
        isoir57: "iso646cn",
        isoir100: "iso88591",
        isoir101: "iso88592",
        isoir109: "iso88593",
        isoir110: "iso88594",
        isoir144: "iso88595",
        isoir127: "iso88596",
        isoir126: "iso88597",
        isoir138: "iso88598",
        isoir148: "iso88599",
        isoir157: "iso885910",
        isoir166: "tis620",
        isoir179: "iso885913",
        isoir199: "iso885914",
        isoir203: "iso885915",
        isoir226: "iso885916",
        cp819: "iso88591",
        ibm819: "iso88591",
        cyrillic: "iso88595",
        arabic: "iso88596",
        arabic8: "iso88596",
        ecma114: "iso88596",
        asmo708: "iso88596",
        greek: "iso88597",
        greek8: "iso88597",
        ecma118: "iso88597",
        elot928: "iso88597",
        hebrew: "iso88598",
        hebrew8: "iso88598",
        turkish: "iso88599",
        turkish8: "iso88599",
        thai: "iso885911",
        thai8: "iso885911",
        celtic: "iso885914",
        celtic8: "iso885914",
        isoceltic: "iso885914",
        tis6200: "tis620",
        tis62025291: "tis620",
        tis62025330: "tis620",
        1e4: "macroman",
        10006: "macgreek",
        10007: "maccyrillic",
        10079: "maciceland",
        10081: "macturkish",
        cspc8codepage437: "cp437",
        cspc775baltic: "cp775",
        cspc850multilingual: "cp850",
        cspcp852: "cp852",
        cspc862latinhebrew: "cp862",
        cpgr: "cp869",
        msee: "cp1250",
        mscyrl: "cp1251",
        msansi: "cp1252",
        msgreek: "cp1253",
        msturk: "cp1254",
        mshebr: "cp1255",
        msarab: "cp1256",
        winbaltrim: "cp1257",
        cp20866: "koi8r",
        20866: "koi8r",
        ibm878: "koi8r",
        cskoi8r: "koi8r",
        cp21866: "koi8u",
        21866: "koi8u",
        ibm1168: "koi8u",
        strk10482002: "rk1048",
        tcvn5712: "tcvn",
        tcvn57121: "tcvn",
        gb198880: "iso646cn",
        cn: "iso646cn",
        csiso14jisc6220ro: "iso646jp",
        jisc62201969ro: "iso646jp",
        jp: "iso646jp",
        cshproman8: "hproman8",
        r8: "hproman8",
        roman8: "hproman8",
        xroman8: "hproman8",
        ibm1051: "hproman8",
        mac: "macintosh",
        csmacintosh: "macintosh",
      })),
    lh
  );
}
var uh, U1;
function xN() {
  return (
    U1 ||
      ((U1 = 1),
      (uh = {
        437: "cp437",
        737: "cp737",
        775: "cp775",
        850: "cp850",
        852: "cp852",
        855: "cp855",
        856: "cp856",
        857: "cp857",
        858: "cp858",
        860: "cp860",
        861: "cp861",
        862: "cp862",
        863: "cp863",
        864: "cp864",
        865: "cp865",
        866: "cp866",
        869: "cp869",
        874: "windows874",
        922: "cp922",
        1046: "cp1046",
        1124: "cp1124",
        1125: "cp1125",
        1129: "cp1129",
        1133: "cp1133",
        1161: "cp1161",
        1162: "cp1162",
        1163: "cp1163",
        1250: "windows1250",
        1251: "windows1251",
        1252: "windows1252",
        1253: "windows1253",
        1254: "windows1254",
        1255: "windows1255",
        1256: "windows1256",
        1257: "windows1257",
        1258: "windows1258",
        28591: "iso88591",
        28592: "iso88592",
        28593: "iso88593",
        28594: "iso88594",
        28595: "iso88595",
        28596: "iso88596",
        28597: "iso88597",
        28598: "iso88598",
        28599: "iso88599",
        28600: "iso885910",
        28601: "iso885911",
        28603: "iso885913",
        28604: "iso885914",
        28605: "iso885915",
        28606: "iso885916",
        windows874: {
          type: "_sbcs",
          chars:
            "€����…�����������‘’“”•–—�������� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����",
        },
        win874: "windows874",
        cp874: "windows874",
        windows1250: {
          type: "_sbcs",
          chars:
            "€�‚�„…†‡�‰Š‹ŚŤŽŹ�‘’“”•–—�™š›śťžź ˇ˘Ł¤Ą¦§¨©Ş«¬­®Ż°±˛ł´µ¶·¸ąş»Ľ˝ľżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙",
        },
        win1250: "windows1250",
        cp1250: "windows1250",
        windows1251: {
          type: "_sbcs",
          chars:
            "ЂЃ‚ѓ„…†‡€‰Љ‹ЊЌЋЏђ‘’“”•–—�™љ›њќћџ ЎўЈ¤Ґ¦§Ё©Є«¬­®Ї°±Ііґµ¶·ё№є»јЅѕїАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя",
        },
        win1251: "windows1251",
        cp1251: "windows1251",
        windows1252: {
          type: "_sbcs",
          chars:
            "€�‚ƒ„…†‡ˆ‰Š‹Œ�Ž��‘’“”•–—˜™š›œ�žŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ",
        },
        win1252: "windows1252",
        cp1252: "windows1252",
        windows1253: {
          type: "_sbcs",
          chars:
            "€�‚ƒ„…†‡�‰�‹�����‘’“”•–—�™�›���� ΅Ά£¤¥¦§¨©�«¬­®―°±²³΄µ¶·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�",
        },
        win1253: "windows1253",
        cp1253: "windows1253",
        windows1254: {
          type: "_sbcs",
          chars:
            "€�‚ƒ„…†‡ˆ‰Š‹Œ����‘’“”•–—˜™š›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ",
        },
        win1254: "windows1254",
        cp1254: "windows1254",
        windows1255: {
          type: "_sbcs",
          chars:
            "€�‚ƒ„…†‡ˆ‰�‹�����‘’“”•–—˜™�›���� ¡¢£₪¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾¿ְֱֲֳִֵֶַָֹֺֻּֽ־ֿ׀ׁׂ׃װױײ׳״�������אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�",
        },
        win1255: "windows1255",
        cp1255: "windows1255",
        windows1256: {
          type: "_sbcs",
          chars:
            "€پ‚ƒ„…†‡ˆ‰ٹ‹Œچژڈگ‘’“”•–—ک™ڑ›œ‌‍ں ،¢£¤¥¦§¨©ھ«¬­®¯°±²³´µ¶·¸¹؛»¼½¾؟ہءآأؤإئابةتثجحخدذرزسشصض×طظعغـفقكàلâمنهوçèéêëىيîïًٌٍَôُِ÷ّùْûü‎‏ے",
        },
        win1256: "windows1256",
        cp1256: "windows1256",
        windows1257: {
          type: "_sbcs",
          chars:
            "€�‚�„…†‡�‰�‹�¨ˇ¸�‘’“”•–—�™�›�¯˛� �¢£¤�¦§Ø©Ŗ«¬­®Æ°±²³´µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž˙",
        },
        win1257: "windows1257",
        cp1257: "windows1257",
        windows1258: {
          type: "_sbcs",
          chars:
            "€�‚ƒ„…†‡ˆ‰�‹Œ����‘’“”•–—˜™�›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ",
        },
        win1258: "windows1258",
        cp1258: "windows1258",
        iso88591: {
          type: "_sbcs",
          chars:
            " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ",
        },
        cp28591: "iso88591",
        iso88592: {
          type: "_sbcs",
          chars:
            " Ą˘Ł¤ĽŚ§¨ŠŞŤŹ­ŽŻ°ą˛ł´ľśˇ¸šşťź˝žżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙",
        },
        cp28592: "iso88592",
        iso88593: {
          type: "_sbcs",
          chars:
            " Ħ˘£¤�Ĥ§¨İŞĞĴ­�Ż°ħ²³´µĥ·¸ışğĵ½�żÀÁÂ�ÄĊĈÇÈÉÊËÌÍÎÏ�ÑÒÓÔĠÖ×ĜÙÚÛÜŬŜßàáâ�äċĉçèéêëìíîï�ñòóôġö÷ĝùúûüŭŝ˙",
        },
        cp28593: "iso88593",
        iso88594: {
          type: "_sbcs",
          chars:
            " ĄĸŖ¤ĨĻ§¨ŠĒĢŦ­Ž¯°ą˛ŗ´ĩļˇ¸šēģŧŊžŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎĪĐŅŌĶÔÕÖ×ØŲÚÛÜŨŪßāáâãäåæįčéęëėíîīđņōķôõö÷øųúûüũū˙",
        },
        cp28594: "iso88594",
        iso88595: {
          type: "_sbcs",
          chars:
            " ЁЂЃЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђѓєѕіїјљњћќ§ўџ",
        },
        cp28595: "iso88595",
        iso88596: {
          type: "_sbcs",
          chars:
            " ���¤�������،­�������������؛���؟�ءآأؤإئابةتثجحخدذرزسشصضطظعغ�����ـفقكلمنهوىيًٌٍَُِّْ�������������",
        },
        cp28596: "iso88596",
        iso88597: {
          type: "_sbcs",
          chars:
            " ‘’£€₯¦§¨©ͺ«¬­�―°±²³΄΅Ά·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�",
        },
        cp28597: "iso88597",
        iso88598: {
          type: "_sbcs",
          chars:
            " �¢£¤¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾��������������������������������‗אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�",
        },
        cp28598: "iso88598",
        iso88599: {
          type: "_sbcs",
          chars:
            " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ",
        },
        cp28599: "iso88599",
        iso885910: {
          type: "_sbcs",
          chars:
            " ĄĒĢĪĨĶ§ĻĐŠŦŽ­ŪŊ°ąēģīĩķ·ļđšŧž―ūŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎÏÐŅŌÓÔÕÖŨØŲÚÛÜÝÞßāáâãäåæįčéęëėíîïðņōóôõöũøųúûüýþĸ",
        },
        cp28600: "iso885910",
        iso885911: {
          type: "_sbcs",
          chars:
            " กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����",
        },
        cp28601: "iso885911",
        iso885913: {
          type: "_sbcs",
          chars:
            " ”¢£¤„¦§Ø©Ŗ«¬­®Æ°±²³“µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž’",
        },
        cp28603: "iso885913",
        iso885914: {
          type: "_sbcs",
          chars:
            " Ḃḃ£ĊċḊ§Ẁ©ẂḋỲ­®ŸḞḟĠġṀṁ¶ṖẁṗẃṠỳẄẅṡÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŴÑÒÓÔÕÖṪØÙÚÛÜÝŶßàáâãäåæçèéêëìíîïŵñòóôõöṫøùúûüýŷÿ",
        },
        cp28604: "iso885914",
        iso885915: {
          type: "_sbcs",
          chars:
            " ¡¢£€¥Š§š©ª«¬­®¯°±²³Žµ¶·ž¹º»ŒœŸ¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ",
        },
        cp28605: "iso885915",
        iso885916: {
          type: "_sbcs",
          chars:
            " ĄąŁ€„Š§š©Ș«Ź­źŻ°±ČłŽ”¶·žčș»ŒœŸżÀÁÂĂÄĆÆÇÈÉÊËÌÍÎÏĐŃÒÓÔŐÖŚŰÙÚÛÜĘȚßàáâăäćæçèéêëìíîïđńòóôőöśűùúûüęțÿ",
        },
        cp28606: "iso885916",
        cp437: {
          type: "_sbcs",
          chars:
            "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ibm437: "cp437",
        csibm437: "cp437",
        cp737: {
          type: "_sbcs",
          chars:
            "ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρσςτυφχψ░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀ωάέήϊίόύϋώΆΈΉΊΌΎΏ±≥≤ΪΫ÷≈°∙·√ⁿ²■ ",
        },
        ibm737: "cp737",
        csibm737: "cp737",
        cp775: {
          type: "_sbcs",
          chars:
            "ĆüéāäģåćłēŖŗīŹÄÅÉæÆōöĢ¢ŚśÖÜø£Ø×¤ĀĪóŻżź”¦©®¬½¼Ł«»░▒▓│┤ĄČĘĖ╣║╗╝ĮŠ┐└┴┬├─┼ŲŪ╚╔╩╦╠═╬Žąčęėįšųūž┘┌█▄▌▐▀ÓßŌŃõÕµńĶķĻļņĒŅ’­±“¾¶§÷„°∙·¹³²■ ",
        },
        ibm775: "cp775",
        csibm775: "cp775",
        cp850: {
          type: "_sbcs",
          chars:
            "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈıÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ ",
        },
        ibm850: "cp850",
        csibm850: "cp850",
        cp852: {
          type: "_sbcs",
          chars:
            "ÇüéâäůćçłëŐőîŹÄĆÉĹĺôöĽľŚśÖÜŤťŁ×čáíóúĄąŽžĘę¬źČş«»░▒▓│┤ÁÂĚŞ╣║╗╝Żż┐└┴┬├─┼Ăă╚╔╩╦╠═╬¤đĐĎËďŇÍÎě┘┌█▄ŢŮ▀ÓßÔŃńňŠšŔÚŕŰýÝţ´­˝˛ˇ˘§÷¸°¨˙űŘř■ ",
        },
        ibm852: "cp852",
        csibm852: "cp852",
        cp855: {
          type: "_sbcs",
          chars:
            "ђЂѓЃёЁєЄѕЅіІїЇјЈљЉњЊћЋќЌўЎџЏюЮъЪаАбБцЦдДеЕфФгГ«»░▒▓│┤хХиИ╣║╗╝йЙ┐└┴┬├─┼кК╚╔╩╦╠═╬¤лЛмМнНоОп┘┌█▄Пя▀ЯрРсСтТуУжЖвВьЬ№­ыЫзЗшШэЭщЩчЧ§■ ",
        },
        ibm855: "cp855",
        csibm855: "cp855",
        cp856: {
          type: "_sbcs",
          chars:
            "אבגדהוזחטיךכלםמןנסעףפץצקרשת�£�×����������®¬½¼�«»░▒▓│┤���©╣║╗╝¢¥┐└┴┬├─┼��╚╔╩╦╠═╬¤���������┘┌█▄¦�▀������µ�������¯´­±‗¾¶§÷¸°¨·¹³²■ ",
        },
        ibm856: "cp856",
        csibm856: "cp856",
        cp857: {
          type: "_sbcs",
          chars:
            "ÇüéâäàåçêëèïîıÄÅÉæÆôöòûùİÖÜø£ØŞşáíóúñÑĞğ¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ºªÊËÈ�ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµ�×ÚÛÙìÿ¯´­±�¾¶§÷¸°¨·¹³²■ ",
        },
        ibm857: "cp857",
        csibm857: "cp857",
        cp858: {
          type: "_sbcs",
          chars:
            "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈ€ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ ",
        },
        ibm858: "cp858",
        csibm858: "cp858",
        cp860: {
          type: "_sbcs",
          chars:
            "ÇüéâãàÁçêÊèÍÔìÃÂÉÀÈôõòÚùÌÕÜ¢£Ù₧ÓáíóúñÑªº¿Ò¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ibm860: "cp860",
        csibm860: "cp860",
        cp861: {
          type: "_sbcs",
          chars:
            "ÇüéâäàåçêëèÐðÞÄÅÉæÆôöþûÝýÖÜø£Ø₧ƒáíóúÁÍÓÚ¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ibm861: "cp861",
        csibm861: "cp861",
        cp862: {
          type: "_sbcs",
          chars:
            "אבגדהוזחטיךכלםמןנסעףפץצקרשת¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ibm862: "cp862",
        csibm862: "cp862",
        cp863: {
          type: "_sbcs",
          chars:
            "ÇüéâÂà¶çêëèïî‗À§ÉÈÊôËÏûù¤ÔÜ¢£ÙÛƒ¦´óú¨¸³¯Î⌐¬½¼¾«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ibm863: "cp863",
        csibm863: "cp863",
        cp864: {
          type: "_sbcs",
          chars: `\0\x07\b
\v\f\r\x1B !"#$٪&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~°·∙√▒─│┼┤┬├┴┐┌└┘β∞φ±½¼≈«»ﻷﻸ��ﻻﻼ� ­ﺂ£¤ﺄ��ﺎﺏﺕﺙ،ﺝﺡﺥ٠١٢٣٤٥٦٧٨٩ﻑ؛ﺱﺵﺹ؟¢ﺀﺁﺃﺅﻊﺋﺍﺑﺓﺗﺛﺟﺣﺧﺩﺫﺭﺯﺳﺷﺻﺿﻁﻅﻋﻏ¦¬÷×ﻉـﻓﻗﻛﻟﻣﻧﻫﻭﻯﻳﺽﻌﻎﻍﻡﹽّﻥﻩﻬﻰﻲﻐﻕﻵﻶﻝﻙﻱ■�`,
        },
        ibm864: "cp864",
        csibm864: "cp864",
        cp865: {
          type: "_sbcs",
          chars:
            "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø₧ƒáíóúñÑªº¿⌐¬½¼¡«¤░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ibm865: "cp865",
        csibm865: "cp865",
        cp866: {
          type: "_sbcs",
          chars:
            "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№¤■ ",
        },
        ibm866: "cp866",
        csibm866: "cp866",
        cp869: {
          type: "_sbcs",
          chars:
            "������Ά�·¬¦‘’Έ―ΉΊΪΌ��ΎΫ©Ώ²³ά£έήίϊΐόύΑΒΓΔΕΖΗ½ΘΙ«»░▒▓│┤ΚΛΜΝ╣║╗╝ΞΟ┐└┴┬├─┼ΠΡ╚╔╩╦╠═╬ΣΤΥΦΧΨΩαβγ┘┌█▄δε▀ζηθικλμνξοπρσςτ΄­±υφχ§ψ΅°¨ωϋΰώ■ ",
        },
        ibm869: "cp869",
        csibm869: "cp869",
        cp922: {
          type: "_sbcs",
          chars:
            " ¡¢£¤¥¦§¨©ª«¬­®‾°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŠÑÒÓÔÕÖ×ØÙÚÛÜÝŽßàáâãäåæçèéêëìíîïšñòóôõö÷øùúûüýžÿ",
        },
        ibm922: "cp922",
        csibm922: "cp922",
        cp1046: {
          type: "_sbcs",
          chars:
            "ﺈ×÷ﹱ■│─┐┌└┘ﹹﹻﹽﹿﹷﺊﻰﻳﻲﻎﻏﻐﻶﻸﻺﻼ ¤ﺋﺑﺗﺛﺟﺣ،­ﺧﺳ٠١٢٣٤٥٦٧٨٩ﺷ؛ﺻﺿﻊ؟ﻋءآأؤإئابةتثجحخدذرزسشصضطﻇعغﻌﺂﺄﺎﻓـفقكلمنهوىيًٌٍَُِّْﻗﻛﻟﻵﻷﻹﻻﻣﻧﻬﻩ�",
        },
        ibm1046: "cp1046",
        csibm1046: "cp1046",
        cp1124: {
          type: "_sbcs",
          chars:
            " ЁЂҐЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђґєѕіїјљњћќ§ўџ",
        },
        ibm1124: "cp1124",
        csibm1124: "cp1124",
        cp1125: {
          type: "_sbcs",
          chars:
            "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёҐґЄєІіЇї·√№¤■ ",
        },
        ibm1125: "cp1125",
        csibm1125: "cp1125",
        cp1129: {
          type: "_sbcs",
          chars:
            " ¡¢£¤¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ",
        },
        ibm1129: "cp1129",
        csibm1129: "cp1129",
        cp1133: {
          type: "_sbcs",
          chars:
            " ກຂຄງຈສຊຍດຕຖທນບປຜຝພຟມຢຣລວຫອຮ���ຯະາຳິີຶືຸູຼັົຽ���ເແໂໃໄ່້໊໋໌ໍໆ�ໜໝ₭����������������໐໑໒໓໔໕໖໗໘໙��¢¬¦�",
        },
        ibm1133: "cp1133",
        csibm1133: "cp1133",
        cp1161: {
          type: "_sbcs",
          chars:
            "��������������������������������่กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู้๊๋€฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛¢¬¦ ",
        },
        ibm1161: "cp1161",
        csibm1161: "cp1161",
        cp1162: {
          type: "_sbcs",
          chars:
            "€…‘’“”•–— กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����",
        },
        ibm1162: "cp1162",
        csibm1162: "cp1162",
        cp1163: {
          type: "_sbcs",
          chars:
            " ¡¢£€¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ",
        },
        ibm1163: "cp1163",
        csibm1163: "cp1163",
        maccroatian: {
          type: "_sbcs",
          chars:
            "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊�©⁄¤‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ",
        },
        maccyrillic: {
          type: "_sbcs",
          chars:
            "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°¢£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµ∂ЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤",
        },
        macgreek: {
          type: "_sbcs",
          chars:
            "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦­ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ�",
        },
        maciceland: {
          type: "_sbcs",
          chars:
            "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
        },
        macroman: {
          type: "_sbcs",
          chars:
            "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
        },
        macromania: {
          type: "_sbcs",
          chars:
            "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂŞ∞±≤≥¥µ∂∑∏π∫ªºΩăş¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›Ţţ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
        },
        macthai: {
          type: "_sbcs",
          chars:
            "«»…“”�•‘’� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู\uFEFF​–—฿เแโใไๅๆ็่้๊๋์ํ™๏๐๑๒๓๔๕๖๗๘๙®©����",
        },
        macturkish: {
          type: "_sbcs",
          chars:
            "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙ�ˆ˜¯˘˙˚¸˝˛ˇ",
        },
        macukraine: {
          type: "_sbcs",
          chars:
            "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤",
        },
        koi8r: {
          type: "_sbcs",
          chars:
            "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ё╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡Ё╢╣╤╥╦╧╨╩╪╫╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ",
        },
        koi8u: {
          type: "_sbcs",
          chars:
            "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґ╝╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪Ґ╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ",
        },
        koi8ru: {
          type: "_sbcs",
          chars:
            "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґў╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪ҐЎ©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ",
        },
        koi8t: {
          type: "_sbcs",
          chars:
            "қғ‚Ғ„…†‡�‰ҳ‹ҲҷҶ�Қ‘’“”•–—�™�›�����ӯӮё¤ӣ¦§���«¬­®�°±²Ё�Ӣ¶·�№�»���©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ",
        },
        armscii8: {
          type: "_sbcs",
          chars:
            " �և։)(»«—.՝,-֊…՜՛՞ԱաԲբԳգԴդԵեԶզԷէԸըԹթԺժԻիԼլԽխԾծԿկՀհՁձՂղՃճՄմՅյՆնՇշՈոՉչՊպՋջՌռՍսՎվՏտՐրՑցՒւՓփՔքՕօՖֆ՚�",
        },
        rk1048: {
          type: "_sbcs",
          chars:
            "ЂЃ‚ѓ„…†‡€‰Љ‹ЊҚҺЏђ‘’“”•–—�™љ›њқһџ ҰұӘ¤Ө¦§Ё©Ғ«¬­®Ү°±Ііөµ¶·ё№ғ»әҢңүАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя",
        },
        tcvn: {
          type: "_sbcs",
          chars: `\0ÚỤỪỬỮ\x07\b
\v\f\rỨỰỲỶỸÝỴ\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~ÀẢÃÁẠẶẬÈẺẼÉẸỆÌỈĨÍỊÒỎÕÓỌỘỜỞỠỚỢÙỦŨ ĂÂÊÔƠƯĐăâêôơưđẶ̀̀̉̃́àảãáạẲằẳẵắẴẮẦẨẪẤỀặầẩẫấậèỂẻẽéẹềểễếệìỉỄẾỒĩíịòỔỏõóọồổỗốộờởỡớợùỖủũúụừửữứựỳỷỹýỵỐ`,
        },
        georgianacademy: {
          type: "_sbcs",
          chars:
            "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზთიკლმნოპჟრსტუფქღყშჩცძწჭხჯჰჱჲჳჴჵჶçèéêëìíîïðñòóôõö÷øùúûüýþÿ",
        },
        georgianps: {
          type: "_sbcs",
          chars:
            "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზჱთიკლმნჲოპჟრსტჳუფქღყშჩცძწჭხჴჯჰჵæçèéêëìíîïðñòóôõö÷øùúûüýþÿ",
        },
        pt154: {
          type: "_sbcs",
          chars:
            "ҖҒӮғ„…ҶҮҲүҠӢҢҚҺҸҗ‘’“”•–—ҳҷҡӣңқһҹ ЎўЈӨҘҰ§Ё©Ә«¬ӯ®Ҝ°ұІіҙө¶·ё№ә»јҪҫҝАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя",
        },
        viscii: {
          type: "_sbcs",
          chars: `\0ẲẴẪ\x07\b
\v\f\rỶỸ\x1BỴ !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~ẠẮẰẶẤẦẨẬẼẸẾỀỂỄỆỐỒỔỖỘỢỚỜỞỊỎỌỈỦŨỤỲÕắằặấầẩậẽẹếềểễệốồổỗỠƠộờởịỰỨỪỬơớƯÀÁÂÃẢĂẳẵÈÉÊẺÌÍĨỳĐứÒÓÔạỷừửÙÚỹỵÝỡưàáâãảăữẫèéêẻìíĩỉđựòóôõỏọụùúũủýợỮ`,
        },
        iso646cn: {
          type: "_sbcs",
          chars: `\0\x07\b
\v\f\r\x1B !"#¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������`,
        },
        iso646jp: {
          type: "_sbcs",
          chars: `\0\x07\b
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[¥]^_\`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������`,
        },
        hproman8: {
          type: "_sbcs",
          chars:
            " ÀÂÈÊËÎÏ´ˋˆ¨˜ÙÛ₤¯Ýý°ÇçÑñ¡¿¤£¥§ƒ¢âêôûáéóúàèòùäëöüÅîØÆåíøæÄìÖÜÉïßÔÁÃãÐðÍÌÓÒÕõŠšÚŸÿÞþ·µ¶¾—¼½ªº«■»±�",
        },
        macintosh: {
          type: "_sbcs",
          chars:
            "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
        },
        ascii: {
          type: "_sbcs",
          chars:
            "��������������������������������������������������������������������������������������������������������������������������������",
        },
        tis620: {
          type: "_sbcs",
          chars:
            "���������������������������������กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����",
        },
      })),
    uh
  );
}
var fh = {},
  F1;
function AN() {
  if (F1) return fh;
  F1 = 1;
  var e = Xa().Buffer;
  fh._dbcs = c;
  for (
    var t = -1, n = -2, r = -10, i = -1e3, a = new Array(256), s = -1, o = 0;
    o < 256;
    o++
  )
    a[o] = t;
  function c(d, p) {
    if (((this.encodingName = d.encodingName), !d))
      throw new Error("DBCS codec is called without the data.");
    if (!d.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var h = d.table();
    (this.decodeTables = []),
      (this.decodeTables[0] = a.slice(0)),
      (this.decodeTableSeq = []);
    for (var m = 0; m < h.length; m++) this._addDecodeChunk(h[m]);
    (this.defaultCharUnicode = p.defaultCharUnicode),
      (this.encodeTable = []),
      (this.encodeTableSeq = []);
    var g = {};
    if (d.encodeSkipVals)
      for (var m = 0; m < d.encodeSkipVals.length; m++) {
        var v = d.encodeSkipVals[m];
        if (typeof v == "number") g[v] = !0;
        else for (var y = v.from; y <= v.to; y++) g[y] = !0;
      }
    if ((this._fillEncodeTable(0, 0, g), d.encodeAdd))
      for (var _ in d.encodeAdd)
        Object.prototype.hasOwnProperty.call(d.encodeAdd, _) &&
          this._setEncodeChar(_.charCodeAt(0), d.encodeAdd[_]);
    if (
      ((this.defCharSB =
        this.encodeTable[0][p.defaultCharSingleByte.charCodeAt(0)]),
      this.defCharSB === t && (this.defCharSB = this.encodeTable[0]["?"]),
      this.defCharSB === t && (this.defCharSB = "?".charCodeAt(0)),
      typeof d.gb18030 == "function")
    ) {
      this.gb18030 = d.gb18030();
      for (
        var E = this.decodeTables.length,
          R = (this.decodeTables[E] = a.slice(0)),
          A = this.decodeTables.length,
          I = (this.decodeTables[A] = a.slice(0)),
          m = 129;
        m <= 254;
        m++
      )
        for (
          var S = i - this.decodeTables[0][m], w = this.decodeTables[S], y = 48;
          y <= 57;
          y++
        )
          w[y] = i - E;
      for (var m = 129; m <= 254; m++) R[m] = i - A;
      for (var m = 48; m <= 57; m++) I[m] = n;
    }
  }
  (c.prototype.encoder = l),
    (c.prototype.decoder = f),
    (c.prototype._getDecodeTrieNode = function (d) {
      for (var p = []; d > 0; d >>= 8) p.push(d & 255);
      p.length == 0 && p.push(0);
      for (var h = this.decodeTables[0], m = p.length - 1; m > 0; m--) {
        var g = h[p[m]];
        if (g == t)
          (h[p[m]] = i - this.decodeTables.length),
            this.decodeTables.push((h = a.slice(0)));
        else if (g <= i) h = this.decodeTables[i - g];
        else
          throw new Error(
            "Overwrite byte in " +
              this.encodingName +
              ", addr: " +
              d.toString(16),
          );
      }
      return h;
    }),
    (c.prototype._addDecodeChunk = function (d) {
      var p = parseInt(d[0], 16),
        h = this._getDecodeTrieNode(p);
      p = p & 255;
      for (var m = 1; m < d.length; m++) {
        var g = d[m];
        if (typeof g == "string")
          for (var v = 0; v < g.length; ) {
            var y = g.charCodeAt(v++);
            if (55296 <= y && y < 56320) {
              var _ = g.charCodeAt(v++);
              if (56320 <= _ && _ < 57344)
                h[p++] = 65536 + (y - 55296) * 1024 + (_ - 56320);
              else
                throw new Error(
                  "Incorrect surrogate pair in " +
                    this.encodingName +
                    " at chunk " +
                    d[0],
                );
            } else if (4080 < y && y <= 4095) {
              for (var E = 4095 - y + 2, R = [], A = 0; A < E; A++)
                R.push(g.charCodeAt(v++));
              (h[p++] = r - this.decodeTableSeq.length),
                this.decodeTableSeq.push(R);
            } else h[p++] = y;
          }
        else if (typeof g == "number")
          for (var I = h[p - 1] + 1, v = 0; v < g; v++) h[p++] = I++;
        else
          throw new Error(
            "Incorrect type '" +
              typeof g +
              "' given in " +
              this.encodingName +
              " at chunk " +
              d[0],
          );
      }
      if (p > 255)
        throw new Error(
          "Incorrect chunk in " +
            this.encodingName +
            " at addr " +
            d[0] +
            ": too long" +
            p,
        );
    }),
    (c.prototype._getEncodeBucket = function (d) {
      var p = d >> 8;
      return (
        this.encodeTable[p] === void 0 && (this.encodeTable[p] = a.slice(0)),
        this.encodeTable[p]
      );
    }),
    (c.prototype._setEncodeChar = function (d, p) {
      var h = this._getEncodeBucket(d),
        m = d & 255;
      h[m] <= r
        ? (this.encodeTableSeq[r - h[m]][s] = p)
        : h[m] == t && (h[m] = p);
    }),
    (c.prototype._setEncodeSequence = function (d, p) {
      var h = d[0],
        m = this._getEncodeBucket(h),
        g = h & 255,
        v;
      m[g] <= r
        ? (v = this.encodeTableSeq[r - m[g]])
        : ((v = {}),
          m[g] !== t && (v[s] = m[g]),
          (m[g] = r - this.encodeTableSeq.length),
          this.encodeTableSeq.push(v));
      for (var y = 1; y < d.length - 1; y++) {
        var _ = v[h];
        typeof _ == "object"
          ? (v = _)
          : ((v = v[h] = {}), _ !== void 0 && (v[s] = _));
      }
      (h = d[d.length - 1]), (v[h] = p);
    }),
    (c.prototype._fillEncodeTable = function (d, p, h) {
      for (var m = this.decodeTables[d], g = 0; g < 256; g++) {
        var v = m[g],
          y = p + g;
        h[y] ||
          (v >= 0
            ? this._setEncodeChar(v, y)
            : v <= i
            ? this._fillEncodeTable(i - v, y << 8, h)
            : v <= r && this._setEncodeSequence(this.decodeTableSeq[r - v], y));
      }
    });
  function l(d, p) {
    (this.leadSurrogate = -1),
      (this.seqObj = void 0),
      (this.encodeTable = p.encodeTable),
      (this.encodeTableSeq = p.encodeTableSeq),
      (this.defaultCharSingleByte = p.defCharSB),
      (this.gb18030 = p.gb18030);
  }
  (l.prototype.write = function (d) {
    for (
      var p = e.alloc(d.length * (this.gb18030 ? 4 : 3)),
        h = this.leadSurrogate,
        m = this.seqObj,
        g = -1,
        v = 0,
        y = 0;
      ;

    ) {
      if (g === -1) {
        if (v == d.length) break;
        var _ = d.charCodeAt(v++);
      } else {
        var _ = g;
        g = -1;
      }
      if (55296 <= _ && _ < 57344)
        if (_ < 56320)
          if (h === -1) {
            h = _;
            continue;
          } else (h = _), (_ = t);
        else
          h !== -1
            ? ((_ = 65536 + (h - 55296) * 1024 + (_ - 56320)), (h = -1))
            : (_ = t);
      else h !== -1 && ((g = _), (_ = t), (h = -1));
      var E = t;
      if (m !== void 0 && _ != t) {
        var R = m[_];
        if (typeof R == "object") {
          m = R;
          continue;
        } else
          typeof R == "number"
            ? (E = R)
            : R == null && ((R = m[s]), R !== void 0 && ((E = R), (g = _)));
        m = void 0;
      } else if (_ >= 0) {
        var A = this.encodeTable[_ >> 8];
        if ((A !== void 0 && (E = A[_ & 255]), E <= r)) {
          m = this.encodeTableSeq[r - E];
          continue;
        }
        if (E == t && this.gb18030) {
          var I = u(this.gb18030.uChars, _);
          if (I != -1) {
            var E = this.gb18030.gbChars[I] + (_ - this.gb18030.uChars[I]);
            (p[y++] = 129 + Math.floor(E / 12600)),
              (E = E % 12600),
              (p[y++] = 48 + Math.floor(E / 1260)),
              (E = E % 1260),
              (p[y++] = 129 + Math.floor(E / 10)),
              (E = E % 10),
              (p[y++] = 48 + E);
            continue;
          }
        }
      }
      E === t && (E = this.defaultCharSingleByte),
        E < 256
          ? (p[y++] = E)
          : E < 65536
          ? ((p[y++] = E >> 8), (p[y++] = E & 255))
          : ((p[y++] = E >> 16), (p[y++] = (E >> 8) & 255), (p[y++] = E & 255));
    }
    return (this.seqObj = m), (this.leadSurrogate = h), p.slice(0, y);
  }),
    (l.prototype.end = function () {
      if (!(this.leadSurrogate === -1 && this.seqObj === void 0)) {
        var d = e.alloc(10),
          p = 0;
        if (this.seqObj) {
          var h = this.seqObj[s];
          h !== void 0 &&
            (h < 256 ? (d[p++] = h) : ((d[p++] = h >> 8), (d[p++] = h & 255))),
            (this.seqObj = void 0);
        }
        return (
          this.leadSurrogate !== -1 &&
            ((d[p++] = this.defaultCharSingleByte), (this.leadSurrogate = -1)),
          d.slice(0, p)
        );
      }
    }),
    (l.prototype.findIdx = u);
  function f(d, p) {
    (this.nodeIdx = 0),
      (this.prevBuf = e.alloc(0)),
      (this.decodeTables = p.decodeTables),
      (this.decodeTableSeq = p.decodeTableSeq),
      (this.defaultCharUnicode = p.defaultCharUnicode),
      (this.gb18030 = p.gb18030);
  }
  (f.prototype.write = function (d) {
    var p = e.alloc(d.length * 2),
      h = this.nodeIdx,
      m = this.prevBuf,
      g = this.prevBuf.length,
      v = -this.prevBuf.length,
      y;
    g > 0 && (m = e.concat([m, d.slice(0, 10)]));
    for (var _ = 0, E = 0; _ < d.length; _++) {
      var R = _ >= 0 ? d[_] : m[_ + g],
        y = this.decodeTables[h][R];
      if (!(y >= 0))
        if (y === t) (_ = v), (y = this.defaultCharUnicode.charCodeAt(0));
        else if (y === n) {
          var A = v >= 0 ? d.slice(v, _ + 1) : m.slice(v + g, _ + 1 + g),
            I =
              (A[0] - 129) * 12600 +
              (A[1] - 48) * 1260 +
              (A[2] - 129) * 10 +
              (A[3] - 48),
            S = u(this.gb18030.gbChars, I);
          y = this.gb18030.uChars[S] + I - this.gb18030.gbChars[S];
        } else if (y <= i) {
          h = i - y;
          continue;
        } else if (y <= r) {
          for (var w = this.decodeTableSeq[r - y], O = 0; O < w.length - 1; O++)
            (y = w[O]), (p[E++] = y & 255), (p[E++] = y >> 8);
          y = w[w.length - 1];
        } else
          throw new Error(
            "iconv-lite internal error: invalid decoding table value " +
              y +
              " at " +
              h +
              "/" +
              R,
          );
      if (y > 65535) {
        y -= 65536;
        var Q = 55296 + Math.floor(y / 1024);
        (p[E++] = Q & 255), (p[E++] = Q >> 8), (y = 56320 + (y % 1024));
      }
      (p[E++] = y & 255), (p[E++] = y >> 8), (h = 0), (v = _ + 1);
    }
    return (
      (this.nodeIdx = h),
      (this.prevBuf = v >= 0 ? d.slice(v) : m.slice(v + g)),
      p.slice(0, E).toString("ucs2")
    );
  }),
    (f.prototype.end = function () {
      for (var d = ""; this.prevBuf.length > 0; ) {
        d += this.defaultCharUnicode;
        var p = this.prevBuf.slice(1);
        (this.prevBuf = e.alloc(0)),
          (this.nodeIdx = 0),
          p.length > 0 && (d += this.write(p));
      }
      return (this.nodeIdx = 0), d;
    });
  function u(d, p) {
    if (d[0] > p) return -1;
    for (var h = 0, m = d.length; h < m - 1; ) {
      var g = h + Math.floor((m - h + 1) / 2);
      d[g] <= p ? (h = g) : (m = g);
    }
    return h;
  }
  return fh;
}
const SN = [
    ["0", "\0", 128],
    ["a1", "｡", 62],
    [
      "8140",
      "　、。，．・：；？！゛゜´｀¨＾￣＿ヽヾゝゞ〃仝々〆〇ー―‐／＼～∥｜…‥‘’“”（）〔〕［］｛｝〈",
      9,
      "＋－±×",
    ],
    ["8180", "÷＝≠＜＞≦≧∞∴♂♀°′″℃￥＄￠￡％＃＆＊＠§☆★○●◎◇◆□■△▲▽▼※〒→←↑↓〓"],
    ["81b8", "∈∋⊆⊇⊂⊃∪∩"],
    ["81c8", "∧∨￢⇒⇔∀∃"],
    ["81da", "∠⊥⌒∂∇≡≒≪≫√∽∝∵∫∬"],
    ["81f0", "Å‰♯♭♪†‡¶"],
    ["81fc", "◯"],
    ["824f", "０", 9],
    ["8260", "Ａ", 25],
    ["8281", "ａ", 25],
    ["829f", "ぁ", 82],
    ["8340", "ァ", 62],
    ["8380", "ム", 22],
    ["839f", "Α", 16, "Σ", 6],
    ["83bf", "α", 16, "σ", 6],
    ["8440", "А", 5, "ЁЖ", 25],
    ["8470", "а", 5, "ёж", 7],
    ["8480", "о", 17],
    ["849f", "─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂"],
    ["8740", "①", 19, "Ⅰ", 9],
    ["875f", "㍉㌔㌢㍍㌘㌧㌃㌶㍑㍗㌍㌦㌣㌫㍊㌻㎜㎝㎞㎎㎏㏄㎡"],
    ["877e", "㍻"],
    ["8780", "〝〟№㏍℡㊤", 4, "㈱㈲㈹㍾㍽㍼≒≡∫∮∑√⊥∠∟⊿∵∩∪"],
    [
      "889f",
      "亜唖娃阿哀愛挨姶逢葵茜穐悪握渥旭葦芦鯵梓圧斡扱宛姐虻飴絢綾鮎或粟袷安庵按暗案闇鞍杏以伊位依偉囲夷委威尉惟意慰易椅為畏異移維緯胃萎衣謂違遺医井亥域育郁磯一壱溢逸稲茨芋鰯允印咽員因姻引飲淫胤蔭",
    ],
    [
      "8940",
      "院陰隠韻吋右宇烏羽迂雨卯鵜窺丑碓臼渦嘘唄欝蔚鰻姥厩浦瓜閏噂云運雲荏餌叡営嬰影映曳栄永泳洩瑛盈穎頴英衛詠鋭液疫益駅悦謁越閲榎厭円",
    ],
    [
      "8980",
      "園堰奄宴延怨掩援沿演炎焔煙燕猿縁艶苑薗遠鉛鴛塩於汚甥凹央奥往応押旺横欧殴王翁襖鴬鴎黄岡沖荻億屋憶臆桶牡乙俺卸恩温穏音下化仮何伽価佳加可嘉夏嫁家寡科暇果架歌河火珂禍禾稼箇花苛茄荷華菓蝦課嘩貨迦過霞蚊俄峨我牙画臥芽蛾賀雅餓駕介会解回塊壊廻快怪悔恢懐戒拐改",
    ],
    [
      "8a40",
      "魁晦械海灰界皆絵芥蟹開階貝凱劾外咳害崖慨概涯碍蓋街該鎧骸浬馨蛙垣柿蛎鈎劃嚇各廓拡撹格核殻獲確穫覚角赫較郭閣隔革学岳楽額顎掛笠樫",
    ],
    [
      "8a80",
      "橿梶鰍潟割喝恰括活渇滑葛褐轄且鰹叶椛樺鞄株兜竃蒲釜鎌噛鴨栢茅萱粥刈苅瓦乾侃冠寒刊勘勧巻喚堪姦完官寛干幹患感慣憾換敢柑桓棺款歓汗漢澗潅環甘監看竿管簡緩缶翰肝艦莞観諌貫還鑑間閑関陥韓館舘丸含岸巌玩癌眼岩翫贋雁頑顔願企伎危喜器基奇嬉寄岐希幾忌揮机旗既期棋棄",
    ],
    [
      "8b40",
      "機帰毅気汽畿祈季稀紀徽規記貴起軌輝飢騎鬼亀偽儀妓宜戯技擬欺犠疑祇義蟻誼議掬菊鞠吉吃喫桔橘詰砧杵黍却客脚虐逆丘久仇休及吸宮弓急救",
    ],
    [
      "8b80",
      "朽求汲泣灸球究窮笈級糾給旧牛去居巨拒拠挙渠虚許距鋸漁禦魚亨享京供侠僑兇競共凶協匡卿叫喬境峡強彊怯恐恭挟教橋況狂狭矯胸脅興蕎郷鏡響饗驚仰凝尭暁業局曲極玉桐粁僅勤均巾錦斤欣欽琴禁禽筋緊芹菌衿襟謹近金吟銀九倶句区狗玖矩苦躯駆駈駒具愚虞喰空偶寓遇隅串櫛釧屑屈",
    ],
    [
      "8c40",
      "掘窟沓靴轡窪熊隈粂栗繰桑鍬勲君薫訓群軍郡卦袈祁係傾刑兄啓圭珪型契形径恵慶慧憩掲携敬景桂渓畦稽系経継繋罫茎荊蛍計詣警軽頚鶏芸迎鯨",
    ],
    [
      "8c80",
      "劇戟撃激隙桁傑欠決潔穴結血訣月件倹倦健兼券剣喧圏堅嫌建憲懸拳捲検権牽犬献研硯絹県肩見謙賢軒遣鍵険顕験鹸元原厳幻弦減源玄現絃舷言諺限乎個古呼固姑孤己庫弧戸故枯湖狐糊袴股胡菰虎誇跨鈷雇顧鼓五互伍午呉吾娯後御悟梧檎瑚碁語誤護醐乞鯉交佼侯候倖光公功効勾厚口向",
    ],
    [
      "8d40",
      "后喉坑垢好孔孝宏工巧巷幸広庚康弘恒慌抗拘控攻昂晃更杭校梗構江洪浩港溝甲皇硬稿糠紅紘絞綱耕考肯肱腔膏航荒行衡講貢購郊酵鉱砿鋼閤降",
    ],
    [
      "8d80",
      "項香高鴻剛劫号合壕拷濠豪轟麹克刻告国穀酷鵠黒獄漉腰甑忽惚骨狛込此頃今困坤墾婚恨懇昏昆根梱混痕紺艮魂些佐叉唆嵯左差査沙瑳砂詐鎖裟坐座挫債催再最哉塞妻宰彩才採栽歳済災采犀砕砦祭斎細菜裁載際剤在材罪財冴坂阪堺榊肴咲崎埼碕鷺作削咋搾昨朔柵窄策索錯桜鮭笹匙冊刷",
    ],
    [
      "8e40",
      "察拶撮擦札殺薩雑皐鯖捌錆鮫皿晒三傘参山惨撒散桟燦珊産算纂蚕讃賛酸餐斬暫残仕仔伺使刺司史嗣四士始姉姿子屍市師志思指支孜斯施旨枝止",
    ],
    [
      "8e80",
      "死氏獅祉私糸紙紫肢脂至視詞詩試誌諮資賜雌飼歯事似侍児字寺慈持時次滋治爾璽痔磁示而耳自蒔辞汐鹿式識鴫竺軸宍雫七叱執失嫉室悉湿漆疾質実蔀篠偲柴芝屡蕊縞舎写射捨赦斜煮社紗者謝車遮蛇邪借勺尺杓灼爵酌釈錫若寂弱惹主取守手朱殊狩珠種腫趣酒首儒受呪寿授樹綬需囚収周",
    ],
    [
      "8f40",
      "宗就州修愁拾洲秀秋終繍習臭舟蒐衆襲讐蹴輯週酋酬集醜什住充十従戎柔汁渋獣縦重銃叔夙宿淑祝縮粛塾熟出術述俊峻春瞬竣舜駿准循旬楯殉淳",
    ],
    [
      "8f80",
      "準潤盾純巡遵醇順処初所暑曙渚庶緒署書薯藷諸助叙女序徐恕鋤除傷償勝匠升召哨商唱嘗奨妾娼宵将小少尚庄床廠彰承抄招掌捷昇昌昭晶松梢樟樵沼消渉湘焼焦照症省硝礁祥称章笑粧紹肖菖蒋蕉衝裳訟証詔詳象賞醤鉦鍾鐘障鞘上丈丞乗冗剰城場壌嬢常情擾条杖浄状畳穣蒸譲醸錠嘱埴飾",
    ],
    [
      "9040",
      "拭植殖燭織職色触食蝕辱尻伸信侵唇娠寝審心慎振新晋森榛浸深申疹真神秦紳臣芯薪親診身辛進針震人仁刃塵壬尋甚尽腎訊迅陣靭笥諏須酢図厨",
    ],
    [
      "9080",
      "逗吹垂帥推水炊睡粋翠衰遂酔錐錘随瑞髄崇嵩数枢趨雛据杉椙菅頗雀裾澄摺寸世瀬畝是凄制勢姓征性成政整星晴棲栖正清牲生盛精聖声製西誠誓請逝醒青静斉税脆隻席惜戚斥昔析石積籍績脊責赤跡蹟碩切拙接摂折設窃節説雪絶舌蝉仙先千占宣専尖川戦扇撰栓栴泉浅洗染潜煎煽旋穿箭線",
    ],
    [
      "9140",
      "繊羨腺舛船薦詮賎践選遷銭銑閃鮮前善漸然全禅繕膳糎噌塑岨措曾曽楚狙疏疎礎祖租粗素組蘇訴阻遡鼠僧創双叢倉喪壮奏爽宋層匝惣想捜掃挿掻",
    ],
    [
      "9180",
      "操早曹巣槍槽漕燥争痩相窓糟総綜聡草荘葬蒼藻装走送遭鎗霜騒像増憎臓蔵贈造促側則即息捉束測足速俗属賊族続卒袖其揃存孫尊損村遜他多太汰詑唾堕妥惰打柁舵楕陀駄騨体堆対耐岱帯待怠態戴替泰滞胎腿苔袋貸退逮隊黛鯛代台大第醍題鷹滝瀧卓啄宅托択拓沢濯琢託鐸濁諾茸凧蛸只",
    ],
    [
      "9240",
      "叩但達辰奪脱巽竪辿棚谷狸鱈樽誰丹単嘆坦担探旦歎淡湛炭短端箪綻耽胆蛋誕鍛団壇弾断暖檀段男談値知地弛恥智池痴稚置致蜘遅馳築畜竹筑蓄",
    ],
    [
      "9280",
      "逐秩窒茶嫡着中仲宙忠抽昼柱注虫衷註酎鋳駐樗瀦猪苧著貯丁兆凋喋寵帖帳庁弔張彫徴懲挑暢朝潮牒町眺聴脹腸蝶調諜超跳銚長頂鳥勅捗直朕沈珍賃鎮陳津墜椎槌追鎚痛通塚栂掴槻佃漬柘辻蔦綴鍔椿潰坪壷嬬紬爪吊釣鶴亭低停偵剃貞呈堤定帝底庭廷弟悌抵挺提梯汀碇禎程締艇訂諦蹄逓",
    ],
    [
      "9340",
      "邸鄭釘鼎泥摘擢敵滴的笛適鏑溺哲徹撤轍迭鉄典填天展店添纏甜貼転顛点伝殿澱田電兎吐堵塗妬屠徒斗杜渡登菟賭途都鍍砥砺努度土奴怒倒党冬",
    ],
    [
      "9380",
      "凍刀唐塔塘套宕島嶋悼投搭東桃梼棟盗淘湯涛灯燈当痘祷等答筒糖統到董蕩藤討謄豆踏逃透鐙陶頭騰闘働動同堂導憧撞洞瞳童胴萄道銅峠鴇匿得徳涜特督禿篤毒独読栃橡凸突椴届鳶苫寅酉瀞噸屯惇敦沌豚遁頓呑曇鈍奈那内乍凪薙謎灘捺鍋楢馴縄畷南楠軟難汝二尼弐迩匂賑肉虹廿日乳入",
    ],
    [
      "9440",
      "如尿韮任妊忍認濡禰祢寧葱猫熱年念捻撚燃粘乃廼之埜嚢悩濃納能脳膿農覗蚤巴把播覇杷波派琶破婆罵芭馬俳廃拝排敗杯盃牌背肺輩配倍培媒梅",
    ],
    [
      "9480",
      "楳煤狽買売賠陪這蝿秤矧萩伯剥博拍柏泊白箔粕舶薄迫曝漠爆縛莫駁麦函箱硲箸肇筈櫨幡肌畑畠八鉢溌発醗髪伐罰抜筏閥鳩噺塙蛤隼伴判半反叛帆搬斑板氾汎版犯班畔繁般藩販範釆煩頒飯挽晩番盤磐蕃蛮匪卑否妃庇彼悲扉批披斐比泌疲皮碑秘緋罷肥被誹費避非飛樋簸備尾微枇毘琵眉美",
    ],
    [
      "9540",
      "鼻柊稗匹疋髭彦膝菱肘弼必畢筆逼桧姫媛紐百謬俵彪標氷漂瓢票表評豹廟描病秒苗錨鋲蒜蛭鰭品彬斌浜瀕貧賓頻敏瓶不付埠夫婦富冨布府怖扶敷",
    ],
    [
      "9580",
      "斧普浮父符腐膚芙譜負賦赴阜附侮撫武舞葡蕪部封楓風葺蕗伏副復幅服福腹複覆淵弗払沸仏物鮒分吻噴墳憤扮焚奮粉糞紛雰文聞丙併兵塀幣平弊柄並蔽閉陛米頁僻壁癖碧別瞥蔑箆偏変片篇編辺返遍便勉娩弁鞭保舗鋪圃捕歩甫補輔穂募墓慕戊暮母簿菩倣俸包呆報奉宝峰峯崩庖抱捧放方朋",
    ],
    [
      "9640",
      "法泡烹砲縫胞芳萌蓬蜂褒訪豊邦鋒飽鳳鵬乏亡傍剖坊妨帽忘忙房暴望某棒冒紡肪膨謀貌貿鉾防吠頬北僕卜墨撲朴牧睦穆釦勃没殆堀幌奔本翻凡盆",
    ],
    [
      "9680",
      "摩磨魔麻埋妹昧枚毎哩槙幕膜枕鮪柾鱒桝亦俣又抹末沫迄侭繭麿万慢満漫蔓味未魅巳箕岬密蜜湊蓑稔脈妙粍民眠務夢無牟矛霧鵡椋婿娘冥名命明盟迷銘鳴姪牝滅免棉綿緬面麺摸模茂妄孟毛猛盲網耗蒙儲木黙目杢勿餅尤戻籾貰問悶紋門匁也冶夜爺耶野弥矢厄役約薬訳躍靖柳薮鑓愉愈油癒",
    ],
    [
      "9740",
      "諭輸唯佑優勇友宥幽悠憂揖有柚湧涌猶猷由祐裕誘遊邑郵雄融夕予余与誉輿預傭幼妖容庸揚揺擁曜楊様洋溶熔用窯羊耀葉蓉要謡踊遥陽養慾抑欲",
    ],
    [
      "9780",
      "沃浴翌翼淀羅螺裸来莱頼雷洛絡落酪乱卵嵐欄濫藍蘭覧利吏履李梨理璃痢裏裡里離陸律率立葎掠略劉流溜琉留硫粒隆竜龍侶慮旅虜了亮僚両凌寮料梁涼猟療瞭稜糧良諒遼量陵領力緑倫厘林淋燐琳臨輪隣鱗麟瑠塁涙累類令伶例冷励嶺怜玲礼苓鈴隷零霊麗齢暦歴列劣烈裂廉恋憐漣煉簾練聯",
    ],
    [
      "9840",
      "蓮連錬呂魯櫓炉賂路露労婁廊弄朗楼榔浪漏牢狼篭老聾蝋郎六麓禄肋録論倭和話歪賄脇惑枠鷲亙亘鰐詫藁蕨椀湾碗腕",
    ],
    [
      "989f",
      "弌丐丕个丱丶丼丿乂乖乘亂亅豫亊舒弍于亞亟亠亢亰亳亶从仍仄仆仂仗仞仭仟价伉佚估佛佝佗佇佶侈侏侘佻佩佰侑佯來侖儘俔俟俎俘俛俑俚俐俤俥倚倨倔倪倥倅伜俶倡倩倬俾俯們倆偃假會偕偐偈做偖偬偸傀傚傅傴傲",
    ],
    [
      "9940",
      "僉僊傳僂僖僞僥僭僣僮價僵儉儁儂儖儕儔儚儡儺儷儼儻儿兀兒兌兔兢竸兩兪兮冀冂囘册冉冏冑冓冕冖冤冦冢冩冪冫决冱冲冰况冽凅凉凛几處凩凭",
    ],
    [
      "9980",
      "凰凵凾刄刋刔刎刧刪刮刳刹剏剄剋剌剞剔剪剴剩剳剿剽劍劔劒剱劈劑辨辧劬劭劼劵勁勍勗勞勣勦飭勠勳勵勸勹匆匈甸匍匐匏匕匚匣匯匱匳匸區卆卅丗卉卍凖卞卩卮夘卻卷厂厖厠厦厥厮厰厶參簒雙叟曼燮叮叨叭叺吁吽呀听吭吼吮吶吩吝呎咏呵咎呟呱呷呰咒呻咀呶咄咐咆哇咢咸咥咬哄哈咨",
    ],
    [
      "9a40",
      "咫哂咤咾咼哘哥哦唏唔哽哮哭哺哢唹啀啣啌售啜啅啖啗唸唳啝喙喀咯喊喟啻啾喘喞單啼喃喩喇喨嗚嗅嗟嗄嗜嗤嗔嘔嗷嘖嗾嗽嘛嗹噎噐營嘴嘶嘲嘸",
    ],
    [
      "9a80",
      "噫噤嘯噬噪嚆嚀嚊嚠嚔嚏嚥嚮嚶嚴囂嚼囁囃囀囈囎囑囓囗囮囹圀囿圄圉圈國圍圓團圖嗇圜圦圷圸坎圻址坏坩埀垈坡坿垉垓垠垳垤垪垰埃埆埔埒埓堊埖埣堋堙堝塲堡塢塋塰毀塒堽塹墅墹墟墫墺壞墻墸墮壅壓壑壗壙壘壥壜壤壟壯壺壹壻壼壽夂夊夐夛梦夥夬夭夲夸夾竒奕奐奎奚奘奢奠奧奬奩",
    ],
    [
      "9b40",
      "奸妁妝佞侫妣妲姆姨姜妍姙姚娥娟娑娜娉娚婀婬婉娵娶婢婪媚媼媾嫋嫂媽嫣嫗嫦嫩嫖嫺嫻嬌嬋嬖嬲嫐嬪嬶嬾孃孅孀孑孕孚孛孥孩孰孳孵學斈孺宀",
    ],
    [
      "9b80",
      "它宦宸寃寇寉寔寐寤實寢寞寥寫寰寶寳尅將專對尓尠尢尨尸尹屁屆屎屓屐屏孱屬屮乢屶屹岌岑岔妛岫岻岶岼岷峅岾峇峙峩峽峺峭嶌峪崋崕崗嵜崟崛崑崔崢崚崙崘嵌嵒嵎嵋嵬嵳嵶嶇嶄嶂嶢嶝嶬嶮嶽嶐嶷嶼巉巍巓巒巖巛巫已巵帋帚帙帑帛帶帷幄幃幀幎幗幔幟幢幤幇幵并幺麼广庠廁廂廈廐廏",
    ],
    [
      "9c40",
      "廖廣廝廚廛廢廡廨廩廬廱廳廰廴廸廾弃弉彝彜弋弑弖弩弭弸彁彈彌彎弯彑彖彗彙彡彭彳彷徃徂彿徊很徑徇從徙徘徠徨徭徼忖忻忤忸忱忝悳忿怡恠",
    ],
    [
      "9c80",
      "怙怐怩怎怱怛怕怫怦怏怺恚恁恪恷恟恊恆恍恣恃恤恂恬恫恙悁悍惧悃悚悄悛悖悗悒悧悋惡悸惠惓悴忰悽惆悵惘慍愕愆惶惷愀惴惺愃愡惻惱愍愎慇愾愨愧慊愿愼愬愴愽慂慄慳慷慘慙慚慫慴慯慥慱慟慝慓慵憙憖憇憬憔憚憊憑憫憮懌懊應懷懈懃懆憺懋罹懍懦懣懶懺懴懿懽懼懾戀戈戉戍戌戔戛",
    ],
    [
      "9d40",
      "戞戡截戮戰戲戳扁扎扞扣扛扠扨扼抂抉找抒抓抖拔抃抔拗拑抻拏拿拆擔拈拜拌拊拂拇抛拉挌拮拱挧挂挈拯拵捐挾捍搜捏掖掎掀掫捶掣掏掉掟掵捫",
    ],
    [
      "9d80",
      "捩掾揩揀揆揣揉插揶揄搖搴搆搓搦搶攝搗搨搏摧摯摶摎攪撕撓撥撩撈撼據擒擅擇撻擘擂擱擧舉擠擡抬擣擯攬擶擴擲擺攀擽攘攜攅攤攣攫攴攵攷收攸畋效敖敕敍敘敞敝敲數斂斃變斛斟斫斷旃旆旁旄旌旒旛旙无旡旱杲昊昃旻杳昵昶昴昜晏晄晉晁晞晝晤晧晨晟晢晰暃暈暎暉暄暘暝曁暹曉暾暼",
    ],
    [
      "9e40",
      "曄暸曖曚曠昿曦曩曰曵曷朏朖朞朦朧霸朮朿朶杁朸朷杆杞杠杙杣杤枉杰枩杼杪枌枋枦枡枅枷柯枴柬枳柩枸柤柞柝柢柮枹柎柆柧檜栞框栩桀桍栲桎",
    ],
    [
      "9e80",
      "梳栫桙档桷桿梟梏梭梔條梛梃檮梹桴梵梠梺椏梍桾椁棊椈棘椢椦棡椌棍棔棧棕椶椒椄棗棣椥棹棠棯椨椪椚椣椡棆楹楷楜楸楫楔楾楮椹楴椽楙椰楡楞楝榁楪榲榮槐榿槁槓榾槎寨槊槝榻槃榧樮榑榠榜榕榴槞槨樂樛槿權槹槲槧樅榱樞槭樔槫樊樒櫁樣樓橄樌橲樶橸橇橢橙橦橈樸樢檐檍檠檄檢檣",
    ],
    [
      "9f40",
      "檗蘗檻櫃櫂檸檳檬櫞櫑櫟檪櫚櫪櫻欅蘖櫺欒欖鬱欟欸欷盜欹飮歇歃歉歐歙歔歛歟歡歸歹歿殀殄殃殍殘殕殞殤殪殫殯殲殱殳殷殼毆毋毓毟毬毫毳毯",
    ],
    [
      "9f80",
      "麾氈氓气氛氤氣汞汕汢汪沂沍沚沁沛汾汨汳沒沐泄泱泓沽泗泅泝沮沱沾沺泛泯泙泪洟衍洶洫洽洸洙洵洳洒洌浣涓浤浚浹浙涎涕濤涅淹渕渊涵淇淦涸淆淬淞淌淨淒淅淺淙淤淕淪淮渭湮渮渙湲湟渾渣湫渫湶湍渟湃渺湎渤滿渝游溂溪溘滉溷滓溽溯滄溲滔滕溏溥滂溟潁漑灌滬滸滾漿滲漱滯漲滌",
    ],
    [
      "e040",
      "漾漓滷澆潺潸澁澀潯潛濳潭澂潼潘澎澑濂潦澳澣澡澤澹濆澪濟濕濬濔濘濱濮濛瀉瀋濺瀑瀁瀏濾瀛瀚潴瀝瀘瀟瀰瀾瀲灑灣炙炒炯烱炬炸炳炮烟烋烝",
    ],
    [
      "e080",
      "烙焉烽焜焙煥煕熈煦煢煌煖煬熏燻熄熕熨熬燗熹熾燒燉燔燎燠燬燧燵燼燹燿爍爐爛爨爭爬爰爲爻爼爿牀牆牋牘牴牾犂犁犇犒犖犢犧犹犲狃狆狄狎狒狢狠狡狹狷倏猗猊猜猖猝猴猯猩猥猾獎獏默獗獪獨獰獸獵獻獺珈玳珎玻珀珥珮珞璢琅瑯琥珸琲琺瑕琿瑟瑙瑁瑜瑩瑰瑣瑪瑶瑾璋璞璧瓊瓏瓔珱",
    ],
    [
      "e140",
      "瓠瓣瓧瓩瓮瓲瓰瓱瓸瓷甄甃甅甌甎甍甕甓甞甦甬甼畄畍畊畉畛畆畚畩畤畧畫畭畸當疆疇畴疊疉疂疔疚疝疥疣痂疳痃疵疽疸疼疱痍痊痒痙痣痞痾痿",
    ],
    [
      "e180",
      "痼瘁痰痺痲痳瘋瘍瘉瘟瘧瘠瘡瘢瘤瘴瘰瘻癇癈癆癜癘癡癢癨癩癪癧癬癰癲癶癸發皀皃皈皋皎皖皓皙皚皰皴皸皹皺盂盍盖盒盞盡盥盧盪蘯盻眈眇眄眩眤眞眥眦眛眷眸睇睚睨睫睛睥睿睾睹瞎瞋瞑瞠瞞瞰瞶瞹瞿瞼瞽瞻矇矍矗矚矜矣矮矼砌砒礦砠礪硅碎硴碆硼碚碌碣碵碪碯磑磆磋磔碾碼磅磊磬",
    ],
    [
      "e240",
      "磧磚磽磴礇礒礑礙礬礫祀祠祗祟祚祕祓祺祿禊禝禧齋禪禮禳禹禺秉秕秧秬秡秣稈稍稘稙稠稟禀稱稻稾稷穃穗穉穡穢穩龝穰穹穽窈窗窕窘窖窩竈窰",
    ],
    [
      "e280",
      "窶竅竄窿邃竇竊竍竏竕竓站竚竝竡竢竦竭竰笂笏笊笆笳笘笙笞笵笨笶筐筺笄筍笋筌筅筵筥筴筧筰筱筬筮箝箘箟箍箜箚箋箒箏筝箙篋篁篌篏箴篆篝篩簑簔篦篥籠簀簇簓篳篷簗簍篶簣簧簪簟簷簫簽籌籃籔籏籀籐籘籟籤籖籥籬籵粃粐粤粭粢粫粡粨粳粲粱粮粹粽糀糅糂糘糒糜糢鬻糯糲糴糶糺紆",
    ],
    [
      "e340",
      "紂紜紕紊絅絋紮紲紿紵絆絳絖絎絲絨絮絏絣經綉絛綏絽綛綺綮綣綵緇綽綫總綢綯緜綸綟綰緘緝緤緞緻緲緡縅縊縣縡縒縱縟縉縋縢繆繦縻縵縹繃縷",
    ],
    [
      "e380",
      "縲縺繧繝繖繞繙繚繹繪繩繼繻纃緕繽辮繿纈纉續纒纐纓纔纖纎纛纜缸缺罅罌罍罎罐网罕罔罘罟罠罨罩罧罸羂羆羃羈羇羌羔羞羝羚羣羯羲羹羮羶羸譱翅翆翊翕翔翡翦翩翳翹飜耆耄耋耒耘耙耜耡耨耿耻聊聆聒聘聚聟聢聨聳聲聰聶聹聽聿肄肆肅肛肓肚肭冐肬胛胥胙胝胄胚胖脉胯胱脛脩脣脯腋",
    ],
    [
      "e440",
      "隋腆脾腓腑胼腱腮腥腦腴膃膈膊膀膂膠膕膤膣腟膓膩膰膵膾膸膽臀臂膺臉臍臑臙臘臈臚臟臠臧臺臻臾舁舂舅與舊舍舐舖舩舫舸舳艀艙艘艝艚艟艤",
    ],
    [
      "e480",
      "艢艨艪艫舮艱艷艸艾芍芒芫芟芻芬苡苣苟苒苴苳苺莓范苻苹苞茆苜茉苙茵茴茖茲茱荀茹荐荅茯茫茗茘莅莚莪莟莢莖茣莎莇莊荼莵荳荵莠莉莨菴萓菫菎菽萃菘萋菁菷萇菠菲萍萢萠莽萸蔆菻葭萪萼蕚蒄葷葫蒭葮蒂葩葆萬葯葹萵蓊葢蒹蒿蒟蓙蓍蒻蓚蓐蓁蓆蓖蒡蔡蓿蓴蔗蔘蔬蔟蔕蔔蓼蕀蕣蕘蕈",
    ],
    [
      "e540",
      "蕁蘂蕋蕕薀薤薈薑薊薨蕭薔薛藪薇薜蕷蕾薐藉薺藏薹藐藕藝藥藜藹蘊蘓蘋藾藺蘆蘢蘚蘰蘿虍乕虔號虧虱蚓蚣蚩蚪蚋蚌蚶蚯蛄蛆蚰蛉蠣蚫蛔蛞蛩蛬",
    ],
    [
      "e580",
      "蛟蛛蛯蜒蜆蜈蜀蜃蛻蜑蜉蜍蛹蜊蜴蜿蜷蜻蜥蜩蜚蝠蝟蝸蝌蝎蝴蝗蝨蝮蝙蝓蝣蝪蠅螢螟螂螯蟋螽蟀蟐雖螫蟄螳蟇蟆螻蟯蟲蟠蠏蠍蟾蟶蟷蠎蟒蠑蠖蠕蠢蠡蠱蠶蠹蠧蠻衄衂衒衙衞衢衫袁衾袞衵衽袵衲袂袗袒袮袙袢袍袤袰袿袱裃裄裔裘裙裝裹褂裼裴裨裲褄褌褊褓襃褞褥褪褫襁襄褻褶褸襌褝襠襞",
    ],
    [
      "e640",
      "襦襤襭襪襯襴襷襾覃覈覊覓覘覡覩覦覬覯覲覺覽覿觀觚觜觝觧觴觸訃訖訐訌訛訝訥訶詁詛詒詆詈詼詭詬詢誅誂誄誨誡誑誥誦誚誣諄諍諂諚諫諳諧",
    ],
    [
      "e680",
      "諤諱謔諠諢諷諞諛謌謇謚諡謖謐謗謠謳鞫謦謫謾謨譁譌譏譎證譖譛譚譫譟譬譯譴譽讀讌讎讒讓讖讙讚谺豁谿豈豌豎豐豕豢豬豸豺貂貉貅貊貍貎貔豼貘戝貭貪貽貲貳貮貶賈賁賤賣賚賽賺賻贄贅贊贇贏贍贐齎贓賍贔贖赧赭赱赳趁趙跂趾趺跏跚跖跌跛跋跪跫跟跣跼踈踉跿踝踞踐踟蹂踵踰踴蹊",
    ],
    [
      "e740",
      "蹇蹉蹌蹐蹈蹙蹤蹠踪蹣蹕蹶蹲蹼躁躇躅躄躋躊躓躑躔躙躪躡躬躰軆躱躾軅軈軋軛軣軼軻軫軾輊輅輕輒輙輓輜輟輛輌輦輳輻輹轅轂輾轌轉轆轎轗轜",
    ],
    [
      "e780",
      "轢轣轤辜辟辣辭辯辷迚迥迢迪迯邇迴逅迹迺逑逕逡逍逞逖逋逧逶逵逹迸遏遐遑遒逎遉逾遖遘遞遨遯遶隨遲邂遽邁邀邊邉邏邨邯邱邵郢郤扈郛鄂鄒鄙鄲鄰酊酖酘酣酥酩酳酲醋醉醂醢醫醯醪醵醴醺釀釁釉釋釐釖釟釡釛釼釵釶鈞釿鈔鈬鈕鈑鉞鉗鉅鉉鉤鉈銕鈿鉋鉐銜銖銓銛鉚鋏銹銷鋩錏鋺鍄錮",
    ],
    [
      "e840",
      "錙錢錚錣錺錵錻鍜鍠鍼鍮鍖鎰鎬鎭鎔鎹鏖鏗鏨鏥鏘鏃鏝鏐鏈鏤鐚鐔鐓鐃鐇鐐鐶鐫鐵鐡鐺鑁鑒鑄鑛鑠鑢鑞鑪鈩鑰鑵鑷鑽鑚鑼鑾钁鑿閂閇閊閔閖閘閙",
    ],
    [
      "e880",
      "閠閨閧閭閼閻閹閾闊濶闃闍闌闕闔闖關闡闥闢阡阨阮阯陂陌陏陋陷陜陞陝陟陦陲陬隍隘隕隗險隧隱隲隰隴隶隸隹雎雋雉雍襍雜霍雕雹霄霆霈霓霎霑霏霖霙霤霪霰霹霽霾靄靆靈靂靉靜靠靤靦靨勒靫靱靹鞅靼鞁靺鞆鞋鞏鞐鞜鞨鞦鞣鞳鞴韃韆韈韋韜韭齏韲竟韶韵頏頌頸頤頡頷頽顆顏顋顫顯顰",
    ],
    [
      "e940",
      "顱顴顳颪颯颱颶飄飃飆飩飫餃餉餒餔餘餡餝餞餤餠餬餮餽餾饂饉饅饐饋饑饒饌饕馗馘馥馭馮馼駟駛駝駘駑駭駮駱駲駻駸騁騏騅駢騙騫騷驅驂驀驃",
    ],
    [
      "e980",
      "騾驕驍驛驗驟驢驥驤驩驫驪骭骰骼髀髏髑髓體髞髟髢髣髦髯髫髮髴髱髷髻鬆鬘鬚鬟鬢鬣鬥鬧鬨鬩鬪鬮鬯鬲魄魃魏魍魎魑魘魴鮓鮃鮑鮖鮗鮟鮠鮨鮴鯀鯊鮹鯆鯏鯑鯒鯣鯢鯤鯔鯡鰺鯲鯱鯰鰕鰔鰉鰓鰌鰆鰈鰒鰊鰄鰮鰛鰥鰤鰡鰰鱇鰲鱆鰾鱚鱠鱧鱶鱸鳧鳬鳰鴉鴈鳫鴃鴆鴪鴦鶯鴣鴟鵄鴕鴒鵁鴿鴾鵆鵈",
    ],
    [
      "ea40",
      "鵝鵞鵤鵑鵐鵙鵲鶉鶇鶫鵯鵺鶚鶤鶩鶲鷄鷁鶻鶸鶺鷆鷏鷂鷙鷓鷸鷦鷭鷯鷽鸚鸛鸞鹵鹹鹽麁麈麋麌麒麕麑麝麥麩麸麪麭靡黌黎黏黐黔黜點黝黠黥黨黯",
    ],
    [
      "ea80",
      "黴黶黷黹黻黼黽鼇鼈皷鼕鼡鼬鼾齊齒齔齣齟齠齡齦齧齬齪齷齲齶龕龜龠堯槇遙瑤凜熙",
    ],
    [
      "ed40",
      "纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏",
    ],
    [
      "ed80",
      "塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱",
    ],
    [
      "ee40",
      "犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙",
    ],
    [
      "ee80",
      "蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑",
    ],
    ["eeef", "ⅰ", 9, "￢￤＇＂"],
    ["f040", "", 62],
    ["f080", "", 124],
    ["f140", "", 62],
    ["f180", "", 124],
    ["f240", "", 62],
    ["f280", "", 124],
    ["f340", "", 62],
    ["f380", "", 124],
    ["f440", "", 62],
    ["f480", "", 124],
    ["f540", "", 62],
    ["f580", "", 124],
    ["f640", "", 62],
    ["f680", "", 124],
    ["f740", "", 62],
    ["f780", "", 124],
    ["f840", "", 62],
    ["f880", "", 124],
    ["f940", ""],
    [
      "fa40",
      "ⅰ",
      9,
      "Ⅰ",
      9,
      "￢￤＇＂㈱№℡∵纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊",
    ],
    [
      "fa80",
      "兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯",
    ],
    [
      "fb40",
      "涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神",
    ],
    [
      "fb80",
      "祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙",
    ],
    ["fc40", "髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"],
  ],
  IN = [
    ["0", "\0", 127],
    ["8ea1", "｡", 62],
    [
      "a1a1",
      "　、。，．・：；？！゛゜´｀¨＾￣＿ヽヾゝゞ〃仝々〆〇ー―‐／＼～∥｜…‥‘’“”（）〔〕［］｛｝〈",
      9,
      "＋－±×÷＝≠＜＞≦≧∞∴♂♀°′″℃￥＄￠￡％＃＆＊＠§☆★○●◎◇",
    ],
    ["a2a1", "◆□■△▲▽▼※〒→←↑↓〓"],
    ["a2ba", "∈∋⊆⊇⊂⊃∪∩"],
    ["a2ca", "∧∨￢⇒⇔∀∃"],
    ["a2dc", "∠⊥⌒∂∇≡≒≪≫√∽∝∵∫∬"],
    ["a2f2", "Å‰♯♭♪†‡¶"],
    ["a2fe", "◯"],
    ["a3b0", "０", 9],
    ["a3c1", "Ａ", 25],
    ["a3e1", "ａ", 25],
    ["a4a1", "ぁ", 82],
    ["a5a1", "ァ", 85],
    ["a6a1", "Α", 16, "Σ", 6],
    ["a6c1", "α", 16, "σ", 6],
    ["a7a1", "А", 5, "ЁЖ", 25],
    ["a7d1", "а", 5, "ёж", 25],
    ["a8a1", "─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂"],
    ["ada1", "①", 19, "Ⅰ", 9],
    ["adc0", "㍉㌔㌢㍍㌘㌧㌃㌶㍑㍗㌍㌦㌣㌫㍊㌻㎜㎝㎞㎎㎏㏄㎡"],
    ["addf", "㍻〝〟№㏍℡㊤", 4, "㈱㈲㈹㍾㍽㍼≒≡∫∮∑√⊥∠∟⊿∵∩∪"],
    [
      "b0a1",
      "亜唖娃阿哀愛挨姶逢葵茜穐悪握渥旭葦芦鯵梓圧斡扱宛姐虻飴絢綾鮎或粟袷安庵按暗案闇鞍杏以伊位依偉囲夷委威尉惟意慰易椅為畏異移維緯胃萎衣謂違遺医井亥域育郁磯一壱溢逸稲茨芋鰯允印咽員因姻引飲淫胤蔭",
    ],
    [
      "b1a1",
      "院陰隠韻吋右宇烏羽迂雨卯鵜窺丑碓臼渦嘘唄欝蔚鰻姥厩浦瓜閏噂云運雲荏餌叡営嬰影映曳栄永泳洩瑛盈穎頴英衛詠鋭液疫益駅悦謁越閲榎厭円園堰奄宴延怨掩援沿演炎焔煙燕猿縁艶苑薗遠鉛鴛塩於汚甥凹央奥往応",
    ],
    [
      "b2a1",
      "押旺横欧殴王翁襖鴬鴎黄岡沖荻億屋憶臆桶牡乙俺卸恩温穏音下化仮何伽価佳加可嘉夏嫁家寡科暇果架歌河火珂禍禾稼箇花苛茄荷華菓蝦課嘩貨迦過霞蚊俄峨我牙画臥芽蛾賀雅餓駕介会解回塊壊廻快怪悔恢懐戒拐改",
    ],
    [
      "b3a1",
      "魁晦械海灰界皆絵芥蟹開階貝凱劾外咳害崖慨概涯碍蓋街該鎧骸浬馨蛙垣柿蛎鈎劃嚇各廓拡撹格核殻獲確穫覚角赫較郭閣隔革学岳楽額顎掛笠樫橿梶鰍潟割喝恰括活渇滑葛褐轄且鰹叶椛樺鞄株兜竃蒲釜鎌噛鴨栢茅萱",
    ],
    [
      "b4a1",
      "粥刈苅瓦乾侃冠寒刊勘勧巻喚堪姦完官寛干幹患感慣憾換敢柑桓棺款歓汗漢澗潅環甘監看竿管簡緩缶翰肝艦莞観諌貫還鑑間閑関陥韓館舘丸含岸巌玩癌眼岩翫贋雁頑顔願企伎危喜器基奇嬉寄岐希幾忌揮机旗既期棋棄",
    ],
    [
      "b5a1",
      "機帰毅気汽畿祈季稀紀徽規記貴起軌輝飢騎鬼亀偽儀妓宜戯技擬欺犠疑祇義蟻誼議掬菊鞠吉吃喫桔橘詰砧杵黍却客脚虐逆丘久仇休及吸宮弓急救朽求汲泣灸球究窮笈級糾給旧牛去居巨拒拠挙渠虚許距鋸漁禦魚亨享京",
    ],
    [
      "b6a1",
      "供侠僑兇競共凶協匡卿叫喬境峡強彊怯恐恭挟教橋況狂狭矯胸脅興蕎郷鏡響饗驚仰凝尭暁業局曲極玉桐粁僅勤均巾錦斤欣欽琴禁禽筋緊芹菌衿襟謹近金吟銀九倶句区狗玖矩苦躯駆駈駒具愚虞喰空偶寓遇隅串櫛釧屑屈",
    ],
    [
      "b7a1",
      "掘窟沓靴轡窪熊隈粂栗繰桑鍬勲君薫訓群軍郡卦袈祁係傾刑兄啓圭珪型契形径恵慶慧憩掲携敬景桂渓畦稽系経継繋罫茎荊蛍計詣警軽頚鶏芸迎鯨劇戟撃激隙桁傑欠決潔穴結血訣月件倹倦健兼券剣喧圏堅嫌建憲懸拳捲",
    ],
    [
      "b8a1",
      "検権牽犬献研硯絹県肩見謙賢軒遣鍵険顕験鹸元原厳幻弦減源玄現絃舷言諺限乎個古呼固姑孤己庫弧戸故枯湖狐糊袴股胡菰虎誇跨鈷雇顧鼓五互伍午呉吾娯後御悟梧檎瑚碁語誤護醐乞鯉交佼侯候倖光公功効勾厚口向",
    ],
    [
      "b9a1",
      "后喉坑垢好孔孝宏工巧巷幸広庚康弘恒慌抗拘控攻昂晃更杭校梗構江洪浩港溝甲皇硬稿糠紅紘絞綱耕考肯肱腔膏航荒行衡講貢購郊酵鉱砿鋼閤降項香高鴻剛劫号合壕拷濠豪轟麹克刻告国穀酷鵠黒獄漉腰甑忽惚骨狛込",
    ],
    [
      "baa1",
      "此頃今困坤墾婚恨懇昏昆根梱混痕紺艮魂些佐叉唆嵯左差査沙瑳砂詐鎖裟坐座挫債催再最哉塞妻宰彩才採栽歳済災采犀砕砦祭斎細菜裁載際剤在材罪財冴坂阪堺榊肴咲崎埼碕鷺作削咋搾昨朔柵窄策索錯桜鮭笹匙冊刷",
    ],
    [
      "bba1",
      "察拶撮擦札殺薩雑皐鯖捌錆鮫皿晒三傘参山惨撒散桟燦珊産算纂蚕讃賛酸餐斬暫残仕仔伺使刺司史嗣四士始姉姿子屍市師志思指支孜斯施旨枝止死氏獅祉私糸紙紫肢脂至視詞詩試誌諮資賜雌飼歯事似侍児字寺慈持時",
    ],
    [
      "bca1",
      "次滋治爾璽痔磁示而耳自蒔辞汐鹿式識鴫竺軸宍雫七叱執失嫉室悉湿漆疾質実蔀篠偲柴芝屡蕊縞舎写射捨赦斜煮社紗者謝車遮蛇邪借勺尺杓灼爵酌釈錫若寂弱惹主取守手朱殊狩珠種腫趣酒首儒受呪寿授樹綬需囚収周",
    ],
    [
      "bda1",
      "宗就州修愁拾洲秀秋終繍習臭舟蒐衆襲讐蹴輯週酋酬集醜什住充十従戎柔汁渋獣縦重銃叔夙宿淑祝縮粛塾熟出術述俊峻春瞬竣舜駿准循旬楯殉淳準潤盾純巡遵醇順処初所暑曙渚庶緒署書薯藷諸助叙女序徐恕鋤除傷償",
    ],
    [
      "bea1",
      "勝匠升召哨商唱嘗奨妾娼宵将小少尚庄床廠彰承抄招掌捷昇昌昭晶松梢樟樵沼消渉湘焼焦照症省硝礁祥称章笑粧紹肖菖蒋蕉衝裳訟証詔詳象賞醤鉦鍾鐘障鞘上丈丞乗冗剰城場壌嬢常情擾条杖浄状畳穣蒸譲醸錠嘱埴飾",
    ],
    [
      "bfa1",
      "拭植殖燭織職色触食蝕辱尻伸信侵唇娠寝審心慎振新晋森榛浸深申疹真神秦紳臣芯薪親診身辛進針震人仁刃塵壬尋甚尽腎訊迅陣靭笥諏須酢図厨逗吹垂帥推水炊睡粋翠衰遂酔錐錘随瑞髄崇嵩数枢趨雛据杉椙菅頗雀裾",
    ],
    [
      "c0a1",
      "澄摺寸世瀬畝是凄制勢姓征性成政整星晴棲栖正清牲生盛精聖声製西誠誓請逝醒青静斉税脆隻席惜戚斥昔析石積籍績脊責赤跡蹟碩切拙接摂折設窃節説雪絶舌蝉仙先千占宣専尖川戦扇撰栓栴泉浅洗染潜煎煽旋穿箭線",
    ],
    [
      "c1a1",
      "繊羨腺舛船薦詮賎践選遷銭銑閃鮮前善漸然全禅繕膳糎噌塑岨措曾曽楚狙疏疎礎祖租粗素組蘇訴阻遡鼠僧創双叢倉喪壮奏爽宋層匝惣想捜掃挿掻操早曹巣槍槽漕燥争痩相窓糟総綜聡草荘葬蒼藻装走送遭鎗霜騒像増憎",
    ],
    [
      "c2a1",
      "臓蔵贈造促側則即息捉束測足速俗属賊族続卒袖其揃存孫尊損村遜他多太汰詑唾堕妥惰打柁舵楕陀駄騨体堆対耐岱帯待怠態戴替泰滞胎腿苔袋貸退逮隊黛鯛代台大第醍題鷹滝瀧卓啄宅托択拓沢濯琢託鐸濁諾茸凧蛸只",
    ],
    [
      "c3a1",
      "叩但達辰奪脱巽竪辿棚谷狸鱈樽誰丹単嘆坦担探旦歎淡湛炭短端箪綻耽胆蛋誕鍛団壇弾断暖檀段男談値知地弛恥智池痴稚置致蜘遅馳築畜竹筑蓄逐秩窒茶嫡着中仲宙忠抽昼柱注虫衷註酎鋳駐樗瀦猪苧著貯丁兆凋喋寵",
    ],
    [
      "c4a1",
      "帖帳庁弔張彫徴懲挑暢朝潮牒町眺聴脹腸蝶調諜超跳銚長頂鳥勅捗直朕沈珍賃鎮陳津墜椎槌追鎚痛通塚栂掴槻佃漬柘辻蔦綴鍔椿潰坪壷嬬紬爪吊釣鶴亭低停偵剃貞呈堤定帝底庭廷弟悌抵挺提梯汀碇禎程締艇訂諦蹄逓",
    ],
    [
      "c5a1",
      "邸鄭釘鼎泥摘擢敵滴的笛適鏑溺哲徹撤轍迭鉄典填天展店添纏甜貼転顛点伝殿澱田電兎吐堵塗妬屠徒斗杜渡登菟賭途都鍍砥砺努度土奴怒倒党冬凍刀唐塔塘套宕島嶋悼投搭東桃梼棟盗淘湯涛灯燈当痘祷等答筒糖統到",
    ],
    [
      "c6a1",
      "董蕩藤討謄豆踏逃透鐙陶頭騰闘働動同堂導憧撞洞瞳童胴萄道銅峠鴇匿得徳涜特督禿篤毒独読栃橡凸突椴届鳶苫寅酉瀞噸屯惇敦沌豚遁頓呑曇鈍奈那内乍凪薙謎灘捺鍋楢馴縄畷南楠軟難汝二尼弐迩匂賑肉虹廿日乳入",
    ],
    [
      "c7a1",
      "如尿韮任妊忍認濡禰祢寧葱猫熱年念捻撚燃粘乃廼之埜嚢悩濃納能脳膿農覗蚤巴把播覇杷波派琶破婆罵芭馬俳廃拝排敗杯盃牌背肺輩配倍培媒梅楳煤狽買売賠陪這蝿秤矧萩伯剥博拍柏泊白箔粕舶薄迫曝漠爆縛莫駁麦",
    ],
    [
      "c8a1",
      "函箱硲箸肇筈櫨幡肌畑畠八鉢溌発醗髪伐罰抜筏閥鳩噺塙蛤隼伴判半反叛帆搬斑板氾汎版犯班畔繁般藩販範釆煩頒飯挽晩番盤磐蕃蛮匪卑否妃庇彼悲扉批披斐比泌疲皮碑秘緋罷肥被誹費避非飛樋簸備尾微枇毘琵眉美",
    ],
    [
      "c9a1",
      "鼻柊稗匹疋髭彦膝菱肘弼必畢筆逼桧姫媛紐百謬俵彪標氷漂瓢票表評豹廟描病秒苗錨鋲蒜蛭鰭品彬斌浜瀕貧賓頻敏瓶不付埠夫婦富冨布府怖扶敷斧普浮父符腐膚芙譜負賦赴阜附侮撫武舞葡蕪部封楓風葺蕗伏副復幅服",
    ],
    [
      "caa1",
      "福腹複覆淵弗払沸仏物鮒分吻噴墳憤扮焚奮粉糞紛雰文聞丙併兵塀幣平弊柄並蔽閉陛米頁僻壁癖碧別瞥蔑箆偏変片篇編辺返遍便勉娩弁鞭保舗鋪圃捕歩甫補輔穂募墓慕戊暮母簿菩倣俸包呆報奉宝峰峯崩庖抱捧放方朋",
    ],
    [
      "cba1",
      "法泡烹砲縫胞芳萌蓬蜂褒訪豊邦鋒飽鳳鵬乏亡傍剖坊妨帽忘忙房暴望某棒冒紡肪膨謀貌貿鉾防吠頬北僕卜墨撲朴牧睦穆釦勃没殆堀幌奔本翻凡盆摩磨魔麻埋妹昧枚毎哩槙幕膜枕鮪柾鱒桝亦俣又抹末沫迄侭繭麿万慢満",
    ],
    [
      "cca1",
      "漫蔓味未魅巳箕岬密蜜湊蓑稔脈妙粍民眠務夢無牟矛霧鵡椋婿娘冥名命明盟迷銘鳴姪牝滅免棉綿緬面麺摸模茂妄孟毛猛盲網耗蒙儲木黙目杢勿餅尤戻籾貰問悶紋門匁也冶夜爺耶野弥矢厄役約薬訳躍靖柳薮鑓愉愈油癒",
    ],
    [
      "cda1",
      "諭輸唯佑優勇友宥幽悠憂揖有柚湧涌猶猷由祐裕誘遊邑郵雄融夕予余与誉輿預傭幼妖容庸揚揺擁曜楊様洋溶熔用窯羊耀葉蓉要謡踊遥陽養慾抑欲沃浴翌翼淀羅螺裸来莱頼雷洛絡落酪乱卵嵐欄濫藍蘭覧利吏履李梨理璃",
    ],
    [
      "cea1",
      "痢裏裡里離陸律率立葎掠略劉流溜琉留硫粒隆竜龍侶慮旅虜了亮僚両凌寮料梁涼猟療瞭稜糧良諒遼量陵領力緑倫厘林淋燐琳臨輪隣鱗麟瑠塁涙累類令伶例冷励嶺怜玲礼苓鈴隷零霊麗齢暦歴列劣烈裂廉恋憐漣煉簾練聯",
    ],
    [
      "cfa1",
      "蓮連錬呂魯櫓炉賂路露労婁廊弄朗楼榔浪漏牢狼篭老聾蝋郎六麓禄肋録論倭和話歪賄脇惑枠鷲亙亘鰐詫藁蕨椀湾碗腕",
    ],
    [
      "d0a1",
      "弌丐丕个丱丶丼丿乂乖乘亂亅豫亊舒弍于亞亟亠亢亰亳亶从仍仄仆仂仗仞仭仟价伉佚估佛佝佗佇佶侈侏侘佻佩佰侑佯來侖儘俔俟俎俘俛俑俚俐俤俥倚倨倔倪倥倅伜俶倡倩倬俾俯們倆偃假會偕偐偈做偖偬偸傀傚傅傴傲",
    ],
    [
      "d1a1",
      "僉僊傳僂僖僞僥僭僣僮價僵儉儁儂儖儕儔儚儡儺儷儼儻儿兀兒兌兔兢竸兩兪兮冀冂囘册冉冏冑冓冕冖冤冦冢冩冪冫决冱冲冰况冽凅凉凛几處凩凭凰凵凾刄刋刔刎刧刪刮刳刹剏剄剋剌剞剔剪剴剩剳剿剽劍劔劒剱劈劑辨",
    ],
    [
      "d2a1",
      "辧劬劭劼劵勁勍勗勞勣勦飭勠勳勵勸勹匆匈甸匍匐匏匕匚匣匯匱匳匸區卆卅丗卉卍凖卞卩卮夘卻卷厂厖厠厦厥厮厰厶參簒雙叟曼燮叮叨叭叺吁吽呀听吭吼吮吶吩吝呎咏呵咎呟呱呷呰咒呻咀呶咄咐咆哇咢咸咥咬哄哈咨",
    ],
    [
      "d3a1",
      "咫哂咤咾咼哘哥哦唏唔哽哮哭哺哢唹啀啣啌售啜啅啖啗唸唳啝喙喀咯喊喟啻啾喘喞單啼喃喩喇喨嗚嗅嗟嗄嗜嗤嗔嘔嗷嘖嗾嗽嘛嗹噎噐營嘴嘶嘲嘸噫噤嘯噬噪嚆嚀嚊嚠嚔嚏嚥嚮嚶嚴囂嚼囁囃囀囈囎囑囓囗囮囹圀囿圄圉",
    ],
    [
      "d4a1",
      "圈國圍圓團圖嗇圜圦圷圸坎圻址坏坩埀垈坡坿垉垓垠垳垤垪垰埃埆埔埒埓堊埖埣堋堙堝塲堡塢塋塰毀塒堽塹墅墹墟墫墺壞墻墸墮壅壓壑壗壙壘壥壜壤壟壯壺壹壻壼壽夂夊夐夛梦夥夬夭夲夸夾竒奕奐奎奚奘奢奠奧奬奩",
    ],
    [
      "d5a1",
      "奸妁妝佞侫妣妲姆姨姜妍姙姚娥娟娑娜娉娚婀婬婉娵娶婢婪媚媼媾嫋嫂媽嫣嫗嫦嫩嫖嫺嫻嬌嬋嬖嬲嫐嬪嬶嬾孃孅孀孑孕孚孛孥孩孰孳孵學斈孺宀它宦宸寃寇寉寔寐寤實寢寞寥寫寰寶寳尅將專對尓尠尢尨尸尹屁屆屎屓",
    ],
    [
      "d6a1",
      "屐屏孱屬屮乢屶屹岌岑岔妛岫岻岶岼岷峅岾峇峙峩峽峺峭嶌峪崋崕崗嵜崟崛崑崔崢崚崙崘嵌嵒嵎嵋嵬嵳嵶嶇嶄嶂嶢嶝嶬嶮嶽嶐嶷嶼巉巍巓巒巖巛巫已巵帋帚帙帑帛帶帷幄幃幀幎幗幔幟幢幤幇幵并幺麼广庠廁廂廈廐廏",
    ],
    [
      "d7a1",
      "廖廣廝廚廛廢廡廨廩廬廱廳廰廴廸廾弃弉彝彜弋弑弖弩弭弸彁彈彌彎弯彑彖彗彙彡彭彳彷徃徂彿徊很徑徇從徙徘徠徨徭徼忖忻忤忸忱忝悳忿怡恠怙怐怩怎怱怛怕怫怦怏怺恚恁恪恷恟恊恆恍恣恃恤恂恬恫恙悁悍惧悃悚",
    ],
    [
      "d8a1",
      "悄悛悖悗悒悧悋惡悸惠惓悴忰悽惆悵惘慍愕愆惶惷愀惴惺愃愡惻惱愍愎慇愾愨愧慊愿愼愬愴愽慂慄慳慷慘慙慚慫慴慯慥慱慟慝慓慵憙憖憇憬憔憚憊憑憫憮懌懊應懷懈懃懆憺懋罹懍懦懣懶懺懴懿懽懼懾戀戈戉戍戌戔戛",
    ],
    [
      "d9a1",
      "戞戡截戮戰戲戳扁扎扞扣扛扠扨扼抂抉找抒抓抖拔抃抔拗拑抻拏拿拆擔拈拜拌拊拂拇抛拉挌拮拱挧挂挈拯拵捐挾捍搜捏掖掎掀掫捶掣掏掉掟掵捫捩掾揩揀揆揣揉插揶揄搖搴搆搓搦搶攝搗搨搏摧摯摶摎攪撕撓撥撩撈撼",
    ],
    [
      "daa1",
      "據擒擅擇撻擘擂擱擧舉擠擡抬擣擯攬擶擴擲擺攀擽攘攜攅攤攣攫攴攵攷收攸畋效敖敕敍敘敞敝敲數斂斃變斛斟斫斷旃旆旁旄旌旒旛旙无旡旱杲昊昃旻杳昵昶昴昜晏晄晉晁晞晝晤晧晨晟晢晰暃暈暎暉暄暘暝曁暹曉暾暼",
    ],
    [
      "dba1",
      "曄暸曖曚曠昿曦曩曰曵曷朏朖朞朦朧霸朮朿朶杁朸朷杆杞杠杙杣杤枉杰枩杼杪枌枋枦枡枅枷柯枴柬枳柩枸柤柞柝柢柮枹柎柆柧檜栞框栩桀桍栲桎梳栫桙档桷桿梟梏梭梔條梛梃檮梹桴梵梠梺椏梍桾椁棊椈棘椢椦棡椌棍",
    ],
    [
      "dca1",
      "棔棧棕椶椒椄棗棣椥棹棠棯椨椪椚椣椡棆楹楷楜楸楫楔楾楮椹楴椽楙椰楡楞楝榁楪榲榮槐榿槁槓榾槎寨槊槝榻槃榧樮榑榠榜榕榴槞槨樂樛槿權槹槲槧樅榱樞槭樔槫樊樒櫁樣樓橄樌橲樶橸橇橢橙橦橈樸樢檐檍檠檄檢檣",
    ],
    [
      "dda1",
      "檗蘗檻櫃櫂檸檳檬櫞櫑櫟檪櫚櫪櫻欅蘖櫺欒欖鬱欟欸欷盜欹飮歇歃歉歐歙歔歛歟歡歸歹歿殀殄殃殍殘殕殞殤殪殫殯殲殱殳殷殼毆毋毓毟毬毫毳毯麾氈氓气氛氤氣汞汕汢汪沂沍沚沁沛汾汨汳沒沐泄泱泓沽泗泅泝沮沱沾",
    ],
    [
      "dea1",
      "沺泛泯泙泪洟衍洶洫洽洸洙洵洳洒洌浣涓浤浚浹浙涎涕濤涅淹渕渊涵淇淦涸淆淬淞淌淨淒淅淺淙淤淕淪淮渭湮渮渙湲湟渾渣湫渫湶湍渟湃渺湎渤滿渝游溂溪溘滉溷滓溽溯滄溲滔滕溏溥滂溟潁漑灌滬滸滾漿滲漱滯漲滌",
    ],
    [
      "dfa1",
      "漾漓滷澆潺潸澁澀潯潛濳潭澂潼潘澎澑濂潦澳澣澡澤澹濆澪濟濕濬濔濘濱濮濛瀉瀋濺瀑瀁瀏濾瀛瀚潴瀝瀘瀟瀰瀾瀲灑灣炙炒炯烱炬炸炳炮烟烋烝烙焉烽焜焙煥煕熈煦煢煌煖煬熏燻熄熕熨熬燗熹熾燒燉燔燎燠燬燧燵燼",
    ],
    [
      "e0a1",
      "燹燿爍爐爛爨爭爬爰爲爻爼爿牀牆牋牘牴牾犂犁犇犒犖犢犧犹犲狃狆狄狎狒狢狠狡狹狷倏猗猊猜猖猝猴猯猩猥猾獎獏默獗獪獨獰獸獵獻獺珈玳珎玻珀珥珮珞璢琅瑯琥珸琲琺瑕琿瑟瑙瑁瑜瑩瑰瑣瑪瑶瑾璋璞璧瓊瓏瓔珱",
    ],
    [
      "e1a1",
      "瓠瓣瓧瓩瓮瓲瓰瓱瓸瓷甄甃甅甌甎甍甕甓甞甦甬甼畄畍畊畉畛畆畚畩畤畧畫畭畸當疆疇畴疊疉疂疔疚疝疥疣痂疳痃疵疽疸疼疱痍痊痒痙痣痞痾痿痼瘁痰痺痲痳瘋瘍瘉瘟瘧瘠瘡瘢瘤瘴瘰瘻癇癈癆癜癘癡癢癨癩癪癧癬癰",
    ],
    [
      "e2a1",
      "癲癶癸發皀皃皈皋皎皖皓皙皚皰皴皸皹皺盂盍盖盒盞盡盥盧盪蘯盻眈眇眄眩眤眞眥眦眛眷眸睇睚睨睫睛睥睿睾睹瞎瞋瞑瞠瞞瞰瞶瞹瞿瞼瞽瞻矇矍矗矚矜矣矮矼砌砒礦砠礪硅碎硴碆硼碚碌碣碵碪碯磑磆磋磔碾碼磅磊磬",
    ],
    [
      "e3a1",
      "磧磚磽磴礇礒礑礙礬礫祀祠祗祟祚祕祓祺祿禊禝禧齋禪禮禳禹禺秉秕秧秬秡秣稈稍稘稙稠稟禀稱稻稾稷穃穗穉穡穢穩龝穰穹穽窈窗窕窘窖窩竈窰窶竅竄窿邃竇竊竍竏竕竓站竚竝竡竢竦竭竰笂笏笊笆笳笘笙笞笵笨笶筐",
    ],
    [
      "e4a1",
      "筺笄筍笋筌筅筵筥筴筧筰筱筬筮箝箘箟箍箜箚箋箒箏筝箙篋篁篌篏箴篆篝篩簑簔篦篥籠簀簇簓篳篷簗簍篶簣簧簪簟簷簫簽籌籃籔籏籀籐籘籟籤籖籥籬籵粃粐粤粭粢粫粡粨粳粲粱粮粹粽糀糅糂糘糒糜糢鬻糯糲糴糶糺紆",
    ],
    [
      "e5a1",
      "紂紜紕紊絅絋紮紲紿紵絆絳絖絎絲絨絮絏絣經綉絛綏絽綛綺綮綣綵緇綽綫總綢綯緜綸綟綰緘緝緤緞緻緲緡縅縊縣縡縒縱縟縉縋縢繆繦縻縵縹繃縷縲縺繧繝繖繞繙繚繹繪繩繼繻纃緕繽辮繿纈纉續纒纐纓纔纖纎纛纜缸缺",
    ],
    [
      "e6a1",
      "罅罌罍罎罐网罕罔罘罟罠罨罩罧罸羂羆羃羈羇羌羔羞羝羚羣羯羲羹羮羶羸譱翅翆翊翕翔翡翦翩翳翹飜耆耄耋耒耘耙耜耡耨耿耻聊聆聒聘聚聟聢聨聳聲聰聶聹聽聿肄肆肅肛肓肚肭冐肬胛胥胙胝胄胚胖脉胯胱脛脩脣脯腋",
    ],
    [
      "e7a1",
      "隋腆脾腓腑胼腱腮腥腦腴膃膈膊膀膂膠膕膤膣腟膓膩膰膵膾膸膽臀臂膺臉臍臑臙臘臈臚臟臠臧臺臻臾舁舂舅與舊舍舐舖舩舫舸舳艀艙艘艝艚艟艤艢艨艪艫舮艱艷艸艾芍芒芫芟芻芬苡苣苟苒苴苳苺莓范苻苹苞茆苜茉苙",
    ],
    [
      "e8a1",
      "茵茴茖茲茱荀茹荐荅茯茫茗茘莅莚莪莟莢莖茣莎莇莊荼莵荳荵莠莉莨菴萓菫菎菽萃菘萋菁菷萇菠菲萍萢萠莽萸蔆菻葭萪萼蕚蒄葷葫蒭葮蒂葩葆萬葯葹萵蓊葢蒹蒿蒟蓙蓍蒻蓚蓐蓁蓆蓖蒡蔡蓿蓴蔗蔘蔬蔟蔕蔔蓼蕀蕣蕘蕈",
    ],
    [
      "e9a1",
      "蕁蘂蕋蕕薀薤薈薑薊薨蕭薔薛藪薇薜蕷蕾薐藉薺藏薹藐藕藝藥藜藹蘊蘓蘋藾藺蘆蘢蘚蘰蘿虍乕虔號虧虱蚓蚣蚩蚪蚋蚌蚶蚯蛄蛆蚰蛉蠣蚫蛔蛞蛩蛬蛟蛛蛯蜒蜆蜈蜀蜃蛻蜑蜉蜍蛹蜊蜴蜿蜷蜻蜥蜩蜚蝠蝟蝸蝌蝎蝴蝗蝨蝮蝙",
    ],
    [
      "eaa1",
      "蝓蝣蝪蠅螢螟螂螯蟋螽蟀蟐雖螫蟄螳蟇蟆螻蟯蟲蟠蠏蠍蟾蟶蟷蠎蟒蠑蠖蠕蠢蠡蠱蠶蠹蠧蠻衄衂衒衙衞衢衫袁衾袞衵衽袵衲袂袗袒袮袙袢袍袤袰袿袱裃裄裔裘裙裝裹褂裼裴裨裲褄褌褊褓襃褞褥褪褫襁襄褻褶褸襌褝襠襞",
    ],
    [
      "eba1",
      "襦襤襭襪襯襴襷襾覃覈覊覓覘覡覩覦覬覯覲覺覽覿觀觚觜觝觧觴觸訃訖訐訌訛訝訥訶詁詛詒詆詈詼詭詬詢誅誂誄誨誡誑誥誦誚誣諄諍諂諚諫諳諧諤諱謔諠諢諷諞諛謌謇謚諡謖謐謗謠謳鞫謦謫謾謨譁譌譏譎證譖譛譚譫",
    ],
    [
      "eca1",
      "譟譬譯譴譽讀讌讎讒讓讖讙讚谺豁谿豈豌豎豐豕豢豬豸豺貂貉貅貊貍貎貔豼貘戝貭貪貽貲貳貮貶賈賁賤賣賚賽賺賻贄贅贊贇贏贍贐齎贓賍贔贖赧赭赱赳趁趙跂趾趺跏跚跖跌跛跋跪跫跟跣跼踈踉跿踝踞踐踟蹂踵踰踴蹊",
    ],
    [
      "eda1",
      "蹇蹉蹌蹐蹈蹙蹤蹠踪蹣蹕蹶蹲蹼躁躇躅躄躋躊躓躑躔躙躪躡躬躰軆躱躾軅軈軋軛軣軼軻軫軾輊輅輕輒輙輓輜輟輛輌輦輳輻輹轅轂輾轌轉轆轎轗轜轢轣轤辜辟辣辭辯辷迚迥迢迪迯邇迴逅迹迺逑逕逡逍逞逖逋逧逶逵逹迸",
    ],
    [
      "eea1",
      "遏遐遑遒逎遉逾遖遘遞遨遯遶隨遲邂遽邁邀邊邉邏邨邯邱邵郢郤扈郛鄂鄒鄙鄲鄰酊酖酘酣酥酩酳酲醋醉醂醢醫醯醪醵醴醺釀釁釉釋釐釖釟釡釛釼釵釶鈞釿鈔鈬鈕鈑鉞鉗鉅鉉鉤鉈銕鈿鉋鉐銜銖銓銛鉚鋏銹銷鋩錏鋺鍄錮",
    ],
    [
      "efa1",
      "錙錢錚錣錺錵錻鍜鍠鍼鍮鍖鎰鎬鎭鎔鎹鏖鏗鏨鏥鏘鏃鏝鏐鏈鏤鐚鐔鐓鐃鐇鐐鐶鐫鐵鐡鐺鑁鑒鑄鑛鑠鑢鑞鑪鈩鑰鑵鑷鑽鑚鑼鑾钁鑿閂閇閊閔閖閘閙閠閨閧閭閼閻閹閾闊濶闃闍闌闕闔闖關闡闥闢阡阨阮阯陂陌陏陋陷陜陞",
    ],
    [
      "f0a1",
      "陝陟陦陲陬隍隘隕隗險隧隱隲隰隴隶隸隹雎雋雉雍襍雜霍雕雹霄霆霈霓霎霑霏霖霙霤霪霰霹霽霾靄靆靈靂靉靜靠靤靦靨勒靫靱靹鞅靼鞁靺鞆鞋鞏鞐鞜鞨鞦鞣鞳鞴韃韆韈韋韜韭齏韲竟韶韵頏頌頸頤頡頷頽顆顏顋顫顯顰",
    ],
    [
      "f1a1",
      "顱顴顳颪颯颱颶飄飃飆飩飫餃餉餒餔餘餡餝餞餤餠餬餮餽餾饂饉饅饐饋饑饒饌饕馗馘馥馭馮馼駟駛駝駘駑駭駮駱駲駻駸騁騏騅駢騙騫騷驅驂驀驃騾驕驍驛驗驟驢驥驤驩驫驪骭骰骼髀髏髑髓體髞髟髢髣髦髯髫髮髴髱髷",
    ],
    [
      "f2a1",
      "髻鬆鬘鬚鬟鬢鬣鬥鬧鬨鬩鬪鬮鬯鬲魄魃魏魍魎魑魘魴鮓鮃鮑鮖鮗鮟鮠鮨鮴鯀鯊鮹鯆鯏鯑鯒鯣鯢鯤鯔鯡鰺鯲鯱鯰鰕鰔鰉鰓鰌鰆鰈鰒鰊鰄鰮鰛鰥鰤鰡鰰鱇鰲鱆鰾鱚鱠鱧鱶鱸鳧鳬鳰鴉鴈鳫鴃鴆鴪鴦鶯鴣鴟鵄鴕鴒鵁鴿鴾鵆鵈",
    ],
    [
      "f3a1",
      "鵝鵞鵤鵑鵐鵙鵲鶉鶇鶫鵯鵺鶚鶤鶩鶲鷄鷁鶻鶸鶺鷆鷏鷂鷙鷓鷸鷦鷭鷯鷽鸚鸛鸞鹵鹹鹽麁麈麋麌麒麕麑麝麥麩麸麪麭靡黌黎黏黐黔黜點黝黠黥黨黯黴黶黷黹黻黼黽鼇鼈皷鼕鼡鼬鼾齊齒齔齣齟齠齡齦齧齬齪齷齲齶龕龜龠",
    ],
    ["f4a1", "堯槇遙瑤凜熙"],
    [
      "f9a1",
      "纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德",
    ],
    [
      "faa1",
      "忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱",
    ],
    [
      "fba1",
      "犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚",
    ],
    [
      "fca1",
      "釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑",
    ],
    ["fcf1", "ⅰ", 9, "￢￤＇＂"],
    ["8fa2af", "˘ˇ¸˙˝¯˛˚～΄΅"],
    ["8fa2c2", "¡¦¿"],
    ["8fa2eb", "ºª©®™¤№"],
    ["8fa6e1", "ΆΈΉΊΪ"],
    ["8fa6e7", "Ό"],
    ["8fa6e9", "ΎΫ"],
    ["8fa6ec", "Ώ"],
    ["8fa6f1", "άέήίϊΐόςύϋΰώ"],
    ["8fa7c2", "Ђ", 10, "ЎЏ"],
    ["8fa7f2", "ђ", 10, "ўџ"],
    ["8fa9a1", "ÆĐ"],
    ["8fa9a4", "Ħ"],
    ["8fa9a6", "Ĳ"],
    ["8fa9a8", "ŁĿ"],
    ["8fa9ab", "ŊØŒ"],
    ["8fa9af", "ŦÞ"],
    ["8fa9c1", "æđðħıĳĸłŀŉŋøœßŧþ"],
    ["8faaa1", "ÁÀÄÂĂǍĀĄÅÃĆĈČÇĊĎÉÈËÊĚĖĒĘ"],
    [
      "8faaba",
      "ĜĞĢĠĤÍÌÏÎǏİĪĮĨĴĶĹĽĻŃŇŅÑÓÒÖÔǑŐŌÕŔŘŖŚŜŠŞŤŢÚÙÜÛŬǓŰŪŲŮŨǗǛǙǕŴÝŸŶŹŽŻ",
    ],
    ["8faba1", "áàäâăǎāąåãćĉčçċďéèëêěėēęǵĝğ"],
    ["8fabbd", "ġĥíìïîǐ"],
    ["8fabc5", "īįĩĵķĺľļńňņñóòöôǒőōõŕřŗśŝšşťţúùüûŭǔűūųůũǘǜǚǖŵýÿŷźžż"],
    [
      "8fb0a1",
      "丂丄丅丌丒丟丣两丨丫丮丯丰丵乀乁乄乇乑乚乜乣乨乩乴乵乹乿亍亖亗亝亯亹仃仐仚仛仠仡仢仨仯仱仳仵份仾仿伀伂伃伈伋伌伒伕伖众伙伮伱你伳伵伷伹伻伾佀佂佈佉佋佌佒佔佖佘佟佣佪佬佮佱佷佸佹佺佽佾侁侂侄",
    ],
    [
      "8fb1a1",
      "侅侉侊侌侎侐侒侓侔侗侙侚侞侟侲侷侹侻侼侽侾俀俁俅俆俈俉俋俌俍俏俒俜俠俢俰俲俼俽俿倀倁倄倇倊倌倎倐倓倗倘倛倜倝倞倢倧倮倰倲倳倵偀偁偂偅偆偊偌偎偑偒偓偗偙偟偠偢偣偦偧偪偭偰偱倻傁傃傄傆傊傎傏傐",
    ],
    [
      "8fb2a1",
      "傒傓傔傖傛傜傞",
      4,
      "傪傯傰傹傺傽僀僃僄僇僌僎僐僓僔僘僜僝僟僢僤僦僨僩僯僱僶僺僾儃儆儇儈儋儌儍儎僲儐儗儙儛儜儝儞儣儧儨儬儭儯儱儳儴儵儸儹兂兊兏兓兕兗兘兟兤兦兾冃冄冋冎冘冝冡冣冭冸冺冼冾冿凂",
    ],
    [
      "8fb3a1",
      "凈减凑凒凓凕凘凞凢凥凮凲凳凴凷刁刂刅划刓刕刖刘刢刨刱刲刵刼剅剉剕剗剘剚剜剟剠剡剦剮剷剸剹劀劂劅劊劌劓劕劖劗劘劚劜劤劥劦劧劯劰劶劷劸劺劻劽勀勄勆勈勌勏勑勔勖勛勜勡勥勨勩勪勬勰勱勴勶勷匀匃匊匋",
    ],
    [
      "8fb4a1",
      "匌匑匓匘匛匜匞匟匥匧匨匩匫匬匭匰匲匵匼匽匾卂卌卋卙卛卡卣卥卬卭卲卹卾厃厇厈厎厓厔厙厝厡厤厪厫厯厲厴厵厷厸厺厽叀叅叏叒叓叕叚叝叞叠另叧叵吂吓吚吡吧吨吪启吱吴吵呃呄呇呍呏呞呢呤呦呧呩呫呭呮呴呿",
    ],
    [
      "8fb5a1",
      "咁咃咅咈咉咍咑咕咖咜咟咡咦咧咩咪咭咮咱咷咹咺咻咿哆哊响哎哠哪哬哯哶哼哾哿唀唁唅唈唉唌唍唎唕唪唫唲唵唶唻唼唽啁啇啉啊啍啐啑啘啚啛啞啠啡啤啦啿喁喂喆喈喎喏喑喒喓喔喗喣喤喭喲喿嗁嗃嗆嗉嗋嗌嗎嗑嗒",
    ],
    [
      "8fb6a1",
      "嗓嗗嗘嗛嗞嗢嗩嗶嗿嘅嘈嘊嘍",
      5,
      "嘙嘬嘰嘳嘵嘷嘹嘻嘼嘽嘿噀噁噃噄噆噉噋噍噏噔噞噠噡噢噣噦噩噭噯噱噲噵嚄嚅嚈嚋嚌嚕嚙嚚嚝嚞嚟嚦嚧嚨嚩嚫嚬嚭嚱嚳嚷嚾囅囉囊囋囏囐囌囍囙囜囝囟囡囤",
      4,
      "囱囫园",
    ],
    [
      "8fb7a1",
      "囶囷圁圂圇圊圌圑圕圚圛圝圠圢圣圤圥圩圪圬圮圯圳圴圽圾圿坅坆坌坍坒坢坥坧坨坫坭",
      4,
      "坳坴坵坷坹坺坻坼坾垁垃垌垔垗垙垚垜垝垞垟垡垕垧垨垩垬垸垽埇埈埌埏埕埝埞埤埦埧埩埭埰埵埶埸埽埾埿堃堄堈堉埡",
    ],
    [
      "8fb8a1",
      "堌堍堛堞堟堠堦堧堭堲堹堿塉塌塍塏塐塕塟塡塤塧塨塸塼塿墀墁墇墈墉墊墌墍墏墐墔墖墝墠墡墢墦墩墱墲壄墼壂壈壍壎壐壒壔壖壚壝壡壢壩壳夅夆夋夌夒夓夔虁夝夡夣夤夨夯夰夳夵夶夿奃奆奒奓奙奛奝奞奟奡奣奫奭",
    ],
    [
      "8fb9a1",
      "奯奲奵奶她奻奼妋妌妎妒妕妗妟妤妧妭妮妯妰妳妷妺妼姁姃姄姈姊姍姒姝姞姟姣姤姧姮姯姱姲姴姷娀娄娌娍娎娒娓娞娣娤娧娨娪娭娰婄婅婇婈婌婐婕婞婣婥婧婭婷婺婻婾媋媐媓媖媙媜媞媟媠媢媧媬媱媲媳媵媸媺媻媿",
    ],
    [
      "8fbaa1",
      "嫄嫆嫈嫏嫚嫜嫠嫥嫪嫮嫵嫶嫽嬀嬁嬈嬗嬴嬙嬛嬝嬡嬥嬭嬸孁孋孌孒孖孞孨孮孯孼孽孾孿宁宄宆宊宎宐宑宓宔宖宨宩宬宭宯宱宲宷宺宼寀寁寍寏寖",
      4,
      "寠寯寱寴寽尌尗尞尟尣尦尩尫尬尮尰尲尵尶屙屚屜屢屣屧屨屩",
    ],
    [
      "8fbba1",
      "屭屰屴屵屺屻屼屽岇岈岊岏岒岝岟岠岢岣岦岪岲岴岵岺峉峋峒峝峗峮峱峲峴崁崆崍崒崫崣崤崦崧崱崴崹崽崿嵂嵃嵆嵈嵕嵑嵙嵊嵟嵠嵡嵢嵤嵪嵭嵰嵹嵺嵾嵿嶁嶃嶈嶊嶒嶓嶔嶕嶙嶛嶟嶠嶧嶫嶰嶴嶸嶹巃巇巋巐巎巘巙巠巤",
    ],
    [
      "8fbca1",
      "巩巸巹帀帇帍帒帔帕帘帟帠帮帨帲帵帾幋幐幉幑幖幘幛幜幞幨幪",
      4,
      "幰庀庋庎庢庤庥庨庪庬庱庳庽庾庿廆廌廋廎廑廒廔廕廜廞廥廫异弆弇弈弎弙弜弝弡弢弣弤弨弫弬弮弰弴弶弻弽弿彀彄彅彇彍彐彔彘彛彠彣彤彧",
    ],
    [
      "8fbda1",
      "彯彲彴彵彸彺彽彾徉徍徏徖徜徝徢徧徫徤徬徯徰徱徸忄忇忈忉忋忐",
      4,
      "忞忡忢忨忩忪忬忭忮忯忲忳忶忺忼怇怊怍怓怔怗怘怚怟怤怭怳怵恀恇恈恉恌恑恔恖恗恝恡恧恱恾恿悂悆悈悊悎悑悓悕悘悝悞悢悤悥您悰悱悷",
    ],
    [
      "8fbea1",
      "悻悾惂惄惈惉惊惋惎惏惔惕惙惛惝惞惢惥惲惵惸惼惽愂愇愊愌愐",
      4,
      "愖愗愙愜愞愢愪愫愰愱愵愶愷愹慁慅慆慉慞慠慬慲慸慻慼慿憀憁憃憄憋憍憒憓憗憘憜憝憟憠憥憨憪憭憸憹憼懀懁懂懎懏懕懜懝懞懟懡懢懧懩懥",
    ],
    [
      "8fbfa1",
      "懬懭懯戁戃戄戇戓戕戜戠戢戣戧戩戫戹戽扂扃扄扆扌扐扑扒扔扖扚扜扤扭扯扳扺扽抍抎抏抐抦抨抳抶抷抺抾抿拄拎拕拖拚拪拲拴拼拽挃挄挊挋挍挐挓挖挘挩挪挭挵挶挹挼捁捂捃捄捆捊捋捎捒捓捔捘捛捥捦捬捭捱捴捵",
    ],
    [
      "8fc0a1",
      "捸捼捽捿掂掄掇掊掐掔掕掙掚掞掤掦掭掮掯掽揁揅揈揎揑揓揔揕揜揠揥揪揬揲揳揵揸揹搉搊搐搒搔搘搞搠搢搤搥搩搪搯搰搵搽搿摋摏摑摒摓摔摚摛摜摝摟摠摡摣摭摳摴摻摽撅撇撏撐撑撘撙撛撝撟撡撣撦撨撬撳撽撾撿",
    ],
    [
      "8fc1a1",
      "擄擉擊擋擌擎擐擑擕擗擤擥擩擪擭擰擵擷擻擿攁攄攈攉攊攏攓攔攖攙攛攞攟攢攦攩攮攱攺攼攽敃敇敉敐敒敔敟敠敧敫敺敽斁斅斊斒斕斘斝斠斣斦斮斲斳斴斿旂旈旉旎旐旔旖旘旟旰旲旴旵旹旾旿昀昄昈昉昍昑昒昕昖昝",
    ],
    [
      "8fc2a1",
      "昞昡昢昣昤昦昩昪昫昬昮昰昱昳昹昷晀晅晆晊晌晑晎晗晘晙晛晜晠晡曻晪晫晬晾晳晵晿晷晸晹晻暀晼暋暌暍暐暒暙暚暛暜暟暠暤暭暱暲暵暻暿曀曂曃曈曌曎曏曔曛曟曨曫曬曮曺朅朇朎朓朙朜朠朢朳朾杅杇杈杌杔杕杝",
    ],
    [
      "8fc3a1",
      "杦杬杮杴杶杻极构枎枏枑枓枖枘枙枛枰枱枲枵枻枼枽柹柀柂柃柅柈柉柒柗柙柜柡柦柰柲柶柷桒栔栙栝栟栨栧栬栭栯栰栱栳栻栿桄桅桊桌桕桗桘桛桫桮",
      4,
      "桵桹桺桻桼梂梄梆梈梖梘梚梜梡梣梥梩梪梮梲梻棅棈棌棏",
    ],
    [
      "8fc4a1",
      "棐棑棓棖棙棜棝棥棨棪棫棬棭棰棱棵棶棻棼棽椆椉椊椐椑椓椖椗椱椳椵椸椻楂楅楉楎楗楛楣楤楥楦楨楩楬楰楱楲楺楻楿榀榍榒榖榘榡榥榦榨榫榭榯榷榸榺榼槅槈槑槖槗槢槥槮槯槱槳槵槾樀樁樃樏樑樕樚樝樠樤樨樰樲",
    ],
    [
      "8fc5a1",
      "樴樷樻樾樿橅橆橉橊橎橐橑橒橕橖橛橤橧橪橱橳橾檁檃檆檇檉檋檑檛檝檞檟檥檫檯檰檱檴檽檾檿櫆櫉櫈櫌櫐櫔櫕櫖櫜櫝櫤櫧櫬櫰櫱櫲櫼櫽欂欃欆欇欉欏欐欑欗欛欞欤欨欫欬欯欵欶欻欿歆歊歍歒歖歘歝歠歧歫歮歰歵歽",
    ],
    [
      "8fc6a1",
      "歾殂殅殗殛殟殠殢殣殨殩殬殭殮殰殸殹殽殾毃毄毉毌毖毚毡毣毦毧毮毱毷毹毿氂氄氅氉氍氎氐氒氙氟氦氧氨氬氮氳氵氶氺氻氿汊汋汍汏汒汔汙汛汜汫汭汯汴汶汸汹汻沅沆沇沉沔沕沗沘沜沟沰沲沴泂泆泍泏泐泑泒泔泖",
    ],
    [
      "8fc7a1",
      "泚泜泠泧泩泫泬泮泲泴洄洇洊洎洏洑洓洚洦洧洨汧洮洯洱洹洼洿浗浞浟浡浥浧浯浰浼涂涇涑涒涔涖涗涘涪涬涴涷涹涽涿淄淈淊淎淏淖淛淝淟淠淢淥淩淯淰淴淶淼渀渄渞渢渧渲渶渹渻渼湄湅湈湉湋湏湑湒湓湔湗湜湝湞",
    ],
    [
      "8fc8a1",
      "湢湣湨湳湻湽溍溓溙溠溧溭溮溱溳溻溿滀滁滃滇滈滊滍滎滏滫滭滮滹滻滽漄漈漊漌漍漖漘漚漛漦漩漪漯漰漳漶漻漼漭潏潑潒潓潗潙潚潝潞潡潢潨潬潽潾澃澇澈澋澌澍澐澒澓澔澖澚澟澠澥澦澧澨澮澯澰澵澶澼濅濇濈濊",
    ],
    [
      "8fc9a1",
      "濚濞濨濩濰濵濹濼濽瀀瀅瀆瀇瀍瀗瀠瀣瀯瀴瀷瀹瀼灃灄灈灉灊灋灔灕灝灞灎灤灥灬灮灵灶灾炁炅炆炔",
      4,
      "炛炤炫炰炱炴炷烊烑烓烔烕烖烘烜烤烺焃",
      4,
      "焋焌焏焞焠焫焭焯焰焱焸煁煅煆煇煊煋煐煒煗煚煜煞煠",
    ],
    [
      "8fcaa1",
      "煨煹熀熅熇熌熒熚熛熠熢熯熰熲熳熺熿燀燁燄燋燌燓燖燙燚燜燸燾爀爇爈爉爓爗爚爝爟爤爫爯爴爸爹牁牂牃牅牎牏牐牓牕牖牚牜牞牠牣牨牫牮牯牱牷牸牻牼牿犄犉犍犎犓犛犨犭犮犱犴犾狁狇狉狌狕狖狘狟狥狳狴狺狻",
    ],
    [
      "8fcba1",
      "狾猂猄猅猇猋猍猒猓猘猙猞猢猤猧猨猬猱猲猵猺猻猽獃獍獐獒獖獘獝獞獟獠獦獧獩獫獬獮獯獱獷獹獼玀玁玃玅玆玎玐玓玕玗玘玜玞玟玠玢玥玦玪玫玭玵玷玹玼玽玿珅珆珉珋珌珏珒珓珖珙珝珡珣珦珧珩珴珵珷珹珺珻珽",
    ],
    [
      "8fcca1",
      "珿琀琁琄琇琊琑琚琛琤琦琨",
      9,
      "琹瑀瑃瑄瑆瑇瑋瑍瑑瑒瑗瑝瑢瑦瑧瑨瑫瑭瑮瑱瑲璀璁璅璆璇璉璏璐璑璒璘璙璚璜璟璠璡璣璦璨璩璪璫璮璯璱璲璵璹璻璿瓈瓉瓌瓐瓓瓘瓚瓛瓞瓟瓤瓨瓪瓫瓯瓴瓺瓻瓼瓿甆",
    ],
    [
      "8fcda1",
      "甒甖甗甠甡甤甧甩甪甯甶甹甽甾甿畀畃畇畈畎畐畒畗畞畟畡畯畱畹",
      5,
      "疁疅疐疒疓疕疙疜疢疤疴疺疿痀痁痄痆痌痎痏痗痜痟痠痡痤痧痬痮痯痱痹瘀瘂瘃瘄瘇瘈瘊瘌瘏瘒瘓瘕瘖瘙瘛瘜瘝瘞瘣瘥瘦瘩瘭瘲瘳瘵瘸瘹",
    ],
    [
      "8fcea1",
      "瘺瘼癊癀癁癃癄癅癉癋癕癙癟癤癥癭癮癯癱癴皁皅皌皍皕皛皜皝皟皠皢",
      6,
      "皪皭皽盁盅盉盋盌盎盔盙盠盦盨盬盰盱盶盹盼眀眆眊眎眒眔眕眗眙眚眜眢眨眭眮眯眴眵眶眹眽眾睂睅睆睊睍睎睏睒睖睗睜睞睟睠睢",
    ],
    [
      "8fcfa1",
      "睤睧睪睬睰睲睳睴睺睽瞀瞄瞌瞍瞔瞕瞖瞚瞟瞢瞧瞪瞮瞯瞱瞵瞾矃矉矑矒矕矙矞矟矠矤矦矪矬矰矱矴矸矻砅砆砉砍砎砑砝砡砢砣砭砮砰砵砷硃硄硇硈硌硎硒硜硞硠硡硣硤硨硪确硺硾碊碏碔碘碡碝碞碟碤碨碬碭碰碱碲碳",
    ],
    [
      "8fd0a1",
      "碻碽碿磇磈磉磌磎磒磓磕磖磤磛磟磠磡磦磪磲磳礀磶磷磺磻磿礆礌礐礚礜礞礟礠礥礧礩礭礱礴礵礻礽礿祄祅祆祊祋祏祑祔祘祛祜祧祩祫祲祹祻祼祾禋禌禑禓禔禕禖禘禛禜禡禨禩禫禯禱禴禸离秂秄秇秈秊秏秔秖秚秝秞",
    ],
    [
      "8fd1a1",
      "秠秢秥秪秫秭秱秸秼稂稃稇稉稊稌稑稕稛稞稡稧稫稭稯稰稴稵稸稹稺穄穅穇穈穌穕穖穙穜穝穟穠穥穧穪穭穵穸穾窀窂窅窆窊窋窐窑窔窞窠窣窬窳窵窹窻窼竆竉竌竎竑竛竨竩竫竬竱竴竻竽竾笇笔笟笣笧笩笪笫笭笮笯笰",
    ],
    [
      "8fd2a1",
      "笱笴笽笿筀筁筇筎筕筠筤筦筩筪筭筯筲筳筷箄箉箎箐箑箖箛箞箠箥箬箯箰箲箵箶箺箻箼箽篂篅篈篊篔篖篗篙篚篛篨篪篲篴篵篸篹篺篼篾簁簂簃簄簆簉簋簌簎簏簙簛簠簥簦簨簬簱簳簴簶簹簺籆籊籕籑籒籓籙",
      5,
    ],
    [
      "8fd3a1",
      "籡籣籧籩籭籮籰籲籹籼籽粆粇粏粔粞粠粦粰粶粷粺粻粼粿糄糇糈糉糍糏糓糔糕糗糙糚糝糦糩糫糵紃紇紈紉紏紑紒紓紖紝紞紣紦紪紭紱紼紽紾絀絁絇絈絍絑絓絗絙絚絜絝絥絧絪絰絸絺絻絿綁綂綃綅綆綈綋綌綍綑綖綗綝",
    ],
    [
      "8fd4a1",
      "綞綦綧綪綳綶綷綹緂",
      4,
      "緌緍緎緗緙縀緢緥緦緪緫緭緱緵緶緹緺縈縐縑縕縗縜縝縠縧縨縬縭縯縳縶縿繄繅繇繎繐繒繘繟繡繢繥繫繮繯繳繸繾纁纆纇纊纍纑纕纘纚纝纞缼缻缽缾缿罃罄罇罏罒罓罛罜罝罡罣罤罥罦罭",
    ],
    [
      "8fd5a1",
      "罱罽罾罿羀羋羍羏羐羑羖羗羜羡羢羦羪羭羴羼羿翀翃翈翎翏翛翟翣翥翨翬翮翯翲翺翽翾翿耇耈耊耍耎耏耑耓耔耖耝耞耟耠耤耦耬耮耰耴耵耷耹耺耼耾聀聄聠聤聦聭聱聵肁肈肎肜肞肦肧肫肸肹胈胍胏胒胔胕胗胘胠胭胮",
    ],
    [
      "8fd6a1",
      "胰胲胳胶胹胺胾脃脋脖脗脘脜脞脠脤脧脬脰脵脺脼腅腇腊腌腒腗腠腡腧腨腩腭腯腷膁膐膄膅膆膋膎膖膘膛膞膢膮膲膴膻臋臃臅臊臎臏臕臗臛臝臞臡臤臫臬臰臱臲臵臶臸臹臽臿舀舃舏舓舔舙舚舝舡舢舨舲舴舺艃艄艅艆",
    ],
    [
      "8fd7a1",
      "艋艎艏艑艖艜艠艣艧艭艴艻艽艿芀芁芃芄芇芉芊芎芑芔芖芘芚芛芠芡芣芤芧芨芩芪芮芰芲芴芷芺芼芾芿苆苐苕苚苠苢苤苨苪苭苯苶苷苽苾茀茁茇茈茊茋荔茛茝茞茟茡茢茬茭茮茰茳茷茺茼茽荂荃荄荇荍荎荑荕荖荗荰荸",
    ],
    [
      "8fd8a1",
      "荽荿莀莂莄莆莍莒莔莕莘莙莛莜莝莦莧莩莬莾莿菀菇菉菏菐菑菔菝荓菨菪菶菸菹菼萁萆萊萏萑萕萙莭萯萹葅葇葈葊葍葏葑葒葖葘葙葚葜葠葤葥葧葪葰葳葴葶葸葼葽蒁蒅蒒蒓蒕蒞蒦蒨蒩蒪蒯蒱蒴蒺蒽蒾蓀蓂蓇蓈蓌蓏蓓",
    ],
    [
      "8fd9a1",
      "蓜蓧蓪蓯蓰蓱蓲蓷蔲蓺蓻蓽蔂蔃蔇蔌蔎蔐蔜蔞蔢蔣蔤蔥蔧蔪蔫蔯蔳蔴蔶蔿蕆蕏",
      4,
      "蕖蕙蕜",
      6,
      "蕤蕫蕯蕹蕺蕻蕽蕿薁薅薆薉薋薌薏薓薘薝薟薠薢薥薧薴薶薷薸薼薽薾薿藂藇藊藋藎薭藘藚藟藠藦藨藭藳藶藼",
    ],
    [
      "8fdaa1",
      "藿蘀蘄蘅蘍蘎蘐蘑蘒蘘蘙蘛蘞蘡蘧蘩蘶蘸蘺蘼蘽虀虂虆虒虓虖虗虘虙虝虠",
      4,
      "虩虬虯虵虶虷虺蚍蚑蚖蚘蚚蚜蚡蚦蚧蚨蚭蚱蚳蚴蚵蚷蚸蚹蚿蛀蛁蛃蛅蛑蛒蛕蛗蛚蛜蛠蛣蛥蛧蚈蛺蛼蛽蜄蜅蜇蜋蜎蜏蜐蜓蜔蜙蜞蜟蜡蜣",
    ],
    [
      "8fdba1",
      "蜨蜮蜯蜱蜲蜹蜺蜼蜽蜾蝀蝃蝅蝍蝘蝝蝡蝤蝥蝯蝱蝲蝻螃",
      6,
      "螋螌螐螓螕螗螘螙螞螠螣螧螬螭螮螱螵螾螿蟁蟈蟉蟊蟎蟕蟖蟙蟚蟜蟟蟢蟣蟤蟪蟫蟭蟱蟳蟸蟺蟿蠁蠃蠆蠉蠊蠋蠐蠙蠒蠓蠔蠘蠚蠛蠜蠞蠟蠨蠭蠮蠰蠲蠵",
    ],
    [
      "8fdca1",
      "蠺蠼衁衃衅衈衉衊衋衎衑衕衖衘衚衜衟衠衤衩衱衹衻袀袘袚袛袜袟袠袨袪袺袽袾裀裊",
      4,
      "裑裒裓裛裞裧裯裰裱裵裷褁褆褍褎褏褕褖褘褙褚褜褠褦褧褨褰褱褲褵褹褺褾襀襂襅襆襉襏襒襗襚襛襜襡襢襣襫襮襰襳襵襺",
    ],
    [
      "8fdda1",
      "襻襼襽覉覍覐覔覕覛覜覟覠覥覰覴覵覶覷覼觔",
      4,
      "觥觩觫觭觱觳觶觹觽觿訄訅訇訏訑訒訔訕訞訠訢訤訦訫訬訯訵訷訽訾詀詃詅詇詉詍詎詓詖詗詘詜詝詡詥詧詵詶詷詹詺詻詾詿誀誃誆誋誏誐誒誖誗誙誟誧誩誮誯誳",
    ],
    [
      "8fdea1",
      "誶誷誻誾諃諆諈諉諊諑諓諔諕諗諝諟諬諰諴諵諶諼諿謅謆謋謑謜謞謟謊謭謰謷謼譂",
      4,
      "譈譒譓譔譙譍譞譣譭譶譸譹譼譾讁讄讅讋讍讏讔讕讜讞讟谸谹谽谾豅豇豉豋豏豑豓豔豗豘豛豝豙豣豤豦豨豩豭豳豵豶豻豾貆",
    ],
    [
      "8fdfa1",
      "貇貋貐貒貓貙貛貜貤貹貺賅賆賉賋賏賖賕賙賝賡賨賬賯賰賲賵賷賸賾賿贁贃贉贒贗贛赥赩赬赮赿趂趄趈趍趐趑趕趞趟趠趦趫趬趯趲趵趷趹趻跀跅跆跇跈跊跎跑跔跕跗跙跤跥跧跬跰趼跱跲跴跽踁踄踅踆踋踑踔踖踠踡踢",
    ],
    [
      "8fe0a1",
      "踣踦踧踱踳踶踷踸踹踽蹀蹁蹋蹍蹎蹏蹔蹛蹜蹝蹞蹡蹢蹩蹬蹭蹯蹰蹱蹹蹺蹻躂躃躉躐躒躕躚躛躝躞躢躧躩躭躮躳躵躺躻軀軁軃軄軇軏軑軔軜軨軮軰軱軷軹軺軭輀輂輇輈輏輐輖輗輘輞輠輡輣輥輧輨輬輭輮輴輵輶輷輺轀轁",
    ],
    [
      "8fe1a1",
      "轃轇轏轑",
      4,
      "轘轝轞轥辝辠辡辤辥辦辵辶辸达迀迁迆迊迋迍运迒迓迕迠迣迤迨迮迱迵迶迻迾适逄逈逌逘逛逨逩逯逪逬逭逳逴逷逿遃遄遌遛遝遢遦遧遬遰遴遹邅邈邋邌邎邐邕邗邘邙邛邠邡邢邥邰邲邳邴邶邽郌邾郃",
    ],
    [
      "8fe2a1",
      "郄郅郇郈郕郗郘郙郜郝郟郥郒郶郫郯郰郴郾郿鄀鄄鄅鄆鄈鄍鄐鄔鄖鄗鄘鄚鄜鄞鄠鄥鄢鄣鄧鄩鄮鄯鄱鄴鄶鄷鄹鄺鄼鄽酃酇酈酏酓酗酙酚酛酡酤酧酭酴酹酺酻醁醃醅醆醊醎醑醓醔醕醘醞醡醦醨醬醭醮醰醱醲醳醶醻醼醽醿",
    ],
    [
      "8fe3a1",
      "釂釃釅釓釔釗釙釚釞釤釥釩釪釬",
      5,
      "釷釹釻釽鈀鈁鈄鈅鈆鈇鈉鈊鈌鈐鈒鈓鈖鈘鈜鈝鈣鈤鈥鈦鈨鈮鈯鈰鈳鈵鈶鈸鈹鈺鈼鈾鉀鉂鉃鉆鉇鉊鉍鉎鉏鉑鉘鉙鉜鉝鉠鉡鉥鉧鉨鉩鉮鉯鉰鉵",
      4,
      "鉻鉼鉽鉿銈銉銊銍銎銒銗",
    ],
    [
      "8fe4a1",
      "銙銟銠銤銥銧銨銫銯銲銶銸銺銻銼銽銿",
      4,
      "鋅鋆鋇鋈鋋鋌鋍鋎鋐鋓鋕鋗鋘鋙鋜鋝鋟鋠鋡鋣鋥鋧鋨鋬鋮鋰鋹鋻鋿錀錂錈錍錑錔錕錜錝錞錟錡錤錥錧錩錪錳錴錶錷鍇鍈鍉鍐鍑鍒鍕鍗鍘鍚鍞鍤鍥鍧鍩鍪鍭鍯鍰鍱鍳鍴鍶",
    ],
    [
      "8fe5a1",
      "鍺鍽鍿鎀鎁鎂鎈鎊鎋鎍鎏鎒鎕鎘鎛鎞鎡鎣鎤鎦鎨鎫鎴鎵鎶鎺鎩鏁鏄鏅鏆鏇鏉",
      4,
      "鏓鏙鏜鏞鏟鏢鏦鏧鏹鏷鏸鏺鏻鏽鐁鐂鐄鐈鐉鐍鐎鐏鐕鐖鐗鐟鐮鐯鐱鐲鐳鐴鐻鐿鐽鑃鑅鑈鑊鑌鑕鑙鑜鑟鑡鑣鑨鑫鑭鑮鑯鑱鑲钄钃镸镹",
    ],
    [
      "8fe6a1",
      "镾閄閈閌閍閎閝閞閟閡閦閩閫閬閴閶閺閽閿闆闈闉闋闐闑闒闓闙闚闝闞闟闠闤闦阝阞阢阤阥阦阬阱阳阷阸阹阺阼阽陁陒陔陖陗陘陡陮陴陻陼陾陿隁隂隃隄隉隑隖隚隝隟隤隥隦隩隮隯隳隺雊雒嶲雘雚雝雞雟雩雯雱雺霂",
    ],
    [
      "8fe7a1",
      "霃霅霉霚霛霝霡霢霣霨霱霳靁靃靊靎靏靕靗靘靚靛靣靧靪靮靳靶靷靸靻靽靿鞀鞉鞕鞖鞗鞙鞚鞞鞟鞢鞬鞮鞱鞲鞵鞶鞸鞹鞺鞼鞾鞿韁韄韅韇韉韊韌韍韎韐韑韔韗韘韙韝韞韠韛韡韤韯韱韴韷韸韺頇頊頙頍頎頔頖頜頞頠頣頦",
    ],
    [
      "8fe8a1",
      "頫頮頯頰頲頳頵頥頾顄顇顊顑顒顓顖顗顙顚顢顣顥顦顪顬颫颭颮颰颴颷颸颺颻颿飂飅飈飌飡飣飥飦飧飪飳飶餂餇餈餑餕餖餗餚餛餜餟餢餦餧餫餱",
      4,
      "餹餺餻餼饀饁饆饇饈饍饎饔饘饙饛饜饞饟饠馛馝馟馦馰馱馲馵",
    ],
    [
      "8fe9a1",
      "馹馺馽馿駃駉駓駔駙駚駜駞駧駪駫駬駰駴駵駹駽駾騂騃騄騋騌騐騑騖騞騠騢騣騤騧騭騮騳騵騶騸驇驁驄驊驋驌驎驑驔驖驝骪骬骮骯骲骴骵骶骹骻骾骿髁髃髆髈髎髐髒髕髖髗髛髜髠髤髥髧髩髬髲髳髵髹髺髽髿",
      4,
    ],
    [
      "8feaa1",
      "鬄鬅鬈鬉鬋鬌鬍鬎鬐鬒鬖鬙鬛鬜鬠鬦鬫鬭鬳鬴鬵鬷鬹鬺鬽魈魋魌魕魖魗魛魞魡魣魥魦魨魪",
      4,
      "魳魵魷魸魹魿鮀鮄鮅鮆鮇鮉鮊鮋鮍鮏鮐鮔鮚鮝鮞鮦鮧鮩鮬鮰鮱鮲鮷鮸鮻鮼鮾鮿鯁鯇鯈鯎鯐鯗鯘鯝鯟鯥鯧鯪鯫鯯鯳鯷鯸",
    ],
    [
      "8feba1",
      "鯹鯺鯽鯿鰀鰂鰋鰏鰑鰖鰘鰙鰚鰜鰞鰢鰣鰦",
      4,
      "鰱鰵鰶鰷鰽鱁鱃鱄鱅鱉鱊鱎鱏鱐鱓鱔鱖鱘鱛鱝鱞鱟鱣鱩鱪鱜鱫鱨鱮鱰鱲鱵鱷鱻鳦鳲鳷鳹鴋鴂鴑鴗鴘鴜鴝鴞鴯鴰鴲鴳鴴鴺鴼鵅鴽鵂鵃鵇鵊鵓鵔鵟鵣鵢鵥鵩鵪鵫鵰鵶鵷鵻",
    ],
    [
      "8feca1",
      "鵼鵾鶃鶄鶆鶊鶍鶎鶒鶓鶕鶖鶗鶘鶡鶪鶬鶮鶱鶵鶹鶼鶿鷃鷇鷉鷊鷔鷕鷖鷗鷚鷞鷟鷠鷥鷧鷩鷫鷮鷰鷳鷴鷾鸊鸂鸇鸎鸐鸑鸒鸕鸖鸙鸜鸝鹺鹻鹼麀麂麃麄麅麇麎麏麖麘麛麞麤麨麬麮麯麰麳麴麵黆黈黋黕黟黤黧黬黭黮黰黱黲黵",
    ],
    [
      "8feda1",
      "黸黿鼂鼃鼉鼏鼐鼑鼒鼔鼖鼗鼙鼚鼛鼟鼢鼦鼪鼫鼯鼱鼲鼴鼷鼹鼺鼼鼽鼿齁齃",
      4,
      "齓齕齖齗齘齚齝齞齨齩齭",
      4,
      "齳齵齺齽龏龐龑龒龔龖龗龞龡龢龣龥",
    ],
  ],
  dh = [
    ["0", "\0", 127, "€"],
    [
      "8140",
      "丂丄丅丆丏丒丗丟丠両丣並丩丮丯丱丳丵丷丼乀乁乂乄乆乊乑乕乗乚乛乢乣乤乥乧乨乪",
      5,
      "乲乴",
      9,
      "乿",
      6,
      "亇亊",
    ],
    [
      "8180",
      "亐亖亗亙亜亝亞亣亪亯亰亱亴亶亷亸亹亼亽亾仈仌仏仐仒仚仛仜仠仢仦仧仩仭仮仯仱仴仸仹仺仼仾伀伂",
      6,
      "伋伌伒",
      4,
      "伜伝伡伣伨伩伬伭伮伱伳伵伷伹伻伾",
      4,
      "佄佅佇",
      5,
      "佒佔佖佡佢佦佨佪佫佭佮佱佲併佷佸佹佺佽侀侁侂侅來侇侊侌侎侐侒侓侕侖侘侙侚侜侞侟価侢",
    ],
    [
      "8240",
      "侤侫侭侰",
      4,
      "侶",
      8,
      "俀俁係俆俇俈俉俋俌俍俒",
      4,
      "俙俛俠俢俤俥俧俫俬俰俲俴俵俶俷俹俻俼俽俿",
      11,
    ],
    [
      "8280",
      "個倎倐們倓倕倖倗倛倝倞倠倢倣値倧倫倯",
      10,
      "倻倽倿偀偁偂偄偅偆偉偊偋偍偐",
      4,
      "偖偗偘偙偛偝",
      7,
      "偦",
      5,
      "偭",
      8,
      "偸偹偺偼偽傁傂傃傄傆傇傉傊傋傌傎",
      20,
      "傤傦傪傫傭",
      4,
      "傳",
      6,
      "傼",
    ],
    [
      "8340",
      "傽",
      17,
      "僐",
      5,
      "僗僘僙僛",
      10,
      "僨僩僪僫僯僰僱僲僴僶",
      4,
      "僼",
      9,
      "儈",
    ],
    [
      "8380",
      "儉儊儌",
      5,
      "儓",
      13,
      "儢",
      28,
      "兂兇兊兌兎兏児兒兓兗兘兙兛兝",
      4,
      "兣兤兦內兩兪兯兲兺兾兿冃冄円冇冊冋冎冏冐冑冓冔冘冚冝冞冟冡冣冦",
      4,
      "冭冮冴冸冹冺冾冿凁凂凃凅凈凊凍凎凐凒",
      5,
    ],
    [
      "8440",
      "凘凙凚凜凞凟凢凣凥",
      5,
      "凬凮凱凲凴凷凾刄刅刉刋刌刏刐刓刔刕刜刞刟刡刢刣別刦刧刪刬刯刱刲刴刵刼刾剄",
      5,
      "剋剎剏剒剓剕剗剘",
    ],
    [
      "8480",
      "剙剚剛剝剟剠剢剣剤剦剨剫剬剭剮剰剱剳",
      9,
      "剾劀劃",
      4,
      "劉",
      6,
      "劑劒劔",
      6,
      "劜劤劥劦劧劮劯劰労",
      9,
      "勀勁勂勄勅勆勈勊勌勍勎勏勑勓勔動勗務",
      5,
      "勠勡勢勣勥",
      10,
      "勱",
      7,
      "勻勼勽匁匂匃匄匇匉匊匋匌匎",
    ],
    [
      "8540",
      "匑匒匓匔匘匛匜匞匟匢匤匥匧匨匩匫匬匭匯",
      9,
      "匼匽區卂卄卆卋卌卍卐協単卙卛卝卥卨卪卬卭卲卶卹卻卼卽卾厀厁厃厇厈厊厎厏",
    ],
    [
      "8580",
      "厐",
      4,
      "厖厗厙厛厜厞厠厡厤厧厪厫厬厭厯",
      6,
      "厷厸厹厺厼厽厾叀參",
      4,
      "収叏叐叒叓叕叚叜叝叞叡叢叧叴叺叾叿吀吂吅吇吋吔吘吙吚吜吢吤吥吪吰吳吶吷吺吽吿呁呂呄呅呇呉呌呍呎呏呑呚呝",
      4,
      "呣呥呧呩",
      7,
      "呴呹呺呾呿咁咃咅咇咈咉咊咍咑咓咗咘咜咞咟咠咡",
    ],
    [
      "8640",
      "咢咥咮咰咲咵咶咷咹咺咼咾哃哅哊哋哖哘哛哠",
      4,
      "哫哬哯哰哱哴",
      5,
      "哻哾唀唂唃唄唅唈唊",
      4,
      "唒唓唕",
      5,
      "唜唝唞唟唡唥唦",
    ],
    [
      "8680",
      "唨唩唫唭唲唴唵唶唸唹唺唻唽啀啂啅啇啈啋",
      4,
      "啑啒啓啔啗",
      4,
      "啝啞啟啠啢啣啨啩啫啯",
      5,
      "啹啺啽啿喅喆喌喍喎喐喒喓喕喖喗喚喛喞喠",
      6,
      "喨",
      8,
      "喲喴営喸喺喼喿",
      4,
      "嗆嗇嗈嗊嗋嗎嗏嗐嗕嗗",
      4,
      "嗞嗠嗢嗧嗩嗭嗮嗰嗱嗴嗶嗸",
      4,
      "嗿嘂嘃嘄嘅",
    ],
    [
      "8740",
      "嘆嘇嘊嘋嘍嘐",
      7,
      "嘙嘚嘜嘝嘠嘡嘢嘥嘦嘨嘩嘪嘫嘮嘯嘰嘳嘵嘷嘸嘺嘼嘽嘾噀",
      11,
      "噏",
      4,
      "噕噖噚噛噝",
      4,
    ],
    [
      "8780",
      "噣噥噦噧噭噮噯噰噲噳噴噵噷噸噹噺噽",
      7,
      "嚇",
      6,
      "嚐嚑嚒嚔",
      14,
      "嚤",
      10,
      "嚰",
      6,
      "嚸嚹嚺嚻嚽",
      12,
      "囋",
      8,
      "囕囖囘囙囜団囥",
      5,
      "囬囮囯囲図囶囷囸囻囼圀圁圂圅圇國",
      6,
    ],
    [
      "8840",
      "園",
      9,
      "圝圞圠圡圢圤圥圦圧圫圱圲圴",
      4,
      "圼圽圿坁坃坄坅坆坈坉坋坒",
      4,
      "坘坙坢坣坥坧坬坮坰坱坲坴坵坸坹坺坽坾坿垀",
    ],
    [
      "8880",
      "垁垇垈垉垊垍",
      4,
      "垔",
      6,
      "垜垝垞垟垥垨垪垬垯垰垱垳垵垶垷垹",
      8,
      "埄",
      6,
      "埌埍埐埑埓埖埗埛埜埞埡埢埣埥",
      7,
      "埮埰埱埲埳埵埶執埻埼埾埿堁堃堄堅堈堉堊堌堎堏堐堒堓堔堖堗堘堚堛堜堝堟堢堣堥",
      4,
      "堫",
      4,
      "報堲堳場堶",
      7,
    ],
    [
      "8940",
      "堾",
      5,
      "塅",
      6,
      "塎塏塐塒塓塕塖塗塙",
      4,
      "塟",
      5,
      "塦",
      4,
      "塭",
      16,
      "塿墂墄墆墇墈墊墋墌",
    ],
    [
      "8980",
      "墍",
      4,
      "墔",
      4,
      "墛墜墝墠",
      7,
      "墪",
      17,
      "墽墾墿壀壂壃壄壆",
      10,
      "壒壓壔壖",
      13,
      "壥",
      5,
      "壭壯壱売壴壵壷壸壺",
      7,
      "夃夅夆夈",
      4,
      "夎夐夑夒夓夗夘夛夝夞夠夡夢夣夦夨夬夰夲夳夵夶夻",
    ],
    [
      "8a40",
      "夽夾夿奀奃奅奆奊奌奍奐奒奓奙奛",
      4,
      "奡奣奤奦",
      12,
      "奵奷奺奻奼奾奿妀妅妉妋妌妎妏妐妑妔妕妘妚妛妜妝妟妠妡妢妦",
    ],
    [
      "8a80",
      "妧妬妭妰妱妳",
      5,
      "妺妼妽妿",
      6,
      "姇姈姉姌姍姎姏姕姖姙姛姞",
      4,
      "姤姦姧姩姪姫姭",
      11,
      "姺姼姽姾娀娂娊娋娍娎娏娐娒娔娕娖娗娙娚娛娝娞娡娢娤娦娧娨娪",
      6,
      "娳娵娷",
      4,
      "娽娾娿婁",
      4,
      "婇婈婋",
      9,
      "婖婗婘婙婛",
      5,
    ],
    [
      "8b40",
      "婡婣婤婥婦婨婩婫",
      8,
      "婸婹婻婼婽婾媀",
      17,
      "媓",
      6,
      "媜",
      13,
      "媫媬",
    ],
    [
      "8b80",
      "媭",
      4,
      "媴媶媷媹",
      4,
      "媿嫀嫃",
      5,
      "嫊嫋嫍",
      4,
      "嫓嫕嫗嫙嫚嫛嫝嫞嫟嫢嫤嫥嫧嫨嫪嫬",
      4,
      "嫲",
      22,
      "嬊",
      11,
      "嬘",
      25,
      "嬳嬵嬶嬸",
      7,
      "孁",
      6,
    ],
    [
      "8c40",
      "孈",
      7,
      "孒孖孞孠孡孧孨孫孭孮孯孲孴孶孷學孹孻孼孾孿宂宆宊宍宎宐宑宒宔宖実宧宨宩宬宭宮宯宱宲宷宺宻宼寀寁寃寈寉寊寋寍寎寏",
    ],
    [
      "8c80",
      "寑寔",
      8,
      "寠寢寣實寧審",
      4,
      "寯寱",
      6,
      "寽対尀専尃尅將專尋尌對導尐尒尓尗尙尛尞尟尠尡尣尦尨尩尪尫尭尮尯尰尲尳尵尶尷屃屄屆屇屌屍屒屓屔屖屗屘屚屛屜屝屟屢層屧",
      6,
      "屰屲",
      6,
      "屻屼屽屾岀岃",
      4,
      "岉岊岋岎岏岒岓岕岝",
      4,
      "岤",
      4,
    ],
    [
      "8d40",
      "岪岮岯岰岲岴岶岹岺岻岼岾峀峂峃峅",
      5,
      "峌",
      5,
      "峓",
      5,
      "峚",
      6,
      "峢峣峧峩峫峬峮峯峱",
      9,
      "峼",
      4,
    ],
    [
      "8d80",
      "崁崄崅崈",
      5,
      "崏",
      4,
      "崕崗崘崙崚崜崝崟",
      4,
      "崥崨崪崫崬崯",
      4,
      "崵",
      7,
      "崿",
      7,
      "嵈嵉嵍",
      10,
      "嵙嵚嵜嵞",
      10,
      "嵪嵭嵮嵰嵱嵲嵳嵵",
      12,
      "嶃",
      21,
      "嶚嶛嶜嶞嶟嶠",
    ],
    ["8e40", "嶡", 21, "嶸", 12, "巆", 6, "巎", 12, "巜巟巠巣巤巪巬巭"],
    [
      "8e80",
      "巰巵巶巸",
      4,
      "巿帀帄帇帉帊帋帍帎帒帓帗帞",
      7,
      "帨",
      4,
      "帯帰帲",
      4,
      "帹帺帾帿幀幁幃幆",
      5,
      "幍",
      6,
      "幖",
      4,
      "幜幝幟幠幣",
      14,
      "幵幷幹幾庁庂広庅庈庉庌庍庎庒庘庛庝庡庢庣庤庨",
      4,
      "庮",
      4,
      "庴庺庻庼庽庿",
      6,
    ],
    [
      "8f40",
      "廆廇廈廋",
      5,
      "廔廕廗廘廙廚廜",
      11,
      "廩廫",
      8,
      "廵廸廹廻廼廽弅弆弇弉弌弍弎弐弒弔弖弙弚弜弝弞弡弢弣弤",
    ],
    [
      "8f80",
      "弨弫弬弮弰弲",
      6,
      "弻弽弾弿彁",
      14,
      "彑彔彙彚彛彜彞彟彠彣彥彧彨彫彮彯彲彴彵彶彸彺彽彾彿徃徆徍徎徏徑従徔徖徚徛徝從徟徠徢",
      5,
      "復徫徬徯",
      5,
      "徶徸徹徺徻徾",
      4,
      "忇忈忊忋忎忓忔忕忚忛応忞忟忢忣忥忦忨忩忬忯忰忲忳忴忶忷忹忺忼怇",
    ],
    [
      "9040",
      "怈怉怋怌怐怑怓怗怘怚怞怟怢怣怤怬怭怮怰",
      4,
      "怶",
      4,
      "怽怾恀恄",
      6,
      "恌恎恏恑恓恔恖恗恘恛恜恞恟恠恡恥恦恮恱恲恴恵恷恾悀",
    ],
    [
      "9080",
      "悁悂悅悆悇悈悊悋悎悏悐悑悓悕悗悘悙悜悞悡悢悤悥悧悩悪悮悰悳悵悶悷悹悺悽",
      7,
      "惇惈惉惌",
      4,
      "惒惓惔惖惗惙惛惞惡",
      4,
      "惪惱惲惵惷惸惻",
      4,
      "愂愃愄愅愇愊愋愌愐",
      4,
      "愖愗愘愙愛愜愝愞愡愢愥愨愩愪愬",
      18,
      "慀",
      6,
    ],
    [
      "9140",
      "慇慉態慍慏慐慒慓慔慖",
      6,
      "慞慟慠慡慣慤慥慦慩",
      6,
      "慱慲慳慴慶慸",
      18,
      "憌憍憏",
      4,
      "憕",
    ],
    [
      "9180",
      "憖",
      6,
      "憞",
      8,
      "憪憫憭",
      9,
      "憸",
      5,
      "憿懀懁懃",
      4,
      "應懌",
      4,
      "懓懕",
      16,
      "懧",
      13,
      "懶",
      8,
      "戀",
      5,
      "戇戉戓戔戙戜戝戞戠戣戦戧戨戩戫戭戯戰戱戲戵戶戸",
      4,
      "扂扄扅扆扊",
    ],
    [
      "9240",
      "扏扐払扖扗扙扚扜",
      6,
      "扤扥扨扱扲扴扵扷扸扺扻扽抁抂抃抅抆抇抈抋",
      5,
      "抔抙抜抝択抣抦抧抩抪抭抮抯抰抲抳抴抶抷抸抺抾拀拁",
    ],
    [
      "9280",
      "拃拋拏拑拕拝拞拠拡拤拪拫拰拲拵拸拹拺拻挀挃挄挅挆挊挋挌挍挏挐挒挓挔挕挗挘挙挜挦挧挩挬挭挮挰挱挳",
      5,
      "挻挼挾挿捀捁捄捇捈捊捑捒捓捔捖",
      7,
      "捠捤捥捦捨捪捫捬捯捰捲捳捴捵捸捹捼捽捾捿掁掃掄掅掆掋掍掑掓掔掕掗掙",
      6,
      "採掤掦掫掯掱掲掵掶掹掻掽掿揀",
    ],
    [
      "9340",
      "揁揂揃揅揇揈揊揋揌揑揓揔揕揗",
      6,
      "揟揢揤",
      4,
      "揫揬揮揯揰揱揳揵揷揹揺揻揼揾搃搄搆",
      4,
      "損搎搑搒搕",
      5,
      "搝搟搢搣搤",
    ],
    [
      "9380",
      "搥搧搨搩搫搮",
      5,
      "搵",
      4,
      "搻搼搾摀摂摃摉摋",
      6,
      "摓摕摖摗摙",
      4,
      "摟",
      7,
      "摨摪摫摬摮",
      9,
      "摻",
      6,
      "撃撆撈",
      8,
      "撓撔撗撘撚撛撜撝撟",
      4,
      "撥撦撧撨撪撫撯撱撲撳撴撶撹撻撽撾撿擁擃擄擆",
      6,
      "擏擑擓擔擕擖擙據",
    ],
    ["9440", "擛擜擝擟擠擡擣擥擧", 24, "攁", 7, "攊", 7, "攓", 4, "攙", 8],
    [
      "9480",
      "攢攣攤攦",
      4,
      "攬攭攰攱攲攳攷攺攼攽敀",
      4,
      "敆敇敊敋敍敎敐敒敓敔敗敘敚敜敟敠敡敤敥敧敨敩敪敭敮敯敱敳敵敶數",
      14,
      "斈斉斊斍斎斏斒斔斕斖斘斚斝斞斠斢斣斦斨斪斬斮斱",
      7,
      "斺斻斾斿旀旂旇旈旉旊旍旐旑旓旔旕旘",
      7,
      "旡旣旤旪旫",
    ],
    [
      "9540",
      "旲旳旴旵旸旹旻",
      4,
      "昁昄昅昇昈昉昋昍昐昑昒昖昗昘昚昛昜昞昡昢昣昤昦昩昪昫昬昮昰昲昳昷",
      4,
      "昽昿晀時晄",
      6,
      "晍晎晐晑晘",
    ],
    [
      "9580",
      "晙晛晜晝晞晠晢晣晥晧晩",
      4,
      "晱晲晳晵晸晹晻晼晽晿暀暁暃暅暆暈暉暊暋暍暎暏暐暒暓暔暕暘",
      4,
      "暞",
      8,
      "暩",
      4,
      "暯",
      4,
      "暵暶暷暸暺暻暼暽暿",
      25,
      "曚曞",
      7,
      "曧曨曪",
      5,
      "曱曵曶書曺曻曽朁朂會",
    ],
    [
      "9640",
      "朄朅朆朇朌朎朏朑朒朓朖朘朙朚朜朞朠",
      5,
      "朧朩朮朰朲朳朶朷朸朹朻朼朾朿杁杄杅杇杊杋杍杒杔杕杗",
      4,
      "杝杢杣杤杦杧杫杬杮東杴杶",
    ],
    [
      "9680",
      "杸杹杺杻杽枀枂枃枅枆枈枊枌枍枎枏枑枒枓枔枖枙枛枟枠枡枤枦枩枬枮枱枲枴枹",
      7,
      "柂柅",
      9,
      "柕柖柗柛柟柡柣柤柦柧柨柪柫柭柮柲柵",
      7,
      "柾栁栂栃栄栆栍栐栒栔栕栘",
      4,
      "栞栟栠栢",
      6,
      "栫",
      6,
      "栴栵栶栺栻栿桇桋桍桏桒桖",
      5,
    ],
    [
      "9740",
      "桜桝桞桟桪桬",
      7,
      "桵桸",
      8,
      "梂梄梇",
      7,
      "梐梑梒梔梕梖梘",
      9,
      "梣梤梥梩梪梫梬梮梱梲梴梶梷梸",
    ],
    [
      "9780",
      "梹",
      6,
      "棁棃",
      5,
      "棊棌棎棏棐棑棓棔棖棗棙棛",
      4,
      "棡棢棤",
      9,
      "棯棲棳棴棶棷棸棻棽棾棿椀椂椃椄椆",
      4,
      "椌椏椑椓",
      11,
      "椡椢椣椥",
      7,
      "椮椯椱椲椳椵椶椷椸椺椻椼椾楀楁楃",
      16,
      "楕楖楘楙楛楜楟",
    ],
    [
      "9840",
      "楡楢楤楥楧楨楩楪楬業楯楰楲",
      4,
      "楺楻楽楾楿榁榃榅榊榋榌榎",
      5,
      "榖榗榙榚榝",
      9,
      "榩榪榬榮榯榰榲榳榵榶榸榹榺榼榽",
    ],
    [
      "9880",
      "榾榿槀槂",
      7,
      "構槍槏槑槒槓槕",
      5,
      "槜槝槞槡",
      11,
      "槮槯槰槱槳",
      9,
      "槾樀",
      9,
      "樋",
      11,
      "標",
      5,
      "樠樢",
      5,
      "権樫樬樭樮樰樲樳樴樶",
      6,
      "樿",
      4,
      "橅橆橈",
      7,
      "橑",
      6,
      "橚",
    ],
    [
      "9940",
      "橜",
      4,
      "橢橣橤橦",
      10,
      "橲",
      6,
      "橺橻橽橾橿檁檂檃檅",
      8,
      "檏檒",
      4,
      "檘",
      7,
      "檡",
      5,
    ],
    ["9980", "檧檨檪檭", 114, "欥欦欨", 6],
    [
      "9a40",
      "欯欰欱欳欴欵欶欸欻欼欽欿歀歁歂歄歅歈歊歋歍",
      11,
      "歚",
      7,
      "歨歩歫",
      13,
      "歺歽歾歿殀殅殈",
    ],
    [
      "9a80",
      "殌殎殏殐殑殔殕殗殘殙殜",
      4,
      "殢",
      7,
      "殫",
      7,
      "殶殸",
      6,
      "毀毃毄毆",
      4,
      "毌毎毐毑毘毚毜",
      4,
      "毢",
      7,
      "毬毭毮毰毱毲毴毶毷毸毺毻毼毾",
      6,
      "氈",
      4,
      "氎氒気氜氝氞氠氣氥氫氬氭氱氳氶氷氹氺氻氼氾氿汃汄汅汈汋",
      4,
      "汑汒汓汖汘",
    ],
    [
      "9b40",
      "汙汚汢汣汥汦汧汫",
      4,
      "汱汳汵汷汸決汻汼汿沀沄沇沊沋沍沎沑沒沕沖沗沘沚沜沝沞沠沢沨沬沯沰沴沵沶沷沺泀況泂泃泆泇泈泋泍泎泏泑泒泘",
    ],
    [
      "9b80",
      "泙泚泜泝泟泤泦泧泩泬泭泲泴泹泿洀洂洃洅洆洈洉洊洍洏洐洑洓洔洕洖洘洜洝洟",
      5,
      "洦洨洩洬洭洯洰洴洶洷洸洺洿浀浂浄浉浌浐浕浖浗浘浛浝浟浡浢浤浥浧浨浫浬浭浰浱浲浳浵浶浹浺浻浽",
      4,
      "涃涄涆涇涊涋涍涏涐涒涖",
      4,
      "涜涢涥涬涭涰涱涳涴涶涷涹",
      5,
      "淁淂淃淈淉淊",
    ],
    [
      "9c40",
      "淍淎淏淐淒淓淔淕淗淚淛淜淟淢淣淥淧淨淩淪淭淯淰淲淴淵淶淸淺淽",
      7,
      "渆渇済渉渋渏渒渓渕渘渙減渜渞渟渢渦渧渨渪測渮渰渱渳渵",
    ],
    [
      "9c80",
      "渶渷渹渻",
      7,
      "湅",
      7,
      "湏湐湑湒湕湗湙湚湜湝湞湠",
      10,
      "湬湭湯",
      14,
      "満溁溂溄溇溈溊",
      4,
      "溑",
      6,
      "溙溚溛溝溞溠溡溣溤溦溨溩溫溬溭溮溰溳溵溸溹溼溾溿滀滃滄滅滆滈滉滊滌滍滎滐滒滖滘滙滛滜滝滣滧滪",
      5,
    ],
    [
      "9d40",
      "滰滱滲滳滵滶滷滸滺",
      7,
      "漃漄漅漇漈漊",
      4,
      "漐漑漒漖",
      9,
      "漡漢漣漥漦漧漨漬漮漰漲漴漵漷",
      6,
      "漿潀潁潂",
    ],
    [
      "9d80",
      "潃潄潅潈潉潊潌潎",
      9,
      "潙潚潛潝潟潠潡潣潤潥潧",
      5,
      "潯潰潱潳潵潶潷潹潻潽",
      6,
      "澅澆澇澊澋澏",
      12,
      "澝澞澟澠澢",
      4,
      "澨",
      10,
      "澴澵澷澸澺",
      5,
      "濁濃",
      5,
      "濊",
      6,
      "濓",
      10,
      "濟濢濣濤濥",
    ],
    ["9e40", "濦", 7, "濰", 32, "瀒", 7, "瀜", 6, "瀤", 6],
    [
      "9e80",
      "瀫",
      9,
      "瀶瀷瀸瀺",
      17,
      "灍灎灐",
      13,
      "灟",
      11,
      "灮灱灲灳灴灷灹灺灻災炁炂炃炄炆炇炈炋炌炍炏炐炑炓炗炘炚炛炞",
      12,
      "炰炲炴炵炶為炾炿烄烅烆烇烉烋",
      12,
      "烚",
    ],
    [
      "9f40",
      "烜烝烞烠烡烢烣烥烪烮烰",
      6,
      "烸烺烻烼烾",
      10,
      "焋",
      4,
      "焑焒焔焗焛",
      10,
      "焧",
      7,
      "焲焳焴",
    ],
    [
      "9f80",
      "焵焷",
      13,
      "煆煇煈煉煋煍煏",
      12,
      "煝煟",
      4,
      "煥煩",
      4,
      "煯煰煱煴煵煶煷煹煻煼煾",
      5,
      "熅",
      4,
      "熋熌熍熎熐熑熒熓熕熖熗熚",
      4,
      "熡",
      6,
      "熩熪熫熭",
      5,
      "熴熶熷熸熺",
      8,
      "燄",
      9,
      "燏",
      4,
    ],
    ["a040", "燖", 9, "燡燢燣燤燦燨", 5, "燯", 9, "燺", 11, "爇", 19],
    [
      "a080",
      "爛爜爞",
      9,
      "爩爫爭爮爯爲爳爴爺爼爾牀",
      6,
      "牉牊牋牎牏牐牑牓牔牕牗牘牚牜牞牠牣牤牥牨牪牫牬牭牰牱牳牴牶牷牸牻牼牽犂犃犅",
      4,
      "犌犎犐犑犓",
      11,
      "犠",
      11,
      "犮犱犲犳犵犺",
      6,
      "狅狆狇狉狊狋狌狏狑狓狔狕狖狘狚狛",
    ],
    [
      "a1a1",
      "　、。·ˉˇ¨〃々—～‖…‘’“”〔〕〈",
      7,
      "〖〗【】±×÷∶∧∨∑∏∪∩∈∷√⊥∥∠⌒⊙∫∮≡≌≈∽∝≠≮≯≤≥∞∵∴♂♀°′″℃＄¤￠￡‰§№☆★○●◎◇◆□■△▲※→←↑↓〓",
    ],
    ["a2a1", "ⅰ", 9],
    ["a2b1", "⒈", 19, "⑴", 19, "①", 9],
    ["a2e5", "㈠", 9],
    ["a2f1", "Ⅰ", 11],
    ["a3a1", "！＂＃￥％", 88, "￣"],
    ["a4a1", "ぁ", 82],
    ["a5a1", "ァ", 85],
    ["a6a1", "Α", 16, "Σ", 6],
    ["a6c1", "α", 16, "σ", 6],
    ["a6e0", "︵︶︹︺︿﹀︽︾﹁﹂﹃﹄"],
    ["a6ee", "︻︼︷︸︱"],
    ["a6f4", "︳︴"],
    ["a7a1", "А", 5, "ЁЖ", 25],
    ["a7d1", "а", 5, "ёж", 25],
    ["a840", "ˊˋ˙–―‥‵℅℉↖↗↘↙∕∟∣≒≦≧⊿═", 35, "▁", 6],
    ["a880", "█", 7, "▓▔▕▼▽◢◣◤◥☉⊕〒〝〞"],
    ["a8a1", "āáǎàēéěèīíǐìōóǒòūúǔùǖǘǚǜüêɑ"],
    ["a8bd", "ńň"],
    ["a8c0", "ɡ"],
    ["a8c5", "ㄅ", 36],
    ["a940", "〡", 8, "㊣㎎㎏㎜㎝㎞㎡㏄㏎㏑㏒㏕︰￢￤"],
    ["a959", "℡㈱"],
    ["a95c", "‐"],
    ["a960", "ー゛゜ヽヾ〆ゝゞ﹉", 9, "﹔﹕﹖﹗﹙", 8],
    ["a980", "﹢", 4, "﹨﹩﹪﹫"],
    ["a996", "〇"],
    ["a9a4", "─", 75],
    [
      "aa40",
      "狜狝狟狢",
      5,
      "狪狫狵狶狹狽狾狿猀猂猄",
      5,
      "猋猌猍猏猐猑猒猔猘猙猚猟猠猣猤猦猧猨猭猯猰猲猳猵猶猺猻猼猽獀",
      8,
    ],
    ["aa80", "獉獊獋獌獎獏獑獓獔獕獖獘", 7, "獡", 10, "獮獰獱"],
    [
      "ab40",
      "獲",
      11,
      "獿",
      4,
      "玅玆玈玊玌玍玏玐玒玓玔玕玗玘玙玚玜玝玞玠玡玣",
      5,
      "玪玬玭玱玴玵玶玸玹玼玽玾玿珁珃",
      4,
    ],
    ["ab80", "珋珌珎珒", 6, "珚珛珜珝珟珡珢珣珤珦珨珪珫珬珮珯珰珱珳", 4],
    [
      "ac40",
      "珸",
      10,
      "琄琇琈琋琌琍琎琑",
      8,
      "琜",
      5,
      "琣琤琧琩琫琭琯琱琲琷",
      4,
      "琽琾琿瑀瑂",
      11,
    ],
    ["ac80", "瑎", 6, "瑖瑘瑝瑠", 12, "瑮瑯瑱", 4, "瑸瑹瑺"],
    [
      "ad40",
      "瑻瑼瑽瑿璂璄璅璆璈璉璊璌璍璏璑",
      10,
      "璝璟",
      7,
      "璪",
      15,
      "璻",
      12,
    ],
    ["ad80", "瓈", 9, "瓓", 8, "瓝瓟瓡瓥瓧", 6, "瓰瓱瓲"],
    [
      "ae40",
      "瓳瓵瓸",
      6,
      "甀甁甂甃甅",
      7,
      "甎甐甒甔甕甖甗甛甝甞甠",
      4,
      "甦甧甪甮甴甶甹甼甽甿畁畂畃畄畆畇畉畊畍畐畑畒畓畕畖畗畘",
    ],
    ["ae80", "畝", 7, "畧畨畩畫", 6, "畳畵當畷畺", 4, "疀疁疂疄疅疇"],
    [
      "af40",
      "疈疉疊疌疍疎疐疓疕疘疛疜疞疢疦",
      4,
      "疭疶疷疺疻疿痀痁痆痋痌痎痏痐痑痓痗痙痚痜痝痟痠痡痥痩痬痭痮痯痲痳痵痶痷痸痺痻痽痾瘂瘄瘆瘇",
    ],
    [
      "af80",
      "瘈瘉瘋瘍瘎瘏瘑瘒瘓瘔瘖瘚瘜瘝瘞瘡瘣瘧瘨瘬瘮瘯瘱瘲瘶瘷瘹瘺瘻瘽癁療癄",
    ],
    [
      "b040",
      "癅",
      6,
      "癎",
      5,
      "癕癗",
      4,
      "癝癟癠癡癢癤",
      6,
      "癬癭癮癰",
      7,
      "癹発發癿皀皁皃皅皉皊皌皍皏皐皒皔皕皗皘皚皛",
    ],
    [
      "b080",
      "皜",
      7,
      "皥",
      8,
      "皯皰皳皵",
      9,
      "盀盁盃啊阿埃挨哎唉哀皑癌蔼矮艾碍爱隘鞍氨安俺按暗岸胺案肮昂盎凹敖熬翱袄傲奥懊澳芭捌扒叭吧笆八疤巴拔跋靶把耙坝霸罢爸白柏百摆佰败拜稗斑班搬扳般颁板版扮拌伴瓣半办绊邦帮梆榜膀绑棒磅蚌镑傍谤苞胞包褒剥",
    ],
    [
      "b140",
      "盄盇盉盋盌盓盕盙盚盜盝盞盠",
      4,
      "盦",
      7,
      "盰盳盵盶盷盺盻盽盿眀眂眃眅眆眊県眎",
      10,
      "眛眜眝眞眡眣眤眥眧眪眫",
    ],
    [
      "b180",
      "眬眮眰",
      4,
      "眹眻眽眾眿睂睄睅睆睈",
      7,
      "睒",
      7,
      "睜薄雹保堡饱宝抱报暴豹鲍爆杯碑悲卑北辈背贝钡倍狈备惫焙被奔苯本笨崩绷甭泵蹦迸逼鼻比鄙笔彼碧蓖蔽毕毙毖币庇痹闭敝弊必辟壁臂避陛鞭边编贬扁便变卞辨辩辫遍标彪膘表鳖憋别瘪彬斌濒滨宾摈兵冰柄丙秉饼炳",
    ],
    [
      "b240",
      "睝睞睟睠睤睧睩睪睭",
      11,
      "睺睻睼瞁瞂瞃瞆",
      5,
      "瞏瞐瞓",
      11,
      "瞡瞣瞤瞦瞨瞫瞭瞮瞯瞱瞲瞴瞶",
      4,
    ],
    [
      "b280",
      "瞼瞾矀",
      12,
      "矎",
      8,
      "矘矙矚矝",
      4,
      "矤病并玻菠播拨钵波博勃搏铂箔伯帛舶脖膊渤泊驳捕卜哺补埠不布步簿部怖擦猜裁材才财睬踩采彩菜蔡餐参蚕残惭惨灿苍舱仓沧藏操糙槽曹草厕策侧册测层蹭插叉茬茶查碴搽察岔差诧拆柴豺搀掺蝉馋谗缠铲产阐颤昌猖",
    ],
    [
      "b340",
      "矦矨矪矯矰矱矲矴矵矷矹矺矻矼砃",
      5,
      "砊砋砎砏砐砓砕砙砛砞砠砡砢砤砨砪砫砮砯砱砲砳砵砶砽砿硁硂硃硄硆硈硉硊硋硍硏硑硓硔硘硙硚",
    ],
    [
      "b380",
      "硛硜硞",
      11,
      "硯",
      7,
      "硸硹硺硻硽",
      6,
      "场尝常长偿肠厂敞畅唱倡超抄钞朝嘲潮巢吵炒车扯撤掣彻澈郴臣辰尘晨忱沉陈趁衬撑称城橙成呈乘程惩澄诚承逞骋秤吃痴持匙池迟弛驰耻齿侈尺赤翅斥炽充冲虫崇宠抽酬畴踌稠愁筹仇绸瞅丑臭初出橱厨躇锄雏滁除楚",
    ],
    [
      "b440",
      "碄碅碆碈碊碋碏碐碒碔碕碖碙碝碞碠碢碤碦碨",
      7,
      "碵碶碷碸確碻碼碽碿磀磂磃磄磆磇磈磌磍磎磏磑磒磓磖磗磘磚",
      9,
    ],
    [
      "b480",
      "磤磥磦磧磩磪磫磭",
      4,
      "磳磵磶磸磹磻",
      5,
      "礂礃礄礆",
      6,
      "础储矗搐触处揣川穿椽传船喘串疮窗幢床闯创吹炊捶锤垂春椿醇唇淳纯蠢戳绰疵茨磁雌辞慈瓷词此刺赐次聪葱囱匆从丛凑粗醋簇促蹿篡窜摧崔催脆瘁粹淬翠村存寸磋撮搓措挫错搭达答瘩打大呆歹傣戴带殆代贷袋待逮",
    ],
    [
      "b540",
      "礍",
      5,
      "礔",
      9,
      "礟",
      4,
      "礥",
      14,
      "礵",
      4,
      "礽礿祂祃祄祅祇祊",
      8,
      "祔祕祘祙祡祣",
    ],
    [
      "b580",
      "祤祦祩祪祫祬祮祰",
      6,
      "祹祻",
      4,
      "禂禃禆禇禈禉禋禌禍禎禐禑禒怠耽担丹单郸掸胆旦氮但惮淡诞弹蛋当挡党荡档刀捣蹈倒岛祷导到稻悼道盗德得的蹬灯登等瞪凳邓堤低滴迪敌笛狄涤翟嫡抵底地蒂第帝弟递缔颠掂滇碘点典靛垫电佃甸店惦奠淀殿碉叼雕凋刁掉吊钓调跌爹碟蝶迭谍叠",
    ],
    [
      "b640",
      "禓",
      6,
      "禛",
      11,
      "禨",
      10,
      "禴",
      4,
      "禼禿秂秄秅秇秈秊秌秎秏秐秓秔秖秗秙",
      5,
      "秠秡秢秥秨秪",
    ],
    [
      "b680",
      "秬秮秱",
      6,
      "秹秺秼秾秿稁稄稅稇稈稉稊稌稏",
      4,
      "稕稖稘稙稛稜丁盯叮钉顶鼎锭定订丢东冬董懂动栋侗恫冻洞兜抖斗陡豆逗痘都督毒犊独读堵睹赌杜镀肚度渡妒端短锻段断缎堆兑队对墩吨蹲敦顿囤钝盾遁掇哆多夺垛躲朵跺舵剁惰堕蛾峨鹅俄额讹娥恶厄扼遏鄂饿恩而儿耳尔饵洱二",
    ],
    ["b740", "稝稟稡稢稤", 14, "稴稵稶稸稺稾穀", 5, "穇", 9, "穒", 4, "穘", 16],
    [
      "b780",
      "穩",
      6,
      "穱穲穳穵穻穼穽穾窂窅窇窉窊窋窌窎窏窐窓窔窙窚窛窞窡窢贰发罚筏伐乏阀法珐藩帆番翻樊矾钒繁凡烦反返范贩犯饭泛坊芳方肪房防妨仿访纺放菲非啡飞肥匪诽吠肺废沸费芬酚吩氛分纷坟焚汾粉奋份忿愤粪丰封枫蜂峰锋风疯烽逢冯缝讽奉凤佛否夫敷肤孵扶拂辐幅氟符伏俘服",
    ],
    [
      "b840",
      "窣窤窧窩窪窫窮",
      4,
      "窴",
      10,
      "竀",
      10,
      "竌",
      9,
      "竗竘竚竛竜竝竡竢竤竧",
      5,
      "竮竰竱竲竳",
    ],
    [
      "b880",
      "竴",
      4,
      "竻竼竾笀笁笂笅笇笉笌笍笎笐笒笓笖笗笘笚笜笝笟笡笢笣笧笩笭浮涪福袱弗甫抚辅俯釜斧脯腑府腐赴副覆赋复傅付阜父腹负富讣附妇缚咐噶嘎该改概钙盖溉干甘杆柑竿肝赶感秆敢赣冈刚钢缸肛纲岗港杠篙皋高膏羔糕搞镐稿告哥歌搁戈鸽胳疙割革葛格蛤阁隔铬个各给根跟耕更庚羹",
    ],
    [
      "b940",
      "笯笰笲笴笵笶笷笹笻笽笿",
      5,
      "筆筈筊筍筎筓筕筗筙筜筞筟筡筣",
      10,
      "筯筰筳筴筶筸筺筼筽筿箁箂箃箄箆",
      6,
      "箎箏",
    ],
    [
      "b980",
      "箑箒箓箖箘箙箚箛箞箟箠箣箤箥箮箯箰箲箳箵箶箷箹",
      7,
      "篂篃範埂耿梗工攻功恭龚供躬公宫弓巩汞拱贡共钩勾沟苟狗垢构购够辜菇咕箍估沽孤姑鼓古蛊骨谷股故顾固雇刮瓜剐寡挂褂乖拐怪棺关官冠观管馆罐惯灌贯光广逛瑰规圭硅归龟闺轨鬼诡癸桂柜跪贵刽辊滚棍锅郭国果裹过哈",
    ],
    [
      "ba40",
      "篅篈築篊篋篍篎篏篐篒篔",
      4,
      "篛篜篞篟篠篢篣篤篧篨篩篫篬篭篯篰篲",
      4,
      "篸篹篺篻篽篿",
      7,
      "簈簉簊簍簎簐",
      5,
      "簗簘簙",
    ],
    [
      "ba80",
      "簚",
      4,
      "簠",
      5,
      "簨簩簫",
      12,
      "簹",
      5,
      "籂骸孩海氦亥害骇酣憨邯韩含涵寒函喊罕翰撼捍旱憾悍焊汗汉夯杭航壕嚎豪毫郝好耗号浩呵喝荷菏核禾和何合盒貉阂河涸赫褐鹤贺嘿黑痕很狠恨哼亨横衡恒轰哄烘虹鸿洪宏弘红喉侯猴吼厚候后呼乎忽瑚壶葫胡蝴狐糊湖",
    ],
    ["bb40", "籃", 9, "籎", 36, "籵", 5, "籾", 9],
    [
      "bb80",
      "粈粊",
      6,
      "粓粔粖粙粚粛粠粡粣粦粧粨粩粫粬粭粯粰粴",
      4,
      "粺粻弧虎唬护互沪户花哗华猾滑画划化话槐徊怀淮坏欢环桓还缓换患唤痪豢焕涣宦幻荒慌黄磺蝗簧皇凰惶煌晃幌恍谎灰挥辉徽恢蛔回毁悔慧卉惠晦贿秽会烩汇讳诲绘荤昏婚魂浑混豁活伙火获或惑霍货祸击圾基机畸稽积箕",
    ],
    [
      "bc40",
      "粿糀糂糃糄糆糉糋糎",
      6,
      "糘糚糛糝糞糡",
      6,
      "糩",
      5,
      "糰",
      7,
      "糹糺糼",
      13,
      "紋",
      5,
    ],
    [
      "bc80",
      "紑",
      14,
      "紡紣紤紥紦紨紩紪紬紭紮細",
      6,
      "肌饥迹激讥鸡姬绩缉吉极棘辑籍集及急疾汲即嫉级挤几脊己蓟技冀季伎祭剂悸济寄寂计记既忌际妓继纪嘉枷夹佳家加荚颊贾甲钾假稼价架驾嫁歼监坚尖笺间煎兼肩艰奸缄茧检柬碱硷拣捡简俭剪减荐槛鉴践贱见键箭件",
    ],
    ["bd40", "紷", 54, "絯", 7],
    [
      "bd80",
      "絸",
      32,
      "健舰剑饯渐溅涧建僵姜将浆江疆蒋桨奖讲匠酱降蕉椒礁焦胶交郊浇骄娇嚼搅铰矫侥脚狡角饺缴绞剿教酵轿较叫窖揭接皆秸街阶截劫节桔杰捷睫竭洁结解姐戒藉芥界借介疥诫届巾筋斤金今津襟紧锦仅谨进靳晋禁近烬浸",
    ],
    ["be40", "継", 12, "綧", 6, "綯", 42],
    [
      "be80",
      "線",
      32,
      "尽劲荆兢茎睛晶鲸京惊精粳经井警景颈静境敬镜径痉靖竟竞净炯窘揪究纠玖韭久灸九酒厩救旧臼舅咎就疚鞠拘狙疽居驹菊局咀矩举沮聚拒据巨具距踞锯俱句惧炬剧捐鹃娟倦眷卷绢撅攫抉掘倔爵觉决诀绝均菌钧军君峻",
    ],
    ["bf40", "緻", 62],
    [
      "bf80",
      "縺縼",
      4,
      "繂",
      4,
      "繈",
      21,
      "俊竣浚郡骏喀咖卡咯开揩楷凯慨刊堪勘坎砍看康慷糠扛抗亢炕考拷烤靠坷苛柯棵磕颗科壳咳可渴克刻客课肯啃垦恳坑吭空恐孔控抠口扣寇枯哭窟苦酷库裤夸垮挎跨胯块筷侩快宽款匡筐狂框矿眶旷况亏盔岿窥葵奎魁傀",
    ],
    ["c040", "繞", 35, "纃", 23, "纜纝纞"],
    [
      "c080",
      "纮纴纻纼绖绤绬绹缊缐缞缷缹缻",
      6,
      "罃罆",
      9,
      "罒罓馈愧溃坤昆捆困括扩廓阔垃拉喇蜡腊辣啦莱来赖蓝婪栏拦篮阑兰澜谰揽览懒缆烂滥琅榔狼廊郎朗浪捞劳牢老佬姥酪烙涝勒乐雷镭蕾磊累儡垒擂肋类泪棱楞冷厘梨犁黎篱狸离漓理李里鲤礼莉荔吏栗丽厉励砾历利傈例俐",
    ],
    [
      "c140",
      "罖罙罛罜罝罞罠罣",
      4,
      "罫罬罭罯罰罳罵罶罷罸罺罻罼罽罿羀羂",
      7,
      "羋羍羏",
      4,
      "羕",
      4,
      "羛羜羠羢羣羥羦羨",
      6,
      "羱",
    ],
    [
      "c180",
      "羳",
      4,
      "羺羻羾翀翂翃翄翆翇翈翉翋翍翏",
      4,
      "翖翗翙",
      5,
      "翢翣痢立粒沥隶力璃哩俩联莲连镰廉怜涟帘敛脸链恋炼练粮凉梁粱良两辆量晾亮谅撩聊僚疗燎寥辽潦了撂镣廖料列裂烈劣猎琳林磷霖临邻鳞淋凛赁吝拎玲菱零龄铃伶羚凌灵陵岭领另令溜琉榴硫馏留刘瘤流柳六龙聋咙笼窿",
    ],
    [
      "c240",
      "翤翧翨翪翫翬翭翯翲翴",
      6,
      "翽翾翿耂耇耈耉耊耎耏耑耓耚耛耝耞耟耡耣耤耫",
      5,
      "耲耴耹耺耼耾聀聁聄聅聇聈聉聎聏聐聑聓聕聖聗",
    ],
    [
      "c280",
      "聙聛",
      13,
      "聫",
      5,
      "聲",
      11,
      "隆垄拢陇楼娄搂篓漏陋芦卢颅庐炉掳卤虏鲁麓碌露路赂鹿潞禄录陆戮驴吕铝侣旅履屡缕虑氯律率滤绿峦挛孪滦卵乱掠略抡轮伦仑沦纶论萝螺罗逻锣箩骡裸落洛骆络妈麻玛码蚂马骂嘛吗埋买麦卖迈脉瞒馒蛮满蔓曼慢漫",
    ],
    [
      "c340",
      "聾肁肂肅肈肊肍",
      5,
      "肔肕肗肙肞肣肦肧肨肬肰肳肵肶肸肹肻胅胇",
      4,
      "胏",
      6,
      "胘胟胠胢胣胦胮胵胷胹胻胾胿脀脁脃脄脅脇脈脋",
    ],
    [
      "c380",
      "脌脕脗脙脛脜脝脟",
      12,
      "脭脮脰脳脴脵脷脹",
      4,
      "脿谩芒茫盲氓忙莽猫茅锚毛矛铆卯茂冒帽貌贸么玫枚梅酶霉煤没眉媒镁每美昧寐妹媚门闷们萌蒙檬盟锰猛梦孟眯醚靡糜迷谜弥米秘觅泌蜜密幂棉眠绵冕免勉娩缅面苗描瞄藐秒渺庙妙蔑灭民抿皿敏悯闽明螟鸣铭名命谬摸",
    ],
    [
      "c440",
      "腀",
      5,
      "腇腉腍腎腏腒腖腗腘腛",
      4,
      "腡腢腣腤腦腨腪腫腬腯腲腳腵腶腷腸膁膃",
      4,
      "膉膋膌膍膎膐膒",
      5,
      "膙膚膞",
      4,
      "膤膥",
    ],
    [
      "c480",
      "膧膩膫",
      7,
      "膴",
      5,
      "膼膽膾膿臄臅臇臈臉臋臍",
      6,
      "摹蘑模膜磨摩魔抹末莫墨默沫漠寞陌谋牟某拇牡亩姆母墓暮幕募慕木目睦牧穆拿哪呐钠那娜纳氖乃奶耐奈南男难囊挠脑恼闹淖呢馁内嫩能妮霓倪泥尼拟你匿腻逆溺蔫拈年碾撵捻念娘酿鸟尿捏聂孽啮镊镍涅您柠狞凝宁",
    ],
    [
      "c540",
      "臔",
      14,
      "臤臥臦臨臩臫臮",
      4,
      "臵",
      5,
      "臽臿舃與",
      4,
      "舎舏舑舓舕",
      5,
      "舝舠舤舥舦舧舩舮舲舺舼舽舿",
    ],
    [
      "c580",
      "艀艁艂艃艅艆艈艊艌艍艎艐",
      7,
      "艙艛艜艝艞艠",
      7,
      "艩拧泞牛扭钮纽脓浓农弄奴努怒女暖虐疟挪懦糯诺哦欧鸥殴藕呕偶沤啪趴爬帕怕琶拍排牌徘湃派攀潘盘磐盼畔判叛乓庞旁耪胖抛咆刨炮袍跑泡呸胚培裴赔陪配佩沛喷盆砰抨烹澎彭蓬棚硼篷膨朋鹏捧碰坯砒霹批披劈琵毗",
    ],
    [
      "c640",
      "艪艫艬艭艱艵艶艷艸艻艼芀芁芃芅芆芇芉芌芐芓芔芕芖芚芛芞芠芢芣芧芲芵芶芺芻芼芿苀苂苃苅苆苉苐苖苙苚苝苢苧苨苩苪苬苭苮苰苲苳苵苶苸",
    ],
    [
      "c680",
      "苺苼",
      4,
      "茊茋茍茐茒茓茖茘茙茝",
      9,
      "茩茪茮茰茲茷茻茽啤脾疲皮匹痞僻屁譬篇偏片骗飘漂瓢票撇瞥拼频贫品聘乒坪苹萍平凭瓶评屏坡泼颇婆破魄迫粕剖扑铺仆莆葡菩蒲埔朴圃普浦谱曝瀑期欺栖戚妻七凄漆柒沏其棋奇歧畦崎脐齐旗祈祁骑起岂乞企启契砌器气迄弃汽泣讫掐",
    ],
    [
      "c740",
      "茾茿荁荂荄荅荈荊",
      4,
      "荓荕",
      4,
      "荝荢荰",
      6,
      "荹荺荾",
      6,
      "莇莈莊莋莌莍莏莐莑莔莕莖莗莙莚莝莟莡",
      6,
      "莬莭莮",
    ],
    [
      "c780",
      "莯莵莻莾莿菂菃菄菆菈菉菋菍菎菐菑菒菓菕菗菙菚菛菞菢菣菤菦菧菨菫菬菭恰洽牵扦钎铅千迁签仟谦乾黔钱钳前潜遣浅谴堑嵌欠歉枪呛腔羌墙蔷强抢橇锹敲悄桥瞧乔侨巧鞘撬翘峭俏窍切茄且怯窃钦侵亲秦琴勤芹擒禽寝沁青轻氢倾卿清擎晴氰情顷请庆琼穷秋丘邱球求囚酋泅趋区蛆曲躯屈驱渠",
    ],
    [
      "c840",
      "菮華菳",
      4,
      "菺菻菼菾菿萀萂萅萇萈萉萊萐萒",
      5,
      "萙萚萛萞",
      5,
      "萩",
      7,
      "萲",
      5,
      "萹萺萻萾",
      7,
      "葇葈葉",
    ],
    [
      "c880",
      "葊",
      6,
      "葒",
      4,
      "葘葝葞葟葠葢葤",
      4,
      "葪葮葯葰葲葴葷葹葻葼取娶龋趣去圈颧权醛泉全痊拳犬券劝缺炔瘸却鹊榷确雀裙群然燃冉染瓤壤攘嚷让饶扰绕惹热壬仁人忍韧任认刃妊纫扔仍日戎茸蓉荣融熔溶容绒冗揉柔肉茹蠕儒孺如辱乳汝入褥软阮蕊瑞锐闰润若弱撒洒萨腮鳃塞赛三叁",
    ],
    [
      "c940",
      "葽",
      4,
      "蒃蒄蒅蒆蒊蒍蒏",
      7,
      "蒘蒚蒛蒝蒞蒟蒠蒢",
      12,
      "蒰蒱蒳蒵蒶蒷蒻蒼蒾蓀蓂蓃蓅蓆蓇蓈蓋蓌蓎蓏蓒蓔蓕蓗",
    ],
    [
      "c980",
      "蓘",
      4,
      "蓞蓡蓢蓤蓧",
      4,
      "蓭蓮蓯蓱",
      10,
      "蓽蓾蔀蔁蔂伞散桑嗓丧搔骚扫嫂瑟色涩森僧莎砂杀刹沙纱傻啥煞筛晒珊苫杉山删煽衫闪陕擅赡膳善汕扇缮墒伤商赏晌上尚裳梢捎稍烧芍勺韶少哨邵绍奢赊蛇舌舍赦摄射慑涉社设砷申呻伸身深娠绅神沈审婶甚肾慎渗声生甥牲升绳",
    ],
    [
      "ca40",
      "蔃",
      8,
      "蔍蔎蔏蔐蔒蔔蔕蔖蔘蔙蔛蔜蔝蔞蔠蔢",
      8,
      "蔭",
      9,
      "蔾",
      4,
      "蕄蕅蕆蕇蕋",
      10,
    ],
    [
      "ca80",
      "蕗蕘蕚蕛蕜蕝蕟",
      4,
      "蕥蕦蕧蕩",
      8,
      "蕳蕵蕶蕷蕸蕼蕽蕿薀薁省盛剩胜圣师失狮施湿诗尸虱十石拾时什食蚀实识史矢使屎驶始式示士世柿事拭誓逝势是嗜噬适仕侍释饰氏市恃室视试收手首守寿授售受瘦兽蔬枢梳殊抒输叔舒淑疏书赎孰熟薯暑曙署蜀黍鼠属术述树束戍竖墅庶数漱",
    ],
    [
      "cb40",
      "薂薃薆薈",
      6,
      "薐",
      10,
      "薝",
      6,
      "薥薦薧薩薫薬薭薱",
      5,
      "薸薺",
      6,
      "藂",
      6,
      "藊",
      4,
      "藑藒",
    ],
    [
      "cb80",
      "藔藖",
      5,
      "藝",
      6,
      "藥藦藧藨藪",
      14,
      "恕刷耍摔衰甩帅栓拴霜双爽谁水睡税吮瞬顺舜说硕朔烁斯撕嘶思私司丝死肆寺嗣四伺似饲巳松耸怂颂送宋讼诵搜艘擞嗽苏酥俗素速粟僳塑溯宿诉肃酸蒜算虽隋随绥髓碎岁穗遂隧祟孙损笋蓑梭唆缩琐索锁所塌他它她塔",
    ],
    [
      "cc40",
      "藹藺藼藽藾蘀",
      4,
      "蘆",
      10,
      "蘒蘓蘔蘕蘗",
      15,
      "蘨蘪",
      13,
      "蘹蘺蘻蘽蘾蘿虀",
    ],
    [
      "cc80",
      "虁",
      11,
      "虒虓處",
      4,
      "虛虜虝號虠虡虣",
      7,
      "獭挞蹋踏胎苔抬台泰酞太态汰坍摊贪瘫滩坛檀痰潭谭谈坦毯袒碳探叹炭汤塘搪堂棠膛唐糖倘躺淌趟烫掏涛滔绦萄桃逃淘陶讨套特藤腾疼誊梯剔踢锑提题蹄啼体替嚏惕涕剃屉天添填田甜恬舔腆挑条迢眺跳贴铁帖厅听烃",
    ],
    [
      "cd40",
      "虭虯虰虲",
      6,
      "蚃",
      6,
      "蚎",
      4,
      "蚔蚖",
      5,
      "蚞",
      4,
      "蚥蚦蚫蚭蚮蚲蚳蚷蚸蚹蚻",
      4,
      "蛁蛂蛃蛅蛈蛌蛍蛒蛓蛕蛖蛗蛚蛜",
    ],
    [
      "cd80",
      "蛝蛠蛡蛢蛣蛥蛦蛧蛨蛪蛫蛬蛯蛵蛶蛷蛺蛻蛼蛽蛿蜁蜄蜅蜆蜋蜌蜎蜏蜐蜑蜔蜖汀廷停亭庭挺艇通桐酮瞳同铜彤童桶捅筒统痛偷投头透凸秃突图徒途涂屠土吐兔湍团推颓腿蜕褪退吞屯臀拖托脱鸵陀驮驼椭妥拓唾挖哇蛙洼娃瓦袜歪外豌弯湾玩顽丸烷完碗挽晚皖惋宛婉万腕汪王亡枉网往旺望忘妄威",
    ],
    [
      "ce40",
      "蜙蜛蜝蜟蜠蜤蜦蜧蜨蜪蜫蜬蜭蜯蜰蜲蜳蜵蜶蜸蜹蜺蜼蜽蝀",
      6,
      "蝊蝋蝍蝏蝐蝑蝒蝔蝕蝖蝘蝚",
      5,
      "蝡蝢蝦",
      7,
      "蝯蝱蝲蝳蝵",
    ],
    [
      "ce80",
      "蝷蝸蝹蝺蝿螀螁螄螆螇螉螊螌螎",
      4,
      "螔螕螖螘",
      6,
      "螠",
      4,
      "巍微危韦违桅围唯惟为潍维苇萎委伟伪尾纬未蔚味畏胃喂魏位渭谓尉慰卫瘟温蚊文闻纹吻稳紊问嗡翁瓮挝蜗涡窝我斡卧握沃巫呜钨乌污诬屋无芜梧吾吴毋武五捂午舞伍侮坞戊雾晤物勿务悟误昔熙析西硒矽晰嘻吸锡牺",
    ],
    [
      "cf40",
      "螥螦螧螩螪螮螰螱螲螴螶螷螸螹螻螼螾螿蟁",
      4,
      "蟇蟈蟉蟌",
      4,
      "蟔",
      6,
      "蟜蟝蟞蟟蟡蟢蟣蟤蟦蟧蟨蟩蟫蟬蟭蟯",
      9,
    ],
    [
      "cf80",
      "蟺蟻蟼蟽蟿蠀蠁蠂蠄",
      5,
      "蠋",
      7,
      "蠔蠗蠘蠙蠚蠜",
      4,
      "蠣稀息希悉膝夕惜熄烯溪汐犀檄袭席习媳喜铣洗系隙戏细瞎虾匣霞辖暇峡侠狭下厦夏吓掀锨先仙鲜纤咸贤衔舷闲涎弦嫌显险现献县腺馅羡宪陷限线相厢镶香箱襄湘乡翔祥详想响享项巷橡像向象萧硝霄削哮嚣销消宵淆晓",
    ],
    [
      "d040",
      "蠤",
      13,
      "蠳",
      5,
      "蠺蠻蠽蠾蠿衁衂衃衆",
      5,
      "衎",
      5,
      "衕衖衘衚",
      6,
      "衦衧衪衭衯衱衳衴衵衶衸衹衺",
    ],
    [
      "d080",
      "衻衼袀袃袆袇袉袊袌袎袏袐袑袓袔袕袗",
      4,
      "袝",
      4,
      "袣袥",
      5,
      "小孝校肖啸笑效楔些歇蝎鞋协挟携邪斜胁谐写械卸蟹懈泄泻谢屑薪芯锌欣辛新忻心信衅星腥猩惺兴刑型形邢行醒幸杏性姓兄凶胸匈汹雄熊休修羞朽嗅锈秀袖绣墟戌需虚嘘须徐许蓄酗叙旭序畜恤絮婿绪续轩喧宣悬旋玄",
    ],
    [
      "d140",
      "袬袮袯袰袲",
      4,
      "袸袹袺袻袽袾袿裀裃裄裇裈裊裋裌裍裏裐裑裓裖裗裚",
      4,
      "裠裡裦裧裩",
      6,
      "裲裵裶裷裺裻製裿褀褁褃",
      5,
    ],
    [
      "d180",
      "褉褋",
      4,
      "褑褔",
      4,
      "褜",
      4,
      "褢褣褤褦褧褨褩褬褭褮褯褱褲褳褵褷选癣眩绚靴薛学穴雪血勋熏循旬询寻驯巡殉汛训讯逊迅压押鸦鸭呀丫芽牙蚜崖衙涯雅哑亚讶焉咽阉烟淹盐严研蜒岩延言颜阎炎沿奄掩眼衍演艳堰燕厌砚雁唁彦焰宴谚验殃央鸯秧杨扬佯疡羊洋阳氧仰痒养样漾邀腰妖瑶",
    ],
    ["d240", "褸", 8, "襂襃襅", 24, "襠", 5, "襧", 19, "襼"],
    [
      "d280",
      "襽襾覀覂覄覅覇",
      26,
      "摇尧遥窑谣姚咬舀药要耀椰噎耶爷野冶也页掖业叶曳腋夜液一壹医揖铱依伊衣颐夷遗移仪胰疑沂宜姨彝椅蚁倚已乙矣以艺抑易邑屹亿役臆逸肄疫亦裔意毅忆义益溢诣议谊译异翼翌绎茵荫因殷音阴姻吟银淫寅饮尹引隐",
    ],
    [
      "d340",
      "覢",
      30,
      "觃觍觓觔觕觗觘觙觛觝觟觠觡觢觤觧觨觩觪觬觭觮觰觱觲觴",
      6,
    ],
    [
      "d380",
      "觻",
      4,
      "訁",
      5,
      "計",
      21,
      "印英樱婴鹰应缨莹萤营荧蝇迎赢盈影颖硬映哟拥佣臃痈庸雍踊蛹咏泳涌永恿勇用幽优悠忧尤由邮铀犹油游酉有友右佑釉诱又幼迂淤于盂榆虞愚舆余俞逾鱼愉渝渔隅予娱雨与屿禹宇语羽玉域芋郁吁遇喻峪御愈欲狱育誉",
    ],
    ["d440", "訞", 31, "訿", 8, "詉", 21],
    [
      "d480",
      "詟",
      25,
      "詺",
      6,
      "浴寓裕预豫驭鸳渊冤元垣袁原援辕园员圆猿源缘远苑愿怨院曰约越跃钥岳粤月悦阅耘云郧匀陨允运蕴酝晕韵孕匝砸杂栽哉灾宰载再在咱攒暂赞赃脏葬遭糟凿藻枣早澡蚤躁噪造皂灶燥责择则泽贼怎增憎曾赠扎喳渣札轧",
    ],
    ["d540", "誁", 7, "誋", 7, "誔", 46],
    [
      "d580",
      "諃",
      32,
      "铡闸眨栅榨咋乍炸诈摘斋宅窄债寨瞻毡詹粘沾盏斩辗崭展蘸栈占战站湛绽樟章彰漳张掌涨杖丈帐账仗胀瘴障招昭找沼赵照罩兆肇召遮折哲蛰辙者锗蔗这浙珍斟真甄砧臻贞针侦枕疹诊震振镇阵蒸挣睁征狰争怔整拯正政",
    ],
    ["d640", "諤", 34, "謈", 27],
    [
      "d680",
      "謤謥謧",
      30,
      "帧症郑证芝枝支吱蜘知肢脂汁之织职直植殖执值侄址指止趾只旨纸志挚掷至致置帜峙制智秩稚质炙痔滞治窒中盅忠钟衷终种肿重仲众舟周州洲诌粥轴肘帚咒皱宙昼骤珠株蛛朱猪诸诛逐竹烛煮拄瞩嘱主著柱助蛀贮铸筑",
    ],
    ["d740", "譆", 31, "譧", 4, "譭", 25],
    [
      "d780",
      "讇",
      24,
      "讬讱讻诇诐诪谉谞住注祝驻抓爪拽专砖转撰赚篆桩庄装妆撞壮状椎锥追赘坠缀谆准捉拙卓桌琢茁酌啄着灼浊兹咨资姿滋淄孜紫仔籽滓子自渍字鬃棕踪宗综总纵邹走奏揍租足卒族祖诅阻组钻纂嘴醉最罪尊遵昨左佐柞做作坐座",
    ],
    [
      "d840",
      "谸",
      8,
      "豂豃豄豅豈豊豋豍",
      7,
      "豖豗豘豙豛",
      5,
      "豣",
      6,
      "豬",
      6,
      "豴豵豶豷豻",
      6,
      "貃貄貆貇",
    ],
    [
      "d880",
      "貈貋貍",
      6,
      "貕貖貗貙",
      20,
      "亍丌兀丐廿卅丕亘丞鬲孬噩丨禺丿匕乇夭爻卮氐囟胤馗毓睾鼗丶亟鼐乜乩亓芈孛啬嘏仄厍厝厣厥厮靥赝匚叵匦匮匾赜卦卣刂刈刎刭刳刿剀剌剞剡剜蒯剽劂劁劐劓冂罔亻仃仉仂仨仡仫仞伛仳伢佤仵伥伧伉伫佞佧攸佚佝",
    ],
    ["d940", "貮", 62],
    [
      "d980",
      "賭",
      32,
      "佟佗伲伽佶佴侑侉侃侏佾佻侪佼侬侔俦俨俪俅俚俣俜俑俟俸倩偌俳倬倏倮倭俾倜倌倥倨偾偃偕偈偎偬偻傥傧傩傺僖儆僭僬僦僮儇儋仝氽佘佥俎龠汆籴兮巽黉馘冁夔勹匍訇匐凫夙兕亠兖亳衮袤亵脔裒禀嬴蠃羸冫冱冽冼",
    ],
    [
      "da40",
      "贎",
      14,
      "贠赑赒赗赟赥赨赩赪赬赮赯赱赲赸",
      8,
      "趂趃趆趇趈趉趌",
      4,
      "趒趓趕",
      9,
      "趠趡",
    ],
    [
      "da80",
      "趢趤",
      12,
      "趲趶趷趹趻趽跀跁跂跅跇跈跉跊跍跐跒跓跔凇冖冢冥讠讦讧讪讴讵讷诂诃诋诏诎诒诓诔诖诘诙诜诟诠诤诨诩诮诰诳诶诹诼诿谀谂谄谇谌谏谑谒谔谕谖谙谛谘谝谟谠谡谥谧谪谫谮谯谲谳谵谶卩卺阝阢阡阱阪阽阼陂陉陔陟陧陬陲陴隈隍隗隰邗邛邝邙邬邡邴邳邶邺",
    ],
    [
      "db40",
      "跕跘跙跜跠跡跢跥跦跧跩跭跮跰跱跲跴跶跼跾",
      6,
      "踆踇踈踋踍踎踐踑踒踓踕",
      7,
      "踠踡踤",
      4,
      "踫踭踰踲踳踴踶踷踸踻踼踾",
    ],
    [
      "db80",
      "踿蹃蹅蹆蹌",
      4,
      "蹓",
      5,
      "蹚",
      11,
      "蹧蹨蹪蹫蹮蹱邸邰郏郅邾郐郄郇郓郦郢郜郗郛郫郯郾鄄鄢鄞鄣鄱鄯鄹酃酆刍奂劢劬劭劾哿勐勖勰叟燮矍廴凵凼鬯厶弁畚巯坌垩垡塾墼壅壑圩圬圪圳圹圮圯坜圻坂坩垅坫垆坼坻坨坭坶坳垭垤垌垲埏垧垴垓垠埕埘埚埙埒垸埴埯埸埤埝",
    ],
    [
      "dc40",
      "蹳蹵蹷",
      4,
      "蹽蹾躀躂躃躄躆躈",
      6,
      "躑躒躓躕",
      6,
      "躝躟",
      11,
      "躭躮躰躱躳",
      6,
      "躻",
      7,
    ],
    [
      "dc80",
      "軃",
      10,
      "軏",
      21,
      "堋堍埽埭堀堞堙塄堠塥塬墁墉墚墀馨鼙懿艹艽艿芏芊芨芄芎芑芗芙芫芸芾芰苈苊苣芘芷芮苋苌苁芩芴芡芪芟苄苎芤苡茉苷苤茏茇苜苴苒苘茌苻苓茑茚茆茔茕苠苕茜荑荛荜茈莒茼茴茱莛荞茯荏荇荃荟荀茗荠茭茺茳荦荥",
    ],
    ["dd40", "軥", 62],
    [
      "dd80",
      "輤",
      32,
      "荨茛荩荬荪荭荮莰荸莳莴莠莪莓莜莅荼莶莩荽莸荻莘莞莨莺莼菁萁菥菘堇萘萋菝菽菖萜萸萑萆菔菟萏萃菸菹菪菅菀萦菰菡葜葑葚葙葳蒇蒈葺蒉葸萼葆葩葶蒌蒎萱葭蓁蓍蓐蓦蒽蓓蓊蒿蒺蓠蒡蒹蒴蒗蓥蓣蔌甍蔸蓰蔹蔟蔺",
    ],
    [
      "de40",
      "轅",
      32,
      "轪辀辌辒辝辠辡辢辤辥辦辧辪辬辭辮辯農辳辴辵辷辸辺辻込辿迀迃迆",
    ],
    [
      "de80",
      "迉",
      4,
      "迏迒迖迗迚迠迡迣迧迬迯迱迲迴迵迶迺迻迼迾迿逇逈逌逎逓逕逘蕖蔻蓿蓼蕙蕈蕨蕤蕞蕺瞢蕃蕲蕻薤薨薇薏蕹薮薜薅薹薷薰藓藁藜藿蘧蘅蘩蘖蘼廾弈夼奁耷奕奚奘匏尢尥尬尴扌扪抟抻拊拚拗拮挢拶挹捋捃掭揶捱捺掎掴捭掬掊捩掮掼揲揸揠揿揄揞揎摒揆掾摅摁搋搛搠搌搦搡摞撄摭撖",
    ],
    [
      "df40",
      "這逜連逤逥逧",
      5,
      "逰",
      4,
      "逷逹逺逽逿遀遃遅遆遈",
      4,
      "過達違遖遙遚遜",
      5,
      "遤遦遧適遪遫遬遯",
      4,
      "遶",
      6,
      "遾邁",
    ],
    [
      "df80",
      "還邅邆邇邉邊邌",
      4,
      "邒邔邖邘邚邜邞邟邠邤邥邧邨邩邫邭邲邷邼邽邿郀摺撷撸撙撺擀擐擗擤擢攉攥攮弋忒甙弑卟叱叽叩叨叻吒吖吆呋呒呓呔呖呃吡呗呙吣吲咂咔呷呱呤咚咛咄呶呦咝哐咭哂咴哒咧咦哓哔呲咣哕咻咿哌哙哚哜咩咪咤哝哏哞唛哧唠哽唔哳唢唣唏唑唧唪啧喏喵啉啭啁啕唿啐唼",
    ],
    [
      "e040",
      "郂郃郆郈郉郋郌郍郒郔郕郖郘郙郚郞郟郠郣郤郥郩郪郬郮郰郱郲郳郵郶郷郹郺郻郼郿鄀鄁鄃鄅",
      19,
      "鄚鄛鄜",
    ],
    [
      "e080",
      "鄝鄟鄠鄡鄤",
      10,
      "鄰鄲",
      6,
      "鄺",
      8,
      "酄唷啖啵啶啷唳唰啜喋嗒喃喱喹喈喁喟啾嗖喑啻嗟喽喾喔喙嗪嗷嗉嘟嗑嗫嗬嗔嗦嗝嗄嗯嗥嗲嗳嗌嗍嗨嗵嗤辔嘞嘈嘌嘁嘤嘣嗾嘀嘧嘭噘嘹噗嘬噍噢噙噜噌噔嚆噤噱噫噻噼嚅嚓嚯囔囗囝囡囵囫囹囿圄圊圉圜帏帙帔帑帱帻帼",
    ],
    [
      "e140",
      "酅酇酈酑酓酔酕酖酘酙酛酜酟酠酦酧酨酫酭酳酺酻酼醀",
      4,
      "醆醈醊醎醏醓",
      6,
      "醜",
      5,
      "醤",
      5,
      "醫醬醰醱醲醳醶醷醸醹醻",
    ],
    [
      "e180",
      "醼",
      10,
      "釈釋釐釒",
      9,
      "針",
      8,
      "帷幄幔幛幞幡岌屺岍岐岖岈岘岙岑岚岜岵岢岽岬岫岱岣峁岷峄峒峤峋峥崂崃崧崦崮崤崞崆崛嵘崾崴崽嵬嵛嵯嵝嵫嵋嵊嵩嵴嶂嶙嶝豳嶷巅彳彷徂徇徉後徕徙徜徨徭徵徼衢彡犭犰犴犷犸狃狁狎狍狒狨狯狩狲狴狷猁狳猃狺",
    ],
    ["e240", "釦", 62],
    [
      "e280",
      "鈥",
      32,
      "狻猗猓猡猊猞猝猕猢猹猥猬猸猱獐獍獗獠獬獯獾舛夥飧夤夂饣饧",
      5,
      "饴饷饽馀馄馇馊馍馐馑馓馔馕庀庑庋庖庥庠庹庵庾庳赓廒廑廛廨廪膺忄忉忖忏怃忮怄忡忤忾怅怆忪忭忸怙怵怦怛怏怍怩怫怊怿怡恸恹恻恺恂",
    ],
    ["e340", "鉆", 45, "鉵", 16],
    [
      "e380",
      "銆",
      7,
      "銏",
      24,
      "恪恽悖悚悭悝悃悒悌悛惬悻悱惝惘惆惚悴愠愦愕愣惴愀愎愫慊慵憬憔憧憷懔懵忝隳闩闫闱闳闵闶闼闾阃阄阆阈阊阋阌阍阏阒阕阖阗阙阚丬爿戕氵汔汜汊沣沅沐沔沌汨汩汴汶沆沩泐泔沭泷泸泱泗沲泠泖泺泫泮沱泓泯泾",
    ],
    ["e440", "銨", 5, "銯", 24, "鋉", 31],
    [
      "e480",
      "鋩",
      32,
      "洹洧洌浃浈洇洄洙洎洫浍洮洵洚浏浒浔洳涑浯涞涠浞涓涔浜浠浼浣渚淇淅淞渎涿淠渑淦淝淙渖涫渌涮渫湮湎湫溲湟溆湓湔渲渥湄滟溱溘滠漭滢溥溧溽溻溷滗溴滏溏滂溟潢潆潇漤漕滹漯漶潋潴漪漉漩澉澍澌潸潲潼潺濑",
    ],
    ["e540", "錊", 51, "錿", 10],
    [
      "e580",
      "鍊",
      31,
      "鍫濉澧澹澶濂濡濮濞濠濯瀚瀣瀛瀹瀵灏灞宀宄宕宓宥宸甯骞搴寤寮褰寰蹇謇辶迓迕迥迮迤迩迦迳迨逅逄逋逦逑逍逖逡逵逶逭逯遄遑遒遐遨遘遢遛暹遴遽邂邈邃邋彐彗彖彘尻咫屐屙孱屣屦羼弪弩弭艴弼鬻屮妁妃妍妩妪妣",
    ],
    ["e640", "鍬", 34, "鎐", 27],
    [
      "e680",
      "鎬",
      29,
      "鏋鏌鏍妗姊妫妞妤姒妲妯姗妾娅娆姝娈姣姘姹娌娉娲娴娑娣娓婀婧婊婕娼婢婵胬媪媛婷婺媾嫫媲嫒嫔媸嫠嫣嫱嫖嫦嫘嫜嬉嬗嬖嬲嬷孀尕尜孚孥孳孑孓孢驵驷驸驺驿驽骀骁骅骈骊骐骒骓骖骘骛骜骝骟骠骢骣骥骧纟纡纣纥纨纩",
    ],
    ["e740", "鏎", 7, "鏗", 54],
    [
      "e780",
      "鐎",
      32,
      "纭纰纾绀绁绂绉绋绌绐绔绗绛绠绡绨绫绮绯绱绲缍绶绺绻绾缁缂缃缇缈缋缌缏缑缒缗缙缜缛缟缡",
      6,
      "缪缫缬缭缯",
      4,
      "缵幺畿巛甾邕玎玑玮玢玟珏珂珑玷玳珀珉珈珥珙顼琊珩珧珞玺珲琏琪瑛琦琥琨琰琮琬",
    ],
    ["e840", "鐯", 14, "鐿", 43, "鑬鑭鑮鑯"],
    [
      "e880",
      "鑰",
      20,
      "钑钖钘铇铏铓铔铚铦铻锜锠琛琚瑁瑜瑗瑕瑙瑷瑭瑾璜璎璀璁璇璋璞璨璩璐璧瓒璺韪韫韬杌杓杞杈杩枥枇杪杳枘枧杵枨枞枭枋杷杼柰栉柘栊柩枰栌柙枵柚枳柝栀柃枸柢栎柁柽栲栳桠桡桎桢桄桤梃栝桕桦桁桧桀栾桊桉栩梵梏桴桷梓桫棂楮棼椟椠棹",
    ],
    ["e940", "锧锳锽镃镈镋镕镚镠镮镴镵長", 7, "門", 42],
    [
      "e980",
      "閫",
      32,
      "椤棰椋椁楗棣椐楱椹楠楂楝榄楫榀榘楸椴槌榇榈槎榉楦楣楹榛榧榻榫榭槔榱槁槊槟榕槠榍槿樯槭樗樘橥槲橄樾檠橐橛樵檎橹樽樨橘橼檑檐檩檗檫猷獒殁殂殇殄殒殓殍殚殛殡殪轫轭轱轲轳轵轶轸轷轹轺轼轾辁辂辄辇辋",
    ],
    [
      "ea40",
      "闌",
      27,
      "闬闿阇阓阘阛阞阠阣",
      6,
      "阫阬阭阯阰阷阸阹阺阾陁陃陊陎陏陑陒陓陖陗",
    ],
    [
      "ea80",
      "陘陙陚陜陝陞陠陣陥陦陫陭",
      4,
      "陳陸",
      12,
      "隇隉隊辍辎辏辘辚軎戋戗戛戟戢戡戥戤戬臧瓯瓴瓿甏甑甓攴旮旯旰昊昙杲昃昕昀炅曷昝昴昱昶昵耆晟晔晁晏晖晡晗晷暄暌暧暝暾曛曜曦曩贲贳贶贻贽赀赅赆赈赉赇赍赕赙觇觊觋觌觎觏觐觑牮犟牝牦牯牾牿犄犋犍犏犒挈挲掰",
    ],
    [
      "eb40",
      "隌階隑隒隓隕隖隚際隝",
      9,
      "隨",
      7,
      "隱隲隴隵隷隸隺隻隿雂雃雈雊雋雐雑雓雔雖",
      9,
      "雡",
      6,
      "雫",
    ],
    [
      "eb80",
      "雬雭雮雰雱雲雴雵雸雺電雼雽雿霂霃霅霊霋霌霐霑霒霔霕霗",
      4,
      "霝霟霠搿擘耄毪毳毽毵毹氅氇氆氍氕氘氙氚氡氩氤氪氲攵敕敫牍牒牖爰虢刖肟肜肓肼朊肽肱肫肭肴肷胧胨胩胪胛胂胄胙胍胗朐胝胫胱胴胭脍脎胲胼朕脒豚脶脞脬脘脲腈腌腓腴腙腚腱腠腩腼腽腭腧塍媵膈膂膑滕膣膪臌朦臊膻",
    ],
    [
      "ec40",
      "霡",
      8,
      "霫霬霮霯霱霳",
      4,
      "霺霻霼霽霿",
      18,
      "靔靕靗靘靚靜靝靟靣靤靦靧靨靪",
      7,
    ],
    [
      "ec80",
      "靲靵靷",
      4,
      "靽",
      7,
      "鞆",
      4,
      "鞌鞎鞏鞐鞓鞕鞖鞗鞙",
      4,
      "臁膦欤欷欹歃歆歙飑飒飓飕飙飚殳彀毂觳斐齑斓於旆旄旃旌旎旒旖炀炜炖炝炻烀炷炫炱烨烊焐焓焖焯焱煳煜煨煅煲煊煸煺熘熳熵熨熠燠燔燧燹爝爨灬焘煦熹戾戽扃扈扉礻祀祆祉祛祜祓祚祢祗祠祯祧祺禅禊禚禧禳忑忐",
    ],
    ["ed40", "鞞鞟鞡鞢鞤", 6, "鞬鞮鞰鞱鞳鞵", 46],
    [
      "ed80",
      "韤韥韨韮",
      4,
      "韴韷",
      23,
      "怼恝恚恧恁恙恣悫愆愍慝憩憝懋懑戆肀聿沓泶淼矶矸砀砉砗砘砑斫砭砜砝砹砺砻砟砼砥砬砣砩硎硭硖硗砦硐硇硌硪碛碓碚碇碜碡碣碲碹碥磔磙磉磬磲礅磴礓礤礞礴龛黹黻黼盱眄眍盹眇眈眚眢眙眭眦眵眸睐睑睇睃睚睨",
    ],
    ["ee40", "頏", 62],
    [
      "ee80",
      "顎",
      32,
      "睢睥睿瞍睽瞀瞌瞑瞟瞠瞰瞵瞽町畀畎畋畈畛畲畹疃罘罡罟詈罨罴罱罹羁罾盍盥蠲钅钆钇钋钊钌钍钏钐钔钗钕钚钛钜钣钤钫钪钭钬钯钰钲钴钶",
      4,
      "钼钽钿铄铈",
      6,
      "铐铑铒铕铖铗铙铘铛铞铟铠铢铤铥铧铨铪",
    ],
    ["ef40", "顯", 5, "颋颎颒颕颙颣風", 37, "飏飐飔飖飗飛飜飝飠", 4],
    [
      "ef80",
      "飥飦飩",
      30,
      "铩铫铮铯铳铴铵铷铹铼铽铿锃锂锆锇锉锊锍锎锏锒",
      4,
      "锘锛锝锞锟锢锪锫锩锬锱锲锴锶锷锸锼锾锿镂锵镄镅镆镉镌镎镏镒镓镔镖镗镘镙镛镞镟镝镡镢镤",
      8,
      "镯镱镲镳锺矧矬雉秕秭秣秫稆嵇稃稂稞稔",
    ],
    ["f040", "餈", 4, "餎餏餑", 28, "餯", 26],
    [
      "f080",
      "饊",
      9,
      "饖",
      12,
      "饤饦饳饸饹饻饾馂馃馉稹稷穑黏馥穰皈皎皓皙皤瓞瓠甬鸠鸢鸨",
      4,
      "鸲鸱鸶鸸鸷鸹鸺鸾鹁鹂鹄鹆鹇鹈鹉鹋鹌鹎鹑鹕鹗鹚鹛鹜鹞鹣鹦",
      6,
      "鹱鹭鹳疒疔疖疠疝疬疣疳疴疸痄疱疰痃痂痖痍痣痨痦痤痫痧瘃痱痼痿瘐瘀瘅瘌瘗瘊瘥瘘瘕瘙",
    ],
    ["f140", "馌馎馚", 10, "馦馧馩", 47],
    [
      "f180",
      "駙",
      32,
      "瘛瘼瘢瘠癀瘭瘰瘿瘵癃瘾瘳癍癞癔癜癖癫癯翊竦穸穹窀窆窈窕窦窠窬窨窭窳衤衩衲衽衿袂袢裆袷袼裉裢裎裣裥裱褚裼裨裾裰褡褙褓褛褊褴褫褶襁襦襻疋胥皲皴矜耒耔耖耜耠耢耥耦耧耩耨耱耋耵聃聆聍聒聩聱覃顸颀颃",
    ],
    ["f240", "駺", 62],
    [
      "f280",
      "騹",
      32,
      "颉颌颍颏颔颚颛颞颟颡颢颥颦虍虔虬虮虿虺虼虻蚨蚍蚋蚬蚝蚧蚣蚪蚓蚩蚶蛄蚵蛎蚰蚺蚱蚯蛉蛏蚴蛩蛱蛲蛭蛳蛐蜓蛞蛴蛟蛘蛑蜃蜇蛸蜈蜊蜍蜉蜣蜻蜞蜥蜮蜚蜾蝈蜴蜱蜩蜷蜿螂蜢蝽蝾蝻蝠蝰蝌蝮螋蝓蝣蝼蝤蝙蝥螓螯螨蟒",
    ],
    [
      "f340",
      "驚",
      17,
      "驲骃骉骍骎骔骕骙骦骩",
      6,
      "骲骳骴骵骹骻骽骾骿髃髄髆",
      4,
      "髍髎髏髐髒體髕髖髗髙髚髛髜",
    ],
    [
      "f380",
      "髝髞髠髢髣髤髥髧髨髩髪髬髮髰",
      8,
      "髺髼",
      6,
      "鬄鬅鬆蟆螈螅螭螗螃螫蟥螬螵螳蟋蟓螽蟑蟀蟊蟛蟪蟠蟮蠖蠓蟾蠊蠛蠡蠹蠼缶罂罄罅舐竺竽笈笃笄笕笊笫笏筇笸笪笙笮笱笠笥笤笳笾笞筘筚筅筵筌筝筠筮筻筢筲筱箐箦箧箸箬箝箨箅箪箜箢箫箴篑篁篌篝篚篥篦篪簌篾篼簏簖簋",
    ],
    [
      "f440",
      "鬇鬉",
      5,
      "鬐鬑鬒鬔",
      10,
      "鬠鬡鬢鬤",
      10,
      "鬰鬱鬳",
      7,
      "鬽鬾鬿魀魆魊魋魌魎魐魒魓魕",
      5,
    ],
    [
      "f480",
      "魛",
      32,
      "簟簪簦簸籁籀臾舁舂舄臬衄舡舢舣舭舯舨舫舸舻舳舴舾艄艉艋艏艚艟艨衾袅袈裘裟襞羝羟羧羯羰羲籼敉粑粝粜粞粢粲粼粽糁糇糌糍糈糅糗糨艮暨羿翎翕翥翡翦翩翮翳糸絷綦綮繇纛麸麴赳趄趔趑趱赧赭豇豉酊酐酎酏酤",
    ],
    ["f540", "魼", 62],
    [
      "f580",
      "鮻",
      32,
      "酢酡酰酩酯酽酾酲酴酹醌醅醐醍醑醢醣醪醭醮醯醵醴醺豕鹾趸跫踅蹙蹩趵趿趼趺跄跖跗跚跞跎跏跛跆跬跷跸跣跹跻跤踉跽踔踝踟踬踮踣踯踺蹀踹踵踽踱蹉蹁蹂蹑蹒蹊蹰蹶蹼蹯蹴躅躏躔躐躜躞豸貂貊貅貘貔斛觖觞觚觜",
    ],
    ["f640", "鯜", 62],
    [
      "f680",
      "鰛",
      32,
      "觥觫觯訾謦靓雩雳雯霆霁霈霏霎霪霭霰霾龀龃龅",
      5,
      "龌黾鼋鼍隹隼隽雎雒瞿雠銎銮鋈錾鍪鏊鎏鐾鑫鱿鲂鲅鲆鲇鲈稣鲋鲎鲐鲑鲒鲔鲕鲚鲛鲞",
      5,
      "鲥",
      4,
      "鲫鲭鲮鲰",
      7,
      "鲺鲻鲼鲽鳄鳅鳆鳇鳊鳋",
    ],
    ["f740", "鰼", 62],
    [
      "f780",
      "鱻鱽鱾鲀鲃鲄鲉鲊鲌鲏鲓鲖鲗鲘鲙鲝鲪鲬鲯鲹鲾",
      4,
      "鳈鳉鳑鳒鳚鳛鳠鳡鳌",
      4,
      "鳓鳔鳕鳗鳘鳙鳜鳝鳟鳢靼鞅鞑鞒鞔鞯鞫鞣鞲鞴骱骰骷鹘骶骺骼髁髀髅髂髋髌髑魅魃魇魉魈魍魑飨餍餮饕饔髟髡髦髯髫髻髭髹鬈鬏鬓鬟鬣麽麾縻麂麇麈麋麒鏖麝麟黛黜黝黠黟黢黩黧黥黪黯鼢鼬鼯鼹鼷鼽鼾齄",
    ],
    ["f840", "鳣", 62],
    ["f880", "鴢", 32],
    ["f940", "鵃", 62],
    ["f980", "鶂", 32],
    ["fa40", "鶣", 62],
    ["fa80", "鷢", 32],
    [
      "fb40",
      "鸃",
      27,
      "鸤鸧鸮鸰鸴鸻鸼鹀鹍鹐鹒鹓鹔鹖鹙鹝鹟鹠鹡鹢鹥鹮鹯鹲鹴",
      9,
      "麀",
    ],
    ["fb80", "麁麃麄麅麆麉麊麌", 5, "麔", 8, "麞麠", 5, "麧麨麩麪"],
    [
      "fc40",
      "麫",
      8,
      "麵麶麷麹麺麼麿",
      4,
      "黅黆黇黈黊黋黌黐黒黓黕黖黗黙黚點黡黣黤黦黨黫黬黭黮黰",
      8,
      "黺黽黿",
      6,
    ],
    ["fc80", "鼆", 4, "鼌鼏鼑鼒鼔鼕鼖鼘鼚", 5, "鼡鼣", 8, "鼭鼮鼰鼱"],
    ["fd40", "鼲", 4, "鼸鼺鼼鼿", 4, "齅", 10, "齒", 38],
    ["fd80", "齹", 5, "龁龂龍", 11, "龜龝龞龡", 4, "郎凉秊裏隣"],
    ["fe40", "兀嗀﨎﨏﨑﨓﨔礼﨟蘒﨡﨣﨤﨧﨨﨩"],
  ],
  j1 = [
    ["a140", "", 62],
    ["a180", "", 32],
    ["a240", "", 62],
    ["a280", "", 32],
    ["a2ab", "", 5],
    ["a2e3", "€"],
    ["a2ef", ""],
    ["a2fd", ""],
    ["a340", "", 62],
    ["a380", "", 31, "　"],
    ["a440", "", 62],
    ["a480", "", 32],
    ["a4f4", "", 10],
    ["a540", "", 62],
    ["a580", "", 32],
    ["a5f7", "", 7],
    ["a640", "", 62],
    ["a680", "", 32],
    ["a6b9", "", 7],
    ["a6d9", "", 6],
    ["a6ec", ""],
    ["a6f3", ""],
    ["a6f6", "", 8],
    ["a740", "", 62],
    ["a780", "", 32],
    ["a7c2", "", 14],
    ["a7f2", "", 12],
    ["a896", "", 10],
    ["a8bc", ""],
    ["a8bf", "ǹ"],
    ["a8c1", ""],
    ["a8ea", "", 20],
    ["a958", ""],
    ["a95b", ""],
    ["a95d", ""],
    ["a989", "〾⿰", 11],
    ["a997", "", 12],
    ["a9f0", "", 14],
    ["aaa1", "", 93],
    ["aba1", "", 93],
    ["aca1", "", 93],
    ["ada1", "", 93],
    ["aea1", "", 93],
    ["afa1", "", 93],
    ["d7fa", "", 4],
    ["f8a1", "", 93],
    ["f9a1", "", 93],
    ["faa1", "", 93],
    ["fba1", "", 93],
    ["fca1", "", 93],
    ["fda1", "", 93],
    [
      "fe50",
      "⺁⺄㑳㑇⺈⺋㖞㘚㘎⺌⺗㥮㤘㧏㧟㩳㧐㭎㱮㳠⺧⺪䁖䅟⺮䌷⺳⺶⺷䎱䎬⺻䏝䓖䙡䙌",
    ],
    ["fe80", "䜣䜩䝼䞍⻊䥇䥺䥽䦂䦃䦅䦆䦟䦛䦷䦶䲣䲟䲠䲡䱷䲢䴓", 6, "䶮", 93],
  ],
  $N = [
    128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276,
    284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506,
    594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215,
    8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471,
    8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740,
    8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854,
    8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652,
    9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913,
    11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292,
    12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850,
    12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727,
    13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471,
    16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301,
    18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620,
    19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437,
    59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016,
    64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127,
    65132, 65375, 65510, 65536,
  ],
  CN = [
    0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148,
    172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443,
    544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927,
    7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236,
    8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394,
    8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496,
    8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108,
    9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346,
    11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692,
    11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336,
    12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973,
    13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318,
    16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859,
    17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962,
    19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513,
    33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066,
    38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265,
    39394, 189e3,
  ],
  RN = { uChars: $N, gbChars: CN },
  kN = [
    ["0", "\0", 127],
    ["8141", "갂갃갅갆갋", 4, "갘갞갟갡갢갣갥", 6, "갮갲갳갴"],
    ["8161", "갵갶갷갺갻갽갾갿걁", 9, "걌걎", 5, "걕"],
    [
      "8181",
      "걖걗걙걚걛걝",
      18,
      "걲걳걵걶걹걻",
      4,
      "겂겇겈겍겎겏겑겒겓겕",
      6,
      "겞겢",
      5,
      "겫겭겮겱",
      6,
      "겺겾겿곀곂곃곅곆곇곉곊곋곍",
      7,
      "곖곘",
      7,
      "곢곣곥곦곩곫곭곮곲곴곷",
      4,
      "곾곿괁괂괃괅괇",
      4,
      "괎괐괒괓",
    ],
    ["8241", "괔괕괖괗괙괚괛괝괞괟괡", 7, "괪괫괮", 5],
    ["8261", "괶괷괹괺괻괽", 6, "굆굈굊", 5, "굑굒굓굕굖굗"],
    [
      "8281",
      "굙",
      7,
      "굢굤",
      7,
      "굮굯굱굲굷굸굹굺굾궀궃",
      4,
      "궊궋궍궎궏궑",
      10,
      "궞",
      5,
      "궥",
      17,
      "궸",
      7,
      "귂귃귅귆귇귉",
      6,
      "귒귔",
      7,
      "귝귞귟귡귢귣귥",
      18,
    ],
    ["8341", "귺귻귽귾긂", 5, "긊긌긎", 5, "긕", 7],
    ["8361", "긝", 18, "긲긳긵긶긹긻긼"],
    [
      "8381",
      "긽긾긿깂깄깇깈깉깋깏깑깒깓깕깗",
      4,
      "깞깢깣깤깦깧깪깫깭깮깯깱",
      6,
      "깺깾",
      5,
      "꺆",
      5,
      "꺍",
      46,
      "꺿껁껂껃껅",
      6,
      "껎껒",
      5,
      "껚껛껝",
      8,
    ],
    ["8441", "껦껧껩껪껬껮", 5, "껵껶껷껹껺껻껽", 8],
    ["8461", "꼆꼉꼊꼋꼌꼎꼏꼑", 18],
    [
      "8481",
      "꼤",
      7,
      "꼮꼯꼱꼳꼵",
      6,
      "꼾꽀꽄꽅꽆꽇꽊",
      5,
      "꽑",
      10,
      "꽞",
      5,
      "꽦",
      18,
      "꽺",
      5,
      "꾁꾂꾃꾅꾆꾇꾉",
      6,
      "꾒꾓꾔꾖",
      5,
      "꾝",
      26,
      "꾺꾻꾽꾾",
    ],
    ["8541", "꾿꿁", 5, "꿊꿌꿏", 4, "꿕", 6, "꿝", 4],
    ["8561", "꿢", 5, "꿪", 5, "꿲꿳꿵꿶꿷꿹", 6, "뀂뀃"],
    [
      "8581",
      "뀅",
      6,
      "뀍뀎뀏뀑뀒뀓뀕",
      6,
      "뀞",
      9,
      "뀩",
      26,
      "끆끇끉끋끍끏끐끑끒끖끘끚끛끜끞",
      29,
      "끾끿낁낂낃낅",
      6,
      "낎낐낒",
      5,
      "낛낝낞낣낤",
    ],
    ["8641", "낥낦낧낪낰낲낶낷낹낺낻낽", 6, "냆냊", 5, "냒"],
    ["8661", "냓냕냖냗냙", 6, "냡냢냣냤냦", 10],
    [
      "8681",
      "냱",
      22,
      "넊넍넎넏넑넔넕넖넗넚넞",
      4,
      "넦넧넩넪넫넭",
      6,
      "넶넺",
      5,
      "녂녃녅녆녇녉",
      6,
      "녒녓녖녗녙녚녛녝녞녟녡",
      22,
      "녺녻녽녾녿놁놃",
      4,
      "놊놌놎놏놐놑놕놖놗놙놚놛놝",
    ],
    ["8741", "놞", 9, "놩", 15],
    ["8761", "놹", 18, "뇍뇎뇏뇑뇒뇓뇕"],
    [
      "8781",
      "뇖",
      5,
      "뇞뇠",
      7,
      "뇪뇫뇭뇮뇯뇱",
      7,
      "뇺뇼뇾",
      5,
      "눆눇눉눊눍",
      6,
      "눖눘눚",
      5,
      "눡",
      18,
      "눵",
      6,
      "눽",
      26,
      "뉙뉚뉛뉝뉞뉟뉡",
      6,
      "뉪",
      4,
    ],
    ["8841", "뉯", 4, "뉶", 5, "뉽", 6, "늆늇늈늊", 4],
    ["8861", "늏늒늓늕늖늗늛", 4, "늢늤늧늨늩늫늭늮늯늱늲늳늵늶늷"],
    [
      "8881",
      "늸",
      15,
      "닊닋닍닎닏닑닓",
      4,
      "닚닜닞닟닠닡닣닧닩닪닰닱닲닶닼닽닾댂댃댅댆댇댉",
      6,
      "댒댖",
      5,
      "댝",
      54,
      "덗덙덚덝덠덡덢덣",
    ],
    ["8941", "덦덨덪덬덭덯덲덳덵덶덷덹", 6, "뎂뎆", 5, "뎍"],
    ["8961", "뎎뎏뎑뎒뎓뎕", 10, "뎢", 5, "뎩뎪뎫뎭"],
    [
      "8981",
      "뎮",
      21,
      "돆돇돉돊돍돏돑돒돓돖돘돚돜돞돟돡돢돣돥돦돧돩",
      18,
      "돽",
      18,
      "됑",
      6,
      "됙됚됛됝됞됟됡",
      6,
      "됪됬",
      7,
      "됵",
      15,
    ],
    ["8a41", "둅", 10, "둒둓둕둖둗둙", 6, "둢둤둦"],
    ["8a61", "둧", 4, "둭", 18, "뒁뒂"],
    [
      "8a81",
      "뒃",
      4,
      "뒉",
      19,
      "뒞",
      5,
      "뒥뒦뒧뒩뒪뒫뒭",
      7,
      "뒶뒸뒺",
      5,
      "듁듂듃듅듆듇듉",
      6,
      "듑듒듓듔듖",
      5,
      "듞듟듡듢듥듧",
      4,
      "듮듰듲",
      5,
      "듹",
      26,
      "딖딗딙딚딝",
    ],
    ["8b41", "딞", 5, "딦딫", 4, "딲딳딵딶딷딹", 6, "땂땆"],
    ["8b61", "땇땈땉땊땎땏땑땒땓땕", 6, "땞땢", 8],
    [
      "8b81",
      "땫",
      52,
      "떢떣떥떦떧떩떬떭떮떯떲떶",
      4,
      "떾떿뗁뗂뗃뗅",
      6,
      "뗎뗒",
      5,
      "뗙",
      18,
      "뗭",
      18,
    ],
    ["8c41", "똀", 15, "똒똓똕똖똗똙", 4],
    ["8c61", "똞", 6, "똦", 5, "똭", 6, "똵", 5],
    [
      "8c81",
      "똻",
      12,
      "뙉",
      26,
      "뙥뙦뙧뙩",
      50,
      "뚞뚟뚡뚢뚣뚥",
      5,
      "뚭뚮뚯뚰뚲",
      16,
    ],
    ["8d41", "뛃", 16, "뛕", 8],
    ["8d61", "뛞", 17, "뛱뛲뛳뛵뛶뛷뛹뛺"],
    [
      "8d81",
      "뛻",
      4,
      "뜂뜃뜄뜆",
      33,
      "뜪뜫뜭뜮뜱",
      6,
      "뜺뜼",
      7,
      "띅띆띇띉띊띋띍",
      6,
      "띖",
      9,
      "띡띢띣띥띦띧띩",
      6,
      "띲띴띶",
      5,
      "띾띿랁랂랃랅",
      6,
      "랎랓랔랕랚랛랝랞",
    ],
    ["8e41", "랟랡", 6, "랪랮", 5, "랶랷랹", 8],
    ["8e61", "럂", 4, "럈럊", 19],
    [
      "8e81",
      "럞",
      13,
      "럮럯럱럲럳럵",
      6,
      "럾렂",
      4,
      "렊렋렍렎렏렑",
      6,
      "렚렜렞",
      5,
      "렦렧렩렪렫렭",
      6,
      "렶렺",
      5,
      "롁롂롃롅",
      11,
      "롒롔",
      7,
      "롞롟롡롢롣롥",
      6,
      "롮롰롲",
      5,
      "롹롺롻롽",
      7,
    ],
    ["8f41", "뢅", 7, "뢎", 17],
    ["8f61", "뢠", 7, "뢩", 6, "뢱뢲뢳뢵뢶뢷뢹", 4],
    [
      "8f81",
      "뢾뢿룂룄룆",
      5,
      "룍룎룏룑룒룓룕",
      7,
      "룞룠룢",
      5,
      "룪룫룭룮룯룱",
      6,
      "룺룼룾",
      5,
      "뤅",
      18,
      "뤙",
      6,
      "뤡",
      26,
      "뤾뤿륁륂륃륅",
      6,
      "륍륎륐륒",
      5,
    ],
    ["9041", "륚륛륝륞륟륡", 6, "륪륬륮", 5, "륶륷륹륺륻륽"],
    ["9061", "륾", 5, "릆릈릋릌릏", 15],
    [
      "9081",
      "릟",
      12,
      "릮릯릱릲릳릵",
      6,
      "릾맀맂",
      5,
      "맊맋맍맓",
      4,
      "맚맜맟맠맢맦맧맩맪맫맭",
      6,
      "맶맻",
      4,
      "먂",
      5,
      "먉",
      11,
      "먖",
      33,
      "먺먻먽먾먿멁멃멄멅멆",
    ],
    ["9141", "멇멊멌멏멐멑멒멖멗멙멚멛멝", 6, "멦멪", 5],
    ["9161", "멲멳멵멶멷멹", 9, "몆몈몉몊몋몍", 5],
    [
      "9181",
      "몓",
      20,
      "몪몭몮몯몱몳",
      4,
      "몺몼몾",
      5,
      "뫅뫆뫇뫉",
      14,
      "뫚",
      33,
      "뫽뫾뫿묁묂묃묅",
      7,
      "묎묐묒",
      5,
      "묙묚묛묝묞묟묡",
      6,
    ],
    ["9241", "묨묪묬", 7, "묷묹묺묿", 4, "뭆뭈뭊뭋뭌뭎뭑뭒"],
    ["9261", "뭓뭕뭖뭗뭙", 7, "뭢뭤", 7, "뭭", 4],
    [
      "9281",
      "뭲",
      21,
      "뮉뮊뮋뮍뮎뮏뮑",
      18,
      "뮥뮦뮧뮩뮪뮫뮭",
      6,
      "뮵뮶뮸",
      7,
      "믁믂믃믅믆믇믉",
      6,
      "믑믒믔",
      35,
      "믺믻믽믾밁",
    ],
    ["9341", "밃", 4, "밊밎밐밒밓밙밚밠밡밢밣밦밨밪밫밬밮밯밲밳밵"],
    ["9361", "밶밷밹", 6, "뱂뱆뱇뱈뱊뱋뱎뱏뱑", 8],
    [
      "9381",
      "뱚뱛뱜뱞",
      37,
      "벆벇벉벊벍벏",
      4,
      "벖벘벛",
      4,
      "벢벣벥벦벩",
      6,
      "벲벶",
      5,
      "벾벿볁볂볃볅",
      7,
      "볎볒볓볔볖볗볙볚볛볝",
      22,
      "볷볹볺볻볽",
    ],
    ["9441", "볾", 5, "봆봈봊", 5, "봑봒봓봕", 8],
    ["9461", "봞", 5, "봥", 6, "봭", 12],
    [
      "9481",
      "봺",
      5,
      "뵁",
      6,
      "뵊뵋뵍뵎뵏뵑",
      6,
      "뵚",
      9,
      "뵥뵦뵧뵩",
      22,
      "붂붃붅붆붋",
      4,
      "붒붔붖붗붘붛붝",
      6,
      "붥",
      10,
      "붱",
      6,
      "붹",
      24,
    ],
    ["9541", "뷒뷓뷖뷗뷙뷚뷛뷝", 11, "뷪", 5, "뷱"],
    ["9561", "뷲뷳뷵뷶뷷뷹", 6, "븁븂븄븆", 5, "븎븏븑븒븓"],
    [
      "9581",
      "븕",
      6,
      "븞븠",
      35,
      "빆빇빉빊빋빍빏",
      4,
      "빖빘빜빝빞빟빢빣빥빦빧빩빫",
      4,
      "빲빶",
      4,
      "빾빿뺁뺂뺃뺅",
      6,
      "뺎뺒",
      5,
      "뺚",
      13,
      "뺩",
      14,
    ],
    ["9641", "뺸", 23, "뻒뻓"],
    ["9661", "뻕뻖뻙", 6, "뻡뻢뻦", 5, "뻭", 8],
    [
      "9681",
      "뻶",
      10,
      "뼂",
      5,
      "뼊",
      13,
      "뼚뼞",
      33,
      "뽂뽃뽅뽆뽇뽉",
      6,
      "뽒뽓뽔뽖",
      44,
    ],
    ["9741", "뾃", 16, "뾕", 8],
    ["9761", "뾞", 17, "뾱", 7],
    ["9781", "뾹", 11, "뿆", 5, "뿎뿏뿑뿒뿓뿕", 6, "뿝뿞뿠뿢", 89, "쀽쀾쀿"],
    ["9841", "쁀", 16, "쁒", 5, "쁙쁚쁛"],
    ["9861", "쁝쁞쁟쁡", 6, "쁪", 15],
    [
      "9881",
      "쁺",
      21,
      "삒삓삕삖삗삙",
      6,
      "삢삤삦",
      5,
      "삮삱삲삷",
      4,
      "삾샂샃샄샆샇샊샋샍샎샏샑",
      6,
      "샚샞",
      5,
      "샦샧샩샪샫샭",
      6,
      "샶샸샺",
      5,
      "섁섂섃섅섆섇섉",
      6,
      "섑섒섓섔섖",
      5,
      "섡섢섥섨섩섪섫섮",
    ],
    ["9941", "섲섳섴섵섷섺섻섽섾섿셁", 6, "셊셎", 5, "셖셗"],
    ["9961", "셙셚셛셝", 6, "셦셪", 5, "셱셲셳셵셶셷셹셺셻"],
    [
      "9981",
      "셼",
      8,
      "솆",
      5,
      "솏솑솒솓솕솗",
      4,
      "솞솠솢솣솤솦솧솪솫솭솮솯솱",
      11,
      "솾",
      5,
      "쇅쇆쇇쇉쇊쇋쇍",
      6,
      "쇕쇖쇙",
      6,
      "쇡쇢쇣쇥쇦쇧쇩",
      6,
      "쇲쇴",
      7,
      "쇾쇿숁숂숃숅",
      6,
      "숎숐숒",
      5,
      "숚숛숝숞숡숢숣",
    ],
    ["9a41", "숤숥숦숧숪숬숮숰숳숵", 16],
    ["9a61", "쉆쉇쉉", 6, "쉒쉓쉕쉖쉗쉙", 6, "쉡쉢쉣쉤쉦"],
    [
      "9a81",
      "쉧",
      4,
      "쉮쉯쉱쉲쉳쉵",
      6,
      "쉾슀슂",
      5,
      "슊",
      5,
      "슑",
      6,
      "슙슚슜슞",
      5,
      "슦슧슩슪슫슮",
      5,
      "슶슸슺",
      33,
      "싞싟싡싢싥",
      5,
      "싮싰싲싳싴싵싷싺싽싾싿쌁",
      6,
      "쌊쌋쌎쌏",
    ],
    ["9b41", "쌐쌑쌒쌖쌗쌙쌚쌛쌝", 6, "쌦쌧쌪", 8],
    ["9b61", "쌳", 17, "썆", 7],
    [
      "9b81",
      "썎",
      25,
      "썪썫썭썮썯썱썳",
      4,
      "썺썻썾",
      5,
      "쎅쎆쎇쎉쎊쎋쎍",
      50,
      "쏁",
      22,
      "쏚",
    ],
    ["9c41", "쏛쏝쏞쏡쏣", 4, "쏪쏫쏬쏮", 5, "쏶쏷쏹", 5],
    ["9c61", "쏿", 8, "쐉", 6, "쐑", 9],
    [
      "9c81",
      "쐛",
      8,
      "쐥",
      6,
      "쐭쐮쐯쐱쐲쐳쐵",
      6,
      "쐾",
      9,
      "쑉",
      26,
      "쑦쑧쑩쑪쑫쑭",
      6,
      "쑶쑷쑸쑺",
      5,
      "쒁",
      18,
      "쒕",
      6,
      "쒝",
      12,
    ],
    ["9d41", "쒪", 13, "쒹쒺쒻쒽", 8],
    ["9d61", "쓆", 25],
    [
      "9d81",
      "쓠",
      8,
      "쓪",
      5,
      "쓲쓳쓵쓶쓷쓹쓻쓼쓽쓾씂",
      9,
      "씍씎씏씑씒씓씕",
      6,
      "씝",
      10,
      "씪씫씭씮씯씱",
      6,
      "씺씼씾",
      5,
      "앆앇앋앏앐앑앒앖앚앛앜앟앢앣앥앦앧앩",
      6,
      "앲앶",
      5,
      "앾앿얁얂얃얅얆얈얉얊얋얎얐얒얓얔",
    ],
    ["9e41", "얖얙얚얛얝얞얟얡", 7, "얪", 9, "얶"],
    ["9e61", "얷얺얿", 4, "엋엍엏엒엓엕엖엗엙", 6, "엢엤엦엧"],
    [
      "9e81",
      "엨엩엪엫엯엱엲엳엵엸엹엺엻옂옃옄옉옊옋옍옎옏옑",
      6,
      "옚옝",
      6,
      "옦옧옩옪옫옯옱옲옶옸옺옼옽옾옿왂왃왅왆왇왉",
      6,
      "왒왖",
      5,
      "왞왟왡",
      10,
      "왭왮왰왲",
      5,
      "왺왻왽왾왿욁",
      6,
      "욊욌욎",
      5,
      "욖욗욙욚욛욝",
      6,
      "욦",
    ],
    ["9f41", "욨욪", 5, "욲욳욵욶욷욻", 4, "웂웄웆", 5, "웎"],
    ["9f61", "웏웑웒웓웕", 6, "웞웟웢", 5, "웪웫웭웮웯웱웲"],
    [
      "9f81",
      "웳",
      4,
      "웺웻웼웾",
      5,
      "윆윇윉윊윋윍",
      6,
      "윖윘윚",
      5,
      "윢윣윥윦윧윩",
      6,
      "윲윴윶윸윹윺윻윾윿읁읂읃읅",
      4,
      "읋읎읐읙읚읛읝읞읟읡",
      6,
      "읩읪읬",
      7,
      "읶읷읹읺읻읿잀잁잂잆잋잌잍잏잒잓잕잙잛",
      4,
      "잢잧",
      4,
      "잮잯잱잲잳잵잶잷",
    ],
    ["a041", "잸잹잺잻잾쟂", 5, "쟊쟋쟍쟏쟑", 6, "쟙쟚쟛쟜"],
    ["a061", "쟞", 5, "쟥쟦쟧쟩쟪쟫쟭", 13],
    [
      "a081",
      "쟻",
      4,
      "젂젃젅젆젇젉젋",
      4,
      "젒젔젗",
      4,
      "젞젟젡젢젣젥",
      6,
      "젮젰젲",
      5,
      "젹젺젻젽젾젿졁",
      6,
      "졊졋졎",
      5,
      "졕",
      26,
      "졲졳졵졶졷졹졻",
      4,
      "좂좄좈좉좊좎",
      5,
      "좕",
      7,
      "좞좠좢좣좤",
    ],
    ["a141", "좥좦좧좩", 18, "좾좿죀죁"],
    ["a161", "죂죃죅죆죇죉죊죋죍", 6, "죖죘죚", 5, "죢죣죥"],
    [
      "a181",
      "죦",
      14,
      "죶",
      5,
      "죾죿줁줂줃줇",
      4,
      "줎　、。·‥…¨〃­―∥＼∼‘’“”〔〕〈",
      9,
      "±×÷≠≤≥∞∴°′″℃Å￠￡￥♂♀∠⊥⌒∂∇≡≒§※☆★○●◎◇◆□■△▲▽▼→←↑↓↔〓≪≫√∽∝∵∫∬∈∋⊆⊇⊂⊃∪∩∧∨￢",
    ],
    ["a241", "줐줒", 5, "줙", 18],
    ["a261", "줭", 6, "줵", 18],
    [
      "a281",
      "쥈",
      7,
      "쥒쥓쥕쥖쥗쥙",
      6,
      "쥢쥤",
      7,
      "쥭쥮쥯⇒⇔∀∃´～ˇ˘˝˚˙¸˛¡¿ː∮∑∏¤℉‰◁◀▷▶♤♠♡♥♧♣⊙◈▣◐◑▒▤▥▨▧▦▩♨☏☎☜☞¶†‡↕↗↙↖↘♭♩♪♬㉿㈜№㏇™㏂㏘℡€®",
    ],
    ["a341", "쥱쥲쥳쥵", 6, "쥽", 10, "즊즋즍즎즏"],
    ["a361", "즑", 6, "즚즜즞", 16],
    ["a381", "즯", 16, "짂짃짅짆짉짋", 4, "짒짔짗짘짛！", 58, "￦］", 32, "￣"],
    ["a441", "짞짟짡짣짥짦짨짩짪짫짮짲", 5, "짺짻짽짾짿쨁쨂쨃쨄"],
    ["a461", "쨅쨆쨇쨊쨎", 5, "쨕쨖쨗쨙", 12],
    ["a481", "쨦쨧쨨쨪", 28, "ㄱ", 93],
    ["a541", "쩇", 4, "쩎쩏쩑쩒쩓쩕", 6, "쩞쩢", 5, "쩩쩪"],
    ["a561", "쩫", 17, "쩾", 5, "쪅쪆"],
    ["a581", "쪇", 16, "쪙", 14, "ⅰ", 9],
    ["a5b0", "Ⅰ", 9],
    ["a5c1", "Α", 16, "Σ", 6],
    ["a5e1", "α", 16, "σ", 6],
    ["a641", "쪨", 19, "쪾쪿쫁쫂쫃쫅"],
    ["a661", "쫆", 5, "쫎쫐쫒쫔쫕쫖쫗쫚", 5, "쫡", 6],
    [
      "a681",
      "쫨쫩쫪쫫쫭",
      6,
      "쫵",
      18,
      "쬉쬊─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂┒┑┚┙┖┕┎┍┞┟┡┢┦┧┩┪┭┮┱┲┵┶┹┺┽┾╀╁╃",
      7,
    ],
    ["a741", "쬋", 4, "쬑쬒쬓쬕쬖쬗쬙", 6, "쬢", 7],
    ["a761", "쬪", 22, "쭂쭃쭄"],
    [
      "a781",
      "쭅쭆쭇쭊쭋쭍쭎쭏쭑",
      6,
      "쭚쭛쭜쭞",
      5,
      "쭥",
      7,
      "㎕㎖㎗ℓ㎘㏄㎣㎤㎥㎦㎙",
      9,
      "㏊㎍㎎㎏㏏㎈㎉㏈㎧㎨㎰",
      9,
      "㎀",
      4,
      "㎺",
      5,
      "㎐",
      4,
      "Ω㏀㏁㎊㎋㎌㏖㏅㎭㎮㎯㏛㎩㎪㎫㎬㏝㏐㏓㏃㏉㏜㏆",
    ],
    ["a841", "쭭", 10, "쭺", 14],
    ["a861", "쮉", 18, "쮝", 6],
    ["a881", "쮤", 19, "쮹", 11, "ÆÐªĦ"],
    ["a8a6", "Ĳ"],
    ["a8a8", "ĿŁØŒºÞŦŊ"],
    ["a8b1", "㉠", 27, "ⓐ", 25, "①", 14, "½⅓⅔¼¾⅛⅜⅝⅞"],
    ["a941", "쯅", 14, "쯕", 10],
    ["a961", "쯠쯡쯢쯣쯥쯦쯨쯪", 18],
    [
      "a981",
      "쯽",
      14,
      "찎찏찑찒찓찕",
      6,
      "찞찟찠찣찤æđðħıĳĸŀłøœßþŧŋŉ㈀",
      27,
      "⒜",
      25,
      "⑴",
      14,
      "¹²³⁴ⁿ₁₂₃₄",
    ],
    ["aa41", "찥찦찪찫찭찯찱", 6, "찺찿", 4, "챆챇챉챊챋챍챎"],
    ["aa61", "챏", 4, "챖챚", 5, "챡챢챣챥챧챩", 6, "챱챲"],
    ["aa81", "챳챴챶", 29, "ぁ", 82],
    ["ab41", "첔첕첖첗첚첛첝첞첟첡", 6, "첪첮", 5, "첶첷첹"],
    ["ab61", "첺첻첽", 6, "쳆쳈쳊", 5, "쳑쳒쳓쳕", 5],
    ["ab81", "쳛", 8, "쳥", 6, "쳭쳮쳯쳱", 12, "ァ", 85],
    ["ac41", "쳾쳿촀촂", 5, "촊촋촍촎촏촑", 6, "촚촜촞촟촠"],
    ["ac61", "촡촢촣촥촦촧촩촪촫촭", 11, "촺", 4],
    ["ac81", "촿", 28, "쵝쵞쵟А", 5, "ЁЖ", 25],
    ["acd1", "а", 5, "ёж", 25],
    ["ad41", "쵡쵢쵣쵥", 6, "쵮쵰쵲", 5, "쵹", 7],
    ["ad61", "춁", 6, "춉", 10, "춖춗춙춚춛춝춞춟"],
    ["ad81", "춠춡춢춣춦춨춪", 5, "춱", 18, "췅"],
    ["ae41", "췆", 5, "췍췎췏췑", 16],
    ["ae61", "췢", 5, "췩췪췫췭췮췯췱", 6, "췺췼췾", 4],
    ["ae81", "츃츅츆츇츉츊츋츍", 6, "츕츖츗츘츚", 5, "츢츣츥츦츧츩츪츫"],
    ["af41", "츬츭츮츯츲츴츶", 19],
    ["af61", "칊", 13, "칚칛칝칞칢", 5, "칪칬"],
    ["af81", "칮", 5, "칶칷칹칺칻칽", 6, "캆캈캊", 5, "캒캓캕캖캗캙"],
    ["b041", "캚", 5, "캢캦", 5, "캮", 12],
    ["b061", "캻", 5, "컂", 19],
    [
      "b081",
      "컖",
      13,
      "컦컧컩컪컭",
      6,
      "컶컺",
      5,
      "가각간갇갈갉갊감",
      7,
      "같",
      4,
      "갠갤갬갭갯갰갱갸갹갼걀걋걍걔걘걜거걱건걷걸걺검겁것겄겅겆겉겊겋게겐겔겜겝겟겠겡겨격겪견겯결겸겹겻겼경곁계곈곌곕곗고곡곤곧골곪곬곯곰곱곳공곶과곽관괄괆",
    ],
    ["b141", "켂켃켅켆켇켉", 6, "켒켔켖", 5, "켝켞켟켡켢켣"],
    ["b161", "켥", 6, "켮켲", 5, "켹", 11],
    [
      "b181",
      "콅",
      14,
      "콖콗콙콚콛콝",
      6,
      "콦콨콪콫콬괌괍괏광괘괜괠괩괬괭괴괵괸괼굄굅굇굉교굔굘굡굣구국군굳굴굵굶굻굼굽굿궁궂궈궉권궐궜궝궤궷귀귁귄귈귐귑귓규균귤그극근귿글긁금급긋긍긔기긱긴긷길긺김깁깃깅깆깊까깍깎깐깔깖깜깝깟깠깡깥깨깩깬깰깸",
    ],
    ["b241", "콭콮콯콲콳콵콶콷콹", 6, "쾁쾂쾃쾄쾆", 5, "쾍"],
    ["b261", "쾎", 18, "쾢", 5, "쾩"],
    [
      "b281",
      "쾪",
      5,
      "쾱",
      18,
      "쿅",
      6,
      "깹깻깼깽꺄꺅꺌꺼꺽꺾껀껄껌껍껏껐껑께껙껜껨껫껭껴껸껼꼇꼈꼍꼐꼬꼭꼰꼲꼴꼼꼽꼿꽁꽂꽃꽈꽉꽐꽜꽝꽤꽥꽹꾀꾄꾈꾐꾑꾕꾜꾸꾹꾼꿀꿇꿈꿉꿋꿍꿎꿔꿜꿨꿩꿰꿱꿴꿸뀀뀁뀄뀌뀐뀔뀜뀝뀨끄끅끈끊끌끎끓끔끕끗끙",
    ],
    ["b341", "쿌", 19, "쿢쿣쿥쿦쿧쿩"],
    ["b361", "쿪", 5, "쿲쿴쿶", 5, "쿽쿾쿿퀁퀂퀃퀅", 5],
    [
      "b381",
      "퀋",
      5,
      "퀒",
      5,
      "퀙",
      19,
      "끝끼끽낀낄낌낍낏낑나낙낚난낟날낡낢남납낫",
      4,
      "낱낳내낵낸낼냄냅냇냈냉냐냑냔냘냠냥너넉넋넌널넒넓넘넙넛넜넝넣네넥넨넬넴넵넷넸넹녀녁년녈념녑녔녕녘녜녠노녹논놀놂놈놉놋농높놓놔놘놜놨뇌뇐뇔뇜뇝",
    ],
    ["b441", "퀮", 5, "퀶퀷퀹퀺퀻퀽", 6, "큆큈큊", 5],
    ["b461", "큑큒큓큕큖큗큙", 6, "큡", 10, "큮큯"],
    [
      "b481",
      "큱큲큳큵",
      6,
      "큾큿킀킂",
      18,
      "뇟뇨뇩뇬뇰뇹뇻뇽누눅눈눋눌눔눕눗눙눠눴눼뉘뉜뉠뉨뉩뉴뉵뉼늄늅늉느늑는늘늙늚늠늡늣능늦늪늬늰늴니닉닌닐닒님닙닛닝닢다닥닦단닫",
      4,
      "닳담답닷",
      4,
      "닿대댁댄댈댐댑댓댔댕댜더덕덖던덛덜덞덟덤덥",
    ],
    ["b541", "킕", 14, "킦킧킩킪킫킭", 5],
    ["b561", "킳킶킸킺", 5, "탂탃탅탆탇탊", 5, "탒탖", 4],
    [
      "b581",
      "탛탞탟탡탢탣탥",
      6,
      "탮탲",
      5,
      "탹",
      11,
      "덧덩덫덮데덱덴델뎀뎁뎃뎄뎅뎌뎐뎔뎠뎡뎨뎬도독돈돋돌돎돐돔돕돗동돛돝돠돤돨돼됐되된될됨됩됫됴두둑둔둘둠둡둣둥둬뒀뒈뒝뒤뒨뒬뒵뒷뒹듀듄듈듐듕드득든듣들듦듬듭듯등듸디딕딘딛딜딤딥딧딨딩딪따딱딴딸",
    ],
    ["b641", "턅", 7, "턎", 17],
    ["b661", "턠", 15, "턲턳턵턶턷턹턻턼턽턾"],
    [
      "b681",
      "턿텂텆",
      5,
      "텎텏텑텒텓텕",
      6,
      "텞텠텢",
      5,
      "텩텪텫텭땀땁땃땄땅땋때땍땐땔땜땝땟땠땡떠떡떤떨떪떫떰떱떳떴떵떻떼떽뗀뗄뗌뗍뗏뗐뗑뗘뗬또똑똔똘똥똬똴뙈뙤뙨뚜뚝뚠뚤뚫뚬뚱뛔뛰뛴뛸뜀뜁뜅뜨뜩뜬뜯뜰뜸뜹뜻띄띈띌띔띕띠띤띨띰띱띳띵라락란랄람랍랏랐랑랒랖랗",
    ],
    ["b741", "텮", 13, "텽", 6, "톅톆톇톉톊"],
    ["b761", "톋", 20, "톢톣톥톦톧"],
    [
      "b781",
      "톩",
      6,
      "톲톴톶톷톸톹톻톽톾톿퇁",
      14,
      "래랙랜랠램랩랫랬랭랴략랸럇량러럭런럴럼럽럿렀렁렇레렉렌렐렘렙렛렝려력련렬렴렵렷렸령례롄롑롓로록론롤롬롭롯롱롸롼뢍뢨뢰뢴뢸룀룁룃룅료룐룔룝룟룡루룩룬룰룸룹룻룽뤄뤘뤠뤼뤽륀륄륌륏륑류륙륜률륨륩",
    ],
    ["b841", "퇐", 7, "퇙", 17],
    ["b861", "퇫", 8, "퇵퇶퇷퇹", 13],
    [
      "b881",
      "툈툊",
      5,
      "툑",
      24,
      "륫륭르륵른를름릅릇릉릊릍릎리릭린릴림립릿링마막만많",
      4,
      "맘맙맛망맞맡맣매맥맨맬맴맵맷맸맹맺먀먁먈먕머먹먼멀멂멈멉멋멍멎멓메멕멘멜멤멥멧멨멩며멱면멸몃몄명몇몌모목몫몬몰몲몸몹못몽뫄뫈뫘뫙뫼",
    ],
    ["b941", "툪툫툮툯툱툲툳툵", 6, "툾퉀퉂", 5, "퉉퉊퉋퉌"],
    ["b961", "퉍", 14, "퉝", 6, "퉥퉦퉧퉨"],
    [
      "b981",
      "퉩",
      22,
      "튂튃튅튆튇튉튊튋튌묀묄묍묏묑묘묜묠묩묫무묵묶문묻물묽묾뭄뭅뭇뭉뭍뭏뭐뭔뭘뭡뭣뭬뮈뮌뮐뮤뮨뮬뮴뮷므믄믈믐믓미믹민믿밀밂밈밉밋밌밍및밑바",
      4,
      "받",
      4,
      "밤밥밧방밭배백밴밸뱀뱁뱃뱄뱅뱉뱌뱍뱐뱝버벅번벋벌벎범법벗",
    ],
    ["ba41", "튍튎튏튒튓튔튖", 5, "튝튞튟튡튢튣튥", 6, "튭"],
    ["ba61", "튮튯튰튲", 5, "튺튻튽튾틁틃", 4, "틊틌", 5],
    [
      "ba81",
      "틒틓틕틖틗틙틚틛틝",
      6,
      "틦",
      9,
      "틲틳틵틶틷틹틺벙벚베벡벤벧벨벰벱벳벴벵벼벽변별볍볏볐병볕볘볜보복볶본볼봄봅봇봉봐봔봤봬뵀뵈뵉뵌뵐뵘뵙뵤뵨부북분붇불붉붊붐붑붓붕붙붚붜붤붰붸뷔뷕뷘뷜뷩뷰뷴뷸븀븃븅브븍븐블븜븝븟비빅빈빌빎빔빕빗빙빚빛빠빡빤",
    ],
    ["bb41", "틻", 4, "팂팄팆", 5, "팏팑팒팓팕팗", 4, "팞팢팣"],
    ["bb61", "팤팦팧팪팫팭팮팯팱", 6, "팺팾", 5, "퍆퍇퍈퍉"],
    [
      "bb81",
      "퍊",
      31,
      "빨빪빰빱빳빴빵빻빼빽뺀뺄뺌뺍뺏뺐뺑뺘뺙뺨뻐뻑뻔뻗뻘뻠뻣뻤뻥뻬뼁뼈뼉뼘뼙뼛뼜뼝뽀뽁뽄뽈뽐뽑뽕뾔뾰뿅뿌뿍뿐뿔뿜뿟뿡쀼쁑쁘쁜쁠쁨쁩삐삑삔삘삠삡삣삥사삭삯산삳살삵삶삼삽삿샀상샅새색샌샐샘샙샛샜생샤",
    ],
    ["bc41", "퍪", 17, "퍾퍿펁펂펃펅펆펇"],
    ["bc61", "펈펉펊펋펎펒", 5, "펚펛펝펞펟펡", 6, "펪펬펮"],
    [
      "bc81",
      "펯",
      4,
      "펵펶펷펹펺펻펽",
      6,
      "폆폇폊",
      5,
      "폑",
      5,
      "샥샨샬샴샵샷샹섀섄섈섐섕서",
      4,
      "섣설섦섧섬섭섯섰성섶세섹센셀셈셉셋셌셍셔셕션셜셤셥셧셨셩셰셴셸솅소속솎손솔솖솜솝솟송솥솨솩솬솰솽쇄쇈쇌쇔쇗쇘쇠쇤쇨쇰쇱쇳쇼쇽숀숄숌숍숏숑수숙순숟술숨숩숫숭",
    ],
    ["bd41", "폗폙", 7, "폢폤", 7, "폮폯폱폲폳폵폶폷"],
    ["bd61", "폸폹폺폻폾퐀퐂", 5, "퐉", 13],
    [
      "bd81",
      "퐗",
      5,
      "퐞",
      25,
      "숯숱숲숴쉈쉐쉑쉔쉘쉠쉥쉬쉭쉰쉴쉼쉽쉿슁슈슉슐슘슛슝스슥슨슬슭슴습슷승시식신싣실싫심십싯싱싶싸싹싻싼쌀쌈쌉쌌쌍쌓쌔쌕쌘쌜쌤쌥쌨쌩썅써썩썬썰썲썸썹썼썽쎄쎈쎌쏀쏘쏙쏜쏟쏠쏢쏨쏩쏭쏴쏵쏸쐈쐐쐤쐬쐰",
    ],
    ["be41", "퐸", 7, "푁푂푃푅", 14],
    ["be61", "푔", 7, "푝푞푟푡푢푣푥", 7, "푮푰푱푲"],
    [
      "be81",
      "푳",
      4,
      "푺푻푽푾풁풃",
      4,
      "풊풌풎",
      5,
      "풕",
      8,
      "쐴쐼쐽쑈쑤쑥쑨쑬쑴쑵쑹쒀쒔쒜쒸쒼쓩쓰쓱쓴쓸쓺쓿씀씁씌씐씔씜씨씩씬씰씸씹씻씽아악안앉않알앍앎앓암압앗았앙앝앞애액앤앨앰앱앳앴앵야약얀얄얇얌얍얏양얕얗얘얜얠얩어억언얹얻얼얽얾엄",
      6,
      "엌엎",
    ],
    ["bf41", "풞", 10, "풪", 14],
    ["bf61", "풹", 18, "퓍퓎퓏퓑퓒퓓퓕"],
    [
      "bf81",
      "퓖",
      5,
      "퓝퓞퓠",
      7,
      "퓩퓪퓫퓭퓮퓯퓱",
      6,
      "퓹퓺퓼에엑엔엘엠엡엣엥여역엮연열엶엷염",
      5,
      "옅옆옇예옌옐옘옙옛옜오옥온올옭옮옰옳옴옵옷옹옻와왁완왈왐왑왓왔왕왜왝왠왬왯왱외왹왼욀욈욉욋욍요욕욘욜욤욥욧용우욱운울욹욺움웁웃웅워웍원월웜웝웠웡웨",
    ],
    ["c041", "퓾", 5, "픅픆픇픉픊픋픍", 6, "픖픘", 5],
    ["c061", "픞", 25],
    [
      "c081",
      "픸픹픺픻픾픿핁핂핃핅",
      6,
      "핎핐핒",
      5,
      "핚핛핝핞핟핡핢핣웩웬웰웸웹웽위윅윈윌윔윕윗윙유육윤율윰윱윳융윷으윽은을읊음읍읏응",
      7,
      "읜읠읨읫이익인일읽읾잃임입잇있잉잊잎자작잔잖잗잘잚잠잡잣잤장잦재잭잰잴잼잽잿쟀쟁쟈쟉쟌쟎쟐쟘쟝쟤쟨쟬저적전절젊",
    ],
    ["c141", "핤핦핧핪핬핮", 5, "핶핷핹핺핻핽", 6, "햆햊햋"],
    ["c161", "햌햍햎햏햑", 19, "햦햧"],
    [
      "c181",
      "햨",
      31,
      "점접젓정젖제젝젠젤젬젭젯젱져젼졀졈졉졌졍졔조족존졸졺좀좁좃종좆좇좋좌좍좔좝좟좡좨좼좽죄죈죌죔죕죗죙죠죡죤죵주죽준줄줅줆줌줍줏중줘줬줴쥐쥑쥔쥘쥠쥡쥣쥬쥰쥴쥼즈즉즌즐즘즙즛증지직진짇질짊짐집짓",
    ],
    ["c241", "헊헋헍헎헏헑헓", 4, "헚헜헞", 5, "헦헧헩헪헫헭헮"],
    ["c261", "헯", 4, "헶헸헺", 5, "혂혃혅혆혇혉", 6, "혒"],
    [
      "c281",
      "혖",
      5,
      "혝혞혟혡혢혣혥",
      7,
      "혮",
      9,
      "혺혻징짖짙짚짜짝짠짢짤짧짬짭짯짰짱째짹짼쨀쨈쨉쨋쨌쨍쨔쨘쨩쩌쩍쩐쩔쩜쩝쩟쩠쩡쩨쩽쪄쪘쪼쪽쫀쫄쫌쫍쫏쫑쫓쫘쫙쫠쫬쫴쬈쬐쬔쬘쬠쬡쭁쭈쭉쭌쭐쭘쭙쭝쭤쭸쭹쮜쮸쯔쯤쯧쯩찌찍찐찔찜찝찡찢찧차착찬찮찰참찹찻",
    ],
    ["c341", "혽혾혿홁홂홃홄홆홇홊홌홎홏홐홒홓홖홗홙홚홛홝", 4],
    ["c361", "홢", 4, "홨홪", 5, "홲홳홵", 11],
    [
      "c381",
      "횁횂횄횆",
      5,
      "횎횏횑횒횓횕",
      7,
      "횞횠횢",
      5,
      "횩횪찼창찾채책챈챌챔챕챗챘챙챠챤챦챨챰챵처척천철첨첩첫첬청체첵첸첼쳄쳅쳇쳉쳐쳔쳤쳬쳰촁초촉촌촐촘촙촛총촤촨촬촹최쵠쵤쵬쵭쵯쵱쵸춈추축춘출춤춥춧충춰췄췌췐취췬췰췸췹췻췽츄츈츌츔츙츠측츤츨츰츱츳층",
    ],
    ["c441", "횫횭횮횯횱", 7, "횺횼", 7, "훆훇훉훊훋"],
    ["c461", "훍훎훏훐훒훓훕훖훘훚", 5, "훡훢훣훥훦훧훩", 4],
    [
      "c481",
      "훮훯훱훲훳훴훶",
      5,
      "훾훿휁휂휃휅",
      11,
      "휒휓휔치칙친칟칠칡침칩칫칭카칵칸칼캄캅캇캉캐캑캔캘캠캡캣캤캥캬캭컁커컥컨컫컬컴컵컷컸컹케켁켄켈켐켑켓켕켜켠켤켬켭켯켰켱켸코콕콘콜콤콥콧콩콰콱콴콸쾀쾅쾌쾡쾨쾰쿄쿠쿡쿤쿨쿰쿱쿳쿵쿼퀀퀄퀑퀘퀭퀴퀵퀸퀼",
    ],
    ["c541", "휕휖휗휚휛휝휞휟휡", 6, "휪휬휮", 5, "휶휷휹"],
    ["c561", "휺휻휽", 6, "흅흆흈흊", 5, "흒흓흕흚", 4],
    [
      "c581",
      "흟흢흤흦흧흨흪흫흭흮흯흱흲흳흵",
      6,
      "흾흿힀힂",
      5,
      "힊힋큄큅큇큉큐큔큘큠크큭큰클큼큽킁키킥킨킬킴킵킷킹타탁탄탈탉탐탑탓탔탕태택탠탤탬탭탯탰탱탸턍터턱턴털턺텀텁텃텄텅테텍텐텔템텝텟텡텨텬텼톄톈토톡톤톨톰톱톳통톺톼퇀퇘퇴퇸툇툉툐투툭툰툴툼툽툿퉁퉈퉜",
    ],
    ["c641", "힍힎힏힑", 6, "힚힜힞", 5],
    [
      "c6a1",
      "퉤튀튁튄튈튐튑튕튜튠튤튬튱트특튼튿틀틂틈틉틋틔틘틜틤틥티틱틴틸팀팁팃팅파팍팎판팔팖팜팝팟팠팡팥패팩팬팰팸팹팻팼팽퍄퍅퍼퍽펀펄펌펍펏펐펑페펙펜펠펨펩펫펭펴편펼폄폅폈평폐폘폡폣포폭폰폴폼폽폿퐁",
    ],
    [
      "c7a1",
      "퐈퐝푀푄표푠푤푭푯푸푹푼푿풀풂품풉풋풍풔풩퓌퓐퓔퓜퓟퓨퓬퓰퓸퓻퓽프픈플픔픕픗피픽핀필핌핍핏핑하학한할핥함합핫항해핵핸핼햄햅햇했행햐향허헉헌헐헒험헙헛헝헤헥헨헬헴헵헷헹혀혁현혈혐협혓혔형혜혠",
    ],
    [
      "c8a1",
      "혤혭호혹혼홀홅홈홉홋홍홑화확환활홧황홰홱홴횃횅회획횐횔횝횟횡효횬횰횹횻후훅훈훌훑훔훗훙훠훤훨훰훵훼훽휀휄휑휘휙휜휠휨휩휫휭휴휵휸휼흄흇흉흐흑흔흖흗흘흙흠흡흣흥흩희흰흴흼흽힁히힉힌힐힘힙힛힝",
    ],
    [
      "caa1",
      "伽佳假價加可呵哥嘉嫁家暇架枷柯歌珂痂稼苛茄街袈訶賈跏軻迦駕刻却各恪慤殼珏脚覺角閣侃刊墾奸姦干幹懇揀杆柬桿澗癎看磵稈竿簡肝艮艱諫間乫喝曷渴碣竭葛褐蝎鞨勘坎堪嵌感憾戡敢柑橄減甘疳監瞰紺邯鑑鑒龕",
    ],
    [
      "cba1",
      "匣岬甲胛鉀閘剛堈姜岡崗康强彊慷江畺疆糠絳綱羌腔舡薑襁講鋼降鱇介价個凱塏愷愾慨改槪漑疥皆盖箇芥蓋豈鎧開喀客坑更粳羹醵倨去居巨拒据據擧渠炬祛距踞車遽鉅鋸乾件健巾建愆楗腱虔蹇鍵騫乞傑杰桀儉劍劒檢",
    ],
    [
      "cca1",
      "瞼鈐黔劫怯迲偈憩揭擊格檄激膈覡隔堅牽犬甄絹繭肩見譴遣鵑抉決潔結缺訣兼慊箝謙鉗鎌京俓倞傾儆勁勍卿坰境庚徑慶憬擎敬景暻更梗涇炅烱璟璥瓊痙硬磬竟競絅經耕耿脛莖警輕逕鏡頃頸驚鯨係啓堺契季屆悸戒桂械",
    ],
    [
      "cda1",
      "棨溪界癸磎稽系繫繼計誡谿階鷄古叩告呱固姑孤尻庫拷攷故敲暠枯槁沽痼皐睾稿羔考股膏苦苽菰藁蠱袴誥賈辜錮雇顧高鼓哭斛曲梏穀谷鵠困坤崑昆梱棍滾琨袞鯤汨滑骨供公共功孔工恐恭拱控攻珙空蚣貢鞏串寡戈果瓜",
    ],
    [
      "cea1",
      "科菓誇課跨過鍋顆廓槨藿郭串冠官寬慣棺款灌琯瓘管罐菅觀貫關館刮恝括适侊光匡壙廣曠洸炚狂珖筐胱鑛卦掛罫乖傀塊壞怪愧拐槐魁宏紘肱轟交僑咬喬嬌嶠巧攪敎校橋狡皎矯絞翹膠蕎蛟較轎郊餃驕鮫丘久九仇俱具勾",
    ],
    [
      "cfa1",
      "區口句咎嘔坵垢寇嶇廐懼拘救枸柩構歐毆毬求溝灸狗玖球瞿矩究絿耉臼舅舊苟衢謳購軀逑邱鉤銶駒驅鳩鷗龜國局菊鞠鞫麴君窘群裙軍郡堀屈掘窟宮弓穹窮芎躬倦券勸卷圈拳捲權淃眷厥獗蕨蹶闕机櫃潰詭軌饋句晷歸貴",
    ],
    [
      "d0a1",
      "鬼龜叫圭奎揆槻珪硅窺竅糾葵規赳逵閨勻均畇筠菌鈞龜橘克剋劇戟棘極隙僅劤勤懃斤根槿瑾筋芹菫覲謹近饉契今妗擒昑檎琴禁禽芩衾衿襟金錦伋及急扱汲級給亘兢矜肯企伎其冀嗜器圻基埼夔奇妓寄岐崎己幾忌技旗旣",
    ],
    [
      "d1a1",
      "朞期杞棋棄機欺氣汽沂淇玘琦琪璂璣畸畿碁磯祁祇祈祺箕紀綺羈耆耭肌記譏豈起錡錤飢饑騎騏驥麒緊佶吉拮桔金喫儺喇奈娜懦懶拏拿癩",
      5,
      "那樂",
      4,
      "諾酪駱亂卵暖欄煖爛蘭難鸞捏捺南嵐枏楠湳濫男藍襤拉",
    ],
    [
      "d2a1",
      "納臘蠟衲囊娘廊",
      4,
      "乃來內奈柰耐冷女年撚秊念恬拈捻寧寗努勞奴弩怒擄櫓爐瑙盧",
      5,
      "駑魯",
      10,
      "濃籠聾膿農惱牢磊腦賂雷尿壘",
      7,
      "嫩訥杻紐勒",
      5,
      "能菱陵尼泥匿溺多茶",
    ],
    [
      "d3a1",
      "丹亶但單團壇彖斷旦檀段湍短端簞緞蛋袒鄲鍛撻澾獺疸達啖坍憺擔曇淡湛潭澹痰聃膽蕁覃談譚錟沓畓答踏遝唐堂塘幢戇撞棠當糖螳黨代垈坮大對岱帶待戴擡玳臺袋貸隊黛宅德悳倒刀到圖堵塗導屠島嶋度徒悼挑掉搗桃",
    ],
    [
      "d4a1",
      "棹櫂淘渡滔濤燾盜睹禱稻萄覩賭跳蹈逃途道都鍍陶韜毒瀆牘犢獨督禿篤纛讀墩惇敦旽暾沌焞燉豚頓乭突仝冬凍動同憧東桐棟洞潼疼瞳童胴董銅兜斗杜枓痘竇荳讀豆逗頭屯臀芚遁遯鈍得嶝橙燈登等藤謄鄧騰喇懶拏癩羅",
    ],
    [
      "d5a1",
      "蘿螺裸邏樂洛烙珞絡落諾酪駱丹亂卵欄欒瀾爛蘭鸞剌辣嵐擥攬欖濫籃纜藍襤覽拉臘蠟廊朗浪狼琅瑯螂郞來崍徠萊冷掠略亮倆兩凉梁樑粮粱糧良諒輛量侶儷勵呂廬慮戾旅櫚濾礪藜蠣閭驢驪麗黎力曆歷瀝礫轢靂憐戀攣漣",
    ],
    [
      "d6a1",
      "煉璉練聯蓮輦連鍊冽列劣洌烈裂廉斂殮濂簾獵令伶囹寧岺嶺怜玲笭羚翎聆逞鈴零靈領齡例澧禮醴隷勞怒撈擄櫓潞瀘爐盧老蘆虜路輅露魯鷺鹵碌祿綠菉錄鹿麓論壟弄朧瀧瓏籠聾儡瀨牢磊賂賚賴雷了僚寮廖料燎療瞭聊蓼",
    ],
    [
      "d7a1",
      "遼鬧龍壘婁屢樓淚漏瘻累縷蔞褸鏤陋劉旒柳榴流溜瀏琉瑠留瘤硫謬類六戮陸侖倫崙淪綸輪律慄栗率隆勒肋凜凌楞稜綾菱陵俚利厘吏唎履悧李梨浬犁狸理璃異痢籬罹羸莉裏裡里釐離鯉吝潾燐璘藺躪隣鱗麟林淋琳臨霖砬",
    ],
    [
      "d8a1",
      "立笠粒摩瑪痲碼磨馬魔麻寞幕漠膜莫邈万卍娩巒彎慢挽晩曼滿漫灣瞞萬蔓蠻輓饅鰻唜抹末沫茉襪靺亡妄忘忙望網罔芒茫莽輞邙埋妹媒寐昧枚梅每煤罵買賣邁魅脈貊陌驀麥孟氓猛盲盟萌冪覓免冕勉棉沔眄眠綿緬面麵滅",
    ],
    [
      "d9a1",
      "蔑冥名命明暝椧溟皿瞑茗蓂螟酩銘鳴袂侮冒募姆帽慕摸摹暮某模母毛牟牡瑁眸矛耗芼茅謀謨貌木沐牧目睦穆鶩歿沒夢朦蒙卯墓妙廟描昴杳渺猫竗苗錨務巫憮懋戊拇撫无楙武毋無珷畝繆舞茂蕪誣貿霧鵡墨默們刎吻問文",
    ],
    [
      "daa1",
      "汶紊紋聞蚊門雯勿沕物味媚尾嵋彌微未梶楣渼湄眉米美薇謎迷靡黴岷悶愍憫敏旻旼民泯玟珉緡閔密蜜謐剝博拍搏撲朴樸泊珀璞箔粕縛膊舶薄迫雹駁伴半反叛拌搬攀斑槃泮潘班畔瘢盤盼磐磻礬絆般蟠返頒飯勃拔撥渤潑",
    ],
    [
      "dba1",
      "發跋醱鉢髮魃倣傍坊妨尨幇彷房放方旁昉枋榜滂磅紡肪膀舫芳蒡蚌訪謗邦防龐倍俳北培徘拜排杯湃焙盃背胚裴裵褙賠輩配陪伯佰帛柏栢白百魄幡樊煩燔番磻繁蕃藩飜伐筏罰閥凡帆梵氾汎泛犯範范法琺僻劈壁擘檗璧癖",
    ],
    [
      "dca1",
      "碧蘗闢霹便卞弁變辨辯邊別瞥鱉鼈丙倂兵屛幷昞昺柄棅炳甁病秉竝輧餠騈保堡報寶普步洑湺潽珤甫菩補褓譜輔伏僕匐卜宓復服福腹茯蔔複覆輹輻馥鰒本乶俸奉封峯峰捧棒烽熢琫縫蓬蜂逢鋒鳳不付俯傅剖副否咐埠夫婦",
    ],
    [
      "dda1",
      "孚孵富府復扶敷斧浮溥父符簿缶腐腑膚艀芙莩訃負賦賻赴趺部釜阜附駙鳧北分吩噴墳奔奮忿憤扮昐汾焚盆粉糞紛芬賁雰不佛弗彿拂崩朋棚硼繃鵬丕備匕匪卑妃婢庇悲憊扉批斐枇榧比毖毗毘沸泌琵痺砒碑秕秘粃緋翡肥",
    ],
    [
      "dea1",
      "脾臂菲蜚裨誹譬費鄙非飛鼻嚬嬪彬斌檳殯浜濱瀕牝玭貧賓頻憑氷聘騁乍事些仕伺似使俟僿史司唆嗣四士奢娑寫寺射巳師徙思捨斜斯柶査梭死沙泗渣瀉獅砂社祀祠私篩紗絲肆舍莎蓑蛇裟詐詞謝賜赦辭邪飼駟麝削數朔索",
    ],
    [
      "dfa1",
      "傘刪山散汕珊産疝算蒜酸霰乷撒殺煞薩三參杉森渗芟蔘衫揷澁鈒颯上傷像償商喪嘗孀尙峠常床庠廂想桑橡湘爽牀狀相祥箱翔裳觴詳象賞霜塞璽賽嗇塞穡索色牲生甥省笙墅壻嶼序庶徐恕抒捿敍暑曙書栖棲犀瑞筮絮緖署",
    ],
    [
      "e0a1",
      "胥舒薯西誓逝鋤黍鼠夕奭席惜昔晳析汐淅潟石碩蓆釋錫仙僊先善嬋宣扇敾旋渲煽琁瑄璇璿癬禪線繕羨腺膳船蘚蟬詵跣選銑鐥饍鮮卨屑楔泄洩渫舌薛褻設說雪齧剡暹殲纖蟾贍閃陝攝涉燮葉城姓宬性惺成星晟猩珹盛省筬",
    ],
    [
      "e1a1",
      "聖聲腥誠醒世勢歲洗稅笹細說貰召嘯塑宵小少巢所掃搔昭梳沼消溯瀟炤燒甦疏疎瘙笑篠簫素紹蔬蕭蘇訴逍遡邵銷韶騷俗屬束涑粟續謖贖速孫巽損蓀遜飡率宋悚松淞訟誦送頌刷殺灑碎鎖衰釗修受嗽囚垂壽嫂守岫峀帥愁",
    ],
    [
      "e2a1",
      "戍手授搜收數樹殊水洙漱燧狩獸琇璲瘦睡秀穗竪粹綏綬繡羞脩茱蒐蓚藪袖誰讐輸遂邃酬銖銹隋隧隨雖需須首髓鬚叔塾夙孰宿淑潚熟琡璹肅菽巡徇循恂旬栒楯橓殉洵淳珣盾瞬筍純脣舜荀蓴蕣詢諄醇錞順馴戌術述鉥崇崧",
    ],
    [
      "e3a1",
      "嵩瑟膝蝨濕拾習褶襲丞乘僧勝升承昇繩蠅陞侍匙嘶始媤尸屎屍市弑恃施是時枾柴猜矢示翅蒔蓍視試詩諡豕豺埴寔式息拭植殖湜熄篒蝕識軾食飾伸侁信呻娠宸愼新晨燼申神紳腎臣莘薪藎蜃訊身辛辰迅失室實悉審尋心沁",
    ],
    [
      "e4a1",
      "沈深瀋甚芯諶什十拾雙氏亞俄兒啞娥峨我牙芽莪蛾衙訝阿雅餓鴉鵝堊岳嶽幄惡愕握樂渥鄂鍔顎鰐齷安岸按晏案眼雁鞍顔鮟斡謁軋閼唵岩巖庵暗癌菴闇壓押狎鴨仰央怏昻殃秧鴦厓哀埃崖愛曖涯碍艾隘靄厄扼掖液縊腋額",
    ],
    [
      "e5a1",
      "櫻罌鶯鸚也倻冶夜惹揶椰爺耶若野弱掠略約若葯蒻藥躍亮佯兩凉壤孃恙揚攘敭暘梁楊樣洋瀁煬痒瘍禳穰糧羊良襄諒讓釀陽量養圄御於漁瘀禦語馭魚齬億憶抑檍臆偃堰彦焉言諺孼蘖俺儼嚴奄掩淹嶪業円予余勵呂女如廬",
    ],
    [
      "e6a1",
      "旅歟汝濾璵礖礪與艅茹輿轝閭餘驪麗黎亦力域役易曆歷疫繹譯轢逆驛嚥堧姸娟宴年延憐戀捐挻撚椽沇沿涎涓淵演漣烟然煙煉燃燕璉硏硯秊筵緣練縯聯衍軟輦蓮連鉛鍊鳶列劣咽悅涅烈熱裂說閱厭廉念捻染殮炎焰琰艶苒",
    ],
    [
      "e7a1",
      "簾閻髥鹽曄獵燁葉令囹塋寧嶺嶸影怜映暎楹榮永泳渶潁濚瀛瀯煐營獰玲瑛瑩瓔盈穎纓羚聆英詠迎鈴鍈零霙靈領乂倪例刈叡曳汭濊猊睿穢芮藝蘂禮裔詣譽豫醴銳隸霓預五伍俉傲午吾吳嗚塢墺奧娛寤悟惡懊敖旿晤梧汚澳",
    ],
    [
      "e8a1",
      "烏熬獒筽蜈誤鰲鼇屋沃獄玉鈺溫瑥瘟穩縕蘊兀壅擁瓮甕癰翁邕雍饔渦瓦窩窪臥蛙蝸訛婉完宛梡椀浣玩琓琬碗緩翫脘腕莞豌阮頑曰往旺枉汪王倭娃歪矮外嵬巍猥畏了僚僥凹堯夭妖姚寥寮尿嶢拗搖撓擾料曜樂橈燎燿瑤療",
    ],
    [
      "e9a1",
      "窈窯繇繞耀腰蓼蟯要謠遙遼邀饒慾欲浴縟褥辱俑傭冗勇埇墉容庸慂榕涌湧溶熔瑢用甬聳茸蓉踊鎔鏞龍于佑偶優又友右宇寓尤愚憂旴牛玗瑀盂祐禑禹紆羽芋藕虞迂遇郵釪隅雨雩勖彧旭昱栯煜稶郁頊云暈橒殞澐熉耘芸蕓",
    ],
    [
      "eaa1",
      "運隕雲韻蔚鬱亐熊雄元原員圓園垣媛嫄寃怨愿援沅洹湲源爰猿瑗苑袁轅遠阮院願鴛月越鉞位偉僞危圍委威尉慰暐渭爲瑋緯胃萎葦蔿蝟衛褘謂違韋魏乳侑儒兪劉唯喩孺宥幼幽庾悠惟愈愉揄攸有杻柔柚柳楡楢油洧流游溜",
    ],
    [
      "eba1",
      "濡猶猷琉瑜由留癒硫紐維臾萸裕誘諛諭踰蹂遊逾遺酉釉鍮類六堉戮毓肉育陸倫允奫尹崙淪潤玧胤贇輪鈗閏律慄栗率聿戎瀜絨融隆垠恩慇殷誾銀隱乙吟淫蔭陰音飮揖泣邑凝應膺鷹依倚儀宜意懿擬椅毅疑矣義艤薏蟻衣誼",
    ],
    [
      "eca1",
      "議醫二以伊利吏夷姨履已弛彛怡易李梨泥爾珥理異痍痢移罹而耳肄苡荑裏裡貽貳邇里離飴餌匿溺瀷益翊翌翼謚人仁刃印吝咽因姻寅引忍湮燐璘絪茵藺蚓認隣靭靷鱗麟一佚佾壹日溢逸鎰馹任壬妊姙恁林淋稔臨荏賃入卄",
    ],
    [
      "eda1",
      "立笠粒仍剩孕芿仔刺咨姉姿子字孜恣慈滋炙煮玆瓷疵磁紫者自茨蔗藉諮資雌作勺嚼斫昨灼炸爵綽芍酌雀鵲孱棧殘潺盞岑暫潛箴簪蠶雜丈仗匠場墻壯奬將帳庄張掌暲杖樟檣欌漿牆狀獐璋章粧腸臟臧莊葬蔣薔藏裝贓醬長",
    ],
    [
      "eea1",
      "障再哉在宰才材栽梓渽滓災縡裁財載齋齎爭箏諍錚佇低儲咀姐底抵杵楮樗沮渚狙猪疽箸紵苧菹著藷詛貯躇這邸雎齟勣吊嫡寂摘敵滴狄炙的積笛籍績翟荻謫賊赤跡蹟迪迹適鏑佃佺傳全典前剪塡塼奠專展廛悛戰栓殿氈澱",
    ],
    [
      "efa1",
      "煎琠田甸畑癲筌箋箭篆纏詮輾轉鈿銓錢鐫電顚顫餞切截折浙癤竊節絶占岾店漸点粘霑鮎點接摺蝶丁井亭停偵呈姃定幀庭廷征情挺政整旌晶晸柾楨檉正汀淀淨渟湞瀞炡玎珽町睛碇禎程穽精綎艇訂諪貞鄭酊釘鉦鋌錠霆靖",
    ],
    [
      "f0a1",
      "靜頂鼎制劑啼堤帝弟悌提梯濟祭第臍薺製諸蹄醍除際霽題齊俎兆凋助嘲弔彫措操早晁曺曹朝條棗槽漕潮照燥爪璪眺祖祚租稠窕粗糟組繰肇藻蚤詔調趙躁造遭釣阻雕鳥族簇足鏃存尊卒拙猝倧宗從悰慫棕淙琮種終綜縱腫",
    ],
    [
      "f1a1",
      "踪踵鍾鐘佐坐左座挫罪主住侏做姝胄呪周嗾奏宙州廚晝朱柱株注洲湊澍炷珠疇籌紂紬綢舟蛛註誅走躊輳週酎酒鑄駐竹粥俊儁准埈寯峻晙樽浚準濬焌畯竣蠢逡遵雋駿茁中仲衆重卽櫛楫汁葺增憎曾拯烝甑症繒蒸證贈之只",
    ],
    [
      "f2a1",
      "咫地址志持指摯支旨智枝枳止池沚漬知砥祉祗紙肢脂至芝芷蜘誌識贄趾遲直稙稷織職唇嗔塵振搢晉晋桭榛殄津溱珍瑨璡畛疹盡眞瞋秦縉縝臻蔯袗診賑軫辰進鎭陣陳震侄叱姪嫉帙桎瓆疾秩窒膣蛭質跌迭斟朕什執潗緝輯",
    ],
    [
      "f3a1",
      "鏶集徵懲澄且侘借叉嗟嵯差次此磋箚茶蹉車遮捉搾着窄錯鑿齪撰澯燦璨瓚竄簒纂粲纘讚贊鑽餐饌刹察擦札紮僭參塹慘慙懺斬站讒讖倉倡創唱娼廠彰愴敞昌昶暢槍滄漲猖瘡窓脹艙菖蒼債埰寀寨彩採砦綵菜蔡采釵冊柵策",
    ],
    [
      "f4a1",
      "責凄妻悽處倜刺剔尺慽戚拓擲斥滌瘠脊蹠陟隻仟千喘天川擅泉淺玔穿舛薦賤踐遷釧闡阡韆凸哲喆徹撤澈綴輟轍鐵僉尖沾添甛瞻簽籤詹諂堞妾帖捷牒疊睫諜貼輒廳晴淸聽菁請靑鯖切剃替涕滯締諦逮遞體初剿哨憔抄招梢",
    ],
    [
      "f5a1",
      "椒楚樵炒焦硝礁礎秒稍肖艸苕草蕉貂超酢醋醮促囑燭矗蜀觸寸忖村邨叢塚寵悤憁摠總聰蔥銃撮催崔最墜抽推椎楸樞湫皺秋芻萩諏趨追鄒酋醜錐錘鎚雛騶鰍丑畜祝竺筑築縮蓄蹙蹴軸逐春椿瑃出朮黜充忠沖蟲衝衷悴膵萃",
    ],
    [
      "f6a1",
      "贅取吹嘴娶就炊翠聚脆臭趣醉驟鷲側仄厠惻測層侈値嗤峙幟恥梔治淄熾痔痴癡稚穉緇緻置致蚩輜雉馳齒則勅飭親七柒漆侵寢枕沈浸琛砧針鍼蟄秤稱快他咤唾墮妥惰打拖朶楕舵陀馱駝倬卓啄坼度托拓擢晫柝濁濯琢琸託",
    ],
    [
      "f7a1",
      "鐸呑嘆坦彈憚歎灘炭綻誕奪脫探眈耽貪塔搭榻宕帑湯糖蕩兌台太怠態殆汰泰笞胎苔跆邰颱宅擇澤撑攄兎吐土討慟桶洞痛筒統通堆槌腿褪退頹偸套妬投透鬪慝特闖坡婆巴把播擺杷波派爬琶破罷芭跛頗判坂板版瓣販辦鈑",
    ],
    [
      "f8a1",
      "阪八叭捌佩唄悖敗沛浿牌狽稗覇貝彭澎烹膨愎便偏扁片篇編翩遍鞭騙貶坪平枰萍評吠嬖幣廢弊斃肺蔽閉陛佈包匍匏咆哺圃布怖抛抱捕暴泡浦疱砲胞脯苞葡蒲袍褒逋鋪飽鮑幅暴曝瀑爆輻俵剽彪慓杓標漂瓢票表豹飇飄驃",
    ],
    [
      "f9a1",
      "品稟楓諷豊風馮彼披疲皮被避陂匹弼必泌珌畢疋筆苾馝乏逼下何厦夏廈昰河瑕荷蝦賀遐霞鰕壑學虐謔鶴寒恨悍旱汗漢澣瀚罕翰閑閒限韓割轄函含咸啣喊檻涵緘艦銜陷鹹合哈盒蛤閤闔陜亢伉姮嫦巷恒抗杭桁沆港缸肛航",
    ],
    [
      "faa1",
      "行降項亥偕咳垓奚孩害懈楷海瀣蟹解該諧邂駭骸劾核倖幸杏荇行享向嚮珦鄕響餉饗香噓墟虛許憲櫶獻軒歇險驗奕爀赫革俔峴弦懸晛泫炫玄玹現眩睍絃絢縣舷衒見賢鉉顯孑穴血頁嫌俠協夾峽挾浹狹脅脇莢鋏頰亨兄刑型",
    ],
    [
      "fba1",
      "形泂滎瀅灐炯熒珩瑩荊螢衡逈邢鎣馨兮彗惠慧暳蕙蹊醯鞋乎互呼壕壺好岵弧戶扈昊晧毫浩淏湖滸澔濠濩灝狐琥瑚瓠皓祜糊縞胡芦葫蒿虎號蝴護豪鎬頀顥惑或酷婚昏混渾琿魂忽惚笏哄弘汞泓洪烘紅虹訌鴻化和嬅樺火畵",
    ],
    [
      "fca1",
      "禍禾花華話譁貨靴廓擴攫確碻穫丸喚奐宦幻患換歡晥桓渙煥環紈還驩鰥活滑猾豁闊凰幌徨恍惶愰慌晃晄榥況湟滉潢煌璜皇篁簧荒蝗遑隍黃匯回廻徊恢悔懷晦會檜淮澮灰獪繪膾茴蛔誨賄劃獲宖橫鐄哮嚆孝效斅曉梟涍淆",
    ],
    [
      "fda1",
      "爻肴酵驍侯候厚后吼喉嗅帿後朽煦珝逅勛勳塤壎焄熏燻薰訓暈薨喧暄煊萱卉喙毁彙徽揮暉煇諱輝麾休携烋畦虧恤譎鷸兇凶匈洶胸黑昕欣炘痕吃屹紇訖欠欽歆吸恰洽翕興僖凞喜噫囍姬嬉希憙憘戱晞曦熙熹熺犧禧稀羲詰",
    ],
  ],
  M1 = [
    ["0", "\0", 127],
    [
      "a140",
      "　，、。．‧；：？！︰…‥﹐﹑﹒·﹔﹕﹖﹗｜–︱—︳╴︴﹏（）︵︶｛｝︷︸〔〕︹︺【】︻︼《》︽︾〈〉︿﹀「」﹁﹂『』﹃﹄﹙﹚",
    ],
    [
      "a1a1",
      "﹛﹜﹝﹞‘’“”〝〞‵′＃＆＊※§〃○●△▲◎☆★◇◆□■▽▼㊣℅¯￣＿ˍ﹉﹊﹍﹎﹋﹌﹟﹠﹡＋－×÷±√＜＞＝≦≧≠∞≒≡﹢",
      4,
      "～∩∪⊥∠∟⊿㏒㏑∫∮∵∴♀♂⊕⊙↑↓←→↖↗↙↘∥∣／",
    ],
    [
      "a240",
      "＼∕﹨＄￥〒￠￡％＠℃℉﹩﹪﹫㏕㎜㎝㎞㏎㎡㎎㎏㏄°兙兛兞兝兡兣嗧瓩糎▁",
      7,
      "▏▎▍▌▋▊▉┼┴┬┤├▔─│▕┌┐└┘╭",
    ],
    ["a2a1", "╮╰╯═╞╪╡◢◣◥◤╱╲╳０", 9, "Ⅰ", 9, "〡", 8, "十卄卅Ａ", 25, "ａ", 21],
    ["a340", "ｗｘｙｚΑ", 16, "Σ", 6, "α", 16, "σ", 6, "ㄅ", 10],
    ["a3a1", "ㄐ", 25, "˙ˉˊˇˋ"],
    ["a3e1", "€"],
    [
      "a440",
      "一乙丁七乃九了二人儿入八几刀刁力匕十卜又三下丈上丫丸凡久么也乞于亡兀刃勺千叉口土士夕大女子孑孓寸小尢尸山川工己已巳巾干廾弋弓才",
    ],
    [
      "a4a1",
      "丑丐不中丰丹之尹予云井互五亢仁什仃仆仇仍今介仄元允內六兮公冗凶分切刈勻勾勿化匹午升卅卞厄友及反壬天夫太夭孔少尤尺屯巴幻廿弔引心戈戶手扎支文斗斤方日曰月木欠止歹毋比毛氏水火爪父爻片牙牛犬王丙",
    ],
    [
      "a540",
      "世丕且丘主乍乏乎以付仔仕他仗代令仙仞充兄冉冊冬凹出凸刊加功包匆北匝仟半卉卡占卯卮去可古右召叮叩叨叼司叵叫另只史叱台句叭叻四囚外",
    ],
    [
      "a5a1",
      "央失奴奶孕它尼巨巧左市布平幼弁弘弗必戊打扔扒扑斥旦朮本未末札正母民氐永汁汀氾犯玄玉瓜瓦甘生用甩田由甲申疋白皮皿目矛矢石示禾穴立丞丟乒乓乩亙交亦亥仿伉伙伊伕伍伐休伏仲件任仰仳份企伋光兇兆先全",
    ],
    [
      "a640",
      "共再冰列刑划刎刖劣匈匡匠印危吉吏同吊吐吁吋各向名合吃后吆吒因回囝圳地在圭圬圯圩夙多夷夸妄奸妃好她如妁字存宇守宅安寺尖屹州帆并年",
    ],
    [
      "a6a1",
      "式弛忙忖戎戌戍成扣扛托收早旨旬旭曲曳有朽朴朱朵次此死氖汝汗汙江池汐汕污汛汍汎灰牟牝百竹米糸缶羊羽老考而耒耳聿肉肋肌臣自至臼舌舛舟艮色艾虫血行衣西阡串亨位住佇佗佞伴佛何估佐佑伽伺伸佃佔似但佣",
    ],
    [
      "a740",
      "作你伯低伶余佝佈佚兌克免兵冶冷別判利刪刨劫助努劬匣即卵吝吭吞吾否呎吧呆呃吳呈呂君吩告吹吻吸吮吵吶吠吼呀吱含吟听囪困囤囫坊坑址坍",
    ],
    [
      "a7a1",
      "均坎圾坐坏圻壯夾妝妒妨妞妣妙妖妍妤妓妊妥孝孜孚孛完宋宏尬局屁尿尾岐岑岔岌巫希序庇床廷弄弟彤形彷役忘忌志忍忱快忸忪戒我抄抗抖技扶抉扭把扼找批扳抒扯折扮投抓抑抆改攻攸旱更束李杏材村杜杖杞杉杆杠",
    ],
    [
      "a840",
      "杓杗步每求汞沙沁沈沉沅沛汪決沐汰沌汨沖沒汽沃汲汾汴沆汶沍沔沘沂灶灼災灸牢牡牠狄狂玖甬甫男甸皂盯矣私秀禿究系罕肖肓肝肘肛肚育良芒",
    ],
    [
      "a8a1",
      "芋芍見角言谷豆豕貝赤走足身車辛辰迂迆迅迄巡邑邢邪邦那酉釆里防阮阱阪阬並乖乳事些亞享京佯依侍佳使佬供例來侃佰併侈佩佻侖佾侏侑佺兔兒兕兩具其典冽函刻券刷刺到刮制剁劾劻卒協卓卑卦卷卸卹取叔受味呵",
    ],
    [
      "a940",
      "咖呸咕咀呻呷咄咒咆呼咐呱呶和咚呢周咋命咎固垃坷坪坩坡坦坤坼夜奉奇奈奄奔妾妻委妹妮姑姆姐姍始姓姊妯妳姒姅孟孤季宗定官宜宙宛尚屈居",
    ],
    [
      "a9a1",
      "屆岷岡岸岩岫岱岳帘帚帖帕帛帑幸庚店府底庖延弦弧弩往征彿彼忝忠忽念忿怏怔怯怵怖怪怕怡性怩怫怛或戕房戾所承拉拌拄抿拂抹拒招披拓拔拋拈抨抽押拐拙拇拍抵拚抱拘拖拗拆抬拎放斧於旺昔易昌昆昂明昀昏昕昊",
    ],
    [
      "aa40",
      "昇服朋杭枋枕東果杳杷枇枝林杯杰板枉松析杵枚枓杼杪杲欣武歧歿氓氛泣注泳沱泌泥河沽沾沼波沫法泓沸泄油況沮泗泅泱沿治泡泛泊沬泯泜泖泠",
    ],
    [
      "aaa1",
      "炕炎炒炊炙爬爭爸版牧物狀狎狙狗狐玩玨玟玫玥甽疝疙疚的盂盲直知矽社祀祁秉秈空穹竺糾罔羌羋者肺肥肢肱股肫肩肴肪肯臥臾舍芳芝芙芭芽芟芹花芬芥芯芸芣芰芾芷虎虱初表軋迎返近邵邸邱邶采金長門阜陀阿阻附",
    ],
    [
      "ab40",
      "陂隹雨青非亟亭亮信侵侯便俠俑俏保促侶俘俟俊俗侮俐俄係俚俎俞侷兗冒冑冠剎剃削前剌剋則勇勉勃勁匍南卻厚叛咬哀咨哎哉咸咦咳哇哂咽咪品",
    ],
    [
      "aba1",
      "哄哈咯咫咱咻咩咧咿囿垂型垠垣垢城垮垓奕契奏奎奐姜姘姿姣姨娃姥姪姚姦威姻孩宣宦室客宥封屎屏屍屋峙峒巷帝帥帟幽庠度建弈弭彥很待徊律徇後徉怒思怠急怎怨恍恰恨恢恆恃恬恫恪恤扁拜挖按拼拭持拮拽指拱拷",
    ],
    [
      "ac40",
      "拯括拾拴挑挂政故斫施既春昭映昧是星昨昱昤曷柿染柱柔某柬架枯柵柩柯柄柑枴柚查枸柏柞柳枰柙柢柝柒歪殃殆段毒毗氟泉洋洲洪流津洌洱洞洗",
    ],
    [
      "aca1",
      "活洽派洶洛泵洹洧洸洩洮洵洎洫炫為炳炬炯炭炸炮炤爰牲牯牴狩狠狡玷珊玻玲珍珀玳甚甭畏界畎畋疫疤疥疢疣癸皆皇皈盈盆盃盅省盹相眉看盾盼眇矜砂研砌砍祆祉祈祇禹禺科秒秋穿突竿竽籽紂紅紀紉紇約紆缸美羿耄",
    ],
    [
      "ad40",
      "耐耍耑耶胖胥胚胃胄背胡胛胎胞胤胝致舢苧范茅苣苛苦茄若茂茉苒苗英茁苜苔苑苞苓苟苯茆虐虹虻虺衍衫要觔計訂訃貞負赴赳趴軍軌述迦迢迪迥",
    ],
    [
      "ada1",
      "迭迫迤迨郊郎郁郃酋酊重閂限陋陌降面革韋韭音頁風飛食首香乘亳倌倍倣俯倦倥俸倩倖倆值借倚倒們俺倀倔倨俱倡個候倘俳修倭倪俾倫倉兼冤冥冢凍凌准凋剖剜剔剛剝匪卿原厝叟哨唐唁唷哼哥哲唆哺唔哩哭員唉哮哪",
    ],
    [
      "ae40",
      "哦唧唇哽唏圃圄埂埔埋埃堉夏套奘奚娑娘娜娟娛娓姬娠娣娩娥娌娉孫屘宰害家宴宮宵容宸射屑展屐峭峽峻峪峨峰島崁峴差席師庫庭座弱徒徑徐恙",
    ],
    [
      "aea1",
      "恣恥恐恕恭恩息悄悟悚悍悔悌悅悖扇拳挈拿捎挾振捕捂捆捏捉挺捐挽挪挫挨捍捌效敉料旁旅時晉晏晃晒晌晅晁書朔朕朗校核案框桓根桂桔栩梳栗桌桑栽柴桐桀格桃株桅栓栘桁殊殉殷氣氧氨氦氤泰浪涕消涇浦浸海浙涓",
    ],
    [
      "af40",
      "浬涉浮浚浴浩涌涊浹涅浥涔烊烘烤烙烈烏爹特狼狹狽狸狷玆班琉珮珠珪珞畔畝畜畚留疾病症疲疳疽疼疹痂疸皋皰益盍盎眩真眠眨矩砰砧砸砝破砷",
    ],
    [
      "afa1",
      "砥砭砠砟砲祕祐祠祟祖神祝祗祚秤秣秧租秦秩秘窄窈站笆笑粉紡紗紋紊素索純紐紕級紜納紙紛缺罟羔翅翁耆耘耕耙耗耽耿胱脂胰脅胭胴脆胸胳脈能脊胼胯臭臬舀舐航舫舨般芻茫荒荔荊茸荐草茵茴荏茲茹茶茗荀茱茨荃",
    ],
    [
      "b040",
      "虔蚊蚪蚓蚤蚩蚌蚣蚜衰衷袁袂衽衹記訐討訌訕訊託訓訖訏訑豈豺豹財貢起躬軒軔軏辱送逆迷退迺迴逃追逅迸邕郡郝郢酒配酌釘針釗釜釙閃院陣陡",
    ],
    [
      "b0a1",
      "陛陝除陘陞隻飢馬骨高鬥鬲鬼乾偺偽停假偃偌做偉健偶偎偕偵側偷偏倏偯偭兜冕凰剪副勒務勘動匐匏匙匿區匾參曼商啪啦啄啞啡啃啊唱啖問啕唯啤唸售啜唬啣唳啁啗圈國圉域堅堊堆埠埤基堂堵執培夠奢娶婁婉婦婪婀",
    ],
    [
      "b140",
      "娼婢婚婆婊孰寇寅寄寂宿密尉專將屠屜屝崇崆崎崛崖崢崑崩崔崙崤崧崗巢常帶帳帷康庸庶庵庾張強彗彬彩彫得徙從徘御徠徜恿患悉悠您惋悴惦悽",
    ],
    [
      "b1a1",
      "情悻悵惜悼惘惕惆惟悸惚惇戚戛扈掠控捲掖探接捷捧掘措捱掩掉掃掛捫推掄授掙採掬排掏掀捻捩捨捺敝敖救教敗啟敏敘敕敔斜斛斬族旋旌旎晝晚晤晨晦晞曹勗望梁梯梢梓梵桿桶梱梧梗械梃棄梭梆梅梔條梨梟梡梂欲殺",
    ],
    [
      "b240",
      "毫毬氫涎涼淳淙液淡淌淤添淺清淇淋涯淑涮淞淹涸混淵淅淒渚涵淚淫淘淪深淮淨淆淄涪淬涿淦烹焉焊烽烯爽牽犁猜猛猖猓猙率琅琊球理現琍瓠瓶",
    ],
    [
      "b2a1",
      "瓷甜產略畦畢異疏痔痕疵痊痍皎盔盒盛眷眾眼眶眸眺硫硃硎祥票祭移窒窕笠笨笛第符笙笞笮粒粗粕絆絃統紮紹紼絀細紳組累終紲紱缽羞羚翌翎習耜聊聆脯脖脣脫脩脰脤舂舵舷舶船莎莞莘荸莢莖莽莫莒莊莓莉莠荷荻荼",
    ],
    [
      "b340",
      "莆莧處彪蛇蛀蚶蛄蚵蛆蛋蚱蚯蛉術袞袈被袒袖袍袋覓規訪訝訣訥許設訟訛訢豉豚販責貫貨貪貧赧赦趾趺軛軟這逍通逗連速逝逐逕逞造透逢逖逛途",
    ],
    [
      "b3a1",
      "部郭都酗野釵釦釣釧釭釩閉陪陵陳陸陰陴陶陷陬雀雪雩章竟頂頃魚鳥鹵鹿麥麻傢傍傅備傑傀傖傘傚最凱割剴創剩勞勝勛博厥啻喀喧啼喊喝喘喂喜喪喔喇喋喃喳單喟唾喲喚喻喬喱啾喉喫喙圍堯堪場堤堰報堡堝堠壹壺奠",
    ],
    [
      "b440",
      "婷媚婿媒媛媧孳孱寒富寓寐尊尋就嵌嵐崴嵇巽幅帽幀幃幾廊廁廂廄弼彭復循徨惑惡悲悶惠愜愣惺愕惰惻惴慨惱愎惶愉愀愒戟扉掣掌描揀揩揉揆揍",
    ],
    [
      "b4a1",
      "插揣提握揖揭揮捶援揪換摒揚揹敞敦敢散斑斐斯普晰晴晶景暑智晾晷曾替期朝棺棕棠棘棗椅棟棵森棧棹棒棲棣棋棍植椒椎棉棚楮棻款欺欽殘殖殼毯氮氯氬港游湔渡渲湧湊渠渥渣減湛湘渤湖湮渭渦湯渴湍渺測湃渝渾滋",
    ],
    [
      "b540",
      "溉渙湎湣湄湲湩湟焙焚焦焰無然煮焜牌犄犀猶猥猴猩琺琪琳琢琥琵琶琴琯琛琦琨甥甦畫番痢痛痣痙痘痞痠登發皖皓皴盜睏短硝硬硯稍稈程稅稀窘",
    ],
    [
      "b5a1",
      "窗窖童竣等策筆筐筒答筍筋筏筑粟粥絞結絨絕紫絮絲絡給絢絰絳善翔翕耋聒肅腕腔腋腑腎脹腆脾腌腓腴舒舜菩萃菸萍菠菅萋菁華菱菴著萊菰萌菌菽菲菊萸萎萄菜萇菔菟虛蛟蛙蛭蛔蛛蛤蛐蛞街裁裂袱覃視註詠評詞証詁",
    ],
    [
      "b640",
      "詔詛詐詆訴診訶詖象貂貯貼貳貽賁費賀貴買貶貿貸越超趁跎距跋跚跑跌跛跆軻軸軼辜逮逵週逸進逶鄂郵鄉郾酣酥量鈔鈕鈣鈉鈞鈍鈐鈇鈑閔閏開閑",
    ],
    [
      "b6a1",
      "間閒閎隊階隋陽隅隆隍陲隄雁雅雄集雇雯雲韌項順須飧飪飯飩飲飭馮馭黃黍黑亂傭債傲傳僅傾催傷傻傯僇剿剷剽募勦勤勢勣匯嗟嗨嗓嗦嗎嗜嗇嗑嗣嗤嗯嗚嗡嗅嗆嗥嗉園圓塞塑塘塗塚塔填塌塭塊塢塒塋奧嫁嫉嫌媾媽媼",
    ],
    [
      "b740",
      "媳嫂媲嵩嵯幌幹廉廈弒彙徬微愚意慈感想愛惹愁愈慎慌慄慍愾愴愧愍愆愷戡戢搓搾搞搪搭搽搬搏搜搔損搶搖搗搆敬斟新暗暉暇暈暖暄暘暍會榔業",
    ],
    [
      "b7a1",
      "楚楷楠楔極椰概楊楨楫楞楓楹榆楝楣楛歇歲毀殿毓毽溢溯滓溶滂源溝滇滅溥溘溼溺溫滑準溜滄滔溪溧溴煎煙煩煤煉照煜煬煦煌煥煞煆煨煖爺牒猷獅猿猾瑯瑚瑕瑟瑞瑁琿瑙瑛瑜當畸瘀痰瘁痲痱痺痿痴痳盞盟睛睫睦睞督",
    ],
    [
      "b840",
      "睹睪睬睜睥睨睢矮碎碰碗碘碌碉硼碑碓硿祺祿禁萬禽稜稚稠稔稟稞窟窠筷節筠筮筧粱粳粵經絹綑綁綏絛置罩罪署義羨群聖聘肆肄腱腰腸腥腮腳腫",
    ],
    [
      "b8a1",
      "腹腺腦舅艇蒂葷落萱葵葦葫葉葬葛萼萵葡董葩葭葆虞虜號蛹蜓蜈蜇蜀蛾蛻蜂蜃蜆蜊衙裟裔裙補裘裝裡裊裕裒覜解詫該詳試詩詰誇詼詣誠話誅詭詢詮詬詹詻訾詨豢貊貉賊資賈賄貲賃賂賅跡跟跨路跳跺跪跤跦躲較載軾輊",
    ],
    [
      "b940",
      "辟農運遊道遂達逼違遐遇遏過遍遑逾遁鄒鄗酬酪酩釉鈷鉗鈸鈽鉀鈾鉛鉋鉤鉑鈴鉉鉍鉅鈹鈿鉚閘隘隔隕雍雋雉雊雷電雹零靖靴靶預頑頓頊頒頌飼飴",
    ],
    [
      "b9a1",
      "飽飾馳馱馴髡鳩麂鼎鼓鼠僧僮僥僖僭僚僕像僑僱僎僩兢凳劃劂匱厭嗾嘀嘛嘗嗽嘔嘆嘉嘍嘎嗷嘖嘟嘈嘐嗶團圖塵塾境墓墊塹墅塽壽夥夢夤奪奩嫡嫦嫩嫗嫖嫘嫣孵寞寧寡寥實寨寢寤察對屢嶄嶇幛幣幕幗幔廓廖弊彆彰徹慇",
    ],
    [
      "ba40",
      "愿態慷慢慣慟慚慘慵截撇摘摔撤摸摟摺摑摧搴摭摻敲斡旗旖暢暨暝榜榨榕槁榮槓構榛榷榻榫榴槐槍榭槌榦槃榣歉歌氳漳演滾漓滴漩漾漠漬漏漂漢",
    ],
    [
      "baa1",
      "滿滯漆漱漸漲漣漕漫漯澈漪滬漁滲滌滷熔熙煽熊熄熒爾犒犖獄獐瑤瑣瑪瑰瑭甄疑瘧瘍瘋瘉瘓盡監瞄睽睿睡磁碟碧碳碩碣禎福禍種稱窪窩竭端管箕箋筵算箝箔箏箸箇箄粹粽精綻綰綜綽綾綠緊綴網綱綺綢綿綵綸維緒緇綬",
    ],
    [
      "bb40",
      "罰翠翡翟聞聚肇腐膀膏膈膊腿膂臧臺與舔舞艋蓉蒿蓆蓄蒙蒞蒲蒜蓋蒸蓀蓓蒐蒼蓑蓊蜿蜜蜻蜢蜥蜴蜘蝕蜷蜩裳褂裴裹裸製裨褚裯誦誌語誣認誡誓誤",
    ],
    [
      "bba1",
      "說誥誨誘誑誚誧豪貍貌賓賑賒赫趙趕跼輔輒輕輓辣遠遘遜遣遙遞遢遝遛鄙鄘鄞酵酸酷酴鉸銀銅銘銖鉻銓銜銨鉼銑閡閨閩閣閥閤隙障際雌雒需靼鞅韶頗領颯颱餃餅餌餉駁骯骰髦魁魂鳴鳶鳳麼鼻齊億儀僻僵價儂儈儉儅凜",
    ],
    [
      "bc40",
      "劇劈劉劍劊勰厲嘮嘻嘹嘲嘿嘴嘩噓噎噗噴嘶嘯嘰墀墟增墳墜墮墩墦奭嬉嫻嬋嫵嬌嬈寮寬審寫層履嶝嶔幢幟幡廢廚廟廝廣廠彈影德徵慶慧慮慝慕憂",
    ],
    [
      "bca1",
      "慼慰慫慾憧憐憫憎憬憚憤憔憮戮摩摯摹撞撲撈撐撰撥撓撕撩撒撮播撫撚撬撙撢撳敵敷數暮暫暴暱樣樟槨樁樞標槽模樓樊槳樂樅槭樑歐歎殤毅毆漿潼澄潑潦潔澆潭潛潸潮澎潺潰潤澗潘滕潯潠潟熟熬熱熨牖犛獎獗瑩璋璃",
    ],
    [
      "bd40",
      "瑾璀畿瘠瘩瘟瘤瘦瘡瘢皚皺盤瞎瞇瞌瞑瞋磋磅確磊碾磕碼磐稿稼穀稽稷稻窯窮箭箱範箴篆篇篁箠篌糊締練緯緻緘緬緝編緣線緞緩綞緙緲緹罵罷羯",
    ],
    [
      "bda1",
      "翩耦膛膜膝膠膚膘蔗蔽蔚蓮蔬蔭蔓蔑蔣蔡蔔蓬蔥蓿蔆螂蝴蝶蝠蝦蝸蝨蝙蝗蝌蝓衛衝褐複褒褓褕褊誼諒談諄誕請諸課諉諂調誰論諍誶誹諛豌豎豬賠賞賦賤賬賭賢賣賜質賡赭趟趣踫踐踝踢踏踩踟踡踞躺輝輛輟輩輦輪輜輞",
    ],
    [
      "be40",
      "輥適遮遨遭遷鄰鄭鄧鄱醇醉醋醃鋅銻銷鋪銬鋤鋁銳銼鋒鋇鋰銲閭閱霄霆震霉靠鞍鞋鞏頡頫頜颳養餓餒餘駝駐駟駛駑駕駒駙骷髮髯鬧魅魄魷魯鴆鴉",
    ],
    [
      "bea1",
      "鴃麩麾黎墨齒儒儘儔儐儕冀冪凝劑劓勳噙噫噹噩噤噸噪器噥噱噯噬噢噶壁墾壇壅奮嬝嬴學寰導彊憲憑憩憊懍憶憾懊懈戰擅擁擋撻撼據擄擇擂操撿擒擔撾整曆曉暹曄曇暸樽樸樺橙橫橘樹橄橢橡橋橇樵機橈歙歷氅濂澱澡",
    ],
    [
      "bf40",
      "濃澤濁澧澳激澹澶澦澠澴熾燉燐燒燈燕熹燎燙燜燃燄獨璜璣璘璟璞瓢甌甍瘴瘸瘺盧盥瞠瞞瞟瞥磨磚磬磧禦積穎穆穌穋窺篙簑築篤篛篡篩篦糕糖縊",
    ],
    [
      "bfa1",
      "縑縈縛縣縞縝縉縐罹羲翰翱翮耨膳膩膨臻興艘艙蕊蕙蕈蕨蕩蕃蕉蕭蕪蕞螃螟螞螢融衡褪褲褥褫褡親覦諦諺諫諱謀諜諧諮諾謁謂諷諭諳諶諼豫豭貓賴蹄踱踴蹂踹踵輻輯輸輳辨辦遵遴選遲遼遺鄴醒錠錶鋸錳錯錢鋼錫錄錚",
    ],
    [
      "c040",
      "錐錦錡錕錮錙閻隧隨險雕霎霑霖霍霓霏靛靜靦鞘頰頸頻頷頭頹頤餐館餞餛餡餚駭駢駱骸骼髻髭鬨鮑鴕鴣鴦鴨鴒鴛默黔龍龜優償儡儲勵嚎嚀嚐嚅嚇",
    ],
    [
      "c0a1",
      "嚏壕壓壑壎嬰嬪嬤孺尷屨嶼嶺嶽嶸幫彌徽應懂懇懦懋戲戴擎擊擘擠擰擦擬擱擢擭斂斃曙曖檀檔檄檢檜櫛檣橾檗檐檠歜殮毚氈濘濱濟濠濛濤濫濯澀濬濡濩濕濮濰燧營燮燦燥燭燬燴燠爵牆獰獲璩環璦璨癆療癌盪瞳瞪瞰瞬",
    ],
    [
      "c140",
      "瞧瞭矯磷磺磴磯礁禧禪穗窿簇簍篾篷簌篠糠糜糞糢糟糙糝縮績繆縷縲繃縫總縱繅繁縴縹繈縵縿縯罄翳翼聱聲聰聯聳臆臃膺臂臀膿膽臉膾臨舉艱薪",
    ],
    [
      "c1a1",
      "薄蕾薜薑薔薯薛薇薨薊虧蟀蟑螳蟒蟆螫螻螺蟈蟋褻褶襄褸褽覬謎謗謙講謊謠謝謄謐豁谿豳賺賽購賸賻趨蹉蹋蹈蹊轄輾轂轅輿避遽還邁邂邀鄹醣醞醜鍍鎂錨鍵鍊鍥鍋錘鍾鍬鍛鍰鍚鍔闊闋闌闈闆隱隸雖霜霞鞠韓顆颶餵騁",
    ],
    [
      "c240",
      "駿鮮鮫鮪鮭鴻鴿麋黏點黜黝黛鼾齋叢嚕嚮壙壘嬸彝懣戳擴擲擾攆擺擻擷斷曜朦檳檬櫃檻檸櫂檮檯歟歸殯瀉瀋濾瀆濺瀑瀏燻燼燾燸獷獵璧璿甕癖癘",
    ],
    [
      "c2a1",
      "癒瞽瞿瞻瞼礎禮穡穢穠竄竅簫簧簪簞簣簡糧織繕繞繚繡繒繙罈翹翻職聶臍臏舊藏薩藍藐藉薰薺薹薦蟯蟬蟲蟠覆覲觴謨謹謬謫豐贅蹙蹣蹦蹤蹟蹕軀轉轍邇邃邈醫醬釐鎔鎊鎖鎢鎳鎮鎬鎰鎘鎚鎗闔闖闐闕離雜雙雛雞霤鞣鞦",
    ],
    [
      "c340",
      "鞭韹額顏題顎顓颺餾餿餽餮馥騎髁鬃鬆魏魎魍鯊鯉鯽鯈鯀鵑鵝鵠黠鼕鼬儳嚥壞壟壢寵龐廬懲懷懶懵攀攏曠曝櫥櫝櫚櫓瀛瀟瀨瀚瀝瀕瀘爆爍牘犢獸",
    ],
    [
      "c3a1",
      "獺璽瓊瓣疇疆癟癡矇礙禱穫穩簾簿簸簽簷籀繫繭繹繩繪羅繳羶羹羸臘藩藝藪藕藤藥藷蟻蠅蠍蟹蟾襠襟襖襞譁譜識證譚譎譏譆譙贈贊蹼蹲躇蹶蹬蹺蹴轔轎辭邊邋醱醮鏡鏑鏟鏃鏈鏜鏝鏖鏢鏍鏘鏤鏗鏨關隴難霪霧靡韜韻類",
    ],
    [
      "c440",
      "願顛颼饅饉騖騙鬍鯨鯧鯖鯛鶉鵡鵲鵪鵬麒麗麓麴勸嚨嚷嚶嚴嚼壤孀孃孽寶巉懸懺攘攔攙曦朧櫬瀾瀰瀲爐獻瓏癢癥礦礪礬礫竇競籌籃籍糯糰辮繽繼",
    ],
    [
      "c4a1",
      "纂罌耀臚艦藻藹蘑藺蘆蘋蘇蘊蠔蠕襤覺觸議譬警譯譟譫贏贍躉躁躅躂醴釋鐘鐃鏽闡霰飄饒饑馨騫騰騷騵鰓鰍鹹麵黨鼯齟齣齡儷儸囁囀囂夔屬巍懼懾攝攜斕曩櫻欄櫺殲灌爛犧瓖瓔癩矓籐纏續羼蘗蘭蘚蠣蠢蠡蠟襪襬覽譴",
    ],
    [
      "c540",
      "護譽贓躊躍躋轟辯醺鐮鐳鐵鐺鐸鐲鐫闢霸霹露響顧顥饗驅驃驀騾髏魔魑鰭鰥鶯鶴鷂鶸麝黯鼙齜齦齧儼儻囈囊囉孿巔巒彎懿攤權歡灑灘玀瓤疊癮癬",
    ],
    [
      "c5a1",
      "禳籠籟聾聽臟襲襯觼讀贖贗躑躓轡酈鑄鑑鑒霽霾韃韁顫饕驕驍髒鬚鱉鰱鰾鰻鷓鷗鼴齬齪龔囌巖戀攣攫攪曬欐瓚竊籤籣籥纓纖纔臢蘸蘿蠱變邐邏鑣鑠鑤靨顯饜驚驛驗髓體髑鱔鱗鱖鷥麟黴囑壩攬灞癱癲矗罐羈蠶蠹衢讓讒",
    ],
    [
      "c640",
      "讖艷贛釀鑪靂靈靄韆顰驟鬢魘鱟鷹鷺鹼鹽鼇齷齲廳欖灣籬籮蠻觀躡釁鑲鑰顱饞髖鬣黌灤矚讚鑷韉驢驥纜讜躪釅鑽鑾鑼鱷鱸黷豔鑿鸚爨驪鬱鸛鸞籲",
    ],
    [
      "c940",
      "乂乜凵匚厂万丌乇亍囗兀屮彳丏冇与丮亓仂仉仈冘勼卬厹圠夃夬尐巿旡殳毌气爿丱丼仨仜仩仡仝仚刌匜卌圢圣夗夯宁宄尒尻屴屳帄庀庂忉戉扐氕",
    ],
    [
      "c9a1",
      "氶汃氿氻犮犰玊禸肊阞伎优伬仵伔仱伀价伈伝伂伅伢伓伄仴伒冱刓刉刐劦匢匟卍厊吇囡囟圮圪圴夼妀奼妅奻奾奷奿孖尕尥屼屺屻屾巟幵庄异弚彴忕忔忏扜扞扤扡扦扢扙扠扚扥旯旮朾朹朸朻机朿朼朳氘汆汒汜汏汊汔汋",
    ],
    [
      "ca40",
      "汌灱牞犴犵玎甪癿穵网艸艼芀艽艿虍襾邙邗邘邛邔阢阤阠阣佖伻佢佉体佤伾佧佒佟佁佘伭伳伿佡冏冹刜刞刡劭劮匉卣卲厎厏吰吷吪呔呅吙吜吥吘",
    ],
    [
      "caa1",
      "吽呏呁吨吤呇囮囧囥坁坅坌坉坋坒夆奀妦妘妠妗妎妢妐妏妧妡宎宒尨尪岍岏岈岋岉岒岊岆岓岕巠帊帎庋庉庌庈庍弅弝彸彶忒忑忐忭忨忮忳忡忤忣忺忯忷忻怀忴戺抃抌抎抏抔抇扱扻扺扰抁抈扷扽扲扴攷旰旴旳旲旵杅杇",
    ],
    [
      "cb40",
      "杙杕杌杈杝杍杚杋毐氙氚汸汧汫沄沋沏汱汯汩沚汭沇沕沜汦汳汥汻沎灴灺牣犿犽狃狆狁犺狅玕玗玓玔玒町甹疔疕皁礽耴肕肙肐肒肜芐芏芅芎芑芓",
    ],
    [
      "cba1",
      "芊芃芄豸迉辿邟邡邥邞邧邠阰阨阯阭丳侘佼侅佽侀侇佶佴侉侄佷佌侗佪侚佹侁佸侐侜侔侞侒侂侕佫佮冞冼冾刵刲刳剆刱劼匊匋匼厒厔咇呿咁咑咂咈呫呺呾呥呬呴呦咍呯呡呠咘呣呧呤囷囹坯坲坭坫坱坰坶垀坵坻坳坴坢",
    ],
    [
      "cc40",
      "坨坽夌奅妵妺姏姎妲姌姁妶妼姃姖妱妽姀姈妴姇孢孥宓宕屄屇岮岤岠岵岯岨岬岟岣岭岢岪岧岝岥岶岰岦帗帔帙弨弢弣弤彔徂彾彽忞忥怭怦怙怲怋",
    ],
    [
      "cca1",
      "怴怊怗怳怚怞怬怢怍怐怮怓怑怌怉怜戔戽抭抴拑抾抪抶拊抮抳抯抻抩抰抸攽斨斻昉旼昄昒昈旻昃昋昍昅旽昑昐曶朊枅杬枎枒杶杻枘枆构杴枍枌杺枟枑枙枃杽极杸杹枔欥殀歾毞氝沓泬泫泮泙沶泔沭泧沷泐泂沺泃泆泭泲",
    ],
    [
      "cd40",
      "泒泝沴沊沝沀泞泀洰泍泇沰泹泏泩泑炔炘炅炓炆炄炑炖炂炚炃牪狖狋狘狉狜狒狔狚狌狑玤玡玭玦玢玠玬玝瓝瓨甿畀甾疌疘皯盳盱盰盵矸矼矹矻矺",
    ],
    [
      "cda1",
      "矷祂礿秅穸穻竻籵糽耵肏肮肣肸肵肭舠芠苀芫芚芘芛芵芧芮芼芞芺芴芨芡芩苂芤苃芶芢虰虯虭虮豖迒迋迓迍迖迕迗邲邴邯邳邰阹阽阼阺陃俍俅俓侲俉俋俁俔俜俙侻侳俛俇俖侺俀侹俬剄剉勀勂匽卼厗厖厙厘咺咡咭咥哏",
    ],
    [
      "ce40",
      "哃茍咷咮哖咶哅哆咠呰咼咢咾呲哞咰垵垞垟垤垌垗垝垛垔垘垏垙垥垚垕壴复奓姡姞姮娀姱姝姺姽姼姶姤姲姷姛姩姳姵姠姾姴姭宨屌峐峘峌峗峋峛",
    ],
    [
      "cea1",
      "峞峚峉峇峊峖峓峔峏峈峆峎峟峸巹帡帢帣帠帤庰庤庢庛庣庥弇弮彖徆怷怹恔恲恞恅恓恇恉恛恌恀恂恟怤恄恘恦恮扂扃拏挍挋拵挎挃拫拹挏挌拸拶挀挓挔拺挕拻拰敁敃斪斿昶昡昲昵昜昦昢昳昫昺昝昴昹昮朏朐柁柲柈枺",
    ],
    [
      "cf40",
      "柜枻柸柘柀枷柅柫柤柟枵柍枳柷柶柮柣柂枹柎柧柰枲柼柆柭柌枮柦柛柺柉柊柃柪柋欨殂殄殶毖毘毠氠氡洨洴洭洟洼洿洒洊泚洳洄洙洺洚洑洀洝浂",
    ],
    [
      "cfa1",
      "洁洘洷洃洏浀洇洠洬洈洢洉洐炷炟炾炱炰炡炴炵炩牁牉牊牬牰牳牮狊狤狨狫狟狪狦狣玅珌珂珈珅玹玶玵玴珫玿珇玾珃珆玸珋瓬瓮甮畇畈疧疪癹盄眈眃眄眅眊盷盻盺矧矨砆砑砒砅砐砏砎砉砃砓祊祌祋祅祄秕种秏秖秎窀",
    ],
    [
      "d040",
      "穾竑笀笁籺籸籹籿粀粁紃紈紁罘羑羍羾耇耎耏耔耷胘胇胠胑胈胂胐胅胣胙胜胊胕胉胏胗胦胍臿舡芔苙苾苹茇苨茀苕茺苫苖苴苬苡苲苵茌苻苶苰苪",
    ],
    [
      "d0a1",
      "苤苠苺苳苭虷虴虼虳衁衎衧衪衩觓訄訇赲迣迡迮迠郱邽邿郕郅邾郇郋郈釔釓陔陏陑陓陊陎倞倅倇倓倢倰倛俵俴倳倷倬俶俷倗倜倠倧倵倯倱倎党冔冓凊凄凅凈凎剡剚剒剞剟剕剢勍匎厞唦哢唗唒哧哳哤唚哿唄唈哫唑唅哱",
    ],
    [
      "d140",
      "唊哻哷哸哠唎唃唋圁圂埌堲埕埒垺埆垽垼垸垶垿埇埐垹埁夎奊娙娖娭娮娕娏娗娊娞娳孬宧宭宬尃屖屔峬峿峮峱峷崀峹帩帨庨庮庪庬弳弰彧恝恚恧",
    ],
    [
      "d1a1",
      "恁悢悈悀悒悁悝悃悕悛悗悇悜悎戙扆拲挐捖挬捄捅挶捃揤挹捋捊挼挩捁挴捘捔捙挭捇挳捚捑挸捗捀捈敊敆旆旃旄旂晊晟晇晑朒朓栟栚桉栲栳栻桋桏栖栱栜栵栫栭栯桎桄栴栝栒栔栦栨栮桍栺栥栠欬欯欭欱欴歭肂殈毦毤",
    ],
    [
      "d240",
      "毨毣毢毧氥浺浣浤浶洍浡涒浘浢浭浯涑涍淯浿涆浞浧浠涗浰浼浟涂涘洯浨涋浾涀涄洖涃浻浽浵涐烜烓烑烝烋缹烢烗烒烞烠烔烍烅烆烇烚烎烡牂牸",
    ],
    [
      "d2a1",
      "牷牶猀狺狴狾狶狳狻猁珓珙珥珖玼珧珣珩珜珒珛珔珝珚珗珘珨瓞瓟瓴瓵甡畛畟疰痁疻痄痀疿疶疺皊盉眝眛眐眓眒眣眑眕眙眚眢眧砣砬砢砵砯砨砮砫砡砩砳砪砱祔祛祏祜祓祒祑秫秬秠秮秭秪秜秞秝窆窉窅窋窌窊窇竘笐",
    ],
    [
      "d340",
      "笄笓笅笏笈笊笎笉笒粄粑粊粌粈粍粅紞紝紑紎紘紖紓紟紒紏紌罜罡罞罠罝罛羖羒翃翂翀耖耾耹胺胲胹胵脁胻脀舁舯舥茳茭荄茙荑茥荖茿荁茦茜茢",
    ],
    [
      "d3a1",
      "荂荎茛茪茈茼荍茖茤茠茷茯茩荇荅荌荓茞茬荋茧荈虓虒蚢蚨蚖蚍蚑蚞蚇蚗蚆蚋蚚蚅蚥蚙蚡蚧蚕蚘蚎蚝蚐蚔衃衄衭衵衶衲袀衱衿衯袃衾衴衼訒豇豗豻貤貣赶赸趵趷趶軑軓迾迵适迿迻逄迼迶郖郠郙郚郣郟郥郘郛郗郜郤酐",
    ],
    [
      "d440",
      "酎酏釕釢釚陜陟隼飣髟鬯乿偰偪偡偞偠偓偋偝偲偈偍偁偛偊偢倕偅偟偩偫偣偤偆偀偮偳偗偑凐剫剭剬剮勖勓匭厜啵啶唼啍啐唴唪啑啢唶唵唰啒啅",
    ],
    [
      "d4a1",
      "唌唲啥啎唹啈唭唻啀啋圊圇埻堔埢埶埜埴堀埭埽堈埸堋埳埏堇埮埣埲埥埬埡堎埼堐埧堁堌埱埩埰堍堄奜婠婘婕婧婞娸娵婭婐婟婥婬婓婤婗婃婝婒婄婛婈媎娾婍娹婌婰婩婇婑婖婂婜孲孮寁寀屙崞崋崝崚崠崌崨崍崦崥崏",
    ],
    [
      "d540",
      "崰崒崣崟崮帾帴庱庴庹庲庳弶弸徛徖徟悊悐悆悾悰悺惓惔惏惤惙惝惈悱惛悷惊悿惃惍惀挲捥掊掂捽掽掞掭掝掗掫掎捯掇掐据掯捵掜捭掮捼掤挻掟",
    ],
    [
      "d5a1",
      "捸掅掁掑掍捰敓旍晥晡晛晙晜晢朘桹梇梐梜桭桮梮梫楖桯梣梬梩桵桴梲梏桷梒桼桫桲梪梀桱桾梛梖梋梠梉梤桸桻梑梌梊桽欶欳欷欸殑殏殍殎殌氪淀涫涴涳湴涬淩淢涷淶淔渀淈淠淟淖涾淥淜淝淛淴淊涽淭淰涺淕淂淏淉",
    ],
    [
      "d640",
      "淐淲淓淽淗淍淣涻烺焍烷焗烴焌烰焄烳焐烼烿焆焓焀烸烶焋焂焎牾牻牼牿猝猗猇猑猘猊猈狿猏猞玈珶珸珵琄琁珽琇琀珺珼珿琌琋珴琈畤畣痎痒痏",
    ],
    [
      "d6a1",
      "痋痌痑痐皏皉盓眹眯眭眱眲眴眳眽眥眻眵硈硒硉硍硊硌砦硅硐祤祧祩祪祣祫祡离秺秸秶秷窏窔窐笵筇笴笥笰笢笤笳笘笪笝笱笫笭笯笲笸笚笣粔粘粖粣紵紽紸紶紺絅紬紩絁絇紾紿絊紻紨罣羕羜羝羛翊翋翍翐翑翇翏翉耟",
    ],
    [
      "d740",
      "耞耛聇聃聈脘脥脙脛脭脟脬脞脡脕脧脝脢舑舸舳舺舴舲艴莐莣莨莍荺荳莤荴莏莁莕莙荵莔莩荽莃莌莝莛莪莋荾莥莯莈莗莰荿莦莇莮荶莚虙虖蚿蚷",
    ],
    [
      "d7a1",
      "蛂蛁蛅蚺蚰蛈蚹蚳蚸蛌蚴蚻蚼蛃蚽蚾衒袉袕袨袢袪袚袑袡袟袘袧袙袛袗袤袬袌袓袎覂觖觙觕訰訧訬訞谹谻豜豝豽貥赽赻赹趼跂趹趿跁軘軞軝軜軗軠軡逤逋逑逜逌逡郯郪郰郴郲郳郔郫郬郩酖酘酚酓酕釬釴釱釳釸釤釹釪",
    ],
    [
      "d840",
      "釫釷釨釮镺閆閈陼陭陫陱陯隿靪頄飥馗傛傕傔傞傋傣傃傌傎傝偨傜傒傂傇兟凔匒匑厤厧喑喨喥喭啷噅喢喓喈喏喵喁喣喒喤啽喌喦啿喕喡喎圌堩堷",
    ],
    [
      "d8a1",
      "堙堞堧堣堨埵塈堥堜堛堳堿堶堮堹堸堭堬堻奡媯媔媟婺媢媞婸媦婼媥媬媕媮娷媄媊媗媃媋媩婻婽媌媜媏媓媝寪寍寋寔寑寊寎尌尰崷嵃嵫嵁嵋崿崵嵑嵎嵕崳崺嵒崽崱嵙嵂崹嵉崸崼崲崶嵀嵅幄幁彘徦徥徫惉悹惌惢惎惄愔",
    ],
    [
      "d940",
      "惲愊愖愅惵愓惸惼惾惁愃愘愝愐惿愄愋扊掔掱掰揎揥揨揯揃撝揳揊揠揶揕揲揵摡揟掾揝揜揄揘揓揂揇揌揋揈揰揗揙攲敧敪敤敜敨敥斌斝斞斮旐旒",
    ],
    [
      "d9a1",
      "晼晬晻暀晱晹晪晲朁椌棓椄棜椪棬棪棱椏棖棷棫棤棶椓椐棳棡椇棌椈楰梴椑棯棆椔棸棐棽棼棨椋椊椗棎棈棝棞棦棴棑椆棔棩椕椥棇欹欻欿欼殔殗殙殕殽毰毲毳氰淼湆湇渟湉溈渼渽湅湢渫渿湁湝湳渜渳湋湀湑渻渃渮湞",
    ],
    [
      "da40",
      "湨湜湡渱渨湠湱湫渹渢渰湓湥渧湸湤湷湕湹湒湦渵渶湚焠焞焯烻焮焱焣焥焢焲焟焨焺焛牋牚犈犉犆犅犋猒猋猰猢猱猳猧猲猭猦猣猵猌琮琬琰琫琖",
    ],
    [
      "daa1",
      "琚琡琭琱琤琣琝琩琠琲瓻甯畯畬痧痚痡痦痝痟痤痗皕皒盚睆睇睄睍睅睊睎睋睌矞矬硠硤硥硜硭硱硪确硰硩硨硞硢祴祳祲祰稂稊稃稌稄窙竦竤筊笻筄筈筌筎筀筘筅粢粞粨粡絘絯絣絓絖絧絪絏絭絜絫絒絔絩絑絟絎缾缿罥",
    ],
    [
      "db40",
      "罦羢羠羡翗聑聏聐胾胔腃腊腒腏腇脽腍脺臦臮臷臸臹舄舼舽舿艵茻菏菹萣菀菨萒菧菤菼菶萐菆菈菫菣莿萁菝菥菘菿菡菋菎菖菵菉萉萏菞萑萆菂菳",
    ],
    [
      "dba1",
      "菕菺菇菑菪萓菃菬菮菄菻菗菢萛菛菾蛘蛢蛦蛓蛣蛚蛪蛝蛫蛜蛬蛩蛗蛨蛑衈衖衕袺裗袹袸裀袾袶袼袷袽袲褁裉覕覘覗觝觚觛詎詍訹詙詀詗詘詄詅詒詈詑詊詌詏豟貁貀貺貾貰貹貵趄趀趉跘跓跍跇跖跜跏跕跙跈跗跅軯軷軺",
    ],
    [
      "dc40",
      "軹軦軮軥軵軧軨軶軫軱軬軴軩逭逴逯鄆鄬鄄郿郼鄈郹郻鄁鄀鄇鄅鄃酡酤酟酢酠鈁鈊鈥鈃鈚鈦鈏鈌鈀鈒釿釽鈆鈄鈧鈂鈜鈤鈙鈗鈅鈖镻閍閌閐隇陾隈",
    ],
    [
      "dca1",
      "隉隃隀雂雈雃雱雰靬靰靮頇颩飫鳦黹亃亄亶傽傿僆傮僄僊傴僈僂傰僁傺傱僋僉傶傸凗剺剸剻剼嗃嗛嗌嗐嗋嗊嗝嗀嗔嗄嗩喿嗒喍嗏嗕嗢嗖嗈嗲嗍嗙嗂圔塓塨塤塏塍塉塯塕塎塝塙塥塛堽塣塱壼嫇嫄嫋媺媸媱媵媰媿嫈媻嫆",
    ],
    [
      "dd40",
      "媷嫀嫊媴媶嫍媹媐寖寘寙尟尳嵱嵣嵊嵥嵲嵬嵞嵨嵧嵢巰幏幎幊幍幋廅廌廆廋廇彀徯徭惷慉慊愫慅愶愲愮慆愯慏愩慀戠酨戣戥戤揅揱揫搐搒搉搠搤",
    ],
    [
      "dda1",
      "搳摃搟搕搘搹搷搢搣搌搦搰搨摁搵搯搊搚摀搥搧搋揧搛搮搡搎敯斒旓暆暌暕暐暋暊暙暔晸朠楦楟椸楎楢楱椿楅楪椹楂楗楙楺楈楉椵楬椳椽楥棰楸椴楩楀楯楄楶楘楁楴楌椻楋椷楜楏楑椲楒椯楻椼歆歅歃歂歈歁殛嗀毻毼",
    ],
    [
      "de40",
      "毹毷毸溛滖滈溏滀溟溓溔溠溱溹滆滒溽滁溞滉溷溰滍溦滏溲溾滃滜滘溙溒溎溍溤溡溿溳滐滊溗溮溣煇煔煒煣煠煁煝煢煲煸煪煡煂煘煃煋煰煟煐煓",
    ],
    [
      "dea1",
      "煄煍煚牏犍犌犑犐犎猼獂猻猺獀獊獉瑄瑊瑋瑒瑑瑗瑀瑏瑐瑎瑂瑆瑍瑔瓡瓿瓾瓽甝畹畷榃痯瘏瘃痷痾痼痹痸瘐痻痶痭痵痽皙皵盝睕睟睠睒睖睚睩睧睔睙睭矠碇碚碔碏碄碕碅碆碡碃硹碙碀碖硻祼禂祽祹稑稘稙稒稗稕稢稓",
    ],
    [
      "df40",
      "稛稐窣窢窞竫筦筤筭筴筩筲筥筳筱筰筡筸筶筣粲粴粯綈綆綀綍絿綅絺綎絻綃絼綌綔綄絽綒罭罫罧罨罬羦羥羧翛翜耡腤腠腷腜腩腛腢腲朡腞腶腧腯",
    ],
    [
      "dfa1",
      "腄腡舝艉艄艀艂艅蓱萿葖葶葹蒏蒍葥葑葀蒆葧萰葍葽葚葙葴葳葝蔇葞萷萺萴葺葃葸萲葅萩菙葋萯葂萭葟葰萹葎葌葒葯蓅蒎萻葇萶萳葨葾葄萫葠葔葮葐蜋蜄蛷蜌蛺蛖蛵蝍蛸蜎蜉蜁蛶蜍蜅裖裋裍裎裞裛裚裌裐覅覛觟觥觤",
    ],
    [
      "e040",
      "觡觠觢觜触詶誆詿詡訿詷誂誄詵誃誁詴詺谼豋豊豥豤豦貆貄貅賌赨赩趑趌趎趏趍趓趔趐趒跰跠跬跱跮跐跩跣跢跧跲跫跴輆軿輁輀輅輇輈輂輋遒逿",
    ],
    [
      "e0a1",
      "遄遉逽鄐鄍鄏鄑鄖鄔鄋鄎酮酯鉈鉒鈰鈺鉦鈳鉥鉞銃鈮鉊鉆鉭鉬鉏鉠鉧鉯鈶鉡鉰鈱鉔鉣鉐鉲鉎鉓鉌鉖鈲閟閜閞閛隒隓隑隗雎雺雽雸雵靳靷靸靲頏頍頎颬飶飹馯馲馰馵骭骫魛鳪鳭鳧麀黽僦僔僗僨僳僛僪僝僤僓僬僰僯僣僠",
    ],
    [
      "e140",
      "凘劀劁勩勫匰厬嘧嘕嘌嘒嗼嘏嘜嘁嘓嘂嗺嘝嘄嗿嗹墉塼墐墘墆墁塿塴墋塺墇墑墎塶墂墈塻墔墏壾奫嫜嫮嫥嫕嫪嫚嫭嫫嫳嫢嫠嫛嫬嫞嫝嫙嫨嫟孷寠",
    ],
    [
      "e1a1",
      "寣屣嶂嶀嵽嶆嵺嶁嵷嶊嶉嶈嵾嵼嶍嵹嵿幘幙幓廘廑廗廎廜廕廙廒廔彄彃彯徶愬愨慁慞慱慳慒慓慲慬憀慴慔慺慛慥愻慪慡慖戩戧戫搫摍摛摝摴摶摲摳摽摵摦撦摎撂摞摜摋摓摠摐摿搿摬摫摙摥摷敳斠暡暠暟朅朄朢榱榶槉",
    ],
    [
      "e240",
      "榠槎榖榰榬榼榑榙榎榧榍榩榾榯榿槄榽榤槔榹槊榚槏榳榓榪榡榞槙榗榐槂榵榥槆歊歍歋殞殟殠毃毄毾滎滵滱漃漥滸漷滻漮漉潎漙漚漧漘漻漒滭漊",
    ],
    [
      "e2a1",
      "漶潳滹滮漭潀漰漼漵滫漇漎潃漅滽滶漹漜滼漺漟漍漞漈漡熇熐熉熀熅熂熏煻熆熁熗牄牓犗犕犓獃獍獑獌瑢瑳瑱瑵瑲瑧瑮甀甂甃畽疐瘖瘈瘌瘕瘑瘊瘔皸瞁睼瞅瞂睮瞀睯睾瞃碲碪碴碭碨硾碫碞碥碠碬碢碤禘禊禋禖禕禔禓",
    ],
    [
      "e340",
      "禗禈禒禐稫穊稰稯稨稦窨窫窬竮箈箜箊箑箐箖箍箌箛箎箅箘劄箙箤箂粻粿粼粺綧綷緂綣綪緁緀緅綝緎緄緆緋緌綯綹綖綼綟綦綮綩綡緉罳翢翣翥翞",
    ],
    [
      "e3a1",
      "耤聝聜膉膆膃膇膍膌膋舕蒗蒤蒡蒟蒺蓎蓂蒬蒮蒫蒹蒴蓁蓍蒪蒚蒱蓐蒝蒧蒻蒢蒔蓇蓌蒛蒩蒯蒨蓖蒘蒶蓏蒠蓗蓔蓒蓛蒰蒑虡蜳蜣蜨蝫蝀蜮蜞蜡蜙蜛蝃蜬蝁蜾蝆蜠蜲蜪蜭蜼蜒蜺蜱蜵蝂蜦蜧蜸蜤蜚蜰蜑裷裧裱裲裺裾裮裼裶裻",
    ],
    [
      "e440",
      "裰裬裫覝覡覟覞觩觫觨誫誙誋誒誏誖谽豨豩賕賏賗趖踉踂跿踍跽踊踃踇踆踅跾踀踄輐輑輎輍鄣鄜鄠鄢鄟鄝鄚鄤鄡鄛酺酲酹酳銥銤鉶銛鉺銠銔銪銍",
    ],
    [
      "e4a1",
      "銦銚銫鉹銗鉿銣鋮銎銂銕銢鉽銈銡銊銆銌銙銧鉾銇銩銝銋鈭隞隡雿靘靽靺靾鞃鞀鞂靻鞄鞁靿韎韍頖颭颮餂餀餇馝馜駃馹馻馺駂馽駇骱髣髧鬾鬿魠魡魟鳱鳲鳵麧僿儃儰僸儆儇僶僾儋儌僽儊劋劌勱勯噈噂噌嘵噁噊噉噆噘",
    ],
    [
      "e540",
      "噚噀嘳嘽嘬嘾嘸嘪嘺圚墫墝墱墠墣墯墬墥墡壿嫿嫴嫽嫷嫶嬃嫸嬂嫹嬁嬇嬅嬏屧嶙嶗嶟嶒嶢嶓嶕嶠嶜嶡嶚嶞幩幝幠幜緳廛廞廡彉徲憋憃慹憱憰憢憉",
    ],
    [
      "e5a1",
      "憛憓憯憭憟憒憪憡憍慦憳戭摮摰撖撠撅撗撜撏撋撊撌撣撟摨撱撘敶敺敹敻斲斳暵暰暩暲暷暪暯樀樆樗槥槸樕槱槤樠槿槬槢樛樝槾樧槲槮樔槷槧橀樈槦槻樍槼槫樉樄樘樥樏槶樦樇槴樖歑殥殣殢殦氁氀毿氂潁漦潾澇濆澒",
    ],
    [
      "e640",
      "澍澉澌潢潏澅潚澖潶潬澂潕潲潒潐潗澔澓潝漀潡潫潽潧澐潓澋潩潿澕潣潷潪潻熲熯熛熰熠熚熩熵熝熥熞熤熡熪熜熧熳犘犚獘獒獞獟獠獝獛獡獚獙",
    ],
    [
      "e6a1",
      "獢璇璉璊璆璁瑽璅璈瑼瑹甈甇畾瘥瘞瘙瘝瘜瘣瘚瘨瘛皜皝皞皛瞍瞏瞉瞈磍碻磏磌磑磎磔磈磃磄磉禚禡禠禜禢禛歶稹窲窴窳箷篋箾箬篎箯箹篊箵糅糈糌糋緷緛緪緧緗緡縃緺緦緶緱緰緮緟罶羬羰羭翭翫翪翬翦翨聤聧膣膟",
    ],
    [
      "e740",
      "膞膕膢膙膗舖艏艓艒艐艎艑蔤蔻蔏蔀蔩蔎蔉蔍蔟蔊蔧蔜蓻蔫蓺蔈蔌蓴蔪蓲蔕蓷蓫蓳蓼蔒蓪蓩蔖蓾蔨蔝蔮蔂蓽蔞蓶蔱蔦蓧蓨蓰蓯蓹蔘蔠蔰蔋蔙蔯虢",
    ],
    [
      "e7a1",
      "蝖蝣蝤蝷蟡蝳蝘蝔蝛蝒蝡蝚蝑蝞蝭蝪蝐蝎蝟蝝蝯蝬蝺蝮蝜蝥蝏蝻蝵蝢蝧蝩衚褅褌褔褋褗褘褙褆褖褑褎褉覢覤覣觭觰觬諏諆誸諓諑諔諕誻諗誾諀諅諘諃誺誽諙谾豍貏賥賟賙賨賚賝賧趠趜趡趛踠踣踥踤踮踕踛踖踑踙踦踧",
    ],
    [
      "e840",
      "踔踒踘踓踜踗踚輬輤輘輚輠輣輖輗遳遰遯遧遫鄯鄫鄩鄪鄲鄦鄮醅醆醊醁醂醄醀鋐鋃鋄鋀鋙銶鋏鋱鋟鋘鋩鋗鋝鋌鋯鋂鋨鋊鋈鋎鋦鋍鋕鋉鋠鋞鋧鋑鋓",
    ],
    [
      "e8a1",
      "銵鋡鋆銴镼閬閫閮閰隤隢雓霅霈霂靚鞊鞎鞈韐韏頞頝頦頩頨頠頛頧颲餈飺餑餔餖餗餕駜駍駏駓駔駎駉駖駘駋駗駌骳髬髫髳髲髱魆魃魧魴魱魦魶魵魰魨魤魬鳼鳺鳽鳿鳷鴇鴀鳹鳻鴈鴅鴄麃黓鼏鼐儜儓儗儚儑凞匴叡噰噠噮",
    ],
    [
      "e940",
      "噳噦噣噭噲噞噷圜圛壈墽壉墿墺壂墼壆嬗嬙嬛嬡嬔嬓嬐嬖嬨嬚嬠嬞寯嶬嶱嶩嶧嶵嶰嶮嶪嶨嶲嶭嶯嶴幧幨幦幯廩廧廦廨廥彋徼憝憨憖懅憴懆懁懌憺",
    ],
    [
      "e9a1",
      "憿憸憌擗擖擐擏擉撽撉擃擛擳擙攳敿敼斢曈暾曀曊曋曏暽暻暺曌朣樴橦橉橧樲橨樾橝橭橶橛橑樨橚樻樿橁橪橤橐橏橔橯橩橠樼橞橖橕橍橎橆歕歔歖殧殪殫毈毇氄氃氆澭濋澣濇澼濎濈潞濄澽澞濊澨瀄澥澮澺澬澪濏澿澸",
    ],
    [
      "ea40",
      "澢濉澫濍澯澲澰燅燂熿熸燖燀燁燋燔燊燇燏熽燘熼燆燚燛犝犞獩獦獧獬獥獫獪瑿璚璠璔璒璕璡甋疀瘯瘭瘱瘽瘳瘼瘵瘲瘰皻盦瞚瞝瞡瞜瞛瞢瞣瞕瞙",
    ],
    [
      "eaa1",
      "瞗磝磩磥磪磞磣磛磡磢磭磟磠禤穄穈穇窶窸窵窱窷篞篣篧篝篕篥篚篨篹篔篪篢篜篫篘篟糒糔糗糐糑縒縡縗縌縟縠縓縎縜縕縚縢縋縏縖縍縔縥縤罃罻罼罺羱翯耪耩聬膱膦膮膹膵膫膰膬膴膲膷膧臲艕艖艗蕖蕅蕫蕍蕓蕡蕘",
    ],
    [
      "eb40",
      "蕀蕆蕤蕁蕢蕄蕑蕇蕣蔾蕛蕱蕎蕮蕵蕕蕧蕠薌蕦蕝蕔蕥蕬虣虥虤螛螏螗螓螒螈螁螖螘蝹螇螣螅螐螑螝螄螔螜螚螉褞褦褰褭褮褧褱褢褩褣褯褬褟觱諠",
    ],
    [
      "eba1",
      "諢諲諴諵諝謔諤諟諰諈諞諡諨諿諯諻貑貒貐賵賮賱賰賳赬赮趥趧踳踾踸蹀蹅踶踼踽蹁踰踿躽輶輮輵輲輹輷輴遶遹遻邆郺鄳鄵鄶醓醐醑醍醏錧錞錈錟錆錏鍺錸錼錛錣錒錁鍆錭錎錍鋋錝鋺錥錓鋹鋷錴錂錤鋿錩錹錵錪錔錌",
    ],
    [
      "ec40",
      "錋鋾錉錀鋻錖閼闍閾閹閺閶閿閵閽隩雔霋霒霐鞙鞗鞔韰韸頵頯頲餤餟餧餩馞駮駬駥駤駰駣駪駩駧骹骿骴骻髶髺髹髷鬳鮀鮅鮇魼魾魻鮂鮓鮒鮐魺鮕",
    ],
    [
      "eca1",
      "魽鮈鴥鴗鴠鴞鴔鴩鴝鴘鴢鴐鴙鴟麈麆麇麮麭黕黖黺鼒鼽儦儥儢儤儠儩勴嚓嚌嚍嚆嚄嚃噾嚂噿嚁壖壔壏壒嬭嬥嬲嬣嬬嬧嬦嬯嬮孻寱寲嶷幬幪徾徻懃憵憼懧懠懥懤懨懞擯擩擣擫擤擨斁斀斶旚曒檍檖檁檥檉檟檛檡檞檇檓檎",
    ],
    [
      "ed40",
      "檕檃檨檤檑橿檦檚檅檌檒歛殭氉濌澩濴濔濣濜濭濧濦濞濲濝濢濨燡燱燨燲燤燰燢獳獮獯璗璲璫璐璪璭璱璥璯甐甑甒甏疄癃癈癉癇皤盩瞵瞫瞲瞷瞶",
    ],
    [
      "eda1",
      "瞴瞱瞨矰磳磽礂磻磼磲礅磹磾礄禫禨穜穛穖穘穔穚窾竀竁簅簏篲簀篿篻簎篴簋篳簂簉簃簁篸篽簆篰篱簐簊糨縭縼繂縳顈縸縪繉繀繇縩繌縰縻縶繄縺罅罿罾罽翴翲耬膻臄臌臊臅臇膼臩艛艚艜薃薀薏薧薕薠薋薣蕻薤薚薞",
    ],
    [
      "ee40",
      "蕷蕼薉薡蕺蕸蕗薎薖薆薍薙薝薁薢薂薈薅蕹蕶薘薐薟虨螾螪螭蟅螰螬螹螵螼螮蟉蟃蟂蟌螷螯蟄蟊螴螶螿螸螽蟞螲褵褳褼褾襁襒褷襂覭覯覮觲觳謞",
    ],
    [
      "eea1",
      "謘謖謑謅謋謢謏謒謕謇謍謈謆謜謓謚豏豰豲豱豯貕貔賹赯蹎蹍蹓蹐蹌蹇轃轀邅遾鄸醚醢醛醙醟醡醝醠鎡鎃鎯鍤鍖鍇鍼鍘鍜鍶鍉鍐鍑鍠鍭鎏鍌鍪鍹鍗鍕鍒鍏鍱鍷鍻鍡鍞鍣鍧鎀鍎鍙闇闀闉闃闅閷隮隰隬霠霟霘霝霙鞚鞡鞜",
    ],
    [
      "ef40",
      "鞞鞝韕韔韱顁顄顊顉顅顃餥餫餬餪餳餲餯餭餱餰馘馣馡騂駺駴駷駹駸駶駻駽駾駼騃骾髾髽鬁髼魈鮚鮨鮞鮛鮦鮡鮥鮤鮆鮢鮠鮯鴳鵁鵧鴶鴮鴯鴱鴸鴰",
    ],
    [
      "efa1",
      "鵅鵂鵃鴾鴷鵀鴽翵鴭麊麉麍麰黈黚黻黿鼤鼣鼢齔龠儱儭儮嚘嚜嚗嚚嚝嚙奰嬼屩屪巀幭幮懘懟懭懮懱懪懰懫懖懩擿攄擽擸攁攃擼斔旛曚曛曘櫅檹檽櫡櫆檺檶檷櫇檴檭歞毉氋瀇瀌瀍瀁瀅瀔瀎濿瀀濻瀦濼濷瀊爁燿燹爃燽獶",
    ],
    [
      "f040",
      "璸瓀璵瓁璾璶璻瓂甔甓癜癤癙癐癓癗癚皦皽盬矂瞺磿礌礓礔礉礐礒礑禭禬穟簜簩簙簠簟簭簝簦簨簢簥簰繜繐繖繣繘繢繟繑繠繗繓羵羳翷翸聵臑臒",
    ],
    [
      "f0a1",
      "臐艟艞薴藆藀藃藂薳薵薽藇藄薿藋藎藈藅薱薶藒蘤薸薷薾虩蟧蟦蟢蟛蟫蟪蟥蟟蟳蟤蟔蟜蟓蟭蟘蟣螤蟗蟙蠁蟴蟨蟝襓襋襏襌襆襐襑襉謪謧謣謳謰謵譇謯謼謾謱謥謷謦謶謮謤謻謽謺豂豵貙貘貗賾贄贂贀蹜蹢蹠蹗蹖蹞蹥蹧",
    ],
    [
      "f140",
      "蹛蹚蹡蹝蹩蹔轆轇轈轋鄨鄺鄻鄾醨醥醧醯醪鎵鎌鎒鎷鎛鎝鎉鎧鎎鎪鎞鎦鎕鎈鎙鎟鎍鎱鎑鎲鎤鎨鎴鎣鎥闒闓闑隳雗雚巂雟雘雝霣霢霥鞬鞮鞨鞫鞤鞪",
    ],
    [
      "f1a1",
      "鞢鞥韗韙韖韘韺顐顑顒颸饁餼餺騏騋騉騍騄騑騊騅騇騆髀髜鬈鬄鬅鬩鬵魊魌魋鯇鯆鯃鮿鯁鮵鮸鯓鮶鯄鮹鮽鵜鵓鵏鵊鵛鵋鵙鵖鵌鵗鵒鵔鵟鵘鵚麎麌黟鼁鼀鼖鼥鼫鼪鼩鼨齌齕儴儵劖勷厴嚫嚭嚦嚧嚪嚬壚壝壛夒嬽嬾嬿巃幰",
    ],
    [
      "f240",
      "徿懻攇攐攍攉攌攎斄旞旝曞櫧櫠櫌櫑櫙櫋櫟櫜櫐櫫櫏櫍櫞歠殰氌瀙瀧瀠瀖瀫瀡瀢瀣瀩瀗瀤瀜瀪爌爊爇爂爅犥犦犤犣犡瓋瓅璷瓃甖癠矉矊矄矱礝礛",
    ],
    [
      "f2a1",
      "礡礜礗礞禰穧穨簳簼簹簬簻糬糪繶繵繸繰繷繯繺繲繴繨罋罊羃羆羷翽翾聸臗臕艤艡艣藫藱藭藙藡藨藚藗藬藲藸藘藟藣藜藑藰藦藯藞藢蠀蟺蠃蟶蟷蠉蠌蠋蠆蟼蠈蟿蠊蠂襢襚襛襗襡襜襘襝襙覈覷覶觶譐譈譊譀譓譖譔譋譕",
    ],
    [
      "f340",
      "譑譂譒譗豃豷豶貚贆贇贉趬趪趭趫蹭蹸蹳蹪蹯蹻軂轒轑轏轐轓辴酀鄿醰醭鏞鏇鏏鏂鏚鏐鏹鏬鏌鏙鎩鏦鏊鏔鏮鏣鏕鏄鏎鏀鏒鏧镽闚闛雡霩霫霬霨霦",
    ],
    [
      "f3a1",
      "鞳鞷鞶韝韞韟顜顙顝顗颿颽颻颾饈饇饃馦馧騚騕騥騝騤騛騢騠騧騣騞騜騔髂鬋鬊鬎鬌鬷鯪鯫鯠鯞鯤鯦鯢鯰鯔鯗鯬鯜鯙鯥鯕鯡鯚鵷鶁鶊鶄鶈鵱鶀鵸鶆鶋鶌鵽鵫鵴鵵鵰鵩鶅鵳鵻鶂鵯鵹鵿鶇鵨麔麑黀黼鼭齀齁齍齖齗齘匷嚲",
    ],
    [
      "f440",
      "嚵嚳壣孅巆巇廮廯忀忁懹攗攖攕攓旟曨曣曤櫳櫰櫪櫨櫹櫱櫮櫯瀼瀵瀯瀷瀴瀱灂瀸瀿瀺瀹灀瀻瀳灁爓爔犨獽獼璺皫皪皾盭矌矎矏矍矲礥礣礧礨礤礩",
    ],
    [
      "f4a1",
      "禲穮穬穭竷籉籈籊籇籅糮繻繾纁纀羺翿聹臛臙舋艨艩蘢藿蘁藾蘛蘀藶蘄蘉蘅蘌藽蠙蠐蠑蠗蠓蠖襣襦覹觷譠譪譝譨譣譥譧譭趮躆躈躄轙轖轗轕轘轚邍酃酁醷醵醲醳鐋鐓鏻鐠鐏鐔鏾鐕鐐鐨鐙鐍鏵鐀鏷鐇鐎鐖鐒鏺鐉鏸鐊鏿",
    ],
    [
      "f540",
      "鏼鐌鏶鐑鐆闞闠闟霮霯鞹鞻韽韾顠顢顣顟飁飂饐饎饙饌饋饓騲騴騱騬騪騶騩騮騸騭髇髊髆鬐鬒鬑鰋鰈鯷鰅鰒鯸鱀鰇鰎鰆鰗鰔鰉鶟鶙鶤鶝鶒鶘鶐鶛",
    ],
    [
      "f5a1",
      "鶠鶔鶜鶪鶗鶡鶚鶢鶨鶞鶣鶿鶩鶖鶦鶧麙麛麚黥黤黧黦鼰鼮齛齠齞齝齙龑儺儹劘劗囃嚽嚾孈孇巋巏廱懽攛欂櫼欃櫸欀灃灄灊灈灉灅灆爝爚爙獾甗癪矐礭礱礯籔籓糲纊纇纈纋纆纍罍羻耰臝蘘蘪蘦蘟蘣蘜蘙蘧蘮蘡蘠蘩蘞蘥",
    ],
    [
      "f640",
      "蠩蠝蠛蠠蠤蠜蠫衊襭襩襮襫觺譹譸譅譺譻贐贔趯躎躌轞轛轝酆酄酅醹鐿鐻鐶鐩鐽鐼鐰鐹鐪鐷鐬鑀鐱闥闤闣霵霺鞿韡顤飉飆飀饘饖騹騽驆驄驂驁騺",
    ],
    [
      "f6a1",
      "騿髍鬕鬗鬘鬖鬺魒鰫鰝鰜鰬鰣鰨鰩鰤鰡鶷鶶鶼鷁鷇鷊鷏鶾鷅鷃鶻鶵鷎鶹鶺鶬鷈鶱鶭鷌鶳鷍鶲鹺麜黫黮黭鼛鼘鼚鼱齎齥齤龒亹囆囅囋奱孋孌巕巑廲攡攠攦攢欋欈欉氍灕灖灗灒爞爟犩獿瓘瓕瓙瓗癭皭礵禴穰穱籗籜籙籛籚",
    ],
    [
      "f740",
      "糴糱纑罏羇臞艫蘴蘵蘳蘬蘲蘶蠬蠨蠦蠪蠥襱覿覾觻譾讄讂讆讅譿贕躕躔躚躒躐躖躗轠轢酇鑌鑐鑊鑋鑏鑇鑅鑈鑉鑆霿韣顪顩飋饔饛驎驓驔驌驏驈驊",
    ],
    [
      "f7a1",
      "驉驒驐髐鬙鬫鬻魖魕鱆鱈鰿鱄鰹鰳鱁鰼鰷鰴鰲鰽鰶鷛鷒鷞鷚鷋鷐鷜鷑鷟鷩鷙鷘鷖鷵鷕鷝麶黰鼵鼳鼲齂齫龕龢儽劙壨壧奲孍巘蠯彏戁戃戄攩攥斖曫欑欒欏毊灛灚爢玂玁玃癰矔籧籦纕艬蘺虀蘹蘼蘱蘻蘾蠰蠲蠮蠳襶襴襳觾",
    ],
    [
      "f840",
      "讌讎讋讈豅贙躘轤轣醼鑢鑕鑝鑗鑞韄韅頀驖驙鬞鬟鬠鱒鱘鱐鱊鱍鱋鱕鱙鱌鱎鷻鷷鷯鷣鷫鷸鷤鷶鷡鷮鷦鷲鷰鷢鷬鷴鷳鷨鷭黂黐黲黳鼆鼜鼸鼷鼶齃齏",
    ],
    [
      "f8a1",
      "齱齰齮齯囓囍孎屭攭曭曮欓灟灡灝灠爣瓛瓥矕礸禷禶籪纗羉艭虃蠸蠷蠵衋讔讕躞躟躠躝醾醽釂鑫鑨鑩雥靆靃靇韇韥驞髕魙鱣鱧鱦鱢鱞鱠鸂鷾鸇鸃鸆鸅鸀鸁鸉鷿鷽鸄麠鼞齆齴齵齶囔攮斸欘欙欗欚灢爦犪矘矙礹籩籫糶纚",
    ],
    [
      "f940",
      "纘纛纙臠臡虆虇虈襹襺襼襻觿讘讙躥躤躣鑮鑭鑯鑱鑳靉顲饟鱨鱮鱭鸋鸍鸐鸏鸒鸑麡黵鼉齇齸齻齺齹圞灦籯蠼趲躦釃鑴鑸鑶鑵驠鱴鱳鱱鱵鸔鸓黶鼊",
    ],
    [
      "f9a1",
      "龤灨灥糷虪蠾蠽蠿讞貜躩軉靋顳顴飌饡馫驤驦驧鬤鸕鸗齈戇欞爧虌躨钂钀钁驩驨鬮鸙爩虋讟钃鱹麷癵驫鱺鸝灩灪麤齾齉龘碁銹裏墻恒粧嫺╔╦╗╠╬╣╚╩╝╒╤╕╞╪╡╘╧╛╓╥╖╟╫╢╙╨╜║═╭╮╰╯▓",
    ],
  ],
  TN = [
    [
      "8740",
      "䏰䰲䘃䖦䕸𧉧䵷䖳𧲱䳢𧳅㮕䜶䝄䱇䱀𤊿𣘗𧍒𦺋𧃒䱗𪍑䝏䗚䲅𧱬䴇䪤䚡𦬣爥𥩔𡩣𣸆𣽡晍囻",
    ],
    ["8767", "綕夝𨮹㷴霴𧯯寛𡵞媤㘥𩺰嫑宷峼杮薓𩥅瑡璝㡵𡵓𣚞𦀡㻬"],
    [
      "87a1",
      "𥣞㫵竼龗𤅡𨤍𣇪𠪊𣉞䌊蒄龖鐯䤰蘓墖靊鈘秐稲晠権袝瑌篅枂稬剏遆㓦珄𥶹瓆鿇垳䤯呌䄱𣚎堘穲𧭥讏䚮𦺈䆁𥶙箮𢒼鿈𢓁𢓉𢓌鿉蔄𣖻䂴鿊䓡𪷿拁灮鿋",
    ],
    [
      "8840",
      "㇀",
      4,
      "𠄌㇅𠃑𠃍㇆㇇𠃋𡿨㇈𠃊㇉㇊㇋㇌𠄎㇍㇎ĀÁǍÀĒÉĚÈŌÓǑÒ࿿Ê̄Ế࿿Ê̌ỀÊāáǎàɑēéěèīíǐìōóǒòūúǔùǖǘǚ",
    ],
    ["88a1", "ǜü࿿ê̄ế࿿ê̌ềêɡ⏚⏛"],
    ["8940", "𪎩𡅅"],
    ["8943", "攊"],
    ["8946", "丽滝鵎釟"],
    [
      "894c",
      "𧜵撑会伨侨兖兴农凤务动医华发变团声处备夲头学实実岚庆总斉柾栄桥济炼电纤纬纺织经统缆缷艺苏药视设询车轧轮",
    ],
    ["89a1", "琑糼緍楆竉刧"],
    ["89ab", "醌碸酞肼"],
    ["89b0", "贋胶𠧧"],
    ["89b5", "肟黇䳍鷉鸌䰾𩷶𧀎鸊𪄳㗁"],
    ["89c1", "溚舾甙"],
    [
      "89c5",
      "䤑马骏龙禇𨑬𡷊𠗐𢫦两亁亀亇亿仫伷㑌侽㹈倃傈㑽㒓㒥円夅凛凼刅争剹劐匧㗇厩㕑厰㕓参吣㕭㕲㚁咓咣咴咹哐哯唘唣唨㖘唿㖥㖿嗗㗅",
    ],
    ["8a40", "𧶄唥"],
    [
      "8a43",
      "𠱂𠴕𥄫喐𢳆㧬𠍁蹆𤶸𩓥䁓𨂾睺𢰸㨴䟕𨅝𦧲𤷪擝𠵼𠾴𠳕𡃴撍蹾𠺖𠰋𠽤𢲩𨉖𤓓",
    ],
    ["8a64", "𠵆𩩍𨃩䟴𤺧𢳂骲㩧𩗴㿭㔆𥋇𩟔𧣈𢵄鵮頕"],
    ["8a76", "䏙𦂥撴哣𢵌𢯊𡁷㧻𡁯"],
    ["8aa1", "𦛚𦜖𧦠擪𥁒𠱃蹨𢆡𨭌𠜱"],
    ["8aac", "䠋𠆩㿺塳𢶍"],
    ["8ab2", "𤗈𠓼𦂗𠽌𠶖啹䂻䎺"],
    ["8abb", "䪴𢩦𡂝膪飵𠶜捹㧾𢝵跀嚡摼㹃"],
    ["8ac9", "𪘁𠸉𢫏𢳉"],
    ["8ace", "𡃈𣧂㦒㨆𨊛㕸𥹉𢃇噒𠼱𢲲𩜠㒼氽𤸻"],
    ["8adf", "𧕴𢺋𢈈𪙛𨳍𠹺𠰴𦠜羓𡃏𢠃𢤹㗻𥇣𠺌𠾍𠺪㾓𠼰𠵇𡅏𠹌"],
    ["8af6", "𠺫𠮩𠵈𡃀𡄽㿹𢚖搲𠾭"],
    ["8b40", "𣏴𧘹𢯎𠵾𠵿𢱑𢱕㨘𠺘𡃇𠼮𪘲𦭐𨳒𨶙𨳊閪哌苄喹"],
    [
      "8b55",
      "𩻃鰦骶𧝞𢷮煀腭胬尜𦕲脴㞗卟𨂽醶𠻺𠸏𠹷𠻻㗝𤷫㘉𠳖嚯𢞵𡃉𠸐𠹸𡁸𡅈𨈇𡑕𠹹𤹐𢶤婔𡀝𡀞𡃵𡃶垜𠸑",
    ],
    [
      "8ba1",
      "𧚔𨋍𠾵𠹻𥅾㜃𠾶𡆀𥋘𪊽𤧚𡠺𤅷𨉼墙剨㘚𥜽箲孨䠀䬬鼧䧧鰟鮍𥭴𣄽嗻㗲嚉丨夂𡯁屮靑𠂆乛亻㔾尣彑忄㣺扌攵歺氵氺灬爫丬犭𤣩罒礻糹罓𦉪㓁",
    ],
    [
      "8bde",
      "𦍋耂肀𦘒𦥑卝衤见𧢲讠贝钅镸长门𨸏韦页风飞饣𩠐鱼鸟黄歯龜丷𠂇阝户钢",
    ],
    [
      "8c40",
      "倻淾𩱳龦㷉袏𤅎灷峵䬠𥇍㕙𥴰愢𨨲辧釶熑朙玺𣊁𪄇㲋𡦀䬐磤琂冮𨜏䀉橣𪊺䈣蘏𠩯稪𩥇𨫪靕灍匤𢁾鏴盙𨧣龧矝亣俰傼丯众龨吴綋墒壐𡶶庒庙忂𢜒斋",
    ],
    ["8ca1", "𣏹椙橃𣱣泿"],
    ["8ca7", "爀𤔅玌㻛𤨓嬕璹讃𥲤𥚕窓篬糃繬苸薗龩袐龪躹龫迏蕟駠鈡龬𨶹𡐿䁱䊢娚"],
    ["8cc9", "顨杫䉶圽"],
    ["8cce", "藖𤥻芿𧄍䲁𦵴嵻𦬕𦾾龭龮宖龯曧繛湗秊㶈䓃𣉖𢞖䎚䔶"],
    ["8ce6", "峕𣬚諹屸㴒𣕑嵸龲煗䕘𤃬𡸣䱷㥸㑊𠆤𦱁諌侴𠈹妿腬顖𩣺弻"],
    ["8d40", "𠮟"],
    [
      "8d42",
      "𢇁𨥭䄂䚻𩁹㼇龳𪆵䃸㟖䛷𦱆䅼𨚲𧏿䕭㣔𥒚䕡䔛䶉䱻䵶䗪㿈𤬏㙡䓞䒽䇭崾嵈嵖㷼㠏嶤嶹㠠㠸幂庽弥徃㤈㤔㤿㥍惗愽峥㦉憷憹懏㦸戬抐拥挘㧸嚱",
    ],
    [
      "8da1",
      "㨃揢揻搇摚㩋擀崕嘡龟㪗斆㪽旿晓㫲暒㬢朖㭂枤栀㭘桊梄㭲㭱㭻椉楃牜楤榟榅㮼槖㯝橥橴橱檂㯬檙㯲檫檵櫔櫶殁毁毪汵沪㳋洂洆洦涁㳯涤涱渕渘温溆𨧀溻滢滚齿滨滩漤漴㵆𣽁澁澾㵪㵵熷岙㶊瀬㶑灐灔灯灿炉𠌥䏁㗱𠻘",
    ],
    [
      "8e40",
      "𣻗垾𦻓焾𥟠㙎榢𨯩孴穉𥣡𩓙穥穽𥦬窻窰竂竃燑𦒍䇊竚竝竪䇯咲𥰁笋筕笩𥌎𥳾箢筯莜𥮴𦱿篐萡箒箸𥴠㶭𥱥蒒篺簆簵𥳁籄粃𤢂粦晽𤕸糉糇糦籴糳糵糎",
    ],
    [
      "8ea1",
      "繧䔝𦹄絝𦻖璍綉綫焵綳緒𤁗𦀩緤㴓緵𡟹緥𨍭縝𦄡𦅚繮纒䌫鑬縧罀罁罇礶𦋐駡羗𦍑羣𡙡𠁨䕜𣝦䔃𨌺翺𦒉者耈耝耨耯𪂇𦳃耻耼聡𢜔䦉𦘦𣷣𦛨朥肧𨩈脇脚墰𢛶汿𦒘𤾸擧𡒊舘𡡞橓𤩥𤪕䑺舩𠬍𦩒𣵾俹𡓽蓢荢𦬊𤦧𣔰𡝳𣷸芪椛芳䇛",
    ],
    [
      "8f40",
      "蕋苐茚𠸖𡞴㛁𣅽𣕚艻苢茘𣺋𦶣𦬅𦮗𣗎㶿茝嗬莅䔋𦶥莬菁菓㑾𦻔橗蕚㒖𦹂𢻯葘𥯤葱㷓䓤檧葊𣲵祘蒨𦮖𦹷𦹃蓞萏莑䒠蒓蓤𥲑䉀𥳀䕃蔴嫲𦺙䔧蕳䔖枿蘖",
    ],
    [
      "8fa1",
      "𨘥𨘻藁𧂈蘂𡖂𧃍䕫䕪蘨㙈𡢢号𧎚虾蝱𪃸蟮𢰧螱蟚蠏噡虬桖䘏衅衆𧗠𣶹𧗤衞袜䙛袴袵揁装睷𧜏覇覊覦覩覧覼𨨥觧𧤤𧪽誜瞓釾誐𧩙竩𧬺𣾏䜓𧬸煼謌謟𥐰𥕥謿譌譍誩𤩺讐讛誯𡛟䘕衏貛𧵔𧶏貫㜥𧵓賖𧶘𧶽贒贃𡤐賛灜贑𤳉㻐起",
    ],
    [
      "9040",
      "趩𨀂𡀔𤦊㭼𨆼𧄌竧躭躶軃鋔輙輭𨍥𨐒辥錃𪊟𠩐辳䤪𨧞𨔽𣶻廸𣉢迹𪀔𨚼𨔁𢌥㦀𦻗逷𨔼𧪾遡𨕬𨘋邨𨜓郄𨛦邮都酧㫰醩釄粬𨤳𡺉鈎沟鉁鉢𥖹銹𨫆𣲛𨬌𥗛",
    ],
    [
      "90a1",
      "𠴱錬鍫𨫡𨯫炏嫃𨫢𨫥䥥鉄𨯬𨰹𨯿鍳鑛躼閅閦鐦閠濶䊹𢙺𨛘𡉼𣸮䧟氜陻隖䅬隣𦻕懚隶磵𨫠隽双䦡𦲸𠉴𦐐𩂯𩃥𤫑𡤕𣌊霱虂霶䨏䔽䖅𤫩灵孁霛靜𩇕靗孊𩇫靟鐥僐𣂷𣂼鞉鞟鞱鞾韀韒韠𥑬韮琜𩐳響韵𩐝𧥺䫑頴頳顋顦㬎𧅵㵑𠘰𤅜",
    ],
    [
      "9140",
      "𥜆飊颷飈飇䫿𦴧𡛓喰飡飦飬鍸餹𤨩䭲𩡗𩤅駵騌騻騐驘𥜥㛄𩂱𩯕髠髢𩬅髴䰎鬔鬭𨘀倴鬴𦦨㣃𣁽魐魀𩴾婅𡡣鮎𤉋鰂鯿鰌𩹨鷔𩾷𪆒𪆫𪃡𪄣𪇟鵾鶃𪄴鸎梈",
    ],
    [
      "91a1",
      "鷄𢅛𪆓𪈠𡤻𪈳鴹𪂹𪊴麐麕麞麢䴴麪麯𤍤黁㭠㧥㴝伲㞾𨰫鼂鼈䮖鐤𦶢鼗鼖鼹嚟嚊齅馸𩂋韲葿齢齩竜龎爖䮾𤥵𤦻煷𤧸𤍈𤩑玞𨯚𡣺禟𨥾𨸶鍩鏳𨩄鋬鎁鏋𨥬𤒹爗㻫睲穃烐𤑳𤏸煾𡟯炣𡢾𣖙㻇𡢅𥐯𡟸㜢𡛻𡠹㛡𡝴𡣑𥽋㜣𡛀坛𤨥𡏾𡊨",
    ],
    [
      "9240",
      "𡏆𡒶蔃𣚦蔃葕𤦔𧅥𣸱𥕜𣻻𧁒䓴𣛮𩦝𦼦柹㜳㰕㷧塬𡤢栐䁗𣜿𤃡𤂋𤄏𦰡哋嚞𦚱嚒𠿟𠮨𠸍鏆𨬓鎜仸儫㠙𤐶亼𠑥𠍿佋侊𥙑婨𠆫𠏋㦙𠌊𠐔㐵伩𠋀𨺳𠉵諚𠈌亘",
    ],
    [
      "92a1",
      "働儍侢伃𤨎𣺊佂倮偬傁俌俥偘僼兙兛兝兞湶𣖕𣸹𣺿浲𡢄𣺉冨凃𠗠䓝𠒣𠒒𠒑赺𨪜𠜎剙劤𠡳勡鍮䙺熌𤎌𠰠𤦬𡃤槑𠸝瑹㻞璙琔瑖玘䮎𤪼𤂍叐㖄爏𤃉喴𠍅响𠯆圝鉝雴鍦埝垍坿㘾壋媙𨩆𡛺𡝯𡜐娬妸銏婾嫏娒𥥆𡧳𡡡𤊕㛵洅瑃娡𥺃",
    ],
    [
      "9340",
      "媁𨯗𠐓鏠璌𡌃焅䥲鐈𨧻鎽㞠尞岞幞幈𡦖𡥼𣫮廍孏𡤃𡤄㜁𡢠㛝𡛾㛓脪𨩇𡶺𣑲𨦨弌弎𡤧𡞫婫𡜻孄蘔𧗽衠恾𢡠𢘫忛㺸𢖯𢖾𩂈𦽳懀𠀾𠁆𢘛憙憘恵𢲛𢴇𤛔𩅍",
    ],
    [
      "93a1",
      "摱𤙥𢭪㨩𢬢𣑐𩣪𢹸挷𪑛撶挱揑𤧣𢵧护𢲡搻敫楲㯴𣂎𣊭𤦉𣊫唍𣋠𡣙𩐿曎𣊉𣆳㫠䆐𥖄𨬢𥖏𡛼𥕛𥐥磮𣄃𡠪𣈴㑤𣈏𣆂𤋉暎𦴤晫䮓昰𧡰𡷫晣𣋒𣋡昞𥡲㣑𣠺𣞼㮙𣞢𣏾瓐㮖枏𤘪梶栞㯄檾㡣𣟕𤒇樳橒櫉欅𡤒攑梘橌㯗橺歗𣿀𣲚鎠鋲𨯪𨫋",
    ],
    [
      "9440",
      "銉𨀞𨧜鑧涥漋𤧬浧𣽿㶏渄𤀼娽渊塇洤硂焻𤌚𤉶烱牐犇犔𤞏𤜥兹𤪤𠗫瑺𣻸𣙟𤩊𤤗𥿡㼆㺱𤫟𨰣𣼵悧㻳瓌琼鎇琷䒟𦷪䕑疃㽣𤳙𤴆㽘畕癳𪗆㬙瑨𨫌𤦫𤦎㫻",
    ],
    [
      "94a1",
      "㷍𤩎㻿𤧅𤣳釺圲鍂𨫣𡡤僟𥈡𥇧睸𣈲眎眏睻𤚗𣞁㩞𤣰琸璛㺿𤪺𤫇䃈𤪖𦆮錇𥖁砞碍碈磒珐祙𧝁𥛣䄎禛蒖禥樭𣻺稺秴䅮𡛦䄲鈵秱𠵌𤦌𠊙𣶺𡝮㖗啫㕰㚪𠇔𠰍竢婙𢛵𥪯𥪜娍𠉛磰娪𥯆竾䇹籝籭䈑𥮳𥺼𥺦糍𤧹𡞰粎籼粮檲緜縇緓罎𦉡",
    ],
    [
      "9540",
      "𦅜𧭈綗𥺂䉪𦭵𠤖柖𠁎𣗏埄𦐒𦏸𤥢翝笧𠠬𥫩𥵃笌𥸎駦虅驣樜𣐿㧢𤧷𦖭騟𦖠蒀𧄧𦳑䓪脷䐂胆脉腂𦞴飃𦩂艢艥𦩑葓𦶧蘐𧈛媆䅿𡡀嬫𡢡嫤𡣘蚠蜨𣶏蠭𧐢娂",
    ],
    [
      "95a1",
      "衮佅袇袿裦襥襍𥚃襔𧞅𧞄𨯵𨯙𨮜𨧹㺭蒣䛵䛏㟲訽訜𩑈彍鈫𤊄旔焩烄𡡅鵭貟賩𧷜妚矃姰䍮㛔踪躧𤰉輰轊䋴汘澻𢌡䢛潹溋𡟚鯩㚵𤤯邻邗啱䤆醻鐄𨩋䁢𨫼鐧𨰝𨰻蓥訫閙閧閗閖𨴴瑅㻂𤣿𤩂𤏪㻧𣈥随𨻧𨹦𨹥㻌𤧭𤩸𣿮琒瑫㻼靁𩂰",
    ],
    [
      "9640",
      "桇䨝𩂓𥟟靝鍨𨦉𨰦𨬯𦎾銺嬑譩䤼珹𤈛鞛靱餸𠼦巁𨯅𤪲頟𩓚鋶𩗗釥䓀𨭐𤩧𨭤飜𨩅㼀鈪䤥萔餻饍𧬆㷽馛䭯馪驜𨭥𥣈檏騡嫾騯𩣱䮐𩥈馼䮽䮗鍽塲𡌂堢𤦸",
    ],
    [
      "96a1",
      "𡓨硄𢜟𣶸棅㵽鑘㤧慐𢞁𢥫愇鱏鱓鱻鰵鰐魿鯏𩸭鮟𪇵𪃾鴡䲮𤄄鸘䲰鴌𪆴𪃭𪃳𩤯鶥蒽𦸒𦿟𦮂藼䔳𦶤𦺄𦷰萠藮𦸀𣟗𦁤秢𣖜𣙀䤭𤧞㵢鏛銾鍈𠊿碹鉷鑍俤㑀遤𥕝砽硔碶硋𡝗𣇉𤥁㚚佲濚濙瀞瀞吔𤆵垻壳垊鴖埗焴㒯𤆬燫𦱀𤾗嬨𡞵𨩉",
    ],
    [
      "9740",
      "愌嫎娋䊼𤒈㜬䭻𨧼鎻鎸𡣖𠼝葲𦳀𡐓𤋺𢰦𤏁妔𣶷𦝁綨𦅛𦂤𤦹𤦋𨧺鋥珢㻩璴𨭣𡢟㻡𤪳櫘珳珻㻖𤨾𤪔𡟙𤩦𠎧𡐤𤧥瑈𤤖炥𤥶銄珦鍟𠓾錱𨫎𨨖鎆𨯧𥗕䤵𨪂煫",
    ],
    [
      "97a1",
      "𤥃𠳿嚤𠘚𠯫𠲸唂秄𡟺緾𡛂𤩐𡡒䔮鐁㜊𨫀𤦭妰𡢿𡢃𧒄媡㛢𣵛㚰鉟婹𨪁𡡢鍴㳍𠪴䪖㦊僴㵩㵌𡎜煵䋻𨈘渏𩃤䓫浗𧹏灧沯㳖𣿭𣸭渂漌㵯𠏵畑㚼㓈䚀㻚䡱姄鉮䤾轁𨰜𦯀堒埈㛖𡑒烾𤍢𤩱𢿣𡊰𢎽梹楧𡎘𣓥𧯴𣛟𨪃𣟖𣏺𤲟樚𣚭𦲷萾䓟䓎",
    ],
    [
      "9840",
      "𦴦𦵑𦲂𦿞漗𧄉茽𡜺菭𦲀𧁓𡟛妉媂𡞳婡婱𡤅𤇼㜭姯𡜼㛇熎鎐暚𤊥婮娫𤊓樫𣻹𧜶𤑛𤋊焝𤉙𨧡侰𦴨峂𤓎𧹍𤎽樌𤉖𡌄炦焳𤏩㶥泟勇𤩏繥姫崯㷳彜𤩝𡟟綤萦",
    ],
    [
      "98a1",
      "咅𣫺𣌀𠈔坾𠣕𠘙㿥𡾞𪊶瀃𩅛嵰玏糓𨩙𩐠俈翧狍猐𧫴猸猹𥛶獁獈㺩𧬘遬燵𤣲珡臶㻊県㻑沢国琙琞琟㻢㻰㻴㻺瓓㼎㽓畂畭畲疍㽼痈痜㿀癍㿗癴㿜発𤽜熈嘣覀塩䀝睃䀹条䁅㗛瞘䁪䁯属瞾矋売砘点砜䂨砹硇硑硦葈𥔵礳栃礲䄃",
    ],
    [
      "9940",
      "䄉禑禙辻稆込䅧窑䆲窼艹䇄竏竛䇏両筢筬筻簒簛䉠䉺类粜䊌粸䊔糭输烀𠳏総緔緐緽羮羴犟䎗耠耥笹耮耱联㷌垴炠肷胩䏭脌猪脎脒畠脔䐁㬹腖腙腚",
    ],
    [
      "99a1",
      "䐓堺腼膄䐥膓䐭膥埯臁臤艔䒏芦艶苊苘苿䒰荗险榊萅烵葤惣蒈䔄蒾蓡蓸蔐蔸蕒䔻蕯蕰藠䕷虲蚒蚲蛯际螋䘆䘗袮裿褤襇覑𧥧訩訸誔誴豑賔賲贜䞘塟跃䟭仮踺嗘坔蹱嗵躰䠷軎転軤軭軲辷迁迊迌逳駄䢭飠鈓䤞鈨鉘鉫銱銮銿",
    ],
    [
      "9a40",
      "鋣鋫鋳鋴鋽鍃鎄鎭䥅䥑麿鐗匁鐝鐭鐾䥪鑔鑹锭関䦧间阳䧥枠䨤靀䨵鞲韂噔䫤惨颹䬙飱塄餎餙冴餜餷饂饝饢䭰駅䮝騼鬏窃魩鮁鯝鯱鯴䱭鰠㝯𡯂鵉鰺",
    ],
    [
      "9aa1",
      "黾噐鶓鶽鷀鷼银辶鹻麬麱麽黆铜黢黱黸竈齄𠂔𠊷𠎠椚铃妬𠓗塀铁㞹𠗕𠘕𠙶𡚺块煳𠫂𠫍𠮿呪吆𠯋咞𠯻𠰻𠱓𠱥𠱼惧𠲍噺𠲵𠳝𠳭𠵯𠶲𠷈楕鰯螥𠸄𠸎𠻗𠾐𠼭𠹳尠𠾼帋𡁜𡁏𡁶朞𡁻𡂈𡂖㙇𡂿𡃓𡄯𡄻卤蒭𡋣𡍵𡌶讁𡕷𡘙𡟃𡟇乸炻𡠭𡥪",
    ],
    [
      "9b40",
      "𡨭𡩅𡰪𡱰𡲬𡻈拃𡻕𡼕熘桕𢁅槩㛈𢉼𢏗𢏺𢜪𢡱𢥏苽𢥧𢦓𢫕覥𢫨辠𢬎鞸𢬿顇骽𢱌",
    ],
    ["9b62", "𢲈𢲷𥯨𢴈𢴒𢶷𢶕𢹂𢽴𢿌𣀳𣁦𣌟𣏞徱晈暿𧩹𣕧𣗳爁𤦺矗𣘚𣜖纇𠍆墵朎"],
    [
      "9ba1",
      "椘𣪧𧙗𥿢𣸑𣺹𧗾𢂚䣐䪸𤄙𨪚𤋮𤌍𤀻𤌴𤎖𤩅𠗊凒𠘑妟𡺨㮾𣳿𤐄𤓖垈𤙴㦛𤜯𨗨𩧉㝢𢇃譞𨭎駖𤠒𤣻𤨕爉𤫀𠱸奥𤺥𤾆𠝹軚𥀬劏圿煱𥊙𥐙𣽊𤪧喼𥑆𥑮𦭒釔㑳𥔿𧘲𥕞䜘𥕢𥕦𥟇𤤿𥡝偦㓻𣏌惞𥤃䝼𨥈𥪮𥮉𥰆𡶐垡煑澶𦄂𧰒遖𦆲𤾚譢𦐂𦑊",
    ],
    [
      "9c40",
      "嵛𦯷輶𦒄𡤜諪𤧶𦒈𣿯𦔒䯀𦖿𦚵𢜛鑥𥟡憕娧晉侻嚹𤔡𦛼乪𤤴陖涏𦲽㘘襷𦞙𦡮𦐑𦡞營𦣇筂𩃀𠨑𦤦鄄𦤹穅鷰𦧺騦𦨭㙟𦑩𠀡禃𦨴𦭛崬𣔙菏𦮝䛐𦲤画补𦶮墶",
    ],
    [
      "9ca1",
      "㜜𢖍𧁋𧇍㱔𧊀𧊅銁𢅺𧊋錰𧋦𤧐氹钟𧑐𠻸蠧裵𢤦𨑳𡞱溸𤨪𡠠㦤㚹尐秣䔿暶𩲭𩢤襃𧟌𧡘囖䃟𡘊㦡𣜯𨃨𡏅熭荦𧧝𩆨婧䲷𧂯𨦫𧧽𧨊𧬋𧵦𤅺筃祾𨀉澵𪋟樃𨌘厢𦸇鎿栶靝𨅯𨀣𦦵𡏭𣈯𨁈嶅𨰰𨂃圕頣𨥉嶫𤦈斾槕叒𤪥𣾁㰑朶𨂐𨃴𨄮𡾡𨅏",
    ],
    [
      "9d40",
      "𨆉𨆯𨈚𨌆𨌯𨎊㗊𨑨𨚪䣺揦𨥖砈鉕𨦸䏲𨧧䏟𨧨𨭆𨯔姸𨰉輋𨿅𩃬筑𩄐𩄼㷷𩅞𤫊运犏嚋𩓧𩗩𩖰𩖸𩜲𩣑𩥉𩥪𩧃𩨨𩬎𩵚𩶛纟𩻸𩼣䲤镇𪊓熢𪋿䶑递𪗋䶜𠲜达嗁",
    ],
    [
      "9da1",
      "辺𢒰边𤪓䔉繿潖檱仪㓤𨬬𧢝㜺躀𡟵𨀤𨭬𨮙𧨾𦚯㷫𧙕𣲷𥘵𥥖亚𥺁𦉘嚿𠹭踎孭𣺈𤲞揞拐𡟶𡡻攰嘭𥱊吚𥌑㷆𩶘䱽嘢嘞罉𥻘奵𣵀蝰东𠿪𠵉𣚺脗鵞贘瘻鱅癎瞹鍅吲腈苷嘥脲萘肽嗪祢噃吖𠺝㗎嘅嗱曱𨋢㘭甴嗰喺咗啲𠱁𠲖廐𥅈𠹶𢱢",
    ],
    [
      "9e40",
      "𠺢麫絚嗞𡁵抝靭咔賍燶酶揼掹揾啩𢭃鱲𢺳冚㓟𠶧冧呍唞唓癦踭𦢊疱肶蠄螆裇膶萜𡃁䓬猄𤜆宐茋𦢓噻𢛴𧴯𤆣𧵳𦻐𧊶酰𡇙鈈𣳼𪚩𠺬𠻹牦𡲢䝎𤿂𧿹𠿫䃺",
    ],
    ["9ea1", "鱝攟𢶠䣳𤟠𩵼𠿬𠸊恢𧖣𠿭"],
    ["9ead", "𦁈𡆇熣纎鵐业丄㕷嬍沲卧㚬㧜卽㚥𤘘墚𤭮舭呋垪𥪕𠥹"],
    [
      "9ec5",
      "㩒𢑥獴𩺬䴉鯭𣳾𩼰䱛𤾩𩖞𩿞葜𣶶𧊲𦞳𣜠挮紥𣻷𣸬㨪逈勌㹴㙺䗩𠒎癀嫰𠺶硺𧼮墧䂿噼鮋嵴癔𪐴麅䳡痹㟻愙𣃚𤏲",
    ],
    ["9ef5", "噝𡊩垧𤥣𩸆刴𧂮㖭汊鵼"],
    ["9f40", "籖鬹埞𡝬屓擓𩓐𦌵𧅤蚭𠴨𦴢𤫢𠵱"],
    [
      "9f4f",
      "凾𡼏嶎霃𡷑麁遌笟鬂峑箣扨挵髿篏鬪籾鬮籂粆鰕篼鬉鼗鰛𤤾齚啳寃俽麘俲剠㸆勑坧偖妷帒韈鶫轜呩鞴饀鞺匬愰",
    ],
    ["9fa1", "椬叚鰊鴂䰻陁榀傦畆𡝭駚剳"],
    ["9fae", "酙隁酜"],
    ["9fb2", "酑𨺗捿𦴣櫊嘑醎畺抅𠏼獏籰𥰡𣳽"],
    ["9fc1", "𤤙盖鮝个𠳔莾衂"],
    ["9fc9", "届槀僭坺刟巵从氱𠇲伹咜哚劚趂㗾弌㗳"],
    ["9fdb", "歒酼龥鮗頮颴骺麨麄煺笔"],
    ["9fe7", "毺蠘罸"],
    ["9feb", "嘠𪙊蹷齓"],
    ["9ff0", "跔蹏鸜踁抂𨍽踨蹵竓𤩷稾磘泪詧瘇"],
    ["a040", "𨩚鼦泎蟖痃𪊲硓咢贌狢獱謭猂瓱賫𤪻蘯徺袠䒷"],
    ["a055", "𡠻𦸅"],
    ["a058", "詾𢔛"],
    ["a05b", "惽癧髗鵄鍮鮏蟵"],
    ["a063", "蠏賷猬霡鮰㗖犲䰇籑饊𦅙慙䰄麖慽"],
    ["a073", "坟慯抦戹拎㩜懢厪𣏵捤栂㗒"],
    ["a0a1", "嵗𨯂迚𨸹"],
    ["a0a6", "僙𡵆礆匲阸𠼻䁥"],
    ["a0ae", "矾"],
    [
      "a0b0",
      "糂𥼚糚稭聦聣絍甅瓲覔舚朌聢𧒆聛瓰脃眤覉𦟌畓𦻑螩蟎臈螌詉貭譃眫瓸蓚㘵榲趦",
    ],
    ["a0d4", "覩瑨涹蟁𤀑瓧㷛煶悤憜㳑煢恷"],
    ["a0e2", "罱𨬭牐惩䭾删㰘𣳇𥻗𧙖𥔱𡥄𡋾𩤃𦷜𧂭峁𦆭𨨏𣙷𠃮𦡆𤼎䕢嬟𦍌齐麦𦉫"],
    ["a3c0", "␀", 31, "␡"],
    [
      "c6a1",
      "①",
      9,
      "⑴",
      9,
      "ⅰ",
      9,
      "丶丿亅亠冂冖冫勹匸卩厶夊宀巛⼳广廴彐彡攴无疒癶辵隶¨ˆヽヾゝゞ〃仝々〆〇ー［］✽ぁ",
      23,
    ],
    ["c740", "す", 58, "ァアィイ"],
    ["c7a1", "ゥ", 81, "А", 5, "ЁЖ", 4],
    ["c840", "Л", 26, "ёж", 25, "⇧↸↹㇏𠃌乚𠂊刂䒑"],
    ["c8a1", "龰冈龱𧘇"],
    [
      "c8cd",
      "￢￤＇＂㈱№℡゛゜⺀⺄⺆⺇⺈⺊⺌⺍⺕⺜⺝⺥⺧⺪⺬⺮⺶⺼⺾⻆⻊⻌⻍⻏⻖⻗⻞⻣",
    ],
    ["c8f5", "ʃɐɛɔɵœøŋʊɪ"],
    ["f9fe", "￭"],
    [
      "fa40",
      "𠕇鋛𠗟𣿅蕌䊵珯况㙉𤥂𨧤鍄𡧛苮𣳈砼杄拟𤤳𨦪𠊠𦮳𡌅侫𢓭倈𦴩𧪄𣘀𤪱𢔓倩𠍾徤𠎀𠍇滛𠐟偽儁㑺儎顬㝃萖𤦤𠒇兠𣎴兪𠯿𢃼𠋥𢔰𠖎𣈳𡦃宂蝽𠖳𣲙冲冸",
    ],
    [
      "faa1",
      "鴴凉减凑㳜凓𤪦决凢卂凭菍椾𣜭彻刋刦刼劵剗劔効勅簕蕂勠蘍𦬓包𨫞啉滙𣾀𠥔𣿬匳卄𠯢泋𡜦栛珕恊㺪㣌𡛨燝䒢卭却𨚫卾卿𡖖𡘓矦厓𨪛厠厫厮玧𥝲㽙玜叁叅汉义埾叙㪫𠮏叠𣿫𢶣叶𠱷吓灹唫晗浛呭𦭓𠵴啝咏咤䞦𡜍𠻝㶴𠵍",
    ],
    [
      "fb40",
      "𨦼𢚘啇䳭启琗喆喩嘅𡣗𤀺䕒𤐵暳𡂴嘷曍𣊊暤暭噍噏磱囱鞇叾圀囯园𨭦㘣𡉏坆𤆥汮炋坂㚱𦱾埦𡐖堃𡑔𤍣堦𤯵塜墪㕡壠壜𡈼壻寿坃𪅐𤉸鏓㖡够梦㛃湙",
    ],
    [
      "fba1",
      "𡘾娤啓𡚒蔅姉𠵎𦲁𦴪𡟜姙𡟻𡞲𦶦浱𡠨𡛕姹𦹅媫婣㛦𤦩婷㜈媖瑥嫓𦾡𢕔㶅𡤑㜲𡚸広勐孶斈孼𧨎䀄䡝𠈄寕慠𡨴𥧌𠖥寳宝䴐尅𡭄尓珎尔𡲥𦬨屉䣝岅峩峯嶋𡷹𡸷崐崘嵆𡺤岺巗苼㠭𤤁𢁉𢅳芇㠶㯂帮檊幵幺𤒼𠳓厦亷廐厨𡝱帉廴𨒂",
    ],
    [
      "fc40",
      "廹廻㢠廼栾鐛弍𠇁弢㫞䢮𡌺强𦢈𢏐彘𢑱彣鞽𦹮彲鍀𨨶徧嶶㵟𥉐𡽪𧃸𢙨釖𠊞𨨩怱暅𡡷㥣㷇㘹垐𢞴祱㹀悞悤悳𤦂𤦏𧩓璤僡媠慤萤慂慈𦻒憁凴𠙖憇宪𣾷",
    ],
    [
      "fca1",
      "𢡟懓𨮝𩥝懐㤲𢦀𢣁怣慜攞掋𠄘担𡝰拕𢸍捬𤧟㨗搸揸𡎎𡟼撐澊𢸶頔𤂌𥜝擡擥鑻㩦携㩗敍漖𤨨𤨣斅敭敟𣁾斵𤥀䬷旑䃘𡠩无旣忟𣐀昘𣇷𣇸晄𣆤𣆥晋𠹵晧𥇦晳晴𡸽𣈱𨗴𣇈𥌓矅𢣷馤朂𤎜𤨡㬫槺𣟂杞杧杢𤇍𩃭柗䓩栢湐鈼栁𣏦𦶠桝",
    ],
    [
      "fd40",
      "𣑯槡樋𨫟楳棃𣗍椁椀㴲㨁𣘼㮀枬楡𨩊䋼椶榘㮡𠏉荣傐槹𣙙𢄪橅𣜃檝㯳枱櫈𩆜㰍欝𠤣惞欵歴𢟍溵𣫛𠎵𡥘㝀吡𣭚毡𣻼毜氷𢒋𤣱𦭑汚舦汹𣶼䓅𣶽𤆤𤤌𤤀",
    ],
    [
      "fda1",
      "𣳉㛥㳫𠴲鮃𣇹𢒑羏样𦴥𦶡𦷫涖浜湼漄𤥿𤂅𦹲蔳𦽴凇沜渝萮𨬡港𣸯瑓𣾂秌湏媑𣁋濸㜍澝𣸰滺𡒗𤀽䕕鏰潄潜㵎潴𩅰㴻澟𤅄濓𤂑𤅕𤀹𣿰𣾴𤄿凟𤅖𤅗𤅀𦇝灋灾炧炁烌烕烖烟䄄㷨熴熖𤉷焫煅媈煊煮岜𤍥煏鍢𤋁焬𤑚𤨧𤨢熺𨯨炽爎",
    ],
    [
      "fe40",
      "鑂爕夑鑃爤鍁𥘅爮牀𤥴梽牕牗㹕𣁄栍漽犂猪猫𤠣𨠫䣭𨠄猨献珏玪𠰺𦨮珉瑉𤇢𡛧𤨤昣㛅𤦷𤦍𤧻珷琕椃𤨦琹𠗃㻗瑜𢢭瑠𨺲瑇珤瑶莹瑬㜰瑴鏱樬璂䥓𤪌",
    ],
    [
      "fea1",
      "𤅟𤩹𨮏孆𨰃𡢞瓈𡦈甎瓩甞𨻙𡩋寗𨺬鎅畍畊畧畮𤾂㼄𤴓疎瑝疞疴瘂瘬癑癏癯癶𦏵皐臯㟸𦤑𦤎皡皥皷盌𦾟葢𥂝𥅽𡸜眞眦着撯𥈠睘𣊬瞯𨥤𨥨𡛁矴砉𡍶𤨒棊碯磇磓隥礮𥗠磗礴碱𧘌辸袄𨬫𦂃𢘜禆褀椂禀𥡗禝𧬹礼禩渪𧄦㺨秆𩄍秔",
    ],
  ];
var ph, H1;
function NN() {
  return (
    H1 ||
      ((H1 = 1),
      (ph = {
        shiftjis: {
          type: "_dbcs",
          table: function () {
            return SN;
          },
          encodeAdd: { "¥": 92, "‾": 126 },
          encodeSkipVals: [{ from: 60736, to: 63808 }],
        },
        csshiftjis: "shiftjis",
        mskanji: "shiftjis",
        sjis: "shiftjis",
        windows31j: "shiftjis",
        ms31j: "shiftjis",
        xsjis: "shiftjis",
        windows932: "shiftjis",
        ms932: "shiftjis",
        932: "shiftjis",
        cp932: "shiftjis",
        eucjp: {
          type: "_dbcs",
          table: function () {
            return IN;
          },
          encodeAdd: { "¥": 92, "‾": 126 },
        },
        gb2312: "cp936",
        gb231280: "cp936",
        gb23121980: "cp936",
        csgb2312: "cp936",
        csiso58gb231280: "cp936",
        euccn: "cp936",
        windows936: "cp936",
        ms936: "cp936",
        936: "cp936",
        cp936: {
          type: "_dbcs",
          table: function () {
            return dh;
          },
        },
        gbk: {
          type: "_dbcs",
          table: function () {
            return dh.concat(j1);
          },
        },
        xgbk: "gbk",
        isoir58: "gbk",
        gb18030: {
          type: "_dbcs",
          table: function () {
            return dh.concat(j1);
          },
          gb18030: function () {
            return RN;
          },
          encodeSkipVals: [128],
          encodeAdd: { "€": 41699 },
        },
        chinese: "gb18030",
        windows949: "cp949",
        ms949: "cp949",
        949: "cp949",
        cp949: {
          type: "_dbcs",
          table: function () {
            return kN;
          },
        },
        cseuckr: "cp949",
        csksc56011987: "cp949",
        euckr: "cp949",
        isoir149: "cp949",
        korean: "cp949",
        ksc56011987: "cp949",
        ksc56011989: "cp949",
        ksc5601: "cp949",
        windows950: "cp950",
        ms950: "cp950",
        950: "cp950",
        cp950: {
          type: "_dbcs",
          table: function () {
            return M1;
          },
        },
        big5: "big5hkscs",
        big5hkscs: {
          type: "_dbcs",
          table: function () {
            return M1.concat(TN);
          },
          encodeSkipVals: [41676],
        },
        cnbig5: "big5hkscs",
        csbig5: "big5hkscs",
        xxbig5: "big5hkscs",
      })),
    ph
  );
}
var q1;
function ON() {
  return (
    q1 ||
      ((q1 = 1),
      (function (e) {
        for (
          var t = [yN(), bN(), _N(), EN(), wN(), xN(), AN(), NN()], n = 0;
          n < t.length;
          n++
        ) {
          var r = t[n];
          for (var i in r)
            Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
        }
      })(sh)),
    sh
  );
}
var hh, G1;
function PN() {
  if (G1) return hh;
  G1 = 1;
  var e = ks.Buffer,
    t = Kr.Transform;
  hh = function (i) {
    (i.encodeStream = function (s, o) {
      return new n(i.getEncoder(s, o), o);
    }),
      (i.decodeStream = function (s, o) {
        return new r(i.getDecoder(s, o), o);
      }),
      (i.supportsStreams = !0),
      (i.IconvLiteEncoderStream = n),
      (i.IconvLiteDecoderStream = r),
      (i._collect = r.prototype.collect);
  };
  function n(i, a) {
    (this.conv = i), (a = a || {}), (a.decodeStrings = !1), t.call(this, a);
  }
  (n.prototype = Object.create(t.prototype, { constructor: { value: n } })),
    (n.prototype._transform = function (i, a, s) {
      if (typeof i != "string")
        return s(
          new Error("Iconv encoding stream needs strings as its input."),
        );
      try {
        var o = this.conv.write(i);
        o && o.length && this.push(o), s();
      } catch (c) {
        s(c);
      }
    }),
    (n.prototype._flush = function (i) {
      try {
        var a = this.conv.end();
        a && a.length && this.push(a), i();
      } catch (s) {
        i(s);
      }
    }),
    (n.prototype.collect = function (i) {
      var a = [];
      return (
        this.on("error", i),
        this.on("data", function (s) {
          a.push(s);
        }),
        this.on("end", function () {
          i(null, e.concat(a));
        }),
        this
      );
    });
  function r(i, a) {
    (this.conv = i),
      (a = a || {}),
      (a.encoding = this.encoding = "utf8"),
      t.call(this, a);
  }
  return (
    (r.prototype = Object.create(t.prototype, { constructor: { value: r } })),
    (r.prototype._transform = function (i, a, s) {
      if (!e.isBuffer(i))
        return s(
          new Error("Iconv decoding stream needs buffers as its input."),
        );
      try {
        var o = this.conv.write(i);
        o && o.length && this.push(o, this.encoding), s();
      } catch (c) {
        s(c);
      }
    }),
    (r.prototype._flush = function (i) {
      try {
        var a = this.conv.end();
        a && a.length && this.push(a, this.encoding), i();
      } catch (s) {
        i(s);
      }
    }),
    (r.prototype.collect = function (i) {
      var a = "";
      return (
        this.on("error", i),
        this.on("data", function (s) {
          a += s;
        }),
        this.on("end", function () {
          i(null, a);
        }),
        this
      );
    }),
    hh
  );
}
var mh, Q1;
function DN() {
  if (Q1) return mh;
  Q1 = 1;
  var e = ks.Buffer;
  return (
    (mh = function (t) {
      var n = void 0;
      (t.supportsNodeEncodingsExtension = !(
        e.from || new e(0) instanceof Uint8Array
      )),
        (t.extendNodeEncodings = function () {
          if (!n) {
            if (((n = {}), !t.supportsNodeEncodingsExtension)) {
              console.error(
                "ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node",
              ),
                console.error(
                  "See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility",
                );
              return;
            }
            var i = {
              hex: !0,
              utf8: !0,
              "utf-8": !0,
              ascii: !0,
              binary: !0,
              base64: !0,
              ucs2: !0,
              "ucs-2": !0,
              utf16le: !0,
              "utf-16le": !0,
            };
            e.isNativeEncoding = function (o) {
              return o && i[o.toLowerCase()];
            };
            var a = ks.SlowBuffer;
            if (
              ((n.SlowBufferToString = a.prototype.toString),
              (a.prototype.toString = function (o, c, l) {
                return (
                  (o = String(o || "utf8").toLowerCase()),
                  e.isNativeEncoding(o)
                    ? n.SlowBufferToString.call(this, o, c, l)
                    : (typeof c > "u" && (c = 0),
                      typeof l > "u" && (l = this.length),
                      t.decode(this.slice(c, l), o))
                );
              }),
              (n.SlowBufferWrite = a.prototype.write),
              (a.prototype.write = function (o, c, l, f) {
                if (isFinite(c)) isFinite(l) || ((f = l), (l = void 0));
                else {
                  var u = f;
                  (f = c), (c = l), (l = u);
                }
                c = +c || 0;
                var d = this.length - c;
                if (
                  (l ? ((l = +l), l > d && (l = d)) : (l = d),
                  (f = String(f || "utf8").toLowerCase()),
                  e.isNativeEncoding(f))
                )
                  return n.SlowBufferWrite.call(this, o, c, l, f);
                if (o.length > 0 && (l < 0 || c < 0))
                  throw new RangeError("attempt to write beyond buffer bounds");
                var p = t.encode(o, f);
                return p.length < l && (l = p.length), p.copy(this, c, 0, l), l;
              }),
              (n.BufferIsEncoding = e.isEncoding),
              (e.isEncoding = function (o) {
                return e.isNativeEncoding(o) || t.encodingExists(o);
              }),
              (n.BufferByteLength = e.byteLength),
              (e.byteLength = a.byteLength =
                function (o, c) {
                  return (
                    (c = String(c || "utf8").toLowerCase()),
                    e.isNativeEncoding(c)
                      ? n.BufferByteLength.call(this, o, c)
                      : t.encode(o, c).length
                  );
                }),
              (n.BufferToString = e.prototype.toString),
              (e.prototype.toString = function (o, c, l) {
                return (
                  (o = String(o || "utf8").toLowerCase()),
                  e.isNativeEncoding(o)
                    ? n.BufferToString.call(this, o, c, l)
                    : (typeof c > "u" && (c = 0),
                      typeof l > "u" && (l = this.length),
                      t.decode(this.slice(c, l), o))
                );
              }),
              (n.BufferWrite = e.prototype.write),
              (e.prototype.write = function (o, c, l, f) {
                var u = c,
                  d = l,
                  p = f;
                if (isFinite(c)) isFinite(l) || ((f = l), (l = void 0));
                else {
                  var h = f;
                  (f = c), (c = l), (l = h);
                }
                if (
                  ((f = String(f || "utf8").toLowerCase()),
                  e.isNativeEncoding(f))
                )
                  return n.BufferWrite.call(this, o, u, d, p);
                c = +c || 0;
                var m = this.length - c;
                if (
                  (l ? ((l = +l), l > m && (l = m)) : (l = m),
                  o.length > 0 && (l < 0 || c < 0))
                )
                  throw new RangeError("attempt to write beyond buffer bounds");
                var g = t.encode(o, f);
                return g.length < l && (l = g.length), g.copy(this, c, 0, l), l;
              }),
              t.supportsStreams)
            ) {
              var s = Kr.Readable;
              (n.ReadableSetEncoding = s.prototype.setEncoding),
                (s.prototype.setEncoding = function (c, l) {
                  (this._readableState.decoder = t.getDecoder(c, l)),
                    (this._readableState.encoding = c);
                }),
                (s.prototype.collect = t._collect);
            }
          }
        }),
        (t.undoExtendNodeEncodings = function () {
          if (t.supportsNodeEncodingsExtension) {
            if (!n)
              throw new Error(
                "require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.",
              );
            delete e.isNativeEncoding;
            var i = ks.SlowBuffer;
            if (
              ((i.prototype.toString = n.SlowBufferToString),
              (i.prototype.write = n.SlowBufferWrite),
              (e.isEncoding = n.BufferIsEncoding),
              (e.byteLength = n.BufferByteLength),
              (e.prototype.toString = n.BufferToString),
              (e.prototype.write = n.BufferWrite),
              t.supportsStreams)
            ) {
              var a = Kr.Readable;
              (a.prototype.setEncoding = n.ReadableSetEncoding),
                delete a.prototype.collect;
            }
            n = void 0;
          }
        });
    }),
    mh
  );
}
var W1;
function qd() {
  return (
    W1 ||
      ((W1 = 1),
      (function (e) {
        var t = Xa().Buffer,
          n = vN(),
          r = e.exports;
        (r.encodings = null),
          (r.defaultCharUnicode = "�"),
          (r.defaultCharSingleByte = "?"),
          (r.encode = function (o, c, l) {
            o = "" + (o || "");
            var f = r.getEncoder(c, l),
              u = f.write(o),
              d = f.end();
            return d && d.length > 0 ? t.concat([u, d]) : u;
          }),
          (r.decode = function (o, c, l) {
            typeof o == "string" &&
              (r.skipDecodeWarning ||
                (console.error(
                  "Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding",
                ),
                (r.skipDecodeWarning = !0)),
              (o = t.from("" + (o || ""), "binary")));
            var f = r.getDecoder(c, l),
              u = f.write(o),
              d = f.end();
            return d ? u + d : u;
          }),
          (r.encodingExists = function (o) {
            try {
              return r.getCodec(o), !0;
            } catch {
              return !1;
            }
          }),
          (r.toEncoding = r.encode),
          (r.fromEncoding = r.decode),
          (r._codecDataCache = {}),
          (r.getCodec = function (o) {
            r.encodings || (r.encodings = ON());
            for (var c = r._canonicalizeEncoding(o), l = {}; ; ) {
              var f = r._codecDataCache[c];
              if (f) return f;
              var u = r.encodings[c];
              switch (typeof u) {
                case "string":
                  c = u;
                  break;
                case "object":
                  for (var d in u) l[d] = u[d];
                  l.encodingName || (l.encodingName = c), (c = u.type);
                  break;
                case "function":
                  return (
                    l.encodingName || (l.encodingName = c),
                    (f = new u(l, r)),
                    (r._codecDataCache[l.encodingName] = f),
                    f
                  );
                default:
                  throw new Error(
                    "Encoding not recognized: '" +
                      o +
                      "' (searched as: '" +
                      c +
                      "')",
                  );
              }
            }
          }),
          (r._canonicalizeEncoding = function (s) {
            return ("" + s).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
          }),
          (r.getEncoder = function (o, c) {
            var l = r.getCodec(o),
              f = new l.encoder(c, l);
            return (
              l.bomAware && c && c.addBOM && (f = new n.PrependBOM(f, c)), f
            );
          }),
          (r.getDecoder = function (o, c) {
            var l = r.getCodec(o),
              f = new l.decoder(c, l);
            return (
              l.bomAware &&
                !(c && c.stripBOM === !1) &&
                (f = new n.StripBOM(f, c)),
              f
            );
          });
        var i =
          typeof process < "u" && process.versions && process.versions.node;
        if (i) {
          var a = i.split(".").map(Number);
          (a[0] > 0 || a[1] >= 10) && PN()(r), DN()(r);
        }
      })(ih)),
    ih.exports
  );
}
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var zl = BN;
function LN(e) {
  for (var t = e.listeners("data"), n = 0; n < t.length; n++)
    if (t[n].name === "ondata") return !0;
  return !1;
}
function BN(e) {
  if (!e) throw new TypeError("argument stream is required");
  if (typeof e.unpipe == "function") {
    e.unpipe();
    return;
  }
  if (LN(e))
    for (var t, n = e.listeners("close"), r = 0; r < n.length; r++)
      (t = n[r]), !(t.name !== "cleanup" && t.name !== "onclose") && t.call(e);
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var gh, z1;
function UN() {
  if (z1) return gh;
  z1 = 1;
  var e = f(),
    t = qi(),
    n = Gi,
    r = qd(),
    i = zl;
  gh = o;
  var a = /^Encoding not recognized: /;
  function s(d) {
    if (!d) return null;
    try {
      return r.getDecoder(d);
    } catch (p) {
      throw a.test(p.message)
        ? n(415, "specified encoding unsupported", {
            encoding: d,
            type: "encoding.unsupported",
          })
        : p;
    }
  }
  function o(d, p, h) {
    var m = h,
      g = p || {};
    if (
      ((p === !0 || typeof p == "string") && (g = { encoding: p }),
      typeof p == "function" && ((m = p), (g = {})),
      m !== void 0 && typeof m != "function")
    )
      throw new TypeError("argument callback must be a function");
    if (!m && !Tn.Promise) throw new TypeError("argument callback is required");
    var v = g.encoding !== !0 ? g.encoding : "utf-8",
      y = t.parse(g.limit),
      _ = g.length != null && !isNaN(g.length) ? parseInt(g.length, 10) : null;
    return m
      ? l(d, v, _, y, u(m))
      : new Promise(function (R, A) {
          l(d, v, _, y, function (S, w) {
            if (S) return A(S);
            R(w);
          });
        });
  }
  function c(d) {
    i(d), typeof d.pause == "function" && d.pause();
  }
  function l(d, p, h, m, g) {
    var v = !1,
      y = !0;
    if (m !== null && h !== null && h > m)
      return I(
        n(413, "request entity too large", {
          expected: h,
          length: h,
          limit: m,
          type: "entity.too.large",
        }),
      );
    var _ = d._readableState;
    if (d._decoder || (_ && (_.encoding || _.decoder)))
      return I(
        n(500, "stream encoding should not be set", {
          type: "stream.encoding.set",
        }),
      );
    if (typeof d.readable < "u" && !d.readable)
      return I(
        n(500, "stream is not readable", { type: "stream.not.readable" }),
      );
    var E = 0,
      R;
    try {
      R = s(p);
    } catch (j) {
      return I(j);
    }
    var A = R ? "" : [];
    d.on("aborted", S),
      d.on("close", Q),
      d.on("data", w),
      d.on("end", O),
      d.on("error", O),
      (y = !1);
    function I() {
      for (var j = new Array(arguments.length), H = 0; H < j.length; H++)
        j[H] = arguments[H];
      (v = !0), y ? process.nextTick(q) : q();
      function q() {
        Q(), j[0] && c(d), g.apply(null, j);
      }
    }
    function S() {
      v ||
        I(
          n(400, "request aborted", {
            code: "ECONNABORTED",
            expected: h,
            length: h,
            received: E,
            type: "request.aborted",
          }),
        );
    }
    function w(j) {
      v ||
        ((E += j.length),
        m !== null && E > m
          ? I(
              n(413, "request entity too large", {
                limit: m,
                received: E,
                type: "entity.too.large",
              }),
            )
          : R
          ? (A += R.write(j))
          : A.push(j));
    }
    function O(j) {
      if (!v) {
        if (j) return I(j);
        if (h !== null && E !== h)
          I(
            n(400, "request size did not match content length", {
              expected: h,
              length: h,
              received: E,
              type: "request.size.invalid",
            }),
          );
        else {
          var H = R ? A + (R.end() || "") : Buffer.concat(A);
          I(null, H);
        }
      }
    }
    function Q() {
      (A = null),
        d.removeListener("aborted", S),
        d.removeListener("data", w),
        d.removeListener("end", O),
        d.removeListener("error", O),
        d.removeListener("close", Q);
    }
  }
  function f() {
    try {
      return require("async_hooks");
    } catch {
      return {};
    }
  }
  function u(d) {
    var p;
    return (
      e.AsyncResource &&
        (p = new e.AsyncResource(d.name || "bound-anonymous-fn")),
      !p || !p.runInAsyncScope ? d : p.runInAsyncScope.bind(p, d, null)
    );
  }
  return gh;
}
var tv = { exports: {} };
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */ var FN = jN;
function jN(e, t) {
  if (!Array.isArray(e))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  for (var n = [], r = 0; r < e.length; r++) {
    var i = e[r];
    if (!Array.isArray(i) || i.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    for (var a = i[0], s = 1; s < i.length; s++) {
      var o = i[s],
        c = MN(o, l);
      a.on(o, c), n.push({ ee: a, event: o, fn: c });
    }
  }
  function l() {
    f(), t.apply(null, arguments);
  }
  function f() {
    for (var d, p = 0; p < n.length; p++)
      (d = n[p]), d.ee.removeListener(d.event, d.fn);
  }
  function u(d) {
    t = d;
  }
  return (u.cancel = f), u;
}
function MN(e, t) {
  return function (r) {
    for (
      var i = new Array(arguments.length),
        a = this,
        s = e === "error" ? r : null,
        o = 0;
      o < i.length;
      o++
    )
      i[o] = arguments[o];
    t(s, a, e, i);
  };
}
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ tv.exports = qN;
tv.exports.isFinished = bI;
var K1 = KN(),
  V1 = FN,
  HN =
    typeof setImmediate == "function"
      ? setImmediate
      : function (e) {
          process.nextTick(e.bind.apply(e, arguments));
        };
function qN(e, t) {
  return bI(e) !== !1 ? (HN(t, null, e), e) : (QN(e, VN(t)), e);
}
function bI(e) {
  var t = e.socket;
  if (typeof e.finished == "boolean")
    return !!(e.finished || (t && !t.writable));
  if (typeof e.complete == "boolean")
    return !!(e.upgrade || !t || !t.readable || (e.complete && !e.readable));
}
function GN(e, t) {
  var n,
    r,
    i = !1;
  function a(o) {
    n.cancel(), r.cancel(), (i = !0), t(o);
  }
  n = r = V1([[e, "end", "finish"]], a);
  function s(o) {
    e.removeListener("socket", s),
      !i && n === r && (r = V1([[o, "error", "close"]], a));
  }
  if (e.socket) {
    s(e.socket);
    return;
  }
  e.on("socket", s), e.socket === void 0 && zN(e, s);
}
function QN(e, t) {
  var n = e.__onFinished;
  (!n || !n.queue) && ((n = e.__onFinished = WN(e)), GN(e, n)), n.queue.push(t);
}
function WN(e) {
  function t(n) {
    if ((e.__onFinished === t && (e.__onFinished = null), !!t.queue)) {
      var r = t.queue;
      t.queue = null;
      for (var i = 0; i < r.length; i++) r[i](n, e);
    }
  }
  return (t.queue = []), t;
}
function zN(e, t) {
  var n = e.assignSocket;
  typeof n == "function" &&
    (e.assignSocket = function (i) {
      n.call(this, i), t(i);
    });
}
function KN() {
  try {
    return require("async_hooks");
  } catch {
    return {};
  }
}
function VN(e) {
  var t;
  return (
    K1.AsyncResource &&
      (t = new K1.AsyncResource(e.name || "bound-anonymous-fn")),
    !t || !t.runInAsyncScope ? e : t.runInAsyncScope.bind(t, e, null)
  );
}
var Kl = tv.exports;
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var vh, Y1;
function Gd() {
  if (Y1) return vh;
  Y1 = 1;
  var e = Gi,
    t = ev,
    n = UN(),
    r = qd(),
    i = Kl,
    a = zl,
    s = mc;
  vh = o;
  function o(f, u, d, p, h, m) {
    var g,
      v = m,
      y;
    f._body = !0;
    var _ = v.encoding !== null ? v.encoding : null,
      E = v.verify;
    try {
      (y = c(f, h, v.inflate)), (g = y.length), (y.length = void 0);
    } catch (R) {
      return d(R);
    }
    if (
      ((v.length = g),
      (v.encoding = E ? null : _),
      v.encoding === null && _ !== null && !r.encodingExists(_))
    )
      return d(
        e(415, 'unsupported charset "' + _.toUpperCase() + '"', {
          charset: _.toLowerCase(),
          type: "charset.unsupported",
        }),
      );
    h("read body"),
      n(y, v, function (R, A) {
        if (R) {
          var I;
          R.type === "encoding.unsupported"
            ? (I = e(415, 'unsupported charset "' + _.toUpperCase() + '"', {
                charset: _.toLowerCase(),
                type: "charset.unsupported",
              }))
            : (I = e(400, R)),
            y !== f && (a(f), t(y, !0)),
            l(f, function () {
              d(e(400, I));
            });
          return;
        }
        if (E)
          try {
            h("verify body"), E(f, u, A, _);
          } catch (w) {
            d(e(403, w, { body: A, type: w.type || "entity.verify.failed" }));
            return;
          }
        var S = A;
        try {
          h("parse body"),
            (S = typeof A != "string" && _ !== null ? r.decode(A, _) : A),
            (f.body = p(S));
        } catch (w) {
          d(e(400, w, { body: S, type: w.type || "entity.parse.failed" }));
          return;
        }
        d();
      });
  }
  function c(f, u, d) {
    var p = (f.headers["content-encoding"] || "identity").toLowerCase(),
      h = f.headers["content-length"],
      m;
    if ((u('content-encoding "%s"', p), d === !1 && p !== "identity"))
      throw e(415, "content encoding unsupported", {
        encoding: p,
        type: "encoding.unsupported",
      });
    switch (p) {
      case "deflate":
        (m = s.createInflate()), u("inflate body"), f.pipe(m);
        break;
      case "gzip":
        (m = s.createGunzip()), u("gunzip body"), f.pipe(m);
        break;
      case "identity":
        (m = f), (m.length = h);
        break;
      default:
        throw e(415, 'unsupported content encoding "' + p + '"', {
          encoding: p,
          type: "encoding.unsupported",
        });
    }
    return m;
  }
  function l(f, u) {
    i.isFinished(f) ? u(null) : (i(f, u), f.resume());
  }
  return vh;
}
var vc = { exports: {} },
  nv = {};
/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ var X1 =
    /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g,
  YN = /^[\u0020-\u007e\u0080-\u00ff]+$/,
  _I = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/,
  XN = /\\([\u0000-\u007f])/g,
  JN = /([\\"])/g,
  ZN = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/,
  J1 = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/,
  eO =
    /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
nv.format = tO;
nv.parse = nO;
function tO(e) {
  if (!e || typeof e != "object")
    throw new TypeError("argument obj is required");
  var t = e.parameters,
    n = e.subtype,
    r = e.suffix,
    i = e.type;
  if (!i || !J1.test(i)) throw new TypeError("invalid type");
  if (!n || !ZN.test(n)) throw new TypeError("invalid subtype");
  var a = i + "/" + n;
  if (r) {
    if (!J1.test(r)) throw new TypeError("invalid suffix");
    a += "+" + r;
  }
  if (t && typeof t == "object")
    for (var s, o = Object.keys(t).sort(), c = 0; c < o.length; c++) {
      if (((s = o[c]), !_I.test(s)))
        throw new TypeError("invalid parameter name");
      a += "; " + s + "=" + iO(t[s]);
    }
  return a;
}
function nO(e) {
  if (!e) throw new TypeError("argument string is required");
  if ((typeof e == "object" && (e = rO(e)), typeof e != "string"))
    throw new TypeError("argument string is required to be a string");
  var t = e.indexOf(";"),
    n = t !== -1 ? e.substr(0, t) : e,
    r,
    i,
    a = aO(n),
    s = {},
    o;
  for (X1.lastIndex = t; (i = X1.exec(e)); ) {
    if (i.index !== t) throw new TypeError("invalid parameter format");
    (t += i[0].length),
      (r = i[1].toLowerCase()),
      (o = i[2]),
      o[0] === '"' && (o = o.substr(1, o.length - 2).replace(XN, "$1")),
      (s[r] = o);
  }
  if (t !== -1 && t !== e.length)
    throw new TypeError("invalid parameter format");
  return (a.parameters = s), a;
}
function rO(e) {
  if (typeof e.getHeader == "function") return e.getHeader("content-type");
  if (typeof e.headers == "object")
    return e.headers && e.headers["content-type"];
}
function iO(e) {
  var t = String(e);
  if (_I.test(t)) return t;
  if (t.length > 0 && !YN.test(t))
    throw new TypeError("invalid parameter value");
  return '"' + t.replace(JN, "\\$1") + '"';
}
function aO(e) {
  var t = eO.exec(e.toLowerCase());
  if (!t) throw new TypeError("invalid media type");
  var n = t[1],
    r = t[2],
    i,
    a = r.lastIndexOf("+");
  a !== -1 && ((i = r.substr(a + 1)), (r = r.substr(0, a)));
  var s = { type: n, subtype: r, suffix: i };
  return s;
}
var rv = {};
const sO = {
  "application/1d-interleaved-parityfec": { source: "iana" },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/3gpp-ims+xml": { source: "iana", compressible: !0 },
  "application/3gpphal+json": { source: "iana", compressible: !0 },
  "application/3gpphalforms+json": { source: "iana", compressible: !0 },
  "application/a2l": { source: "iana" },
  "application/ace+cbor": { source: "iana" },
  "application/activemessage": { source: "iana" },
  "application/activity+json": { source: "iana", compressible: !0 },
  "application/alto-costmap+json": { source: "iana", compressible: !0 },
  "application/alto-costmapfilter+json": { source: "iana", compressible: !0 },
  "application/alto-directory+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcost+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-endpointprop+json": { source: "iana", compressible: !0 },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-error+json": { source: "iana", compressible: !0 },
  "application/alto-networkmap+json": { source: "iana", compressible: !0 },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: !0,
  },
  "application/aml": { source: "iana" },
  "application/andrew-inset": { source: "iana", extensions: ["ez"] },
  "application/applefile": { source: "iana" },
  "application/applixware": { source: "apache", extensions: ["aw"] },
  "application/at+jwt": { source: "iana" },
  "application/atf": { source: "iana" },
  "application/atfx": { source: "iana" },
  "application/atom+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atom"],
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atomcat"],
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atomdeleted"],
  },
  "application/atomicmail": { source: "iana" },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atomsvc"],
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["dwd"],
  },
  "application/atsc-dynamic-event-message": { source: "iana" },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["held"],
  },
  "application/atsc-rdt+json": { source: "iana", compressible: !0 },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rsat"],
  },
  "application/atxml": { source: "iana" },
  "application/auth-policy+xml": { source: "iana", compressible: !0 },
  "application/bacnet-xdd+zip": { source: "iana", compressible: !1 },
  "application/batch-smtp": { source: "iana" },
  "application/bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/calendar+json": { source: "iana", compressible: !0 },
  "application/calendar+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xcs"],
  },
  "application/call-completion": { source: "iana" },
  "application/cals-1840": { source: "iana" },
  "application/captive+json": { source: "iana", compressible: !0 },
  "application/cbor": { source: "iana" },
  "application/cbor-seq": { source: "iana" },
  "application/cccex": { source: "iana" },
  "application/ccmp+xml": { source: "iana", compressible: !0 },
  "application/ccxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ccxml"],
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["cdfx"],
  },
  "application/cdmi-capability": { source: "iana", extensions: ["cdmia"] },
  "application/cdmi-container": { source: "iana", extensions: ["cdmic"] },
  "application/cdmi-domain": { source: "iana", extensions: ["cdmid"] },
  "application/cdmi-object": { source: "iana", extensions: ["cdmio"] },
  "application/cdmi-queue": { source: "iana", extensions: ["cdmiq"] },
  "application/cdni": { source: "iana" },
  "application/cea": { source: "iana" },
  "application/cea-2018+xml": { source: "iana", compressible: !0 },
  "application/cellml+xml": { source: "iana", compressible: !0 },
  "application/cfw": { source: "iana" },
  "application/city+json": { source: "iana", compressible: !0 },
  "application/clr": { source: "iana" },
  "application/clue+xml": { source: "iana", compressible: !0 },
  "application/clue_info+xml": { source: "iana", compressible: !0 },
  "application/cms": { source: "iana" },
  "application/cnrp+xml": { source: "iana", compressible: !0 },
  "application/coap-group+json": { source: "iana", compressible: !0 },
  "application/coap-payload": { source: "iana" },
  "application/commonground": { source: "iana" },
  "application/conference-info+xml": { source: "iana", compressible: !0 },
  "application/cose": { source: "iana" },
  "application/cose-key": { source: "iana" },
  "application/cose-key-set": { source: "iana" },
  "application/cpl+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["cpl"],
  },
  "application/csrattrs": { source: "iana" },
  "application/csta+xml": { source: "iana", compressible: !0 },
  "application/cstadata+xml": { source: "iana", compressible: !0 },
  "application/csvm+json": { source: "iana", compressible: !0 },
  "application/cu-seeme": { source: "apache", extensions: ["cu"] },
  "application/cwt": { source: "iana" },
  "application/cybercash": { source: "iana" },
  "application/dart": { compressible: !0 },
  "application/dash+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpd"],
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpp"],
  },
  "application/dashdelta": { source: "iana" },
  "application/davmount+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["davmount"],
  },
  "application/dca-rft": { source: "iana" },
  "application/dcd": { source: "iana" },
  "application/dec-dx": { source: "iana" },
  "application/dialog-info+xml": { source: "iana", compressible: !0 },
  "application/dicom": { source: "iana" },
  "application/dicom+json": { source: "iana", compressible: !0 },
  "application/dicom+xml": { source: "iana", compressible: !0 },
  "application/dii": { source: "iana" },
  "application/dit": { source: "iana" },
  "application/dns": { source: "iana" },
  "application/dns+json": { source: "iana", compressible: !0 },
  "application/dns-message": { source: "iana" },
  "application/docbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["dbk"],
  },
  "application/dots+cbor": { source: "iana" },
  "application/dskpp+xml": { source: "iana", compressible: !0 },
  "application/dssc+der": { source: "iana", extensions: ["dssc"] },
  "application/dssc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xdssc"],
  },
  "application/dvcs": { source: "iana" },
  "application/ecmascript": {
    source: "iana",
    compressible: !0,
    extensions: ["es", "ecma"],
  },
  "application/edi-consent": { source: "iana" },
  "application/edi-x12": { source: "iana", compressible: !1 },
  "application/edifact": { source: "iana", compressible: !1 },
  "application/efi": { source: "iana" },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/elm+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.ecall.msd": { source: "iana" },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emma+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["emma"],
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["emotionml"],
  },
  "application/encaprtp": { source: "iana" },
  "application/epp+xml": { source: "iana", compressible: !0 },
  "application/epub+zip": {
    source: "iana",
    compressible: !1,
    extensions: ["epub"],
  },
  "application/eshop": { source: "iana" },
  "application/exi": { source: "iana", extensions: ["exi"] },
  "application/expect-ct-report+json": { source: "iana", compressible: !0 },
  "application/express": { source: "iana", extensions: ["exp"] },
  "application/fastinfoset": { source: "iana" },
  "application/fastsoap": { source: "iana" },
  "application/fdt+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["fdt"],
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/fido.trusted-apps+json": { compressible: !0 },
  "application/fits": { source: "iana" },
  "application/flexfec": { source: "iana" },
  "application/font-sfnt": { source: "iana" },
  "application/font-tdpfr": { source: "iana", extensions: ["pfr"] },
  "application/font-woff": { source: "iana", compressible: !1 },
  "application/framework-attributes+xml": { source: "iana", compressible: !0 },
  "application/geo+json": {
    source: "iana",
    compressible: !0,
    extensions: ["geojson"],
  },
  "application/geo+json-seq": { source: "iana" },
  "application/geopackage+sqlite3": { source: "iana" },
  "application/geoxacml+xml": { source: "iana", compressible: !0 },
  "application/gltf-buffer": { source: "iana" },
  "application/gml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["gml"],
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["gpx"],
  },
  "application/gxf": { source: "apache", extensions: ["gxf"] },
  "application/gzip": { source: "iana", compressible: !1, extensions: ["gz"] },
  "application/h224": { source: "iana" },
  "application/held+xml": { source: "iana", compressible: !0 },
  "application/hjson": { extensions: ["hjson"] },
  "application/http": { source: "iana" },
  "application/hyperstudio": { source: "iana", extensions: ["stk"] },
  "application/ibe-key-request+xml": { source: "iana", compressible: !0 },
  "application/ibe-pkg-reply+xml": { source: "iana", compressible: !0 },
  "application/ibe-pp-data": { source: "iana" },
  "application/iges": { source: "iana" },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/index": { source: "iana" },
  "application/index.cmd": { source: "iana" },
  "application/index.obj": { source: "iana" },
  "application/index.response": { source: "iana" },
  "application/index.vnd": { source: "iana" },
  "application/inkml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ink", "inkml"],
  },
  "application/iotp": { source: "iana" },
  "application/ipfix": { source: "iana", extensions: ["ipfix"] },
  "application/ipp": { source: "iana" },
  "application/isup": { source: "iana" },
  "application/its+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["its"],
  },
  "application/java-archive": {
    source: "apache",
    compressible: !1,
    extensions: ["jar", "war", "ear"],
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: !1,
    extensions: ["ser"],
  },
  "application/java-vm": {
    source: "apache",
    compressible: !1,
    extensions: ["class"],
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["js", "mjs"],
  },
  "application/jf2feed+json": { source: "iana", compressible: !0 },
  "application/jose": { source: "iana" },
  "application/jose+json": { source: "iana", compressible: !0 },
  "application/jrd+json": { source: "iana", compressible: !0 },
  "application/jscalendar+json": { source: "iana", compressible: !0 },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["json", "map"],
  },
  "application/json-patch+json": { source: "iana", compressible: !0 },
  "application/json-seq": { source: "iana" },
  "application/json5": { extensions: ["json5"] },
  "application/jsonml+json": {
    source: "apache",
    compressible: !0,
    extensions: ["jsonml"],
  },
  "application/jwk+json": { source: "iana", compressible: !0 },
  "application/jwk-set+json": { source: "iana", compressible: !0 },
  "application/jwt": { source: "iana" },
  "application/kpml-request+xml": { source: "iana", compressible: !0 },
  "application/kpml-response+xml": { source: "iana", compressible: !0 },
  "application/ld+json": {
    source: "iana",
    compressible: !0,
    extensions: ["jsonld"],
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lgr"],
  },
  "application/link-format": { source: "iana" },
  "application/load-control+xml": { source: "iana", compressible: !0 },
  "application/lost+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lostxml"],
  },
  "application/lostsync+xml": { source: "iana", compressible: !0 },
  "application/lpf+zip": { source: "iana", compressible: !1 },
  "application/lxf": { source: "iana" },
  "application/mac-binhex40": { source: "iana", extensions: ["hqx"] },
  "application/mac-compactpro": { source: "apache", extensions: ["cpt"] },
  "application/macwriteii": { source: "iana" },
  "application/mads+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mads"],
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["webmanifest"],
  },
  "application/marc": { source: "iana", extensions: ["mrc"] },
  "application/marcxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mrcx"],
  },
  "application/mathematica": { source: "iana", extensions: ["ma", "nb", "mb"] },
  "application/mathml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mathml"],
  },
  "application/mathml-content+xml": { source: "iana", compressible: !0 },
  "application/mathml-presentation+xml": { source: "iana", compressible: !0 },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbms-deregister+xml": { source: "iana", compressible: !0 },
  "application/mbms-envelope+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk-response+xml": { source: "iana", compressible: !0 },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbms-reception-report+xml": { source: "iana", compressible: !0 },
  "application/mbms-register+xml": { source: "iana", compressible: !0 },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbms-schedule+xml": { source: "iana", compressible: !0 },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbox": { source: "iana", extensions: ["mbox"] },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpf"],
  },
  "application/media_control+xml": { source: "iana", compressible: !0 },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mscml"],
  },
  "application/merge-patch+json": { source: "iana", compressible: !0 },
  "application/metalink+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["metalink"],
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["meta4"],
  },
  "application/mets+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mets"],
  },
  "application/mf4": { source: "iana" },
  "application/mikey": { source: "iana" },
  "application/mipc": { source: "iana" },
  "application/missing-blocks+cbor-seq": { source: "iana" },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["maei"],
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["musd"],
  },
  "application/mods+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mods"],
  },
  "application/moss-keys": { source: "iana" },
  "application/moss-signature": { source: "iana" },
  "application/mosskey-data": { source: "iana" },
  "application/mosskey-request": { source: "iana" },
  "application/mp21": { source: "iana", extensions: ["m21", "mp21"] },
  "application/mp4": { source: "iana", extensions: ["mp4s", "m4p"] },
  "application/mpeg4-generic": { source: "iana" },
  "application/mpeg4-iod": { source: "iana" },
  "application/mpeg4-iod-xmt": { source: "iana" },
  "application/mrb-consumer+xml": { source: "iana", compressible: !0 },
  "application/mrb-publish+xml": { source: "iana", compressible: !0 },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/msword": {
    source: "iana",
    compressible: !1,
    extensions: ["doc", "dot"],
  },
  "application/mud+json": { source: "iana", compressible: !0 },
  "application/multipart-core": { source: "iana" },
  "application/mxf": { source: "iana", extensions: ["mxf"] },
  "application/n-quads": { source: "iana", extensions: ["nq"] },
  "application/n-triples": { source: "iana", extensions: ["nt"] },
  "application/nasdata": { source: "iana" },
  "application/news-checkgroups": { source: "iana", charset: "US-ASCII" },
  "application/news-groupinfo": { source: "iana", charset: "US-ASCII" },
  "application/news-transmission": { source: "iana" },
  "application/nlsml+xml": { source: "iana", compressible: !0 },
  "application/node": { source: "iana", extensions: ["cjs"] },
  "application/nss": { source: "iana" },
  "application/oauth-authz-req+jwt": { source: "iana" },
  "application/oblivious-dns-message": { source: "iana" },
  "application/ocsp-request": { source: "iana" },
  "application/ocsp-response": { source: "iana" },
  "application/octet-stream": {
    source: "iana",
    compressible: !1,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer",
    ],
  },
  "application/oda": { source: "iana", extensions: ["oda"] },
  "application/odm+xml": { source: "iana", compressible: !0 },
  "application/odx": { source: "iana" },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["opf"],
  },
  "application/ogg": { source: "iana", compressible: !1, extensions: ["ogx"] },
  "application/omdoc+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["omdoc"],
  },
  "application/onenote": {
    source: "apache",
    extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"],
  },
  "application/opc-nodeset+xml": { source: "iana", compressible: !0 },
  "application/oscore": { source: "iana" },
  "application/oxps": { source: "iana", extensions: ["oxps"] },
  "application/p21": { source: "iana" },
  "application/p21+zip": { source: "iana", compressible: !1 },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["relo"],
  },
  "application/parityfec": { source: "iana" },
  "application/passport": { source: "iana" },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xer"],
  },
  "application/pdf": { source: "iana", compressible: !1, extensions: ["pdf"] },
  "application/pdx": { source: "iana" },
  "application/pem-certificate-chain": { source: "iana" },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: !1,
    extensions: ["pgp"],
  },
  "application/pgp-keys": { source: "iana", extensions: ["asc"] },
  "application/pgp-signature": { source: "iana", extensions: ["asc", "sig"] },
  "application/pics-rules": { source: "apache", extensions: ["prf"] },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/pkcs10": { source: "iana", extensions: ["p10"] },
  "application/pkcs12": { source: "iana" },
  "application/pkcs7-mime": { source: "iana", extensions: ["p7m", "p7c"] },
  "application/pkcs7-signature": { source: "iana", extensions: ["p7s"] },
  "application/pkcs8": { source: "iana", extensions: ["p8"] },
  "application/pkcs8-encrypted": { source: "iana" },
  "application/pkix-attr-cert": { source: "iana", extensions: ["ac"] },
  "application/pkix-cert": { source: "iana", extensions: ["cer"] },
  "application/pkix-crl": { source: "iana", extensions: ["crl"] },
  "application/pkix-pkipath": { source: "iana", extensions: ["pkipath"] },
  "application/pkixcmp": { source: "iana", extensions: ["pki"] },
  "application/pls+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["pls"],
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/postscript": {
    source: "iana",
    compressible: !0,
    extensions: ["ai", "eps", "ps"],
  },
  "application/ppsp-tracker+json": { source: "iana", compressible: !0 },
  "application/problem+json": { source: "iana", compressible: !0 },
  "application/problem+xml": { source: "iana", compressible: !0 },
  "application/provenance+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["provx"],
  },
  "application/prs.alvestrand.titrax-sheet": { source: "iana" },
  "application/prs.cww": { source: "iana", extensions: ["cww"] },
  "application/prs.cyn": { source: "iana", charset: "7-BIT" },
  "application/prs.hpub+zip": { source: "iana", compressible: !1 },
  "application/prs.nprend": { source: "iana" },
  "application/prs.plucker": { source: "iana" },
  "application/prs.rdf-xml-crypt": { source: "iana" },
  "application/prs.xsf+xml": { source: "iana", compressible: !0 },
  "application/pskc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["pskcxml"],
  },
  "application/pvd+json": { source: "iana", compressible: !0 },
  "application/qsig": { source: "iana" },
  "application/raml+yaml": { compressible: !0, extensions: ["raml"] },
  "application/raptorfec": { source: "iana" },
  "application/rdap+json": { source: "iana", compressible: !0 },
  "application/rdf+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rdf", "owl"],
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rif"],
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: ["rnc"],
  },
  "application/remote-printing": { source: "iana" },
  "application/reputon+json": { source: "iana", compressible: !0 },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rl"],
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rld"],
  },
  "application/rfc+xml": { source: "iana", compressible: !0 },
  "application/riscos": { source: "iana" },
  "application/rlmi+xml": { source: "iana", compressible: !0 },
  "application/rls-services+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rs"],
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rapd"],
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sls"],
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rusd"],
  },
  "application/rpki-ghostbusters": { source: "iana", extensions: ["gbr"] },
  "application/rpki-manifest": { source: "iana", extensions: ["mft"] },
  "application/rpki-publication": { source: "iana" },
  "application/rpki-roa": { source: "iana", extensions: ["roa"] },
  "application/rpki-updown": { source: "iana" },
  "application/rsd+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["rsd"],
  },
  "application/rss+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["rss"],
  },
  "application/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "application/rtploopback": { source: "iana" },
  "application/rtx": { source: "iana" },
  "application/samlassertion+xml": { source: "iana", compressible: !0 },
  "application/samlmetadata+xml": { source: "iana", compressible: !0 },
  "application/sarif+json": { source: "iana", compressible: !0 },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: !0,
  },
  "application/sbe": { source: "iana" },
  "application/sbml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sbml"],
  },
  "application/scaip+xml": { source: "iana", compressible: !0 },
  "application/scim+json": { source: "iana", compressible: !0 },
  "application/scvp-cv-request": { source: "iana", extensions: ["scq"] },
  "application/scvp-cv-response": { source: "iana", extensions: ["scs"] },
  "application/scvp-vp-request": { source: "iana", extensions: ["spq"] },
  "application/scvp-vp-response": { source: "iana", extensions: ["spp"] },
  "application/sdp": { source: "iana", extensions: ["sdp"] },
  "application/secevent+jwt": { source: "iana" },
  "application/senml+cbor": { source: "iana" },
  "application/senml+json": { source: "iana", compressible: !0 },
  "application/senml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["senmlx"],
  },
  "application/senml-etch+cbor": { source: "iana" },
  "application/senml-etch+json": { source: "iana", compressible: !0 },
  "application/senml-exi": { source: "iana" },
  "application/sensml+cbor": { source: "iana" },
  "application/sensml+json": { source: "iana", compressible: !0 },
  "application/sensml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sensmlx"],
  },
  "application/sensml-exi": { source: "iana" },
  "application/sep+xml": { source: "iana", compressible: !0 },
  "application/sep-exi": { source: "iana" },
  "application/session-info": { source: "iana" },
  "application/set-payment": { source: "iana" },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: ["setpay"],
  },
  "application/set-registration": { source: "iana" },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: ["setreg"],
  },
  "application/sgml": { source: "iana" },
  "application/sgml-open-catalog": { source: "iana" },
  "application/shf+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["shf"],
  },
  "application/sieve": { source: "iana", extensions: ["siv", "sieve"] },
  "application/simple-filter+xml": { source: "iana", compressible: !0 },
  "application/simple-message-summary": { source: "iana" },
  "application/simplesymbolcontainer": { source: "iana" },
  "application/sipc": { source: "iana" },
  "application/slate": { source: "iana" },
  "application/smil": { source: "iana" },
  "application/smil+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["smi", "smil"],
  },
  "application/smpte336m": { source: "iana" },
  "application/soap+fastinfoset": { source: "iana" },
  "application/soap+xml": { source: "iana", compressible: !0 },
  "application/sparql-query": { source: "iana", extensions: ["rq"] },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["srx"],
  },
  "application/spdx+json": { source: "iana", compressible: !0 },
  "application/spirits-event+xml": { source: "iana", compressible: !0 },
  "application/sql": { source: "iana" },
  "application/srgs": { source: "iana", extensions: ["gram"] },
  "application/srgs+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["grxml"],
  },
  "application/sru+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sru"],
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["ssdl"],
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ssml"],
  },
  "application/stix+json": { source: "iana", compressible: !0 },
  "application/swid+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["swidtag"],
  },
  "application/tamp-apex-update": { source: "iana" },
  "application/tamp-apex-update-confirm": { source: "iana" },
  "application/tamp-community-update": { source: "iana" },
  "application/tamp-community-update-confirm": { source: "iana" },
  "application/tamp-error": { source: "iana" },
  "application/tamp-sequence-adjust": { source: "iana" },
  "application/tamp-sequence-adjust-confirm": { source: "iana" },
  "application/tamp-status-query": { source: "iana" },
  "application/tamp-status-response": { source: "iana" },
  "application/tamp-update": { source: "iana" },
  "application/tamp-update-confirm": { source: "iana" },
  "application/tar": { compressible: !0 },
  "application/taxii+json": { source: "iana", compressible: !0 },
  "application/td+json": { source: "iana", compressible: !0 },
  "application/tei+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["tei", "teicorpus"],
  },
  "application/tetra_isi": { source: "iana" },
  "application/thraud+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["tfi"],
  },
  "application/timestamp-query": { source: "iana" },
  "application/timestamp-reply": { source: "iana" },
  "application/timestamped-data": { source: "iana", extensions: ["tsd"] },
  "application/tlsrpt+gzip": { source: "iana" },
  "application/tlsrpt+json": { source: "iana", compressible: !0 },
  "application/tnauthlist": { source: "iana" },
  "application/token-introspection+jwt": { source: "iana" },
  "application/toml": { compressible: !0, extensions: ["toml"] },
  "application/trickle-ice-sdpfrag": { source: "iana" },
  "application/trig": { source: "iana", extensions: ["trig"] },
  "application/ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ttml"],
  },
  "application/tve-trigger": { source: "iana" },
  "application/tzif": { source: "iana" },
  "application/tzif-leap": { source: "iana" },
  "application/ubjson": { compressible: !1, extensions: ["ubj"] },
  "application/ulpfec": { source: "iana" },
  "application/urc-grpsheet+xml": { source: "iana", compressible: !0 },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rsheet"],
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["td"],
  },
  "application/urc-uisocketdesc+xml": { source: "iana", compressible: !0 },
  "application/vcard+json": { source: "iana", compressible: !0 },
  "application/vcard+xml": { source: "iana", compressible: !0 },
  "application/vemmi": { source: "iana" },
  "application/vividence.scriptfile": { source: "apache" },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["1km"],
  },
  "application/vnd.3gpp-prose+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-prose-pc3ch+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-v2x-local-service-information": { source: "iana" },
  "application/vnd.3gpp.5gnas": { source: "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.bsf+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gmop+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gtpc": { source: "iana" },
  "application/vnd.3gpp.interworking-data": { source: "iana" },
  "application/vnd.3gpp.lpp": { source: "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { source: "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcdata-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-payload": { source: "iana" },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcdata-signalling": { source: "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-signed+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mid-call+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.ngap": { source: "iana" },
  "application/vnd.3gpp.pfcp": { source: "iana" },
  "application/vnd.3gpp.pic-bw-large": { source: "iana", extensions: ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { source: "iana", extensions: ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { source: "iana", extensions: ["pvb"] },
  "application/vnd.3gpp.s1ap": { source: "iana" },
  "application/vnd.3gpp.sms": { source: "iana" },
  "application/vnd.3gpp.sms+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-ext+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.ussd+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.bcmcsinfo+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.sms": { source: "iana" },
  "application/vnd.3gpp2.tcap": { source: "iana", extensions: ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { source: "iana" },
  "application/vnd.3m.post-it-notes": { source: "iana", extensions: ["pwn"] },
  "application/vnd.accpac.simply.aso": { source: "iana", extensions: ["aso"] },
  "application/vnd.accpac.simply.imp": { source: "iana", extensions: ["imp"] },
  "application/vnd.acucobol": { source: "iana", extensions: ["acu"] },
  "application/vnd.acucorp": { source: "iana", extensions: ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: !1,
    extensions: ["air"],
  },
  "application/vnd.adobe.flash.movie": { source: "iana" },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: ["fcdt"],
  },
  "application/vnd.adobe.fxp": { source: "iana", extensions: ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { source: "iana" },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xdp"],
  },
  "application/vnd.adobe.xfdf": { source: "iana", extensions: ["xfdf"] },
  "application/vnd.aether.imp": { source: "iana" },
  "application/vnd.afpc.afplinedata": { source: "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { source: "iana" },
  "application/vnd.afpc.cmoca-cmresource": { source: "iana" },
  "application/vnd.afpc.foca-charset": { source: "iana" },
  "application/vnd.afpc.foca-codedfont": { source: "iana" },
  "application/vnd.afpc.foca-codepage": { source: "iana" },
  "application/vnd.afpc.modca": { source: "iana" },
  "application/vnd.afpc.modca-cmtable": { source: "iana" },
  "application/vnd.afpc.modca-formdef": { source: "iana" },
  "application/vnd.afpc.modca-mediummap": { source: "iana" },
  "application/vnd.afpc.modca-objectcontainer": { source: "iana" },
  "application/vnd.afpc.modca-overlay": { source: "iana" },
  "application/vnd.afpc.modca-pagesegment": { source: "iana" },
  "application/vnd.age": { source: "iana", extensions: ["age"] },
  "application/vnd.ah-barcode": { source: "iana" },
  "application/vnd.ahead.space": { source: "iana", extensions: ["ahead"] },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: ["azf"],
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: ["azs"],
  },
  "application/vnd.amadeus+json": { source: "iana", compressible: !0 },
  "application/vnd.amazon.ebook": { source: "apache", extensions: ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { source: "iana" },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: ["acc"],
  },
  "application/vnd.amiga.ami": { source: "iana", extensions: ["ami"] },
  "application/vnd.amundsen.maze+xml": { source: "iana", compressible: !0 },
  "application/vnd.android.ota": { source: "iana" },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: !1,
    extensions: ["apk"],
  },
  "application/vnd.anki": { source: "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: ["cii"],
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: ["fti"],
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: ["atx"],
  },
  "application/vnd.apache.arrow.file": { source: "iana" },
  "application/vnd.apache.arrow.stream": { source: "iana" },
  "application/vnd.apache.thrift.binary": { source: "iana" },
  "application/vnd.apache.thrift.compact": { source: "iana" },
  "application/vnd.apache.thrift.json": { source: "iana" },
  "application/vnd.api+json": { source: "iana", compressible: !0 },
  "application/vnd.aplextor.warrp+json": { source: "iana", compressible: !0 },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpkg"],
  },
  "application/vnd.apple.keynote": { source: "iana", extensions: ["key"] },
  "application/vnd.apple.mpegurl": { source: "iana", extensions: ["m3u8"] },
  "application/vnd.apple.numbers": { source: "iana", extensions: ["numbers"] },
  "application/vnd.apple.pages": { source: "iana", extensions: ["pages"] },
  "application/vnd.apple.pkpass": { compressible: !1, extensions: ["pkpass"] },
  "application/vnd.arastra.swi": { source: "iana" },
  "application/vnd.aristanetworks.swi": { source: "iana", extensions: ["swi"] },
  "application/vnd.artisan+json": { source: "iana", compressible: !0 },
  "application/vnd.artsquare": { source: "iana" },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: ["iota"],
  },
  "application/vnd.audiograph": { source: "iana", extensions: ["aep"] },
  "application/vnd.autopackage": { source: "iana" },
  "application/vnd.avalon+json": { source: "iana", compressible: !0 },
  "application/vnd.avistar+xml": { source: "iana", compressible: !0 },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["bmml"],
  },
  "application/vnd.balsamiq.bmpr": { source: "iana" },
  "application/vnd.banana-accounting": { source: "iana" },
  "application/vnd.bbf.usp.error": { source: "iana" },
  "application/vnd.bbf.usp.msg": { source: "iana" },
  "application/vnd.bbf.usp.msg+json": { source: "iana", compressible: !0 },
  "application/vnd.bekitzur-stech+json": { source: "iana", compressible: !0 },
  "application/vnd.bint.med-content": { source: "iana" },
  "application/vnd.biopax.rdf+xml": { source: "iana", compressible: !0 },
  "application/vnd.blink-idb-value-wrapper": { source: "iana" },
  "application/vnd.blueice.multipass": { source: "iana", extensions: ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { source: "iana" },
  "application/vnd.bluetooth.le.oob": { source: "iana" },
  "application/vnd.bmi": { source: "iana", extensions: ["bmi"] },
  "application/vnd.bpf": { source: "iana" },
  "application/vnd.bpf3": { source: "iana" },
  "application/vnd.businessobjects": { source: "iana", extensions: ["rep"] },
  "application/vnd.byu.uapi+json": { source: "iana", compressible: !0 },
  "application/vnd.cab-jscript": { source: "iana" },
  "application/vnd.canon-cpdl": { source: "iana" },
  "application/vnd.canon-lips": { source: "iana" },
  "application/vnd.capasystems-pg+json": { source: "iana", compressible: !0 },
  "application/vnd.cendio.thinlinc.clientconf": { source: "iana" },
  "application/vnd.century-systems.tcp_stream": { source: "iana" },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["cdxml"],
  },
  "application/vnd.chess-pgn": { source: "iana" },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: ["mmd"],
  },
  "application/vnd.ciedi": { source: "iana" },
  "application/vnd.cinderella": { source: "iana", extensions: ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { source: "iana" },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["csl"],
  },
  "application/vnd.claymore": { source: "iana", extensions: ["cla"] },
  "application/vnd.cloanto.rp9": { source: "iana", extensions: ["rp9"] },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"],
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: ["c11amc"],
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: ["c11amz"],
  },
  "application/vnd.coffeescript": { source: "iana" },
  "application/vnd.collabio.xodocuments.document": { source: "iana" },
  "application/vnd.collabio.xodocuments.document-template": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana",
  },
  "application/vnd.collabio.xodocuments.spreadsheet": { source: "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana",
  },
  "application/vnd.collection+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.doc+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.next+json": { source: "iana", compressible: !0 },
  "application/vnd.comicbook+zip": { source: "iana", compressible: !1 },
  "application/vnd.comicbook-rar": { source: "iana" },
  "application/vnd.commerce-battelle": { source: "iana" },
  "application/vnd.commonspace": { source: "iana", extensions: ["csp"] },
  "application/vnd.contact.cmsg": { source: "iana", extensions: ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { source: "iana", compressible: !0 },
  "application/vnd.cosmocaller": { source: "iana", extensions: ["cmc"] },
  "application/vnd.crick.clicker": { source: "iana", extensions: ["clkx"] },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: ["clkk"],
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: ["clkp"],
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: ["clkt"],
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: ["clkw"],
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wbs"],
  },
  "application/vnd.cryptii.pipe+json": { source: "iana", compressible: !0 },
  "application/vnd.crypto-shade-file": { source: "iana" },
  "application/vnd.cryptomator.encrypted": { source: "iana" },
  "application/vnd.cryptomator.vault": { source: "iana" },
  "application/vnd.ctc-posml": { source: "iana", extensions: ["pml"] },
  "application/vnd.ctct.ws+xml": { source: "iana", compressible: !0 },
  "application/vnd.cups-pdf": { source: "iana" },
  "application/vnd.cups-postscript": { source: "iana" },
  "application/vnd.cups-ppd": { source: "iana", extensions: ["ppd"] },
  "application/vnd.cups-raster": { source: "iana" },
  "application/vnd.cups-raw": { source: "iana" },
  "application/vnd.curl": { source: "iana" },
  "application/vnd.curl.car": { source: "apache", extensions: ["car"] },
  "application/vnd.curl.pcurl": { source: "apache", extensions: ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { source: "iana", compressible: !0 },
  "application/vnd.cybank": { source: "iana" },
  "application/vnd.cyclonedx+json": { source: "iana", compressible: !0 },
  "application/vnd.cyclonedx+xml": { source: "iana", compressible: !0 },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: !1,
  },
  "application/vnd.d3m-dataset": { source: "iana" },
  "application/vnd.d3m-problem": { source: "iana" },
  "application/vnd.dart": {
    source: "iana",
    compressible: !0,
    extensions: ["dart"],
  },
  "application/vnd.data-vision.rdz": { source: "iana", extensions: ["rdz"] },
  "application/vnd.datapackage+json": { source: "iana", compressible: !0 },
  "application/vnd.dataresource+json": { source: "iana", compressible: !0 },
  "application/vnd.dbf": { source: "iana", extensions: ["dbf"] },
  "application/vnd.debian.binary-package": { source: "iana" },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: ["uvf", "uvvf", "uvd", "uvvd"],
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["uvt", "uvvt"],
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: ["uvx", "uvvx"],
  },
  "application/vnd.dece.zip": { source: "iana", extensions: ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: ["fe_launch"],
  },
  "application/vnd.desmume.movie": { source: "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { source: "iana" },
  "application/vnd.dm.delegation+xml": { source: "iana", compressible: !0 },
  "application/vnd.dna": { source: "iana", extensions: ["dna"] },
  "application/vnd.document+json": { source: "iana", compressible: !0 },
  "application/vnd.dolby.mlp": { source: "apache", extensions: ["mlp"] },
  "application/vnd.dolby.mobile.1": { source: "iana" },
  "application/vnd.dolby.mobile.2": { source: "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { source: "iana" },
  "application/vnd.dpgraph": { source: "iana", extensions: ["dpg"] },
  "application/vnd.dreamfactory": { source: "iana", extensions: ["dfac"] },
  "application/vnd.drive+json": { source: "iana", compressible: !0 },
  "application/vnd.ds-keypoint": { source: "apache", extensions: ["kpxx"] },
  "application/vnd.dtg.local": { source: "iana" },
  "application/vnd.dtg.local.flash": { source: "iana" },
  "application/vnd.dtg.local.html": { source: "iana" },
  "application/vnd.dvb.ait": { source: "iana", extensions: ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.dvbj": { source: "iana" },
  "application/vnd.dvb.esgcontainer": { source: "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { source: "iana" },
  "application/vnd.dvb.ipdcesgpdd": { source: "iana" },
  "application/vnd.dvb.ipdcroaming": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-base": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { source: "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-generic+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-init+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.pfr": { source: "iana" },
  "application/vnd.dvb.service": { source: "iana", extensions: ["svc"] },
  "application/vnd.dxr": { source: "iana" },
  "application/vnd.dynageo": { source: "iana", extensions: ["geo"] },
  "application/vnd.dzr": { source: "iana" },
  "application/vnd.easykaraoke.cdgdownload": { source: "iana" },
  "application/vnd.ecdis-update": { source: "iana" },
  "application/vnd.ecip.rlp": { source: "iana" },
  "application/vnd.eclipse.ditto+json": { source: "iana", compressible: !0 },
  "application/vnd.ecowin.chart": { source: "iana", extensions: ["mag"] },
  "application/vnd.ecowin.filerequest": { source: "iana" },
  "application/vnd.ecowin.fileupdate": { source: "iana" },
  "application/vnd.ecowin.series": { source: "iana" },
  "application/vnd.ecowin.seriesrequest": { source: "iana" },
  "application/vnd.ecowin.seriesupdate": { source: "iana" },
  "application/vnd.efi.img": { source: "iana" },
  "application/vnd.efi.iso": { source: "iana" },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.enliven": { source: "iana", extensions: ["nml"] },
  "application/vnd.enphase.envoy": { source: "iana" },
  "application/vnd.eprints.data+xml": { source: "iana", compressible: !0 },
  "application/vnd.epson.esf": { source: "iana", extensions: ["esf"] },
  "application/vnd.epson.msf": { source: "iana", extensions: ["msf"] },
  "application/vnd.epson.quickanime": { source: "iana", extensions: ["qam"] },
  "application/vnd.epson.salt": { source: "iana", extensions: ["slt"] },
  "application/vnd.epson.ssf": { source: "iana", extensions: ["ssf"] },
  "application/vnd.ericsson.quickcall": { source: "iana" },
  "application/vnd.espass-espass+zip": { source: "iana", compressible: !1 },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["es3", "et3"],
  },
  "application/vnd.etsi.aoc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.asic-e+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.asic-s+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.cug+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvcommand+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.etsi.iptvprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-bc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-cod+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-npvr+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvservice+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsync+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.etsi.mcid+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.mheg5": { source: "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.etsi.pstn+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.sci+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.simservs+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.timestamp-token": { source: "iana" },
  "application/vnd.etsi.tsl+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.tsl.der": { source: "iana" },
  "application/vnd.eu.kasparian.car+json": { source: "iana", compressible: !0 },
  "application/vnd.eudora.data": { source: "iana" },
  "application/vnd.evolv.ecig.profile": { source: "iana" },
  "application/vnd.evolv.ecig.settings": { source: "iana" },
  "application/vnd.evolv.ecig.theme": { source: "iana" },
  "application/vnd.exstream-empower+zip": { source: "iana", compressible: !1 },
  "application/vnd.exstream-package": { source: "iana" },
  "application/vnd.ezpix-album": { source: "iana", extensions: ["ez2"] },
  "application/vnd.ezpix-package": { source: "iana", extensions: ["ez3"] },
  "application/vnd.f-secure.mobile": { source: "iana" },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: !1,
  },
  "application/vnd.fastcopy-disk-image": { source: "iana" },
  "application/vnd.fdf": { source: "iana", extensions: ["fdf"] },
  "application/vnd.fdsn.mseed": { source: "iana", extensions: ["mseed"] },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: ["seed", "dataless"],
  },
  "application/vnd.ffsns": { source: "iana" },
  "application/vnd.ficlab.flb+zip": { source: "iana", compressible: !1 },
  "application/vnd.filmit.zfc": { source: "iana" },
  "application/vnd.fints": { source: "iana" },
  "application/vnd.firemonkeys.cloudcell": { source: "iana" },
  "application/vnd.flographit": { source: "iana", extensions: ["gph"] },
  "application/vnd.fluxtime.clip": { source: "iana", extensions: ["ftc"] },
  "application/vnd.font-fontforge-sfd": { source: "iana" },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: ["fm", "frame", "maker", "book"],
  },
  "application/vnd.frogans.fnc": { source: "iana", extensions: ["fnc"] },
  "application/vnd.frogans.ltf": { source: "iana", extensions: ["ltf"] },
  "application/vnd.fsc.weblaunch": { source: "iana", extensions: ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { source: "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { source: "iana", compressible: !0 },
  "application/vnd.fujitsu.oasys": { source: "iana", extensions: ["oas"] },
  "application/vnd.fujitsu.oasys2": { source: "iana", extensions: ["oa2"] },
  "application/vnd.fujitsu.oasys3": { source: "iana", extensions: ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { source: "iana", extensions: ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { source: "iana", extensions: ["bh2"] },
  "application/vnd.fujixerox.art-ex": { source: "iana" },
  "application/vnd.fujixerox.art4": { source: "iana" },
  "application/vnd.fujixerox.ddd": { source: "iana", extensions: ["ddd"] },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: ["xdw"],
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: ["xbd"],
  },
  "application/vnd.fujixerox.docuworks.container": { source: "iana" },
  "application/vnd.fujixerox.hbpl": { source: "iana" },
  "application/vnd.fut-misnet": { source: "iana" },
  "application/vnd.futoin+cbor": { source: "iana" },
  "application/vnd.futoin+json": { source: "iana", compressible: !0 },
  "application/vnd.fuzzysheet": { source: "iana", extensions: ["fzs"] },
  "application/vnd.genomatix.tuxedo": { source: "iana", extensions: ["txd"] },
  "application/vnd.gentics.grd+json": { source: "iana", compressible: !0 },
  "application/vnd.geo+json": { source: "iana", compressible: !0 },
  "application/vnd.geocube+xml": { source: "iana", compressible: !0 },
  "application/vnd.geogebra.file": { source: "iana", extensions: ["ggb"] },
  "application/vnd.geogebra.slides": { source: "iana" },
  "application/vnd.geogebra.tool": { source: "iana", extensions: ["ggt"] },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: ["gex", "gre"],
  },
  "application/vnd.geonext": { source: "iana", extensions: ["gxt"] },
  "application/vnd.geoplan": { source: "iana", extensions: ["g2w"] },
  "application/vnd.geospace": { source: "iana", extensions: ["g3w"] },
  "application/vnd.gerber": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana",
  },
  "application/vnd.gmx": { source: "iana", extensions: ["gmx"] },
  "application/vnd.google-apps.document": {
    compressible: !1,
    extensions: ["gdoc"],
  },
  "application/vnd.google-apps.presentation": {
    compressible: !1,
    extensions: ["gslides"],
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: !1,
    extensions: ["gsheet"],
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["kml"],
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: !1,
    extensions: ["kmz"],
  },
  "application/vnd.gov.sk.e-form+xml": { source: "iana", compressible: !0 },
  "application/vnd.gov.sk.e-form+zip": { source: "iana", compressible: !1 },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.grafeq": { source: "iana", extensions: ["gqf", "gqs"] },
  "application/vnd.gridmp": { source: "iana" },
  "application/vnd.groove-account": { source: "iana", extensions: ["gac"] },
  "application/vnd.groove-help": { source: "iana", extensions: ["ghf"] },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: ["gim"],
  },
  "application/vnd.groove-injector": { source: "iana", extensions: ["grv"] },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: ["gtm"],
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: ["tpl"],
  },
  "application/vnd.groove-vcard": { source: "iana", extensions: ["vcg"] },
  "application/vnd.hal+json": { source: "iana", compressible: !0 },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["hal"],
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["zmm"],
  },
  "application/vnd.hbci": { source: "iana", extensions: ["hbci"] },
  "application/vnd.hc+json": { source: "iana", compressible: !0 },
  "application/vnd.hcl-bireports": { source: "iana" },
  "application/vnd.hdt": { source: "iana" },
  "application/vnd.heroku+json": { source: "iana", compressible: !0 },
  "application/vnd.hhe.lesson-player": { source: "iana", extensions: ["les"] },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.hp-hpgl": { source: "iana", extensions: ["hpgl"] },
  "application/vnd.hp-hpid": { source: "iana", extensions: ["hpid"] },
  "application/vnd.hp-hps": { source: "iana", extensions: ["hps"] },
  "application/vnd.hp-jlyt": { source: "iana", extensions: ["jlt"] },
  "application/vnd.hp-pcl": { source: "iana", extensions: ["pcl"] },
  "application/vnd.hp-pclxl": { source: "iana", extensions: ["pclxl"] },
  "application/vnd.httphone": { source: "iana" },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: ["sfd-hdstx"],
  },
  "application/vnd.hyper+json": { source: "iana", compressible: !0 },
  "application/vnd.hyper-item+json": { source: "iana", compressible: !0 },
  "application/vnd.hyperdrive+json": { source: "iana", compressible: !0 },
  "application/vnd.hzn-3d-crossword": { source: "iana" },
  "application/vnd.ibm.afplinedata": { source: "iana" },
  "application/vnd.ibm.electronic-media": { source: "iana" },
  "application/vnd.ibm.minipay": { source: "iana", extensions: ["mpy"] },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: ["afp", "listafp", "list3820"],
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: ["irm"],
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: ["sc"],
  },
  "application/vnd.iccprofile": { source: "iana", extensions: ["icc", "icm"] },
  "application/vnd.ieee.1905": { source: "iana" },
  "application/vnd.igloader": { source: "iana", extensions: ["igl"] },
  "application/vnd.imagemeter.folder+zip": { source: "iana", compressible: !1 },
  "application/vnd.imagemeter.image+zip": { source: "iana", compressible: !1 },
  "application/vnd.immervision-ivp": { source: "iana", extensions: ["ivp"] },
  "application/vnd.immervision-ivu": { source: "iana", extensions: ["ivu"] },
  "application/vnd.ims.imsccv1p1": { source: "iana" },
  "application/vnd.ims.imsccv1p2": { source: "iana" },
  "application/vnd.ims.imsccv1p3": { source: "iana" },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.informix-visionary": { source: "iana" },
  "application/vnd.infotech.project": { source: "iana" },
  "application/vnd.infotech.project+xml": { source: "iana", compressible: !0 },
  "application/vnd.innopath.wamp.notification": { source: "iana" },
  "application/vnd.insors.igm": { source: "iana", extensions: ["igm"] },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: ["xpw", "xpx"],
  },
  "application/vnd.intergeo": { source: "iana", extensions: ["i2g"] },
  "application/vnd.intertrust.digibox": { source: "iana" },
  "application/vnd.intertrust.nncp": { source: "iana" },
  "application/vnd.intu.qbo": { source: "iana", extensions: ["qbo"] },
  "application/vnd.intu.qfx": { source: "iana", extensions: ["qfx"] },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.newsitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: ["rcprofile"],
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["irp"],
  },
  "application/vnd.is-xpr": { source: "iana", extensions: ["xpr"] },
  "application/vnd.isac.fcs": { source: "iana", extensions: ["fcs"] },
  "application/vnd.iso11783-10+zip": { source: "iana", compressible: !1 },
  "application/vnd.jam": { source: "iana", extensions: ["jam"] },
  "application/vnd.japannet-directory-service": { source: "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { source: "iana" },
  "application/vnd.japannet-payment-wakeup": { source: "iana" },
  "application/vnd.japannet-registration": { source: "iana" },
  "application/vnd.japannet-registration-wakeup": { source: "iana" },
  "application/vnd.japannet-setstore-wakeup": { source: "iana" },
  "application/vnd.japannet-verification": { source: "iana" },
  "application/vnd.japannet-verification-wakeup": { source: "iana" },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: ["rms"],
  },
  "application/vnd.jisp": { source: "iana", extensions: ["jisp"] },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: ["joda"],
  },
  "application/vnd.jsk.isdn-ngn": { source: "iana" },
  "application/vnd.kahootz": { source: "iana", extensions: ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { source: "iana", extensions: ["karbon"] },
  "application/vnd.kde.kchart": { source: "iana", extensions: ["chrt"] },
  "application/vnd.kde.kformula": { source: "iana", extensions: ["kfo"] },
  "application/vnd.kde.kivio": { source: "iana", extensions: ["flw"] },
  "application/vnd.kde.kontour": { source: "iana", extensions: ["kon"] },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: ["kpr", "kpt"],
  },
  "application/vnd.kde.kspread": { source: "iana", extensions: ["ksp"] },
  "application/vnd.kde.kword": { source: "iana", extensions: ["kwd", "kwt"] },
  "application/vnd.kenameaapp": { source: "iana", extensions: ["htke"] },
  "application/vnd.kidspiration": { source: "iana", extensions: ["kia"] },
  "application/vnd.kinar": { source: "iana", extensions: ["kne", "knp"] },
  "application/vnd.koan": {
    source: "iana",
    extensions: ["skp", "skd", "skt", "skm"],
  },
  "application/vnd.kodak-descriptor": { source: "iana", extensions: ["sse"] },
  "application/vnd.las": { source: "iana" },
  "application/vnd.las.las+json": { source: "iana", compressible: !0 },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lasxml"],
  },
  "application/vnd.laszip": { source: "iana" },
  "application/vnd.leap+json": { source: "iana", compressible: !0 },
  "application/vnd.liberty-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: ["lbd"],
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lbe"],
  },
  "application/vnd.logipipe.circuit+zip": { source: "iana", compressible: !1 },
  "application/vnd.loom": { source: "iana" },
  "application/vnd.lotus-1-2-3": { source: "iana", extensions: ["123"] },
  "application/vnd.lotus-approach": { source: "iana", extensions: ["apr"] },
  "application/vnd.lotus-freelance": { source: "iana", extensions: ["pre"] },
  "application/vnd.lotus-notes": { source: "iana", extensions: ["nsf"] },
  "application/vnd.lotus-organizer": { source: "iana", extensions: ["org"] },
  "application/vnd.lotus-screencam": { source: "iana", extensions: ["scm"] },
  "application/vnd.lotus-wordpro": { source: "iana", extensions: ["lwp"] },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: ["portpkg"],
  },
  "application/vnd.mapbox-vector-tile": { source: "iana", extensions: ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.marlin.drm.mdcf": { source: "iana" },
  "application/vnd.mason+json": { source: "iana", compressible: !0 },
  "application/vnd.maxar.archive.3tz+zip": { source: "iana", compressible: !1 },
  "application/vnd.maxmind.maxmind-db": { source: "iana" },
  "application/vnd.mcd": { source: "iana", extensions: ["mcd"] },
  "application/vnd.medcalcdata": { source: "iana", extensions: ["mc1"] },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: ["cdkey"],
  },
  "application/vnd.meridian-slingshot": { source: "iana" },
  "application/vnd.mfer": { source: "iana", extensions: ["mwf"] },
  "application/vnd.mfmp": { source: "iana", extensions: ["mfm"] },
  "application/vnd.micro+json": { source: "iana", compressible: !0 },
  "application/vnd.micrografx.flo": { source: "iana", extensions: ["flo"] },
  "application/vnd.micrografx.igx": { source: "iana", extensions: ["igx"] },
  "application/vnd.microsoft.portable-executable": { source: "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { source: "iana" },
  "application/vnd.miele+json": { source: "iana", compressible: !0 },
  "application/vnd.mif": { source: "iana", extensions: ["mif"] },
  "application/vnd.minisoft-hp3000-save": { source: "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { source: "iana" },
  "application/vnd.mobius.daf": { source: "iana", extensions: ["daf"] },
  "application/vnd.mobius.dis": { source: "iana", extensions: ["dis"] },
  "application/vnd.mobius.mbk": { source: "iana", extensions: ["mbk"] },
  "application/vnd.mobius.mqy": { source: "iana", extensions: ["mqy"] },
  "application/vnd.mobius.msl": { source: "iana", extensions: ["msl"] },
  "application/vnd.mobius.plc": { source: "iana", extensions: ["plc"] },
  "application/vnd.mobius.txf": { source: "iana", extensions: ["txf"] },
  "application/vnd.mophun.application": { source: "iana", extensions: ["mpn"] },
  "application/vnd.mophun.certificate": { source: "iana", extensions: ["mpc"] },
  "application/vnd.motorola.flexsuite": { source: "iana" },
  "application/vnd.motorola.flexsuite.adsi": { source: "iana" },
  "application/vnd.motorola.flexsuite.fis": { source: "iana" },
  "application/vnd.motorola.flexsuite.gotap": { source: "iana" },
  "application/vnd.motorola.flexsuite.kmr": { source: "iana" },
  "application/vnd.motorola.flexsuite.ttc": { source: "iana" },
  "application/vnd.motorola.flexsuite.wem": { source: "iana" },
  "application/vnd.motorola.iprm": { source: "iana" },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xul"],
  },
  "application/vnd.ms-3mfdocument": { source: "iana" },
  "application/vnd.ms-artgalry": { source: "iana", extensions: ["cil"] },
  "application/vnd.ms-asf": { source: "iana" },
  "application/vnd.ms-cab-compressed": { source: "iana", extensions: ["cab"] },
  "application/vnd.ms-color.iccprofile": { source: "apache" },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: !1,
    extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: ["xlam"],
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: ["xlsb"],
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: ["xlsm"],
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: ["xltm"],
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: !0,
    extensions: ["eot"],
  },
  "application/vnd.ms-htmlhelp": { source: "iana", extensions: ["chm"] },
  "application/vnd.ms-ims": { source: "iana", extensions: ["ims"] },
  "application/vnd.ms-lrm": { source: "iana", extensions: ["lrm"] },
  "application/vnd.ms-office.activex+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-officetheme": { source: "iana", extensions: ["thmx"] },
  "application/vnd.ms-opentype": { source: "apache", compressible: !0 },
  "application/vnd.ms-outlook": { compressible: !1, extensions: ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { source: "apache" },
  "application/vnd.ms-pki.seccat": { source: "apache", extensions: ["cat"] },
  "application/vnd.ms-pki.stl": { source: "apache", extensions: ["stl"] },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: !1,
    extensions: ["ppt", "pps", "pot"],
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: ["ppam"],
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: ["pptm"],
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: ["sldm"],
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: ["ppsm"],
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: ["potm"],
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: !0,
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ms-project": { source: "iana", extensions: ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { source: "iana" },
  "application/vnd.ms-windows.devicepairing": { source: "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { source: "iana" },
  "application/vnd.ms-windows.printerpairing": { source: "iana" },
  "application/vnd.ms-windows.wsd.oob": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { source: "iana" },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: ["docm"],
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: ["dotm"],
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: ["wps", "wks", "wcm", "wdb"],
  },
  "application/vnd.ms-wpl": { source: "iana", extensions: ["wpl"] },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: !1,
    extensions: ["xps"],
  },
  "application/vnd.msa-disk-image": { source: "iana" },
  "application/vnd.mseq": { source: "iana", extensions: ["mseq"] },
  "application/vnd.msign": { source: "iana" },
  "application/vnd.multiad.creator": { source: "iana" },
  "application/vnd.multiad.creator.cif": { source: "iana" },
  "application/vnd.music-niff": { source: "iana" },
  "application/vnd.musician": { source: "iana", extensions: ["mus"] },
  "application/vnd.muvee.style": { source: "iana", extensions: ["msty"] },
  "application/vnd.mynfc": { source: "iana", extensions: ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { source: "iana", compressible: !0 },
  "application/vnd.ncd.control": { source: "iana" },
  "application/vnd.ncd.reference": { source: "iana" },
  "application/vnd.nearst.inv+json": { source: "iana", compressible: !0 },
  "application/vnd.nebumind.line": { source: "iana" },
  "application/vnd.nervana": { source: "iana" },
  "application/vnd.netfpx": { source: "iana" },
  "application/vnd.neurolanguage.nlu": { source: "iana", extensions: ["nlu"] },
  "application/vnd.nimn": { source: "iana" },
  "application/vnd.nintendo.nitro.rom": { source: "iana" },
  "application/vnd.nintendo.snes.rom": { source: "iana" },
  "application/vnd.nitf": { source: "iana", extensions: ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { source: "iana", extensions: ["nnd"] },
  "application/vnd.noblenet-sealer": { source: "iana", extensions: ["nns"] },
  "application/vnd.noblenet-web": { source: "iana", extensions: ["nnw"] },
  "application/vnd.nokia.catalogs": { source: "iana" },
  "application/vnd.nokia.conml+wbxml": { source: "iana" },
  "application/vnd.nokia.conml+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.iptv.config+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.isds-radio-presets": { source: "iana" },
  "application/vnd.nokia.landmark+wbxml": { source: "iana" },
  "application/vnd.nokia.landmark+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ac"],
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: ["ngdat"],
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: ["n-gage"],
  },
  "application/vnd.nokia.ncd": { source: "iana" },
  "application/vnd.nokia.pcd+wbxml": { source: "iana" },
  "application/vnd.nokia.pcd+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: ["rpst"],
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: ["rpss"],
  },
  "application/vnd.novadigm.edm": { source: "iana", extensions: ["edm"] },
  "application/vnd.novadigm.edx": { source: "iana", extensions: ["edx"] },
  "application/vnd.novadigm.ext": { source: "iana", extensions: ["ext"] },
  "application/vnd.ntt-local.content-share": { source: "iana" },
  "application/vnd.ntt-local.file-transfer": { source: "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { source: "iana" },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: ["odc"],
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: ["otc"],
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: ["odb"],
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: ["odf"],
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: ["odft"],
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: !1,
    extensions: ["odg"],
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: ["otg"],
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: ["odi"],
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: ["oti"],
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: !1,
    extensions: ["odp"],
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: ["otp"],
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: !1,
    extensions: ["ods"],
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: ["ots"],
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: !1,
    extensions: ["odt"],
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: ["odm"],
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: ["ott"],
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: ["oth"],
  },
  "application/vnd.obn": { source: "iana" },
  "application/vnd.ocf+cbor": { source: "iana" },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oftn.l10n+json": { source: "iana", compressible: !0 },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oipf.cspg-hexbinary": { source: "iana" },
  "application/vnd.oipf.dae.svg+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.dae.xhtml+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oipf.pae.gem": { source: "iana" },
  "application/vnd.oipf.spdiscovery+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.spdlist+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.ueprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.userprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.olpc-sugar": { source: "iana", extensions: ["xo"] },
  "application/vnd.oma-scws-config": { source: "iana" },
  "application/vnd.oma-scws-http-request": { source: "iana" },
  "application/vnd.oma-scws-http-response": { source: "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.imd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.ltkm": { source: "iana" },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.provisioningtrigger": { source: "iana" },
  "application/vnd.oma.bcast.sgboot": { source: "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.sgdu": { source: "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { source: "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.sprov+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.stkm": { source: "iana" },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.cab-pcc+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.dcd": { source: "iana" },
  "application/vnd.oma.dcdc": { source: "iana" },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["dd2"],
  },
  "application/vnd.oma.drm.risd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.lwm2m+cbor": { source: "iana" },
  "application/vnd.oma.lwm2m+json": { source: "iana", compressible: !0 },
  "application/vnd.oma.lwm2m+tlv": { source: "iana" },
  "application/vnd.oma.pal+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.poc.groups+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.push": { source: "iana" },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.omaloc-supl-init": { source: "iana" },
  "application/vnd.onepager": { source: "iana" },
  "application/vnd.onepagertamp": { source: "iana" },
  "application/vnd.onepagertamx": { source: "iana" },
  "application/vnd.onepagertat": { source: "iana" },
  "application/vnd.onepagertatp": { source: "iana" },
  "application/vnd.onepagertatx": { source: "iana" },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["obgx"],
  },
  "application/vnd.openblox.game-binary": { source: "iana" },
  "application/vnd.openeye.oeb": { source: "iana" },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: ["oxt"],
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["osm"],
  },
  "application/vnd.opentimestamps.ots": { source: "iana" },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: !1,
    extensions: ["pptx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: ["sldx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: ["ppsx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: ["potx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: !1,
    extensions: ["xlsx"],
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: ["xltx"],
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana",
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: !1,
    extensions: ["docx"],
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: ["dotx"],
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oracle.resource+json": { source: "iana", compressible: !0 },
  "application/vnd.orange.indata": { source: "iana" },
  "application/vnd.osa.netdeploy": { source: "iana" },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: ["mgp"],
  },
  "application/vnd.osgi.bundle": { source: "iana" },
  "application/vnd.osgi.dp": { source: "iana", extensions: ["dp"] },
  "application/vnd.osgi.subsystem": { source: "iana", extensions: ["esa"] },
  "application/vnd.otps.ct-kip+xml": { source: "iana", compressible: !0 },
  "application/vnd.oxli.countgraph": { source: "iana" },
  "application/vnd.pagerduty+json": { source: "iana", compressible: !0 },
  "application/vnd.palm": {
    source: "iana",
    extensions: ["pdb", "pqa", "oprc"],
  },
  "application/vnd.panoply": { source: "iana" },
  "application/vnd.paos.xml": { source: "iana" },
  "application/vnd.patentdive": { source: "iana" },
  "application/vnd.patientecommsdoc": { source: "iana" },
  "application/vnd.pawaafile": { source: "iana", extensions: ["paw"] },
  "application/vnd.pcos": { source: "iana" },
  "application/vnd.pg.format": { source: "iana", extensions: ["str"] },
  "application/vnd.pg.osasli": { source: "iana", extensions: ["ei6"] },
  "application/vnd.piaccess.application-licence": { source: "iana" },
  "application/vnd.picsel": { source: "iana", extensions: ["efif"] },
  "application/vnd.pmi.widget": { source: "iana", extensions: ["wg"] },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.pocketlearn": { source: "iana", extensions: ["plf"] },
  "application/vnd.powerbuilder6": { source: "iana", extensions: ["pbd"] },
  "application/vnd.powerbuilder6-s": { source: "iana" },
  "application/vnd.powerbuilder7": { source: "iana" },
  "application/vnd.powerbuilder7-s": { source: "iana" },
  "application/vnd.powerbuilder75": { source: "iana" },
  "application/vnd.powerbuilder75-s": { source: "iana" },
  "application/vnd.preminet": { source: "iana" },
  "application/vnd.previewsystems.box": { source: "iana", extensions: ["box"] },
  "application/vnd.proteus.magazine": { source: "iana", extensions: ["mgz"] },
  "application/vnd.psfs": { source: "iana" },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: ["qps"],
  },
  "application/vnd.pvi.ptid1": { source: "iana", extensions: ["ptid"] },
  "application/vnd.pwg-multiplexed": { source: "iana" },
  "application/vnd.pwg-xhtml-print+xml": { source: "iana", compressible: !0 },
  "application/vnd.qualcomm.brew-app-res": { source: "iana" },
  "application/vnd.quarantainenet": { source: "iana" },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
  },
  "application/vnd.quobject-quoxdocument": { source: "iana" },
  "application/vnd.radisys.moml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-conf+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.rainstor.data": { source: "iana" },
  "application/vnd.rapid": { source: "iana" },
  "application/vnd.rar": { source: "iana", extensions: ["rar"] },
  "application/vnd.realvnc.bed": { source: "iana", extensions: ["bed"] },
  "application/vnd.recordare.musicxml": { source: "iana", extensions: ["mxl"] },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["musicxml"],
  },
  "application/vnd.renlearn.rlprint": { source: "iana" },
  "application/vnd.resilient.logic": { source: "iana" },
  "application/vnd.restful+json": { source: "iana", compressible: !0 },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: ["cryptonote"],
  },
  "application/vnd.rim.cod": { source: "apache", extensions: ["cod"] },
  "application/vnd.rn-realmedia": { source: "apache", extensions: ["rm"] },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: ["rmvb"],
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["link66"],
  },
  "application/vnd.rs-274x": { source: "iana" },
  "application/vnd.ruckus.download": { source: "iana" },
  "application/vnd.s3sms": { source: "iana" },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: ["st"],
  },
  "application/vnd.sar": { source: "iana" },
  "application/vnd.sbm.cid": { source: "iana" },
  "application/vnd.sbm.mid2": { source: "iana" },
  "application/vnd.scribus": { source: "iana" },
  "application/vnd.sealed.3df": { source: "iana" },
  "application/vnd.sealed.csf": { source: "iana" },
  "application/vnd.sealed.doc": { source: "iana" },
  "application/vnd.sealed.eml": { source: "iana" },
  "application/vnd.sealed.mht": { source: "iana" },
  "application/vnd.sealed.net": { source: "iana" },
  "application/vnd.sealed.ppt": { source: "iana" },
  "application/vnd.sealed.tiff": { source: "iana" },
  "application/vnd.sealed.xls": { source: "iana" },
  "application/vnd.sealedmedia.softseal.html": { source: "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { source: "iana" },
  "application/vnd.seemail": { source: "iana", extensions: ["see"] },
  "application/vnd.seis+json": { source: "iana", compressible: !0 },
  "application/vnd.sema": { source: "iana", extensions: ["sema"] },
  "application/vnd.semd": { source: "iana", extensions: ["semd"] },
  "application/vnd.semf": { source: "iana", extensions: ["semf"] },
  "application/vnd.shade-save-file": { source: "iana" },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: ["ifm"],
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: ["itp"],
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: ["iif"],
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: ["ipk"],
  },
  "application/vnd.shootproof+json": { source: "iana", compressible: !0 },
  "application/vnd.shopkick+json": { source: "iana", compressible: !0 },
  "application/vnd.shp": { source: "iana" },
  "application/vnd.shx": { source: "iana" },
  "application/vnd.sigrok.session": { source: "iana" },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: ["twd", "twds"],
  },
  "application/vnd.siren+json": { source: "iana", compressible: !0 },
  "application/vnd.smaf": { source: "iana", extensions: ["mmf"] },
  "application/vnd.smart.notebook": { source: "iana" },
  "application/vnd.smart.teacher": { source: "iana", extensions: ["teacher"] },
  "application/vnd.snesdev-page-table": { source: "iana" },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["fo"],
  },
  "application/vnd.software602.filler.form-xml-zip": { source: "iana" },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sdkm", "sdkd"],
  },
  "application/vnd.spotfire.dxp": { source: "iana", extensions: ["dxp"] },
  "application/vnd.spotfire.sfs": { source: "iana", extensions: ["sfs"] },
  "application/vnd.sqlite3": { source: "iana" },
  "application/vnd.sss-cod": { source: "iana" },
  "application/vnd.sss-dtf": { source: "iana" },
  "application/vnd.sss-ntf": { source: "iana" },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: ["sdc"],
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: ["sda"],
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: ["sdd"],
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: ["smf"],
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: ["sdw", "vor"],
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: ["sgl"],
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: ["smzip"],
  },
  "application/vnd.stepmania.stepchart": { source: "iana", extensions: ["sm"] },
  "application/vnd.street-stream": { source: "iana" },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wadl"],
  },
  "application/vnd.sun.xml.calc": { source: "apache", extensions: ["sxc"] },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: ["stc"],
  },
  "application/vnd.sun.xml.draw": { source: "apache", extensions: ["sxd"] },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: ["std"],
  },
  "application/vnd.sun.xml.impress": { source: "apache", extensions: ["sxi"] },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: ["sti"],
  },
  "application/vnd.sun.xml.math": { source: "apache", extensions: ["sxm"] },
  "application/vnd.sun.xml.writer": { source: "apache", extensions: ["sxw"] },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: ["sxg"],
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: ["stw"],
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: ["sus", "susp"],
  },
  "application/vnd.svd": { source: "iana", extensions: ["svd"] },
  "application/vnd.swiftview-ics": { source: "iana" },
  "application/vnd.sycle+xml": { source: "iana", compressible: !0 },
  "application/vnd.syft+json": { source: "iana", compressible: !0 },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: ["sis", "sisx"],
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["xsm"],
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["bdm"],
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["xdm"],
  },
  "application/vnd.syncml.dm.notification": { source: "iana" },
  "application/vnd.syncml.dmddf+wbxml": { source: "iana" },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["ddf"],
  },
  "application/vnd.syncml.dmtnds+wbxml": { source: "iana" },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.syncml.ds.notification": { source: "iana" },
  "application/vnd.tableschema+json": { source: "iana", compressible: !0 },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: ["tao"],
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: ["pcap", "cap", "dmp"],
  },
  "application/vnd.think-cell.ppttc+json": { source: "iana", compressible: !0 },
  "application/vnd.tmd.mediaflex.api+xml": { source: "iana", compressible: !0 },
  "application/vnd.tml": { source: "iana" },
  "application/vnd.tmobile-livetv": { source: "iana", extensions: ["tmo"] },
  "application/vnd.tri.onesource": { source: "iana" },
  "application/vnd.trid.tpt": { source: "iana", extensions: ["tpt"] },
  "application/vnd.triscape.mxs": { source: "iana", extensions: ["mxs"] },
  "application/vnd.trueapp": { source: "iana", extensions: ["tra"] },
  "application/vnd.truedoc": { source: "iana" },
  "application/vnd.ubisoft.webplayer": { source: "iana" },
  "application/vnd.ufdl": { source: "iana", extensions: ["ufd", "ufdl"] },
  "application/vnd.uiq.theme": { source: "iana", extensions: ["utz"] },
  "application/vnd.umajin": { source: "iana", extensions: ["umj"] },
  "application/vnd.unity": { source: "iana", extensions: ["unityweb"] },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["uoml"],
  },
  "application/vnd.uplanet.alert": { source: "iana" },
  "application/vnd.uplanet.alert-wbxml": { source: "iana" },
  "application/vnd.uplanet.bearer-choice": { source: "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { source: "iana" },
  "application/vnd.uplanet.cacheop": { source: "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { source: "iana" },
  "application/vnd.uplanet.channel": { source: "iana" },
  "application/vnd.uplanet.channel-wbxml": { source: "iana" },
  "application/vnd.uplanet.list": { source: "iana" },
  "application/vnd.uplanet.list-wbxml": { source: "iana" },
  "application/vnd.uplanet.listcmd": { source: "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { source: "iana" },
  "application/vnd.uplanet.signal": { source: "iana" },
  "application/vnd.uri-map": { source: "iana" },
  "application/vnd.valve.source.material": { source: "iana" },
  "application/vnd.vcx": { source: "iana", extensions: ["vcx"] },
  "application/vnd.vd-study": { source: "iana" },
  "application/vnd.vectorworks": { source: "iana" },
  "application/vnd.vel+json": { source: "iana", compressible: !0 },
  "application/vnd.verimatrix.vcas": { source: "iana" },
  "application/vnd.veritone.aion+json": { source: "iana", compressible: !0 },
  "application/vnd.veryant.thin": { source: "iana" },
  "application/vnd.ves.encrypted": { source: "iana" },
  "application/vnd.vidsoft.vidconference": { source: "iana" },
  "application/vnd.visio": {
    source: "iana",
    extensions: ["vsd", "vst", "vss", "vsw"],
  },
  "application/vnd.visionary": { source: "iana", extensions: ["vis"] },
  "application/vnd.vividence.scriptfile": { source: "iana" },
  "application/vnd.vsf": { source: "iana", extensions: ["vsf"] },
  "application/vnd.wap.sic": { source: "iana" },
  "application/vnd.wap.slc": { source: "iana" },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["wbxml"],
  },
  "application/vnd.wap.wmlc": { source: "iana", extensions: ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { source: "iana", extensions: ["wmlsc"] },
  "application/vnd.webturbo": { source: "iana", extensions: ["wtb"] },
  "application/vnd.wfa.dpp": { source: "iana" },
  "application/vnd.wfa.p2p": { source: "iana" },
  "application/vnd.wfa.wsc": { source: "iana" },
  "application/vnd.windows.devicepairing": { source: "iana" },
  "application/vnd.wmc": { source: "iana" },
  "application/vnd.wmf.bootstrap": { source: "iana" },
  "application/vnd.wolfram.mathematica": { source: "iana" },
  "application/vnd.wolfram.mathematica.package": { source: "iana" },
  "application/vnd.wolfram.player": { source: "iana", extensions: ["nbp"] },
  "application/vnd.wordperfect": { source: "iana", extensions: ["wpd"] },
  "application/vnd.wqd": { source: "iana", extensions: ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { source: "iana" },
  "application/vnd.wt.stf": { source: "iana", extensions: ["stf"] },
  "application/vnd.wv.csp+wbxml": { source: "iana" },
  "application/vnd.wv.csp+xml": { source: "iana", compressible: !0 },
  "application/vnd.wv.ssp+xml": { source: "iana", compressible: !0 },
  "application/vnd.xacml+json": { source: "iana", compressible: !0 },
  "application/vnd.xara": { source: "iana", extensions: ["xar"] },
  "application/vnd.xfdl": { source: "iana", extensions: ["xfdl"] },
  "application/vnd.xfdl.webform": { source: "iana" },
  "application/vnd.xmi+xml": { source: "iana", compressible: !0 },
  "application/vnd.xmpie.cpkg": { source: "iana" },
  "application/vnd.xmpie.dpkg": { source: "iana" },
  "application/vnd.xmpie.plan": { source: "iana" },
  "application/vnd.xmpie.ppkg": { source: "iana" },
  "application/vnd.xmpie.xlim": { source: "iana" },
  "application/vnd.yamaha.hv-dic": { source: "iana", extensions: ["hvd"] },
  "application/vnd.yamaha.hv-script": { source: "iana", extensions: ["hvs"] },
  "application/vnd.yamaha.hv-voice": { source: "iana", extensions: ["hvp"] },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: ["osf"],
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["osfpvg"],
  },
  "application/vnd.yamaha.remote-setup": { source: "iana" },
  "application/vnd.yamaha.smaf-audio": { source: "iana", extensions: ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { source: "iana", extensions: ["spf"] },
  "application/vnd.yamaha.through-ngn": { source: "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { source: "iana" },
  "application/vnd.yaoweme": { source: "iana" },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: ["cmp"],
  },
  "application/vnd.youtube.yt": { source: "iana" },
  "application/vnd.zul": { source: "iana", extensions: ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["zaz"],
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["vxml"],
  },
  "application/voucher-cms+json": { source: "iana", compressible: !0 },
  "application/vq-rtcpxr": { source: "iana" },
  "application/wasm": {
    source: "iana",
    compressible: !0,
    extensions: ["wasm"],
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wif"],
  },
  "application/webpush-options+json": { source: "iana", compressible: !0 },
  "application/whoispp-query": { source: "iana" },
  "application/whoispp-response": { source: "iana" },
  "application/widget": { source: "iana", extensions: ["wgt"] },
  "application/winhlp": { source: "apache", extensions: ["hlp"] },
  "application/wita": { source: "iana" },
  "application/wordperfect5.1": { source: "iana" },
  "application/wsdl+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wsdl"],
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wspolicy"],
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: !1,
    extensions: ["7z"],
  },
  "application/x-abiword": { source: "apache", extensions: ["abw"] },
  "application/x-ace-compressed": { source: "apache", extensions: ["ace"] },
  "application/x-amf": { source: "apache" },
  "application/x-apple-diskimage": { source: "apache", extensions: ["dmg"] },
  "application/x-arj": { compressible: !1, extensions: ["arj"] },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: ["aab", "x32", "u32", "vox"],
  },
  "application/x-authorware-map": { source: "apache", extensions: ["aam"] },
  "application/x-authorware-seg": { source: "apache", extensions: ["aas"] },
  "application/x-bcpio": { source: "apache", extensions: ["bcpio"] },
  "application/x-bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/x-bittorrent": { source: "apache", extensions: ["torrent"] },
  "application/x-blorb": { source: "apache", extensions: ["blb", "blorb"] },
  "application/x-bzip": {
    source: "apache",
    compressible: !1,
    extensions: ["bz"],
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: !1,
    extensions: ["bz2", "boz"],
  },
  "application/x-cbr": {
    source: "apache",
    extensions: ["cbr", "cba", "cbt", "cbz", "cb7"],
  },
  "application/x-cdlink": { source: "apache", extensions: ["vcd"] },
  "application/x-cfs-compressed": { source: "apache", extensions: ["cfs"] },
  "application/x-chat": { source: "apache", extensions: ["chat"] },
  "application/x-chess-pgn": { source: "apache", extensions: ["pgn"] },
  "application/x-chrome-extension": { extensions: ["crx"] },
  "application/x-cocoa": { source: "nginx", extensions: ["cco"] },
  "application/x-compress": { source: "apache" },
  "application/x-conference": { source: "apache", extensions: ["nsc"] },
  "application/x-cpio": { source: "apache", extensions: ["cpio"] },
  "application/x-csh": { source: "apache", extensions: ["csh"] },
  "application/x-deb": { compressible: !1 },
  "application/x-debian-package": {
    source: "apache",
    extensions: ["deb", "udeb"],
  },
  "application/x-dgc-compressed": { source: "apache", extensions: ["dgc"] },
  "application/x-director": {
    source: "apache",
    extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
  },
  "application/x-doom": { source: "apache", extensions: ["wad"] },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["ncx"],
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["dtb"],
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["res"],
  },
  "application/x-dvi": {
    source: "apache",
    compressible: !1,
    extensions: ["dvi"],
  },
  "application/x-envoy": { source: "apache", extensions: ["evy"] },
  "application/x-eva": { source: "apache", extensions: ["eva"] },
  "application/x-font-bdf": { source: "apache", extensions: ["bdf"] },
  "application/x-font-dos": { source: "apache" },
  "application/x-font-framemaker": { source: "apache" },
  "application/x-font-ghostscript": { source: "apache", extensions: ["gsf"] },
  "application/x-font-libgrx": { source: "apache" },
  "application/x-font-linux-psf": { source: "apache", extensions: ["psf"] },
  "application/x-font-pcf": { source: "apache", extensions: ["pcf"] },
  "application/x-font-snf": { source: "apache", extensions: ["snf"] },
  "application/x-font-speedo": { source: "apache" },
  "application/x-font-sunos-news": { source: "apache" },
  "application/x-font-type1": {
    source: "apache",
    extensions: ["pfa", "pfb", "pfm", "afm"],
  },
  "application/x-font-vfont": { source: "apache" },
  "application/x-freearc": { source: "apache", extensions: ["arc"] },
  "application/x-futuresplash": { source: "apache", extensions: ["spl"] },
  "application/x-gca-compressed": { source: "apache", extensions: ["gca"] },
  "application/x-glulx": { source: "apache", extensions: ["ulx"] },
  "application/x-gnumeric": { source: "apache", extensions: ["gnumeric"] },
  "application/x-gramps-xml": { source: "apache", extensions: ["gramps"] },
  "application/x-gtar": { source: "apache", extensions: ["gtar"] },
  "application/x-gzip": { source: "apache" },
  "application/x-hdf": { source: "apache", extensions: ["hdf"] },
  "application/x-httpd-php": { compressible: !0, extensions: ["php"] },
  "application/x-install-instructions": {
    source: "apache",
    extensions: ["install"],
  },
  "application/x-iso9660-image": { source: "apache", extensions: ["iso"] },
  "application/x-iwork-keynote-sffkey": { extensions: ["key"] },
  "application/x-iwork-numbers-sffnumbers": { extensions: ["numbers"] },
  "application/x-iwork-pages-sffpages": { extensions: ["pages"] },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: ["jardiff"],
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: !1,
    extensions: ["jnlp"],
  },
  "application/x-javascript": { compressible: !0 },
  "application/x-keepass2": { extensions: ["kdbx"] },
  "application/x-latex": {
    source: "apache",
    compressible: !1,
    extensions: ["latex"],
  },
  "application/x-lua-bytecode": { extensions: ["luac"] },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: ["lzh", "lha"],
  },
  "application/x-makeself": { source: "nginx", extensions: ["run"] },
  "application/x-mie": { source: "apache", extensions: ["mie"] },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: ["prc", "mobi"],
  },
  "application/x-mpegurl": { compressible: !1 },
  "application/x-ms-application": {
    source: "apache",
    extensions: ["application"],
  },
  "application/x-ms-shortcut": { source: "apache", extensions: ["lnk"] },
  "application/x-ms-wmd": { source: "apache", extensions: ["wmd"] },
  "application/x-ms-wmz": { source: "apache", extensions: ["wmz"] },
  "application/x-ms-xbap": { source: "apache", extensions: ["xbap"] },
  "application/x-msaccess": { source: "apache", extensions: ["mdb"] },
  "application/x-msbinder": { source: "apache", extensions: ["obd"] },
  "application/x-mscardfile": { source: "apache", extensions: ["crd"] },
  "application/x-msclip": { source: "apache", extensions: ["clp"] },
  "application/x-msdos-program": { extensions: ["exe"] },
  "application/x-msdownload": {
    source: "apache",
    extensions: ["exe", "dll", "com", "bat", "msi"],
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: ["mvb", "m13", "m14"],
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: ["wmf", "wmz", "emf", "emz"],
  },
  "application/x-msmoney": { source: "apache", extensions: ["mny"] },
  "application/x-mspublisher": { source: "apache", extensions: ["pub"] },
  "application/x-msschedule": { source: "apache", extensions: ["scd"] },
  "application/x-msterminal": { source: "apache", extensions: ["trm"] },
  "application/x-mswrite": { source: "apache", extensions: ["wri"] },
  "application/x-netcdf": { source: "apache", extensions: ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": {
    compressible: !0,
    extensions: ["pac"],
  },
  "application/x-nzb": { source: "apache", extensions: ["nzb"] },
  "application/x-perl": { source: "nginx", extensions: ["pl", "pm"] },
  "application/x-pilot": { source: "nginx", extensions: ["prc", "pdb"] },
  "application/x-pkcs12": {
    source: "apache",
    compressible: !1,
    extensions: ["p12", "pfx"],
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: ["p7b", "spc"],
  },
  "application/x-pkcs7-certreqresp": { source: "apache", extensions: ["p7r"] },
  "application/x-pki-message": { source: "iana" },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: !1,
    extensions: ["rar"],
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: ["rpm"],
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: ["ris"],
  },
  "application/x-sea": { source: "nginx", extensions: ["sea"] },
  "application/x-sh": {
    source: "apache",
    compressible: !0,
    extensions: ["sh"],
  },
  "application/x-shar": { source: "apache", extensions: ["shar"] },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: !1,
    extensions: ["swf"],
  },
  "application/x-silverlight-app": { source: "apache", extensions: ["xap"] },
  "application/x-sql": { source: "apache", extensions: ["sql"] },
  "application/x-stuffit": {
    source: "apache",
    compressible: !1,
    extensions: ["sit"],
  },
  "application/x-stuffitx": { source: "apache", extensions: ["sitx"] },
  "application/x-subrip": { source: "apache", extensions: ["srt"] },
  "application/x-sv4cpio": { source: "apache", extensions: ["sv4cpio"] },
  "application/x-sv4crc": { source: "apache", extensions: ["sv4crc"] },
  "application/x-t3vm-image": { source: "apache", extensions: ["t3"] },
  "application/x-tads": { source: "apache", extensions: ["gam"] },
  "application/x-tar": {
    source: "apache",
    compressible: !0,
    extensions: ["tar"],
  },
  "application/x-tcl": { source: "apache", extensions: ["tcl", "tk"] },
  "application/x-tex": { source: "apache", extensions: ["tex"] },
  "application/x-tex-tfm": { source: "apache", extensions: ["tfm"] },
  "application/x-texinfo": {
    source: "apache",
    extensions: ["texinfo", "texi"],
  },
  "application/x-tgif": { source: "apache", extensions: ["obj"] },
  "application/x-ustar": { source: "apache", extensions: ["ustar"] },
  "application/x-virtualbox-hdd": { compressible: !0, extensions: ["hdd"] },
  "application/x-virtualbox-ova": { compressible: !0, extensions: ["ova"] },
  "application/x-virtualbox-ovf": { compressible: !0, extensions: ["ovf"] },
  "application/x-virtualbox-vbox": { compressible: !0, extensions: ["vbox"] },
  "application/x-virtualbox-vbox-extpack": {
    compressible: !1,
    extensions: ["vbox-extpack"],
  },
  "application/x-virtualbox-vdi": { compressible: !0, extensions: ["vdi"] },
  "application/x-virtualbox-vhd": { compressible: !0, extensions: ["vhd"] },
  "application/x-virtualbox-vmdk": { compressible: !0, extensions: ["vmdk"] },
  "application/x-wais-source": { source: "apache", extensions: ["src"] },
  "application/x-web-app-manifest+json": {
    compressible: !0,
    extensions: ["webapp"],
  },
  "application/x-www-form-urlencoded": { source: "iana", compressible: !0 },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: ["der", "crt", "pem"],
  },
  "application/x-x509-ca-ra-cert": { source: "iana" },
  "application/x-x509-next-ca-cert": { source: "iana" },
  "application/x-xfig": { source: "apache", extensions: ["fig"] },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xlf"],
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: !1,
    extensions: ["xpi"],
  },
  "application/x-xz": { source: "apache", extensions: ["xz"] },
  "application/x-zmachine": {
    source: "apache",
    extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
  },
  "application/x400-bp": { source: "iana" },
  "application/xacml+xml": { source: "iana", compressible: !0 },
  "application/xaml+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xaml"],
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xav"],
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xca"],
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xdf"],
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xel"],
  },
  "application/xcap-error+xml": { source: "iana", compressible: !0 },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xns"],
  },
  "application/xcon-conference-info+xml": { source: "iana", compressible: !0 },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xenc"],
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xhtml", "xht"],
  },
  "application/xhtml-voice+xml": { source: "apache", compressible: !0 },
  "application/xliff+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xlf"],
  },
  "application/xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xml", "xsl", "xsd", "rng"],
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: !0,
    extensions: ["dtd"],
  },
  "application/xml-external-parsed-entity": { source: "iana" },
  "application/xml-patch+xml": { source: "iana", compressible: !0 },
  "application/xmpp+xml": { source: "iana", compressible: !0 },
  "application/xop+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xop"],
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xpl"],
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xsl", "xslt"],
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xspf"],
  },
  "application/xv+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mxml", "xhvml", "xvml", "xvm"],
  },
  "application/yang": { source: "iana", extensions: ["yang"] },
  "application/yang-data+json": { source: "iana", compressible: !0 },
  "application/yang-data+xml": { source: "iana", compressible: !0 },
  "application/yang-patch+json": { source: "iana", compressible: !0 },
  "application/yang-patch+xml": { source: "iana", compressible: !0 },
  "application/yin+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["yin"],
  },
  "application/zip": { source: "iana", compressible: !1, extensions: ["zip"] },
  "application/zlib": { source: "iana" },
  "application/zstd": { source: "iana" },
  "audio/1d-interleaved-parityfec": { source: "iana" },
  "audio/32kadpcm": { source: "iana" },
  "audio/3gpp": { source: "iana", compressible: !1, extensions: ["3gpp"] },
  "audio/3gpp2": { source: "iana" },
  "audio/aac": { source: "iana" },
  "audio/ac3": { source: "iana" },
  "audio/adpcm": { source: "apache", extensions: ["adp"] },
  "audio/amr": { source: "iana", extensions: ["amr"] },
  "audio/amr-wb": { source: "iana" },
  "audio/amr-wb+": { source: "iana" },
  "audio/aptx": { source: "iana" },
  "audio/asc": { source: "iana" },
  "audio/atrac-advanced-lossless": { source: "iana" },
  "audio/atrac-x": { source: "iana" },
  "audio/atrac3": { source: "iana" },
  "audio/basic": {
    source: "iana",
    compressible: !1,
    extensions: ["au", "snd"],
  },
  "audio/bv16": { source: "iana" },
  "audio/bv32": { source: "iana" },
  "audio/clearmode": { source: "iana" },
  "audio/cn": { source: "iana" },
  "audio/dat12": { source: "iana" },
  "audio/dls": { source: "iana" },
  "audio/dsr-es201108": { source: "iana" },
  "audio/dsr-es202050": { source: "iana" },
  "audio/dsr-es202211": { source: "iana" },
  "audio/dsr-es202212": { source: "iana" },
  "audio/dv": { source: "iana" },
  "audio/dvi4": { source: "iana" },
  "audio/eac3": { source: "iana" },
  "audio/encaprtp": { source: "iana" },
  "audio/evrc": { source: "iana" },
  "audio/evrc-qcp": { source: "iana" },
  "audio/evrc0": { source: "iana" },
  "audio/evrc1": { source: "iana" },
  "audio/evrcb": { source: "iana" },
  "audio/evrcb0": { source: "iana" },
  "audio/evrcb1": { source: "iana" },
  "audio/evrcnw": { source: "iana" },
  "audio/evrcnw0": { source: "iana" },
  "audio/evrcnw1": { source: "iana" },
  "audio/evrcwb": { source: "iana" },
  "audio/evrcwb0": { source: "iana" },
  "audio/evrcwb1": { source: "iana" },
  "audio/evs": { source: "iana" },
  "audio/flexfec": { source: "iana" },
  "audio/fwdred": { source: "iana" },
  "audio/g711-0": { source: "iana" },
  "audio/g719": { source: "iana" },
  "audio/g722": { source: "iana" },
  "audio/g7221": { source: "iana" },
  "audio/g723": { source: "iana" },
  "audio/g726-16": { source: "iana" },
  "audio/g726-24": { source: "iana" },
  "audio/g726-32": { source: "iana" },
  "audio/g726-40": { source: "iana" },
  "audio/g728": { source: "iana" },
  "audio/g729": { source: "iana" },
  "audio/g7291": { source: "iana" },
  "audio/g729d": { source: "iana" },
  "audio/g729e": { source: "iana" },
  "audio/gsm": { source: "iana" },
  "audio/gsm-efr": { source: "iana" },
  "audio/gsm-hr-08": { source: "iana" },
  "audio/ilbc": { source: "iana" },
  "audio/ip-mr_v2.5": { source: "iana" },
  "audio/isac": { source: "apache" },
  "audio/l16": { source: "iana" },
  "audio/l20": { source: "iana" },
  "audio/l24": { source: "iana", compressible: !1 },
  "audio/l8": { source: "iana" },
  "audio/lpc": { source: "iana" },
  "audio/melp": { source: "iana" },
  "audio/melp1200": { source: "iana" },
  "audio/melp2400": { source: "iana" },
  "audio/melp600": { source: "iana" },
  "audio/mhas": { source: "iana" },
  "audio/midi": { source: "apache", extensions: ["mid", "midi", "kar", "rmi"] },
  "audio/mobile-xmf": { source: "iana", extensions: ["mxmf"] },
  "audio/mp3": { compressible: !1, extensions: ["mp3"] },
  "audio/mp4": {
    source: "iana",
    compressible: !1,
    extensions: ["m4a", "mp4a"],
  },
  "audio/mp4a-latm": { source: "iana" },
  "audio/mpa": { source: "iana" },
  "audio/mpa-robust": { source: "iana" },
  "audio/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  },
  "audio/mpeg4-generic": { source: "iana" },
  "audio/musepack": { source: "apache" },
  "audio/ogg": {
    source: "iana",
    compressible: !1,
    extensions: ["oga", "ogg", "spx", "opus"],
  },
  "audio/opus": { source: "iana" },
  "audio/parityfec": { source: "iana" },
  "audio/pcma": { source: "iana" },
  "audio/pcma-wb": { source: "iana" },
  "audio/pcmu": { source: "iana" },
  "audio/pcmu-wb": { source: "iana" },
  "audio/prs.sid": { source: "iana" },
  "audio/qcelp": { source: "iana" },
  "audio/raptorfec": { source: "iana" },
  "audio/red": { source: "iana" },
  "audio/rtp-enc-aescm128": { source: "iana" },
  "audio/rtp-midi": { source: "iana" },
  "audio/rtploopback": { source: "iana" },
  "audio/rtx": { source: "iana" },
  "audio/s3m": { source: "apache", extensions: ["s3m"] },
  "audio/scip": { source: "iana" },
  "audio/silk": { source: "apache", extensions: ["sil"] },
  "audio/smv": { source: "iana" },
  "audio/smv-qcp": { source: "iana" },
  "audio/smv0": { source: "iana" },
  "audio/sofa": { source: "iana" },
  "audio/sp-midi": { source: "iana" },
  "audio/speex": { source: "iana" },
  "audio/t140c": { source: "iana" },
  "audio/t38": { source: "iana" },
  "audio/telephone-event": { source: "iana" },
  "audio/tetra_acelp": { source: "iana" },
  "audio/tetra_acelp_bb": { source: "iana" },
  "audio/tone": { source: "iana" },
  "audio/tsvcis": { source: "iana" },
  "audio/uemclip": { source: "iana" },
  "audio/ulpfec": { source: "iana" },
  "audio/usac": { source: "iana" },
  "audio/vdvi": { source: "iana" },
  "audio/vmr-wb": { source: "iana" },
  "audio/vnd.3gpp.iufp": { source: "iana" },
  "audio/vnd.4sb": { source: "iana" },
  "audio/vnd.audiokoz": { source: "iana" },
  "audio/vnd.celp": { source: "iana" },
  "audio/vnd.cisco.nse": { source: "iana" },
  "audio/vnd.cmles.radio-events": { source: "iana" },
  "audio/vnd.cns.anp1": { source: "iana" },
  "audio/vnd.cns.inf1": { source: "iana" },
  "audio/vnd.dece.audio": { source: "iana", extensions: ["uva", "uvva"] },
  "audio/vnd.digital-winds": { source: "iana", extensions: ["eol"] },
  "audio/vnd.dlna.adts": { source: "iana" },
  "audio/vnd.dolby.heaac.1": { source: "iana" },
  "audio/vnd.dolby.heaac.2": { source: "iana" },
  "audio/vnd.dolby.mlp": { source: "iana" },
  "audio/vnd.dolby.mps": { source: "iana" },
  "audio/vnd.dolby.pl2": { source: "iana" },
  "audio/vnd.dolby.pl2x": { source: "iana" },
  "audio/vnd.dolby.pl2z": { source: "iana" },
  "audio/vnd.dolby.pulse.1": { source: "iana" },
  "audio/vnd.dra": { source: "iana", extensions: ["dra"] },
  "audio/vnd.dts": { source: "iana", extensions: ["dts"] },
  "audio/vnd.dts.hd": { source: "iana", extensions: ["dtshd"] },
  "audio/vnd.dts.uhd": { source: "iana" },
  "audio/vnd.dvb.file": { source: "iana" },
  "audio/vnd.everad.plj": { source: "iana" },
  "audio/vnd.hns.audio": { source: "iana" },
  "audio/vnd.lucent.voice": { source: "iana", extensions: ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { source: "iana", extensions: ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { source: "iana" },
  "audio/vnd.nortel.vbk": { source: "iana" },
  "audio/vnd.nuera.ecelp4800": { source: "iana", extensions: ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { source: "iana", extensions: ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { source: "iana", extensions: ["ecelp9600"] },
  "audio/vnd.octel.sbc": { source: "iana" },
  "audio/vnd.presonus.multitrack": { source: "iana" },
  "audio/vnd.qcelp": { source: "iana" },
  "audio/vnd.rhetorex.32kadpcm": { source: "iana" },
  "audio/vnd.rip": { source: "iana", extensions: ["rip"] },
  "audio/vnd.rn-realaudio": { compressible: !1 },
  "audio/vnd.sealedmedia.softseal.mpeg": { source: "iana" },
  "audio/vnd.vmx.cvsd": { source: "iana" },
  "audio/vnd.wave": { compressible: !1 },
  "audio/vorbis": { source: "iana", compressible: !1 },
  "audio/vorbis-config": { source: "iana" },
  "audio/wav": { compressible: !1, extensions: ["wav"] },
  "audio/wave": { compressible: !1, extensions: ["wav"] },
  "audio/webm": { source: "apache", compressible: !1, extensions: ["weba"] },
  "audio/x-aac": { source: "apache", compressible: !1, extensions: ["aac"] },
  "audio/x-aiff": { source: "apache", extensions: ["aif", "aiff", "aifc"] },
  "audio/x-caf": { source: "apache", compressible: !1, extensions: ["caf"] },
  "audio/x-flac": { source: "apache", extensions: ["flac"] },
  "audio/x-m4a": { source: "nginx", extensions: ["m4a"] },
  "audio/x-matroska": { source: "apache", extensions: ["mka"] },
  "audio/x-mpegurl": { source: "apache", extensions: ["m3u"] },
  "audio/x-ms-wax": { source: "apache", extensions: ["wax"] },
  "audio/x-ms-wma": { source: "apache", extensions: ["wma"] },
  "audio/x-pn-realaudio": { source: "apache", extensions: ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { source: "apache", extensions: ["rmp"] },
  "audio/x-realaudio": { source: "nginx", extensions: ["ra"] },
  "audio/x-tta": { source: "apache" },
  "audio/x-wav": { source: "apache", extensions: ["wav"] },
  "audio/xm": { source: "apache", extensions: ["xm"] },
  "chemical/x-cdx": { source: "apache", extensions: ["cdx"] },
  "chemical/x-cif": { source: "apache", extensions: ["cif"] },
  "chemical/x-cmdf": { source: "apache", extensions: ["cmdf"] },
  "chemical/x-cml": { source: "apache", extensions: ["cml"] },
  "chemical/x-csml": { source: "apache", extensions: ["csml"] },
  "chemical/x-pdb": { source: "apache" },
  "chemical/x-xyz": { source: "apache", extensions: ["xyz"] },
  "font/collection": { source: "iana", extensions: ["ttc"] },
  "font/otf": { source: "iana", compressible: !0, extensions: ["otf"] },
  "font/sfnt": { source: "iana" },
  "font/ttf": { source: "iana", compressible: !0, extensions: ["ttf"] },
  "font/woff": { source: "iana", extensions: ["woff"] },
  "font/woff2": { source: "iana", extensions: ["woff2"] },
  "image/aces": { source: "iana", extensions: ["exr"] },
  "image/apng": { compressible: !1, extensions: ["apng"] },
  "image/avci": { source: "iana", extensions: ["avci"] },
  "image/avcs": { source: "iana", extensions: ["avcs"] },
  "image/avif": { source: "iana", compressible: !1, extensions: ["avif"] },
  "image/bmp": { source: "iana", compressible: !0, extensions: ["bmp"] },
  "image/cgm": { source: "iana", extensions: ["cgm"] },
  "image/dicom-rle": { source: "iana", extensions: ["drle"] },
  "image/emf": { source: "iana", extensions: ["emf"] },
  "image/fits": { source: "iana", extensions: ["fits"] },
  "image/g3fax": { source: "iana", extensions: ["g3"] },
  "image/gif": { source: "iana", compressible: !1, extensions: ["gif"] },
  "image/heic": { source: "iana", extensions: ["heic"] },
  "image/heic-sequence": { source: "iana", extensions: ["heics"] },
  "image/heif": { source: "iana", extensions: ["heif"] },
  "image/heif-sequence": { source: "iana", extensions: ["heifs"] },
  "image/hej2k": { source: "iana", extensions: ["hej2"] },
  "image/hsj2": { source: "iana", extensions: ["hsj2"] },
  "image/ief": { source: "iana", extensions: ["ief"] },
  "image/jls": { source: "iana", extensions: ["jls"] },
  "image/jp2": {
    source: "iana",
    compressible: !1,
    extensions: ["jp2", "jpg2"],
  },
  "image/jpeg": {
    source: "iana",
    compressible: !1,
    extensions: ["jpeg", "jpg", "jpe"],
  },
  "image/jph": { source: "iana", extensions: ["jph"] },
  "image/jphc": { source: "iana", extensions: ["jhc"] },
  "image/jpm": { source: "iana", compressible: !1, extensions: ["jpm"] },
  "image/jpx": { source: "iana", compressible: !1, extensions: ["jpx", "jpf"] },
  "image/jxr": { source: "iana", extensions: ["jxr"] },
  "image/jxra": { source: "iana", extensions: ["jxra"] },
  "image/jxrs": { source: "iana", extensions: ["jxrs"] },
  "image/jxs": { source: "iana", extensions: ["jxs"] },
  "image/jxsc": { source: "iana", extensions: ["jxsc"] },
  "image/jxsi": { source: "iana", extensions: ["jxsi"] },
  "image/jxss": { source: "iana", extensions: ["jxss"] },
  "image/ktx": { source: "iana", extensions: ["ktx"] },
  "image/ktx2": { source: "iana", extensions: ["ktx2"] },
  "image/naplps": { source: "iana" },
  "image/pjpeg": { compressible: !1 },
  "image/png": { source: "iana", compressible: !1, extensions: ["png"] },
  "image/prs.btif": { source: "iana", extensions: ["btif"] },
  "image/prs.pti": { source: "iana", extensions: ["pti"] },
  "image/pwg-raster": { source: "iana" },
  "image/sgi": { source: "apache", extensions: ["sgi"] },
  "image/svg+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["svg", "svgz"],
  },
  "image/t38": { source: "iana", extensions: ["t38"] },
  "image/tiff": {
    source: "iana",
    compressible: !1,
    extensions: ["tif", "tiff"],
  },
  "image/tiff-fx": { source: "iana", extensions: ["tfx"] },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: !0,
    extensions: ["psd"],
  },
  "image/vnd.airzip.accelerator.azv": { source: "iana", extensions: ["azv"] },
  "image/vnd.cns.inf2": { source: "iana" },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: ["uvi", "uvvi", "uvg", "uvvg"],
  },
  "image/vnd.djvu": { source: "iana", extensions: ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "image/vnd.dwg": { source: "iana", extensions: ["dwg"] },
  "image/vnd.dxf": { source: "iana", extensions: ["dxf"] },
  "image/vnd.fastbidsheet": { source: "iana", extensions: ["fbs"] },
  "image/vnd.fpx": { source: "iana", extensions: ["fpx"] },
  "image/vnd.fst": { source: "iana", extensions: ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { source: "iana", extensions: ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { source: "iana", extensions: ["rlc"] },
  "image/vnd.globalgraphics.pgb": { source: "iana" },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: !0,
    extensions: ["ico"],
  },
  "image/vnd.mix": { source: "iana" },
  "image/vnd.mozilla.apng": { source: "iana" },
  "image/vnd.ms-dds": { compressible: !0, extensions: ["dds"] },
  "image/vnd.ms-modi": { source: "iana", extensions: ["mdi"] },
  "image/vnd.ms-photo": { source: "apache", extensions: ["wdp"] },
  "image/vnd.net-fpx": { source: "iana", extensions: ["npx"] },
  "image/vnd.pco.b16": { source: "iana", extensions: ["b16"] },
  "image/vnd.radiance": { source: "iana" },
  "image/vnd.sealed.png": { source: "iana" },
  "image/vnd.sealedmedia.softseal.gif": { source: "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { source: "iana" },
  "image/vnd.svf": { source: "iana" },
  "image/vnd.tencent.tap": { source: "iana", extensions: ["tap"] },
  "image/vnd.valve.source.texture": { source: "iana", extensions: ["vtf"] },
  "image/vnd.wap.wbmp": { source: "iana", extensions: ["wbmp"] },
  "image/vnd.xiff": { source: "iana", extensions: ["xif"] },
  "image/vnd.zbrush.pcx": { source: "iana", extensions: ["pcx"] },
  "image/webp": { source: "apache", extensions: ["webp"] },
  "image/wmf": { source: "iana", extensions: ["wmf"] },
  "image/x-3ds": { source: "apache", extensions: ["3ds"] },
  "image/x-cmu-raster": { source: "apache", extensions: ["ras"] },
  "image/x-cmx": { source: "apache", extensions: ["cmx"] },
  "image/x-freehand": {
    source: "apache",
    extensions: ["fh", "fhc", "fh4", "fh5", "fh7"],
  },
  "image/x-icon": { source: "apache", compressible: !0, extensions: ["ico"] },
  "image/x-jng": { source: "nginx", extensions: ["jng"] },
  "image/x-mrsid-image": { source: "apache", extensions: ["sid"] },
  "image/x-ms-bmp": { source: "nginx", compressible: !0, extensions: ["bmp"] },
  "image/x-pcx": { source: "apache", extensions: ["pcx"] },
  "image/x-pict": { source: "apache", extensions: ["pic", "pct"] },
  "image/x-portable-anymap": { source: "apache", extensions: ["pnm"] },
  "image/x-portable-bitmap": { source: "apache", extensions: ["pbm"] },
  "image/x-portable-graymap": { source: "apache", extensions: ["pgm"] },
  "image/x-portable-pixmap": { source: "apache", extensions: ["ppm"] },
  "image/x-rgb": { source: "apache", extensions: ["rgb"] },
  "image/x-tga": { source: "apache", extensions: ["tga"] },
  "image/x-xbitmap": { source: "apache", extensions: ["xbm"] },
  "image/x-xcf": { compressible: !1 },
  "image/x-xpixmap": { source: "apache", extensions: ["xpm"] },
  "image/x-xwindowdump": { source: "apache", extensions: ["xwd"] },
  "message/cpim": { source: "iana" },
  "message/delivery-status": { source: "iana" },
  "message/disposition-notification": {
    source: "iana",
    extensions: ["disposition-notification"],
  },
  "message/external-body": { source: "iana" },
  "message/feedback-report": { source: "iana" },
  "message/global": { source: "iana", extensions: ["u8msg"] },
  "message/global-delivery-status": { source: "iana", extensions: ["u8dsn"] },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: ["u8mdn"],
  },
  "message/global-headers": { source: "iana", extensions: ["u8hdr"] },
  "message/http": { source: "iana", compressible: !1 },
  "message/imdn+xml": { source: "iana", compressible: !0 },
  "message/news": { source: "iana" },
  "message/partial": { source: "iana", compressible: !1 },
  "message/rfc822": {
    source: "iana",
    compressible: !0,
    extensions: ["eml", "mime"],
  },
  "message/s-http": { source: "iana" },
  "message/sip": { source: "iana" },
  "message/sipfrag": { source: "iana" },
  "message/tracking-status": { source: "iana" },
  "message/vnd.si.simp": { source: "iana" },
  "message/vnd.wfa.wsc": { source: "iana", extensions: ["wsc"] },
  "model/3mf": { source: "iana", extensions: ["3mf"] },
  "model/e57": { source: "iana" },
  "model/gltf+json": { source: "iana", compressible: !0, extensions: ["gltf"] },
  "model/gltf-binary": {
    source: "iana",
    compressible: !0,
    extensions: ["glb"],
  },
  "model/iges": {
    source: "iana",
    compressible: !1,
    extensions: ["igs", "iges"],
  },
  "model/mesh": {
    source: "iana",
    compressible: !1,
    extensions: ["msh", "mesh", "silo"],
  },
  "model/mtl": { source: "iana", extensions: ["mtl"] },
  "model/obj": { source: "iana", extensions: ["obj"] },
  "model/step": { source: "iana" },
  "model/step+xml": { source: "iana", compressible: !0, extensions: ["stpx"] },
  "model/step+zip": { source: "iana", compressible: !1, extensions: ["stpz"] },
  "model/step-xml+zip": {
    source: "iana",
    compressible: !1,
    extensions: ["stpxz"],
  },
  "model/stl": { source: "iana", extensions: ["stl"] },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["dae"],
  },
  "model/vnd.dwf": { source: "iana", extensions: ["dwf"] },
  "model/vnd.flatland.3dml": { source: "iana" },
  "model/vnd.gdl": { source: "iana", extensions: ["gdl"] },
  "model/vnd.gs-gdl": { source: "apache" },
  "model/vnd.gs.gdl": { source: "iana" },
  "model/vnd.gtw": { source: "iana", extensions: ["gtw"] },
  "model/vnd.moml+xml": { source: "iana", compressible: !0 },
  "model/vnd.mts": { source: "iana", extensions: ["mts"] },
  "model/vnd.opengex": { source: "iana", extensions: ["ogex"] },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: ["x_b"],
  },
  "model/vnd.parasolid.transmit.text": { source: "iana", extensions: ["x_t"] },
  "model/vnd.pytha.pyox": { source: "iana" },
  "model/vnd.rosette.annotated-data-model": { source: "iana" },
  "model/vnd.sap.vds": { source: "iana", extensions: ["vds"] },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: !1,
    extensions: ["usdz"],
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: ["bsp"],
  },
  "model/vnd.vtu": { source: "iana", extensions: ["vtu"] },
  "model/vrml": {
    source: "iana",
    compressible: !1,
    extensions: ["wrl", "vrml"],
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: !1,
    extensions: ["x3db", "x3dbz"],
  },
  "model/x3d+fastinfoset": { source: "iana", extensions: ["x3db"] },
  "model/x3d+vrml": {
    source: "apache",
    compressible: !1,
    extensions: ["x3dv", "x3dvz"],
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["x3d", "x3dz"],
  },
  "model/x3d-vrml": { source: "iana", extensions: ["x3dv"] },
  "multipart/alternative": { source: "iana", compressible: !1 },
  "multipart/appledouble": { source: "iana" },
  "multipart/byteranges": { source: "iana" },
  "multipart/digest": { source: "iana" },
  "multipart/encrypted": { source: "iana", compressible: !1 },
  "multipart/form-data": { source: "iana", compressible: !1 },
  "multipart/header-set": { source: "iana" },
  "multipart/mixed": { source: "iana" },
  "multipart/multilingual": { source: "iana" },
  "multipart/parallel": { source: "iana" },
  "multipart/related": { source: "iana", compressible: !1 },
  "multipart/report": { source: "iana" },
  "multipart/signed": { source: "iana", compressible: !1 },
  "multipart/vnd.bint.med-plus": { source: "iana" },
  "multipart/voice-message": { source: "iana" },
  "multipart/x-mixed-replace": { source: "iana" },
  "text/1d-interleaved-parityfec": { source: "iana" },
  "text/cache-manifest": {
    source: "iana",
    compressible: !0,
    extensions: ["appcache", "manifest"],
  },
  "text/calendar": { source: "iana", extensions: ["ics", "ifb"] },
  "text/calender": { compressible: !0 },
  "text/cmd": { compressible: !0 },
  "text/coffeescript": { extensions: ["coffee", "litcoffee"] },
  "text/cql": { source: "iana" },
  "text/cql-expression": { source: "iana" },
  "text/cql-identifier": { source: "iana" },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["css"],
  },
  "text/csv": { source: "iana", compressible: !0, extensions: ["csv"] },
  "text/csv-schema": { source: "iana" },
  "text/directory": { source: "iana" },
  "text/dns": { source: "iana" },
  "text/ecmascript": { source: "iana" },
  "text/encaprtp": { source: "iana" },
  "text/enriched": { source: "iana" },
  "text/fhirpath": { source: "iana" },
  "text/flexfec": { source: "iana" },
  "text/fwdred": { source: "iana" },
  "text/gff3": { source: "iana" },
  "text/grammar-ref-list": { source: "iana" },
  "text/html": {
    source: "iana",
    compressible: !0,
    extensions: ["html", "htm", "shtml"],
  },
  "text/jade": { extensions: ["jade"] },
  "text/javascript": { source: "iana", compressible: !0 },
  "text/jcr-cnd": { source: "iana" },
  "text/jsx": { compressible: !0, extensions: ["jsx"] },
  "text/less": { compressible: !0, extensions: ["less"] },
  "text/markdown": {
    source: "iana",
    compressible: !0,
    extensions: ["markdown", "md"],
  },
  "text/mathml": { source: "nginx", extensions: ["mml"] },
  "text/mdx": { compressible: !0, extensions: ["mdx"] },
  "text/mizar": { source: "iana" },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["n3"],
  },
  "text/parameters": { source: "iana", charset: "UTF-8" },
  "text/parityfec": { source: "iana" },
  "text/plain": {
    source: "iana",
    compressible: !0,
    extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
  },
  "text/provenance-notation": { source: "iana", charset: "UTF-8" },
  "text/prs.fallenstein.rst": { source: "iana" },
  "text/prs.lines.tag": { source: "iana", extensions: ["dsc"] },
  "text/prs.prop.logic": { source: "iana" },
  "text/raptorfec": { source: "iana" },
  "text/red": { source: "iana" },
  "text/rfc822-headers": { source: "iana" },
  "text/richtext": { source: "iana", compressible: !0, extensions: ["rtx"] },
  "text/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "text/rtp-enc-aescm128": { source: "iana" },
  "text/rtploopback": { source: "iana" },
  "text/rtx": { source: "iana" },
  "text/sgml": { source: "iana", extensions: ["sgml", "sgm"] },
  "text/shaclc": { source: "iana" },
  "text/shex": { source: "iana", extensions: ["shex"] },
  "text/slim": { extensions: ["slim", "slm"] },
  "text/spdx": { source: "iana", extensions: ["spdx"] },
  "text/strings": { source: "iana" },
  "text/stylus": { extensions: ["stylus", "styl"] },
  "text/t140": { source: "iana" },
  "text/tab-separated-values": {
    source: "iana",
    compressible: !0,
    extensions: ["tsv"],
  },
  "text/troff": {
    source: "iana",
    extensions: ["t", "tr", "roff", "man", "me", "ms"],
  },
  "text/turtle": { source: "iana", charset: "UTF-8", extensions: ["ttl"] },
  "text/ulpfec": { source: "iana" },
  "text/uri-list": {
    source: "iana",
    compressible: !0,
    extensions: ["uri", "uris", "urls"],
  },
  "text/vcard": { source: "iana", compressible: !0, extensions: ["vcard"] },
  "text/vnd.a": { source: "iana" },
  "text/vnd.abc": { source: "iana" },
  "text/vnd.ascii-art": { source: "iana" },
  "text/vnd.curl": { source: "iana", extensions: ["curl"] },
  "text/vnd.curl.dcurl": { source: "apache", extensions: ["dcurl"] },
  "text/vnd.curl.mcurl": { source: "apache", extensions: ["mcurl"] },
  "text/vnd.curl.scurl": { source: "apache", extensions: ["scurl"] },
  "text/vnd.debian.copyright": { source: "iana", charset: "UTF-8" },
  "text/vnd.dmclientscript": { source: "iana" },
  "text/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { source: "iana", charset: "UTF-8" },
  "text/vnd.familysearch.gedcom": { source: "iana", extensions: ["ged"] },
  "text/vnd.ficlab.flt": { source: "iana" },
  "text/vnd.fly": { source: "iana", extensions: ["fly"] },
  "text/vnd.fmi.flexstor": { source: "iana", extensions: ["flx"] },
  "text/vnd.gml": { source: "iana" },
  "text/vnd.graphviz": { source: "iana", extensions: ["gv"] },
  "text/vnd.hans": { source: "iana" },
  "text/vnd.hgl": { source: "iana" },
  "text/vnd.in3d.3dml": { source: "iana", extensions: ["3dml"] },
  "text/vnd.in3d.spot": { source: "iana", extensions: ["spot"] },
  "text/vnd.iptc.newsml": { source: "iana" },
  "text/vnd.iptc.nitf": { source: "iana" },
  "text/vnd.latex-z": { source: "iana" },
  "text/vnd.motorola.reflex": { source: "iana" },
  "text/vnd.ms-mediapackage": { source: "iana" },
  "text/vnd.net2phone.commcenter.command": { source: "iana" },
  "text/vnd.radisys.msml-basic-layout": { source: "iana" },
  "text/vnd.senx.warpscript": { source: "iana" },
  "text/vnd.si.uricatalogue": { source: "iana" },
  "text/vnd.sosi": { source: "iana" },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["jad"],
  },
  "text/vnd.trolltech.linguist": { source: "iana", charset: "UTF-8" },
  "text/vnd.wap.si": { source: "iana" },
  "text/vnd.wap.sl": { source: "iana" },
  "text/vnd.wap.wml": { source: "iana", extensions: ["wml"] },
  "text/vnd.wap.wmlscript": { source: "iana", extensions: ["wmls"] },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["vtt"],
  },
  "text/x-asm": { source: "apache", extensions: ["s", "asm"] },
  "text/x-c": {
    source: "apache",
    extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
  },
  "text/x-component": { source: "nginx", extensions: ["htc"] },
  "text/x-fortran": {
    source: "apache",
    extensions: ["f", "for", "f77", "f90"],
  },
  "text/x-gwt-rpc": { compressible: !0 },
  "text/x-handlebars-template": { extensions: ["hbs"] },
  "text/x-java-source": { source: "apache", extensions: ["java"] },
  "text/x-jquery-tmpl": { compressible: !0 },
  "text/x-lua": { extensions: ["lua"] },
  "text/x-markdown": { compressible: !0, extensions: ["mkd"] },
  "text/x-nfo": { source: "apache", extensions: ["nfo"] },
  "text/x-opml": { source: "apache", extensions: ["opml"] },
  "text/x-org": { compressible: !0, extensions: ["org"] },
  "text/x-pascal": { source: "apache", extensions: ["p", "pas"] },
  "text/x-processing": { compressible: !0, extensions: ["pde"] },
  "text/x-sass": { extensions: ["sass"] },
  "text/x-scss": { extensions: ["scss"] },
  "text/x-setext": { source: "apache", extensions: ["etx"] },
  "text/x-sfv": { source: "apache", extensions: ["sfv"] },
  "text/x-suse-ymp": { compressible: !0, extensions: ["ymp"] },
  "text/x-uuencode": { source: "apache", extensions: ["uu"] },
  "text/x-vcalendar": { source: "apache", extensions: ["vcs"] },
  "text/x-vcard": { source: "apache", extensions: ["vcf"] },
  "text/xml": { source: "iana", compressible: !0, extensions: ["xml"] },
  "text/xml-external-parsed-entity": { source: "iana" },
  "text/yaml": { compressible: !0, extensions: ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { source: "iana" },
  "video/3gpp": { source: "iana", extensions: ["3gp", "3gpp"] },
  "video/3gpp-tt": { source: "iana" },
  "video/3gpp2": { source: "iana", extensions: ["3g2"] },
  "video/av1": { source: "iana" },
  "video/bmpeg": { source: "iana" },
  "video/bt656": { source: "iana" },
  "video/celb": { source: "iana" },
  "video/dv": { source: "iana" },
  "video/encaprtp": { source: "iana" },
  "video/ffv1": { source: "iana" },
  "video/flexfec": { source: "iana" },
  "video/h261": { source: "iana", extensions: ["h261"] },
  "video/h263": { source: "iana", extensions: ["h263"] },
  "video/h263-1998": { source: "iana" },
  "video/h263-2000": { source: "iana" },
  "video/h264": { source: "iana", extensions: ["h264"] },
  "video/h264-rcdo": { source: "iana" },
  "video/h264-svc": { source: "iana" },
  "video/h265": { source: "iana" },
  "video/iso.segment": { source: "iana", extensions: ["m4s"] },
  "video/jpeg": { source: "iana", extensions: ["jpgv"] },
  "video/jpeg2000": { source: "iana" },
  "video/jpm": { source: "apache", extensions: ["jpm", "jpgm"] },
  "video/jxsv": { source: "iana" },
  "video/mj2": { source: "iana", extensions: ["mj2", "mjp2"] },
  "video/mp1s": { source: "iana" },
  "video/mp2p": { source: "iana" },
  "video/mp2t": { source: "iana", extensions: ["ts"] },
  "video/mp4": {
    source: "iana",
    compressible: !1,
    extensions: ["mp4", "mp4v", "mpg4"],
  },
  "video/mp4v-es": { source: "iana" },
  "video/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  },
  "video/mpeg4-generic": { source: "iana" },
  "video/mpv": { source: "iana" },
  "video/nv": { source: "iana" },
  "video/ogg": { source: "iana", compressible: !1, extensions: ["ogv"] },
  "video/parityfec": { source: "iana" },
  "video/pointer": { source: "iana" },
  "video/quicktime": {
    source: "iana",
    compressible: !1,
    extensions: ["qt", "mov"],
  },
  "video/raptorfec": { source: "iana" },
  "video/raw": { source: "iana" },
  "video/rtp-enc-aescm128": { source: "iana" },
  "video/rtploopback": { source: "iana" },
  "video/rtx": { source: "iana" },
  "video/scip": { source: "iana" },
  "video/smpte291": { source: "iana" },
  "video/smpte292m": { source: "iana" },
  "video/ulpfec": { source: "iana" },
  "video/vc1": { source: "iana" },
  "video/vc2": { source: "iana" },
  "video/vnd.cctv": { source: "iana" },
  "video/vnd.dece.hd": { source: "iana", extensions: ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { source: "iana", extensions: ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { source: "iana" },
  "video/vnd.dece.pd": { source: "iana", extensions: ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { source: "iana", extensions: ["uvs", "uvvs"] },
  "video/vnd.dece.video": { source: "iana", extensions: ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { source: "iana" },
  "video/vnd.directv.mpeg-tts": { source: "iana" },
  "video/vnd.dlna.mpeg-tts": { source: "iana" },
  "video/vnd.dvb.file": { source: "iana", extensions: ["dvb"] },
  "video/vnd.fvt": { source: "iana", extensions: ["fvt"] },
  "video/vnd.hns.video": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.ttsavc": { source: "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { source: "iana" },
  "video/vnd.motorola.video": { source: "iana" },
  "video/vnd.motorola.videop": { source: "iana" },
  "video/vnd.mpegurl": { source: "iana", extensions: ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { source: "iana", extensions: ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { source: "iana" },
  "video/vnd.nokia.mp4vr": { source: "iana" },
  "video/vnd.nokia.videovoip": { source: "iana" },
  "video/vnd.objectvideo": { source: "iana" },
  "video/vnd.radgamettools.bink": { source: "iana" },
  "video/vnd.radgamettools.smacker": { source: "iana" },
  "video/vnd.sealed.mpeg1": { source: "iana" },
  "video/vnd.sealed.mpeg4": { source: "iana" },
  "video/vnd.sealed.swf": { source: "iana" },
  "video/vnd.sealedmedia.softseal.mov": { source: "iana" },
  "video/vnd.uvvu.mp4": { source: "iana", extensions: ["uvu", "uvvu"] },
  "video/vnd.vivo": { source: "iana", extensions: ["viv"] },
  "video/vnd.youtube.yt": { source: "iana" },
  "video/vp8": { source: "iana" },
  "video/vp9": { source: "iana" },
  "video/webm": { source: "apache", compressible: !1, extensions: ["webm"] },
  "video/x-f4v": { source: "apache", extensions: ["f4v"] },
  "video/x-fli": { source: "apache", extensions: ["fli"] },
  "video/x-flv": { source: "apache", compressible: !1, extensions: ["flv"] },
  "video/x-m4v": { source: "apache", extensions: ["m4v"] },
  "video/x-matroska": {
    source: "apache",
    compressible: !1,
    extensions: ["mkv", "mk3d", "mks"],
  },
  "video/x-mng": { source: "apache", extensions: ["mng"] },
  "video/x-ms-asf": { source: "apache", extensions: ["asf", "asx"] },
  "video/x-ms-vob": { source: "apache", extensions: ["vob"] },
  "video/x-ms-wm": { source: "apache", extensions: ["wm"] },
  "video/x-ms-wmv": { source: "apache", compressible: !1, extensions: ["wmv"] },
  "video/x-ms-wmx": { source: "apache", extensions: ["wmx"] },
  "video/x-ms-wvx": { source: "apache", extensions: ["wvx"] },
  "video/x-msvideo": { source: "apache", extensions: ["avi"] },
  "video/x-sgi-movie": { source: "apache", extensions: ["movie"] },
  "video/x-smv": { source: "apache", extensions: ["smv"] },
  "x-conference/x-cooltalk": { source: "apache", extensions: ["ice"] },
  "x-shader/x-fragment": { compressible: !0 },
  "x-shader/x-vertex": { compressible: !0 },
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var oO = sO;
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e) {
  var t = oO,
    n = pt.extname,
    r = /^\s*([^;\s]*)(?:;|\s|$)/,
    i = /^text\//i;
  (e.charset = a),
    (e.charsets = { lookup: a }),
    (e.contentType = s),
    (e.extension = o),
    (e.extensions = Object.create(null)),
    (e.lookup = c),
    (e.types = Object.create(null)),
    l(e.extensions, e.types);
  function a(f) {
    if (!f || typeof f != "string") return !1;
    var u = r.exec(f),
      d = u && t[u[1].toLowerCase()];
    return d && d.charset ? d.charset : u && i.test(u[1]) ? "UTF-8" : !1;
  }
  function s(f) {
    if (!f || typeof f != "string") return !1;
    var u = f.indexOf("/") === -1 ? e.lookup(f) : f;
    if (!u) return !1;
    if (u.indexOf("charset") === -1) {
      var d = e.charset(u);
      d && (u += "; charset=" + d.toLowerCase());
    }
    return u;
  }
  function o(f) {
    if (!f || typeof f != "string") return !1;
    var u = r.exec(f),
      d = u && e.extensions[u[1].toLowerCase()];
    return !d || !d.length ? !1 : d[0];
  }
  function c(f) {
    if (!f || typeof f != "string") return !1;
    var u = n("x." + f)
      .toLowerCase()
      .substr(1);
    return (u && e.types[u]) || !1;
  }
  function l(f, u) {
    var d = ["nginx", "apache", void 0, "iana"];
    Object.keys(t).forEach(function (h) {
      var m = t[h],
        g = m.extensions;
      if (!(!g || !g.length)) {
        f[h] = g;
        for (var v = 0; v < g.length; v++) {
          var y = g[v];
          if (u[y]) {
            var _ = d.indexOf(t[u[y]].source),
              E = d.indexOf(m.source);
            if (
              u[y] !== "application/octet-stream" &&
              (_ > E || (_ === E && u[y].substr(0, 12) === "application/"))
            )
              continue;
          }
          u[y] = h;
        }
      }
    });
  }
})(rv);
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Z1 = nv,
  cO = rv;
vc.exports = lO;
vc.exports.is = EI;
vc.exports.hasBody = wI;
vc.exports.normalize = xI;
vc.exports.match = AI;
function EI(e, t) {
  var n,
    r = t,
    i = fO(e);
  if (!i) return !1;
  if (r && !Array.isArray(r))
    for (r = new Array(arguments.length - 1), n = 0; n < r.length; n++)
      r[n] = arguments[n + 1];
  if (!r || !r.length) return i;
  var a;
  for (n = 0; n < r.length; n++)
    if (AI(xI((a = r[n])), i))
      return a[0] === "+" || a.indexOf("*") !== -1 ? i : a;
  return !1;
}
function wI(e) {
  return (
    e.headers["transfer-encoding"] !== void 0 ||
    !isNaN(e.headers["content-length"])
  );
}
function lO(e, t) {
  var n = t;
  if (!wI(e)) return null;
  if (arguments.length > 2) {
    n = new Array(arguments.length - 1);
    for (var r = 0; r < n.length; r++) n[r] = arguments[r + 1];
  }
  var i = e.headers["content-type"];
  return EI(i, n);
}
function xI(e) {
  if (typeof e != "string") return !1;
  switch (e) {
    case "urlencoded":
      return "application/x-www-form-urlencoded";
    case "multipart":
      return "multipart/*";
  }
  return e[0] === "+" ? "*/*" + e : e.indexOf("/") === -1 ? cO.lookup(e) : e;
}
function AI(e, t) {
  if (e === !1) return !1;
  var n = t.split("/"),
    r = e.split("/");
  return n.length !== 2 || r.length !== 2 || (r[0] !== "*" && r[0] !== n[0])
    ? !1
    : r[1].substr(0, 2) === "*+"
    ? r[1].length <= n[1].length + 1 &&
      r[1].substr(1) === n[1].substr(1 - r[1].length)
    : !(r[1] !== "*" && r[1] !== n[1]);
}
function uO(e) {
  var t = Z1.parse(e);
  return (t.parameters = void 0), Z1.format(t);
}
function fO(e) {
  if (!e) return null;
  try {
    return uO(e);
  } catch {
    return null;
  }
}
var ga = vc.exports;
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var yh, e_;
function dO() {
  if (e_) return yh;
  e_ = 1;
  var e = qi(),
    t = zs(),
    n = Gi,
    r = ma("body-parser:json"),
    i = Gd(),
    a = ga;
  yh = o;
  var s = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  function o(p) {
    var h = p || {},
      m = typeof h.limit != "number" ? e.parse(h.limit || "100kb") : h.limit,
      g = h.inflate !== !1,
      v = h.reviver,
      y = h.strict !== !1,
      _ = h.type || "application/json",
      E = h.verify || !1;
    if (E !== !1 && typeof E != "function")
      throw new TypeError("option verify must be function");
    var R = typeof _ != "function" ? d(_) : _;
    function A(I) {
      if (I.length === 0) return {};
      if (y) {
        var S = l(I);
        if (S !== "{" && S !== "[") throw (r("strict violation"), c(I, S));
      }
      try {
        return r("parse json"), JSON.parse(I, v);
      } catch (w) {
        throw u(w, { message: w.message, stack: w.stack });
      }
    }
    return function (S, w, O) {
      if (S._body) {
        r("body already parsed"), O();
        return;
      }
      if (((S.body = S.body || {}), !a.hasBody(S))) {
        r("skip empty body"), O();
        return;
      }
      if ((r("content-type %j", S.headers["content-type"]), !R(S))) {
        r("skip parsing"), O();
        return;
      }
      var Q = f(S) || "utf-8";
      if (Q.slice(0, 4) !== "utf-") {
        r("invalid charset"),
          O(
            n(415, 'unsupported charset "' + Q.toUpperCase() + '"', {
              charset: Q,
              type: "charset.unsupported",
            }),
          );
        return;
      }
      i(S, w, O, A, r, { encoding: Q, inflate: g, limit: m, verify: E });
    };
  }
  function c(p, h) {
    var m = p.indexOf(h),
      g = m !== -1 ? p.substring(0, m) + "#" : "";
    try {
      throw (JSON.parse(g), new SyntaxError("strict violation"));
    } catch (v) {
      return u(v, { message: v.message.replace("#", h), stack: v.stack });
    }
  }
  function l(p) {
    var h = s.exec(p);
    return h ? h[1] : void 0;
  }
  function f(p) {
    try {
      return (t.parse(p).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function u(p, h) {
    for (var m = Object.getOwnPropertyNames(p), g = 0; g < m.length; g++) {
      var v = m[g];
      v !== "stack" && v !== "message" && delete p[v];
    }
    return (
      (p.stack = h.stack.replace(p.message, h.message)),
      (p.message = h.message),
      p
    );
  }
  function d(p) {
    return function (m) {
      return !!a(m, p);
    };
  }
  return yh;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bh, t_;
function pO() {
  if (t_) return bh;
  t_ = 1;
  var e = qi(),
    t = ma("body-parser:raw"),
    n = Gd(),
    r = ga;
  bh = i;
  function i(s) {
    var o = s || {},
      c = o.inflate !== !1,
      l = typeof o.limit != "number" ? e.parse(o.limit || "100kb") : o.limit,
      f = o.type || "application/octet-stream",
      u = o.verify || !1;
    if (u !== !1 && typeof u != "function")
      throw new TypeError("option verify must be function");
    var d = typeof f != "function" ? a(f) : f;
    function p(h) {
      return h;
    }
    return function (m, g, v) {
      if (m._body) {
        t("body already parsed"), v();
        return;
      }
      if (((m.body = m.body || {}), !r.hasBody(m))) {
        t("skip empty body"), v();
        return;
      }
      if ((t("content-type %j", m.headers["content-type"]), !d(m))) {
        t("skip parsing"), v();
        return;
      }
      n(m, g, v, p, t, { encoding: null, inflate: c, limit: l, verify: u });
    };
  }
  function a(s) {
    return function (c) {
      return !!r(c, s);
    };
  }
  return bh;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var _h, n_;
function hO() {
  if (n_) return _h;
  n_ = 1;
  var e = qi(),
    t = zs(),
    n = ma("body-parser:text"),
    r = Gd(),
    i = ga;
  _h = a;
  function a(c) {
    var l = c || {},
      f = l.defaultCharset || "utf-8",
      u = l.inflate !== !1,
      d = typeof l.limit != "number" ? e.parse(l.limit || "100kb") : l.limit,
      p = l.type || "text/plain",
      h = l.verify || !1;
    if (h !== !1 && typeof h != "function")
      throw new TypeError("option verify must be function");
    var m = typeof p != "function" ? o(p) : p;
    function g(v) {
      return v;
    }
    return function (y, _, E) {
      if (y._body) {
        n("body already parsed"), E();
        return;
      }
      if (((y.body = y.body || {}), !i.hasBody(y))) {
        n("skip empty body"), E();
        return;
      }
      if ((n("content-type %j", y.headers["content-type"]), !m(y))) {
        n("skip parsing"), E();
        return;
      }
      var R = s(y) || f;
      r(y, _, E, g, n, { encoding: R, inflate: u, limit: d, verify: h });
    };
  }
  function s(c) {
    try {
      return (t.parse(c).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function o(c) {
    return function (f) {
      return !!i(f, c);
    };
  }
  return _h;
}
var mO = function () {
    if (
      typeof Symbol != "function" ||
      typeof Object.getOwnPropertySymbols != "function"
    )
      return !1;
    if (typeof Symbol.iterator == "symbol") return !0;
    var t = {},
      n = Symbol("test"),
      r = Object(n);
    if (
      typeof n == "string" ||
      Object.prototype.toString.call(n) !== "[object Symbol]" ||
      Object.prototype.toString.call(r) !== "[object Symbol]"
    )
      return !1;
    var i = 42;
    t[n] = i;
    for (n in t) return !1;
    if (
      (typeof Object.keys == "function" && Object.keys(t).length !== 0) ||
      (typeof Object.getOwnPropertyNames == "function" &&
        Object.getOwnPropertyNames(t).length !== 0)
    )
      return !1;
    var a = Object.getOwnPropertySymbols(t);
    if (
      a.length !== 1 ||
      a[0] !== n ||
      !Object.prototype.propertyIsEnumerable.call(t, n)
    )
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var s = Object.getOwnPropertyDescriptor(t, n);
      if (s.value !== i || s.enumerable !== !0) return !1;
    }
    return !0;
  },
  r_ = typeof Symbol < "u" && Symbol,
  gO = mO,
  vO = function () {
    return typeof r_ != "function" ||
      typeof Symbol != "function" ||
      typeof r_("foo") != "symbol" ||
      typeof Symbol("bar") != "symbol"
      ? !1
      : gO();
  },
  i_ = { foo: {} },
  yO = Object,
  bO = function () {
    return (
      { __proto__: i_ }.foo === i_.foo && !({ __proto__: null } instanceof yO)
    );
  },
  _O = "Function.prototype.bind called on incompatible ",
  Eh = Array.prototype.slice,
  EO = Object.prototype.toString,
  wO = "[object Function]",
  xO = function (t) {
    var n = this;
    if (typeof n != "function" || EO.call(n) !== wO)
      throw new TypeError(_O + n);
    for (
      var r = Eh.call(arguments, 1),
        i,
        a = function () {
          if (this instanceof i) {
            var f = n.apply(this, r.concat(Eh.call(arguments)));
            return Object(f) === f ? f : this;
          } else return n.apply(t, r.concat(Eh.call(arguments)));
        },
        s = Math.max(0, n.length - r.length),
        o = [],
        c = 0;
      c < s;
      c++
    )
      o.push("$" + c);
    if (
      ((i = Function(
        "binder",
        "return function (" +
          o.join(",") +
          "){ return binder.apply(this,arguments); }",
      )(a)),
      n.prototype)
    ) {
      var l = function () {};
      (l.prototype = n.prototype),
        (i.prototype = new l()),
        (l.prototype = null);
    }
    return i;
  },
  AO = xO,
  iv = Function.prototype.bind || AO,
  SO = iv,
  IO = SO.call(Function.call, Object.prototype.hasOwnProperty),
  kt,
  Ho = SyntaxError,
  SI = Function,
  Po = TypeError,
  wh = function (e) {
    try {
      return SI('"use strict"; return (' + e + ").constructor;")();
    } catch {}
  },
  Ts = Object.getOwnPropertyDescriptor;
if (Ts)
  try {
    Ts({}, "");
  } catch {
    Ts = null;
  }
var xh = function () {
    throw new Po();
  },
  $O = Ts
    ? (function () {
        try {
          return arguments.callee, xh;
        } catch {
          try {
            return Ts(arguments, "callee").get;
          } catch {
            return xh;
          }
        }
      })()
    : xh,
  ro = vO(),
  CO = bO(),
  Wn =
    Object.getPrototypeOf ||
    (CO
      ? function (e) {
          return e.__proto__;
        }
      : null),
  wo = {},
  RO = typeof Uint8Array > "u" || !Wn ? kt : Wn(Uint8Array),
  Ns = {
    "%AggregateError%": typeof AggregateError > "u" ? kt : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? kt : ArrayBuffer,
    "%ArrayIteratorPrototype%": ro && Wn ? Wn([][Symbol.iterator]()) : kt,
    "%AsyncFromSyncIteratorPrototype%": kt,
    "%AsyncFunction%": wo,
    "%AsyncGenerator%": wo,
    "%AsyncGeneratorFunction%": wo,
    "%AsyncIteratorPrototype%": wo,
    "%Atomics%": typeof Atomics > "u" ? kt : Atomics,
    "%BigInt%": typeof BigInt > "u" ? kt : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? kt : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? kt : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? kt : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array > "u" ? kt : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? kt : Float64Array,
    "%FinalizationRegistry%":
      typeof FinalizationRegistry > "u" ? kt : FinalizationRegistry,
    "%Function%": SI,
    "%GeneratorFunction%": wo,
    "%Int8Array%": typeof Int8Array > "u" ? kt : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? kt : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? kt : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": ro && Wn ? Wn(Wn([][Symbol.iterator]())) : kt,
    "%JSON%": typeof JSON == "object" ? JSON : kt,
    "%Map%": typeof Map > "u" ? kt : Map,
    "%MapIteratorPrototype%":
      typeof Map > "u" || !ro || !Wn ? kt : Wn(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? kt : Promise,
    "%Proxy%": typeof Proxy > "u" ? kt : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect > "u" ? kt : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? kt : Set,
    "%SetIteratorPrototype%":
      typeof Set > "u" || !ro || !Wn ? kt : Wn(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%":
      typeof SharedArrayBuffer > "u" ? kt : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": ro && Wn ? Wn(""[Symbol.iterator]()) : kt,
    "%Symbol%": ro ? Symbol : kt,
    "%SyntaxError%": Ho,
    "%ThrowTypeError%": $O,
    "%TypedArray%": RO,
    "%TypeError%": Po,
    "%Uint8Array%": typeof Uint8Array > "u" ? kt : Uint8Array,
    "%Uint8ClampedArray%":
      typeof Uint8ClampedArray > "u" ? kt : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? kt : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? kt : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap > "u" ? kt : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? kt : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? kt : WeakSet,
  };
if (Wn)
  try {
    null.error;
  } catch (e) {
    var kO = Wn(Wn(e));
    Ns["%Error.prototype%"] = kO;
  }
var TO = function e(t) {
    var n;
    if (t === "%AsyncFunction%") n = wh("async function () {}");
    else if (t === "%GeneratorFunction%") n = wh("function* () {}");
    else if (t === "%AsyncGeneratorFunction%") n = wh("async function* () {}");
    else if (t === "%AsyncGenerator%") {
      var r = e("%AsyncGeneratorFunction%");
      r && (n = r.prototype);
    } else if (t === "%AsyncIteratorPrototype%") {
      var i = e("%AsyncGenerator%");
      i && Wn && (n = Wn(i.prototype));
    }
    return (Ns[t] = n), n;
  },
  a_ = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": [
      "AsyncGeneratorFunction",
      "prototype",
      "prototype",
    ],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"],
  },
  Vl = iv,
  ed = IO,
  NO = Vl.call(Function.call, Array.prototype.concat),
  OO = Vl.call(Function.apply, Array.prototype.splice),
  s_ = Vl.call(Function.call, String.prototype.replace),
  td = Vl.call(Function.call, String.prototype.slice),
  PO = Vl.call(Function.call, RegExp.prototype.exec),
  DO =
    /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
  LO = /\\(\\)?/g,
  BO = function (t) {
    var n = td(t, 0, 1),
      r = td(t, -1);
    if (n === "%" && r !== "%")
      throw new Ho("invalid intrinsic syntax, expected closing `%`");
    if (r === "%" && n !== "%")
      throw new Ho("invalid intrinsic syntax, expected opening `%`");
    var i = [];
    return (
      s_(t, DO, function (a, s, o, c) {
        i[i.length] = o ? s_(c, LO, "$1") : s || a;
      }),
      i
    );
  },
  UO = function (t, n) {
    var r = t,
      i;
    if ((ed(a_, r) && ((i = a_[r]), (r = "%" + i[0] + "%")), ed(Ns, r))) {
      var a = Ns[r];
      if ((a === wo && (a = TO(r)), typeof a > "u" && !n))
        throw new Po(
          "intrinsic " +
            t +
            " exists, but is not available. Please file an issue!",
        );
      return { alias: i, name: r, value: a };
    }
    throw new Ho("intrinsic " + t + " does not exist!");
  },
  av = function (t, n) {
    if (typeof t != "string" || t.length === 0)
      throw new Po("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof n != "boolean")
      throw new Po('"allowMissing" argument must be a boolean');
    if (PO(/^%?[^%]*%?$/, t) === null)
      throw new Ho(
        "`%` may not be present anywhere but at the beginning and end of the intrinsic name",
      );
    var r = BO(t),
      i = r.length > 0 ? r[0] : "",
      a = UO("%" + i + "%", n),
      s = a.name,
      o = a.value,
      c = !1,
      l = a.alias;
    l && ((i = l[0]), OO(r, NO([0, 1], l)));
    for (var f = 1, u = !0; f < r.length; f += 1) {
      var d = r[f],
        p = td(d, 0, 1),
        h = td(d, -1);
      if (
        (p === '"' ||
          p === "'" ||
          p === "`" ||
          h === '"' ||
          h === "'" ||
          h === "`") &&
        p !== h
      )
        throw new Ho("property names with quotes must have matching quotes");
      if (
        ((d === "constructor" || !u) && (c = !0),
        (i += "." + d),
        (s = "%" + i + "%"),
        ed(Ns, s))
      )
        o = Ns[s];
      else if (o != null) {
        if (!(d in o)) {
          if (!n)
            throw new Po(
              "base intrinsic for " +
                t +
                " exists, but the property is not available.",
            );
          return;
        }
        if (Ts && f + 1 >= r.length) {
          var m = Ts(o, d);
          (u = !!m),
            u && "get" in m && !("originalValue" in m.get)
              ? (o = m.get)
              : (o = o[d]);
        } else (u = ed(o, d)), (o = o[d]);
        u && !c && (Ns[s] = o);
      }
    }
    return o;
  },
  II = { exports: {} };
(function (e) {
  var t = iv,
    n = av,
    r = n("%Function.prototype.apply%"),
    i = n("%Function.prototype.call%"),
    a = n("%Reflect.apply%", !0) || t.call(i, r),
    s = n("%Object.getOwnPropertyDescriptor%", !0),
    o = n("%Object.defineProperty%", !0),
    c = n("%Math.max%");
  if (o)
    try {
      o({}, "a", { value: 1 });
    } catch {
      o = null;
    }
  e.exports = function (u) {
    var d = a(t, i, arguments);
    if (s && o) {
      var p = s(d, "length");
      p.configurable &&
        o(d, "length", { value: 1 + c(0, u.length - (arguments.length - 1)) });
    }
    return d;
  };
  var l = function () {
    return a(t, r, arguments);
  };
  o ? o(e.exports, "apply", { value: l }) : (e.exports.apply = l);
})(II);
var FO = II.exports,
  $I = av,
  CI = FO,
  jO = CI($I("String.prototype.indexOf")),
  MO = function (t, n) {
    var r = $I(t, !!n);
    return typeof r == "function" && jO(t, ".prototype.") > -1 ? CI(r) : r;
  },
  HO = wr.inspect,
  sv = typeof Map == "function" && Map.prototype,
  Ah =
    Object.getOwnPropertyDescriptor && sv
      ? Object.getOwnPropertyDescriptor(Map.prototype, "size")
      : null,
  nd = sv && Ah && typeof Ah.get == "function" ? Ah.get : null,
  o_ = sv && Map.prototype.forEach,
  ov = typeof Set == "function" && Set.prototype,
  Sh =
    Object.getOwnPropertyDescriptor && ov
      ? Object.getOwnPropertyDescriptor(Set.prototype, "size")
      : null,
  rd = ov && Sh && typeof Sh.get == "function" ? Sh.get : null,
  c_ = ov && Set.prototype.forEach,
  qO = typeof WeakMap == "function" && WeakMap.prototype,
  ll = qO ? WeakMap.prototype.has : null,
  GO = typeof WeakSet == "function" && WeakSet.prototype,
  ul = GO ? WeakSet.prototype.has : null,
  QO = typeof WeakRef == "function" && WeakRef.prototype,
  l_ = QO ? WeakRef.prototype.deref : null,
  WO = Boolean.prototype.valueOf,
  zO = Object.prototype.toString,
  KO = Function.prototype.toString,
  VO = String.prototype.match,
  cv = String.prototype.slice,
  Pa = String.prototype.replace,
  YO = String.prototype.toUpperCase,
  u_ = String.prototype.toLowerCase,
  RI = RegExp.prototype.test,
  f_ = Array.prototype.concat,
  Pi = Array.prototype.join,
  XO = Array.prototype.slice,
  d_ = Math.floor,
  Hg = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
  Ih = Object.getOwnPropertySymbols,
  qg =
    typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
      ? Symbol.prototype.toString
      : null,
  qo = typeof Symbol == "function" && typeof Symbol.iterator == "object",
  dr =
    typeof Symbol == "function" &&
    Symbol.toStringTag &&
    (typeof Symbol.toStringTag === qo || "symbol")
      ? Symbol.toStringTag
      : null,
  kI = Object.prototype.propertyIsEnumerable,
  p_ =
    (typeof Reflect == "function"
      ? Reflect.getPrototypeOf
      : Object.getPrototypeOf) ||
    ([].__proto__ === Array.prototype
      ? function (e) {
          return e.__proto__;
        }
      : null);
function h_(e, t) {
  if (
    e === 1 / 0 ||
    e === -1 / 0 ||
    e !== e ||
    (e && e > -1e3 && e < 1e3) ||
    RI.call(/e/, t)
  )
    return t;
  var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof e == "number") {
    var r = e < 0 ? -d_(-e) : d_(e);
    if (r !== e) {
      var i = String(r),
        a = cv.call(t, i.length + 1);
      return (
        Pa.call(i, n, "$&_") +
        "." +
        Pa.call(Pa.call(a, /([0-9]{3})/g, "$&_"), /_$/, "")
      );
    }
  }
  return Pa.call(t, n, "$&_");
}
var Gg = HO,
  m_ = Gg.custom,
  g_ = NI(m_) ? m_ : null,
  JO = function e(t, n, r, i) {
    var a = n || {};
    if (
      $a(a, "quoteStyle") &&
      a.quoteStyle !== "single" &&
      a.quoteStyle !== "double"
    )
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (
      $a(a, "maxStringLength") &&
      (typeof a.maxStringLength == "number"
        ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0
        : a.maxStringLength !== null)
    )
      throw new TypeError(
        'option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`',
      );
    var s = $a(a, "customInspect") ? a.customInspect : !0;
    if (typeof s != "boolean" && s !== "symbol")
      throw new TypeError(
        "option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`",
      );
    if (
      $a(a, "indent") &&
      a.indent !== null &&
      a.indent !== "	" &&
      !(parseInt(a.indent, 10) === a.indent && a.indent > 0)
    )
      throw new TypeError(
        'option "indent" must be "\\t", an integer > 0, or `null`',
      );
    if ($a(a, "numericSeparator") && typeof a.numericSeparator != "boolean")
      throw new TypeError(
        'option "numericSeparator", if provided, must be `true` or `false`',
      );
    var o = a.numericSeparator;
    if (typeof t > "u") return "undefined";
    if (t === null) return "null";
    if (typeof t == "boolean") return t ? "true" : "false";
    if (typeof t == "string") return PI(t, a);
    if (typeof t == "number") {
      if (t === 0) return 1 / 0 / t > 0 ? "0" : "-0";
      var c = String(t);
      return o ? h_(t, c) : c;
    }
    if (typeof t == "bigint") {
      var l = String(t) + "n";
      return o ? h_(t, l) : l;
    }
    var f = typeof a.depth > "u" ? 5 : a.depth;
    if ((typeof r > "u" && (r = 0), r >= f && f > 0 && typeof t == "object"))
      return Qg(t) ? "[Array]" : "[Object]";
    var u = gP(a, r);
    if (typeof i > "u") i = [];
    else if (OI(i, t) >= 0) return "[Circular]";
    function d(H, q, J) {
      if ((q && ((i = XO.call(i)), i.push(q)), J)) {
        var Z = { depth: a.depth };
        return (
          $a(a, "quoteStyle") && (Z.quoteStyle = a.quoteStyle),
          e(H, Z, r + 1, i)
        );
      }
      return e(H, a, r + 1, i);
    }
    if (typeof t == "function" && !v_(t)) {
      var p = oP(t),
        h = Fu(t, d);
      return (
        "[Function" +
        (p ? ": " + p : " (anonymous)") +
        "]" +
        (h.length > 0 ? " { " + Pi.call(h, ", ") + " }" : "")
      );
    }
    if (NI(t)) {
      var m = qo
        ? Pa.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1")
        : qg.call(t);
      return typeof t == "object" && !qo ? Pc(m) : m;
    }
    if (pP(t)) {
      for (
        var g = "<" + u_.call(String(t.nodeName)),
          v = t.attributes || [],
          y = 0;
        y < v.length;
        y++
      )
        g += " " + v[y].name + "=" + TI(ZO(v[y].value), "double", a);
      return (
        (g += ">"),
        t.childNodes && t.childNodes.length && (g += "..."),
        (g += "</" + u_.call(String(t.nodeName)) + ">"),
        g
      );
    }
    if (Qg(t)) {
      if (t.length === 0) return "[]";
      var _ = Fu(t, d);
      return u && !mP(_)
        ? "[" + Wg(_, u) + "]"
        : "[ " + Pi.call(_, ", ") + " ]";
    }
    if (tP(t)) {
      var E = Fu(t, d);
      return !("cause" in Error.prototype) &&
        "cause" in t &&
        !kI.call(t, "cause")
        ? "{ [" +
            String(t) +
            "] " +
            Pi.call(f_.call("[cause]: " + d(t.cause), E), ", ") +
            " }"
        : E.length === 0
        ? "[" + String(t) + "]"
        : "{ [" + String(t) + "] " + Pi.call(E, ", ") + " }";
    }
    if (typeof t == "object" && s) {
      if (g_ && typeof t[g_] == "function" && Gg)
        return Gg(t, { depth: f - r });
      if (s !== "symbol" && typeof t.inspect == "function") return t.inspect();
    }
    if (cP(t)) {
      var R = [];
      return (
        o_ &&
          o_.call(t, function (H, q) {
            R.push(d(q, t, !0) + " => " + d(H, t));
          }),
        y_("Map", nd.call(t), R, u)
      );
    }
    if (fP(t)) {
      var A = [];
      return (
        c_ &&
          c_.call(t, function (H) {
            A.push(d(H, t));
          }),
        y_("Set", rd.call(t), A, u)
      );
    }
    if (lP(t)) return $h("WeakMap");
    if (dP(t)) return $h("WeakSet");
    if (uP(t)) return $h("WeakRef");
    if (rP(t)) return Pc(d(Number(t)));
    if (aP(t)) return Pc(d(Hg.call(t)));
    if (iP(t)) return Pc(WO.call(t));
    if (nP(t)) return Pc(d(String(t)));
    if (!eP(t) && !v_(t)) {
      var I = Fu(t, d),
        S = p_
          ? p_(t) === Object.prototype
          : t instanceof Object || t.constructor === Object,
        w = t instanceof Object ? "" : "null prototype",
        O =
          !S && dr && Object(t) === t && dr in t
            ? cv.call(Ja(t), 8, -1)
            : w
            ? "Object"
            : "",
        Q =
          S || typeof t.constructor != "function"
            ? ""
            : t.constructor.name
            ? t.constructor.name + " "
            : "",
        j =
          Q +
          (O || w
            ? "[" + Pi.call(f_.call([], O || [], w || []), ": ") + "] "
            : "");
      return I.length === 0
        ? j + "{}"
        : u
        ? j + "{" + Wg(I, u) + "}"
        : j + "{ " + Pi.call(I, ", ") + " }";
    }
    return String(t);
  };
function TI(e, t, n) {
  var r = (n.quoteStyle || t) === "double" ? '"' : "'";
  return r + e + r;
}
function ZO(e) {
  return Pa.call(String(e), /"/g, "&quot;");
}
function Qg(e) {
  return (
    Ja(e) === "[object Array]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function eP(e) {
  return (
    Ja(e) === "[object Date]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function v_(e) {
  return (
    Ja(e) === "[object RegExp]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function tP(e) {
  return (
    Ja(e) === "[object Error]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function nP(e) {
  return (
    Ja(e) === "[object String]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function rP(e) {
  return (
    Ja(e) === "[object Number]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function iP(e) {
  return (
    Ja(e) === "[object Boolean]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function NI(e) {
  if (qo) return e && typeof e == "object" && e instanceof Symbol;
  if (typeof e == "symbol") return !0;
  if (!e || typeof e != "object" || !qg) return !1;
  try {
    return qg.call(e), !0;
  } catch {}
  return !1;
}
function aP(e) {
  if (!e || typeof e != "object" || !Hg) return !1;
  try {
    return Hg.call(e), !0;
  } catch {}
  return !1;
}
var sP =
  Object.prototype.hasOwnProperty ||
  function (e) {
    return e in this;
  };
function $a(e, t) {
  return sP.call(e, t);
}
function Ja(e) {
  return zO.call(e);
}
function oP(e) {
  if (e.name) return e.name;
  var t = VO.call(KO.call(e), /^function\s*([\w$]+)/);
  return t ? t[1] : null;
}
function OI(e, t) {
  if (e.indexOf) return e.indexOf(t);
  for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;
  return -1;
}
function cP(e) {
  if (!nd || !e || typeof e != "object") return !1;
  try {
    nd.call(e);
    try {
      rd.call(e);
    } catch {
      return !0;
    }
    return e instanceof Map;
  } catch {}
  return !1;
}
function lP(e) {
  if (!ll || !e || typeof e != "object") return !1;
  try {
    ll.call(e, ll);
    try {
      ul.call(e, ul);
    } catch {
      return !0;
    }
    return e instanceof WeakMap;
  } catch {}
  return !1;
}
function uP(e) {
  if (!l_ || !e || typeof e != "object") return !1;
  try {
    return l_.call(e), !0;
  } catch {}
  return !1;
}
function fP(e) {
  if (!rd || !e || typeof e != "object") return !1;
  try {
    rd.call(e);
    try {
      nd.call(e);
    } catch {
      return !0;
    }
    return e instanceof Set;
  } catch {}
  return !1;
}
function dP(e) {
  if (!ul || !e || typeof e != "object") return !1;
  try {
    ul.call(e, ul);
    try {
      ll.call(e, ll);
    } catch {
      return !0;
    }
    return e instanceof WeakSet;
  } catch {}
  return !1;
}
function pP(e) {
  return !e || typeof e != "object"
    ? !1
    : typeof HTMLElement < "u" && e instanceof HTMLElement
    ? !0
    : typeof e.nodeName == "string" && typeof e.getAttribute == "function";
}
function PI(e, t) {
  if (e.length > t.maxStringLength) {
    var n = e.length - t.maxStringLength,
      r = "... " + n + " more character" + (n > 1 ? "s" : "");
    return PI(cv.call(e, 0, t.maxStringLength), t) + r;
  }
  var i = Pa.call(Pa.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, hP);
  return TI(i, "single", t);
}
function hP(e) {
  var t = e.charCodeAt(0),
    n = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[t];
  return n ? "\\" + n : "\\x" + (t < 16 ? "0" : "") + YO.call(t.toString(16));
}
function Pc(e) {
  return "Object(" + e + ")";
}
function $h(e) {
  return e + " { ? }";
}
function y_(e, t, n, r) {
  var i = r ? Wg(n, r) : Pi.call(n, ", ");
  return e + " (" + t + ") {" + i + "}";
}
function mP(e) {
  for (var t = 0; t < e.length; t++)
    if (
      OI(
        e[t],
        `
`,
      ) >= 0
    )
      return !1;
  return !0;
}
function gP(e, t) {
  var n;
  if (e.indent === "	") n = "	";
  else if (typeof e.indent == "number" && e.indent > 0)
    n = Pi.call(Array(e.indent + 1), " ");
  else return null;
  return { base: n, prev: Pi.call(Array(t + 1), n) };
}
function Wg(e, t) {
  if (e.length === 0) return "";
  var n =
    `
` +
    t.prev +
    t.base;
  return (
    n +
    Pi.call(e, "," + n) +
    `
` +
    t.prev
  );
}
function Fu(e, t) {
  var n = Qg(e),
    r = [];
  if (n) {
    r.length = e.length;
    for (var i = 0; i < e.length; i++) r[i] = $a(e, i) ? t(e[i], e) : "";
  }
  var a = typeof Ih == "function" ? Ih(e) : [],
    s;
  if (qo) {
    s = {};
    for (var o = 0; o < a.length; o++) s["$" + a[o]] = a[o];
  }
  for (var c in e)
    $a(e, c) &&
      ((n && String(Number(c)) === c && c < e.length) ||
        (qo && s["$" + c] instanceof Symbol) ||
        (RI.call(/[^\w$]/, c)
          ? r.push(t(c, e) + ": " + t(e[c], e))
          : r.push(c + ": " + t(e[c], e))));
  if (typeof Ih == "function")
    for (var l = 0; l < a.length; l++)
      kI.call(e, a[l]) && r.push("[" + t(a[l]) + "]: " + t(e[a[l]], e));
  return r;
}
var lv = av,
  yc = MO,
  vP = JO,
  yP = lv("%TypeError%"),
  ju = lv("%WeakMap%", !0),
  Mu = lv("%Map%", !0),
  bP = yc("WeakMap.prototype.get", !0),
  _P = yc("WeakMap.prototype.set", !0),
  EP = yc("WeakMap.prototype.has", !0),
  wP = yc("Map.prototype.get", !0),
  xP = yc("Map.prototype.set", !0),
  AP = yc("Map.prototype.has", !0),
  uv = function (e, t) {
    for (var n = e, r; (r = n.next) !== null; n = r)
      if (r.key === t)
        return (n.next = r.next), (r.next = e.next), (e.next = r), r;
  },
  SP = function (e, t) {
    var n = uv(e, t);
    return n && n.value;
  },
  IP = function (e, t, n) {
    var r = uv(e, t);
    r ? (r.value = n) : (e.next = { key: t, next: e.next, value: n });
  },
  $P = function (e, t) {
    return !!uv(e, t);
  },
  DI = function () {
    var t,
      n,
      r,
      i = {
        assert: function (a) {
          if (!i.has(a)) throw new yP("Side channel does not contain " + vP(a));
        },
        get: function (a) {
          if (ju && a && (typeof a == "object" || typeof a == "function")) {
            if (t) return bP(t, a);
          } else if (Mu) {
            if (n) return wP(n, a);
          } else if (r) return SP(r, a);
        },
        has: function (a) {
          if (ju && a && (typeof a == "object" || typeof a == "function")) {
            if (t) return EP(t, a);
          } else if (Mu) {
            if (n) return AP(n, a);
          } else if (r) return $P(r, a);
          return !1;
        },
        set: function (a, s) {
          ju && a && (typeof a == "object" || typeof a == "function")
            ? (t || (t = new ju()), _P(t, a, s))
            : Mu
            ? (n || (n = new Mu()), xP(n, a, s))
            : (r || (r = { key: {}, next: null }), IP(r, a, s));
        },
      };
    return i;
  },
  CP = String.prototype.replace,
  RP = /%20/g,
  Ch = { RFC1738: "RFC1738", RFC3986: "RFC3986" },
  fv = {
    default: Ch.RFC3986,
    formatters: {
      RFC1738: function (e) {
        return CP.call(e, RP, "+");
      },
      RFC3986: function (e) {
        return String(e);
      },
    },
    RFC1738: Ch.RFC1738,
    RFC3986: Ch.RFC3986,
  },
  kP = fv,
  Rh = Object.prototype.hasOwnProperty,
  hs = Array.isArray,
  Ri = (function () {
    for (var e = [], t = 0; t < 256; ++t)
      e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
    return e;
  })(),
  TP = function (t) {
    for (; t.length > 1; ) {
      var n = t.pop(),
        r = n.obj[n.prop];
      if (hs(r)) {
        for (var i = [], a = 0; a < r.length; ++a)
          typeof r[a] < "u" && i.push(r[a]);
        n.obj[n.prop] = i;
      }
    }
  },
  LI = function (t, n) {
    for (
      var r = n && n.plainObjects ? Object.create(null) : {}, i = 0;
      i < t.length;
      ++i
    )
      typeof t[i] < "u" && (r[i] = t[i]);
    return r;
  },
  NP = function e(t, n, r) {
    if (!n) return t;
    if (typeof n != "object") {
      if (hs(t)) t.push(n);
      else if (t && typeof t == "object")
        ((r && (r.plainObjects || r.allowPrototypes)) ||
          !Rh.call(Object.prototype, n)) &&
          (t[n] = !0);
      else return [t, n];
      return t;
    }
    if (!t || typeof t != "object") return [t].concat(n);
    var i = t;
    return (
      hs(t) && !hs(n) && (i = LI(t, r)),
      hs(t) && hs(n)
        ? (n.forEach(function (a, s) {
            if (Rh.call(t, s)) {
              var o = t[s];
              o && typeof o == "object" && a && typeof a == "object"
                ? (t[s] = e(o, a, r))
                : t.push(a);
            } else t[s] = a;
          }),
          t)
        : Object.keys(n).reduce(function (a, s) {
            var o = n[s];
            return Rh.call(a, s) ? (a[s] = e(a[s], o, r)) : (a[s] = o), a;
          }, i)
    );
  },
  OP = function (t, n) {
    return Object.keys(n).reduce(function (r, i) {
      return (r[i] = n[i]), r;
    }, t);
  },
  PP = function (e, t, n) {
    var r = e.replace(/\+/g, " ");
    if (n === "iso-8859-1") return r.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(r);
    } catch {
      return r;
    }
  },
  DP = function (t, n, r, i, a) {
    if (t.length === 0) return t;
    var s = t;
    if (
      (typeof t == "symbol"
        ? (s = Symbol.prototype.toString.call(t))
        : typeof t != "string" && (s = String(t)),
      r === "iso-8859-1")
    )
      return escape(s).replace(/%u[0-9a-f]{4}/gi, function (f) {
        return "%26%23" + parseInt(f.slice(2), 16) + "%3B";
      });
    for (var o = "", c = 0; c < s.length; ++c) {
      var l = s.charCodeAt(c);
      if (
        l === 45 ||
        l === 46 ||
        l === 95 ||
        l === 126 ||
        (l >= 48 && l <= 57) ||
        (l >= 65 && l <= 90) ||
        (l >= 97 && l <= 122) ||
        (a === kP.RFC1738 && (l === 40 || l === 41))
      ) {
        o += s.charAt(c);
        continue;
      }
      if (l < 128) {
        o = o + Ri[l];
        continue;
      }
      if (l < 2048) {
        o = o + (Ri[192 | (l >> 6)] + Ri[128 | (l & 63)]);
        continue;
      }
      if (l < 55296 || l >= 57344) {
        o =
          o +
          (Ri[224 | (l >> 12)] +
            Ri[128 | ((l >> 6) & 63)] +
            Ri[128 | (l & 63)]);
        continue;
      }
      (c += 1),
        (l = 65536 + (((l & 1023) << 10) | (s.charCodeAt(c) & 1023))),
        (o +=
          Ri[240 | (l >> 18)] +
          Ri[128 | ((l >> 12) & 63)] +
          Ri[128 | ((l >> 6) & 63)] +
          Ri[128 | (l & 63)]);
    }
    return o;
  },
  LP = function (t) {
    for (
      var n = [{ obj: { o: t }, prop: "o" }], r = [], i = 0;
      i < n.length;
      ++i
    )
      for (
        var a = n[i], s = a.obj[a.prop], o = Object.keys(s), c = 0;
        c < o.length;
        ++c
      ) {
        var l = o[c],
          f = s[l];
        typeof f == "object" &&
          f !== null &&
          r.indexOf(f) === -1 &&
          (n.push({ obj: s, prop: l }), r.push(f));
      }
    return TP(n), t;
  },
  BP = function (t) {
    return Object.prototype.toString.call(t) === "[object RegExp]";
  },
  UP = function (t) {
    return !t || typeof t != "object"
      ? !1
      : !!(
          t.constructor &&
          t.constructor.isBuffer &&
          t.constructor.isBuffer(t)
        );
  },
  FP = function (t, n) {
    return [].concat(t, n);
  },
  jP = function (t, n) {
    if (hs(t)) {
      for (var r = [], i = 0; i < t.length; i += 1) r.push(n(t[i]));
      return r;
    }
    return n(t);
  },
  BI = {
    arrayToObject: LI,
    assign: OP,
    combine: FP,
    compact: LP,
    decode: PP,
    encode: DP,
    isBuffer: UP,
    isRegExp: BP,
    maybeMap: jP,
    merge: NP,
  },
  UI = DI,
  zg = BI,
  fl = fv,
  MP = Object.prototype.hasOwnProperty,
  b_ = {
    brackets: function (t) {
      return t + "[]";
    },
    comma: "comma",
    indices: function (t, n) {
      return t + "[" + n + "]";
    },
    repeat: function (t) {
      return t;
    },
  },
  na = Array.isArray,
  HP = String.prototype.split,
  qP = Array.prototype.push,
  FI = function (e, t) {
    qP.apply(e, na(t) ? t : [t]);
  },
  GP = Date.prototype.toISOString,
  __ = fl.default,
  Zn = {
    addQueryPrefix: !1,
    allowDots: !1,
    charset: "utf-8",
    charsetSentinel: !1,
    delimiter: "&",
    encode: !0,
    encoder: zg.encode,
    encodeValuesOnly: !1,
    format: __,
    formatter: fl.formatters[__],
    indices: !1,
    serializeDate: function (t) {
      return GP.call(t);
    },
    skipNulls: !1,
    strictNullHandling: !1,
  },
  QP = function (t) {
    return (
      typeof t == "string" ||
      typeof t == "number" ||
      typeof t == "boolean" ||
      typeof t == "symbol" ||
      typeof t == "bigint"
    );
  },
  kh = {},
  WP = function e(t, n, r, i, a, s, o, c, l, f, u, d, p, h, m, g) {
    for (var v = t, y = g, _ = 0, E = !1; (y = y.get(kh)) !== void 0 && !E; ) {
      var R = y.get(t);
      if (((_ += 1), typeof R < "u")) {
        if (R === _) throw new RangeError("Cyclic object value");
        E = !0;
      }
      typeof y.get(kh) > "u" && (_ = 0);
    }
    if (
      (typeof c == "function"
        ? (v = c(n, v))
        : v instanceof Date
        ? (v = u(v))
        : r === "comma" &&
          na(v) &&
          (v = zg.maybeMap(v, function (G) {
            return G instanceof Date ? u(G) : G;
          })),
      v === null)
    ) {
      if (a) return o && !h ? o(n, Zn.encoder, m, "key", d) : n;
      v = "";
    }
    if (QP(v) || zg.isBuffer(v)) {
      if (o) {
        var A = h ? n : o(n, Zn.encoder, m, "key", d);
        if (r === "comma" && h) {
          for (
            var I = HP.call(String(v), ","), S = "", w = 0;
            w < I.length;
            ++w
          )
            S += (w === 0 ? "" : ",") + p(o(I[w], Zn.encoder, m, "value", d));
          return [p(A) + (i && na(v) && I.length === 1 ? "[]" : "") + "=" + S];
        }
        return [p(A) + "=" + p(o(v, Zn.encoder, m, "value", d))];
      }
      return [p(n) + "=" + p(String(v))];
    }
    var O = [];
    if (typeof v > "u") return O;
    var Q;
    if (r === "comma" && na(v))
      Q = [{ value: v.length > 0 ? v.join(",") || null : void 0 }];
    else if (na(c)) Q = c;
    else {
      var j = Object.keys(v);
      Q = l ? j.sort(l) : j;
    }
    for (
      var H = i && na(v) && v.length === 1 ? n + "[]" : n, q = 0;
      q < Q.length;
      ++q
    ) {
      var J = Q[q],
        Z = typeof J == "object" && typeof J.value < "u" ? J.value : v[J];
      if (!(s && Z === null)) {
        var z = na(v)
          ? typeof r == "function"
            ? r(H, J)
            : H
          : H + (f ? "." + J : "[" + J + "]");
        g.set(t, _);
        var U = UI();
        U.set(kh, g), FI(O, e(Z, z, r, i, a, s, o, c, l, f, u, d, p, h, m, U));
      }
    }
    return O;
  },
  zP = function (t) {
    if (!t) return Zn;
    if (
      t.encoder !== null &&
      typeof t.encoder < "u" &&
      typeof t.encoder != "function"
    )
      throw new TypeError("Encoder has to be a function.");
    var n = t.charset || Zn.charset;
    if (
      typeof t.charset < "u" &&
      t.charset !== "utf-8" &&
      t.charset !== "iso-8859-1"
    )
      throw new TypeError(
        "The charset option must be either utf-8, iso-8859-1, or undefined",
      );
    var r = fl.default;
    if (typeof t.format < "u") {
      if (!MP.call(fl.formatters, t.format))
        throw new TypeError("Unknown format option provided.");
      r = t.format;
    }
    var i = fl.formatters[r],
      a = Zn.filter;
    return (
      (typeof t.filter == "function" || na(t.filter)) && (a = t.filter),
      {
        addQueryPrefix:
          typeof t.addQueryPrefix == "boolean"
            ? t.addQueryPrefix
            : Zn.addQueryPrefix,
        allowDots: typeof t.allowDots > "u" ? Zn.allowDots : !!t.allowDots,
        charset: n,
        charsetSentinel:
          typeof t.charsetSentinel == "boolean"
            ? t.charsetSentinel
            : Zn.charsetSentinel,
        delimiter: typeof t.delimiter > "u" ? Zn.delimiter : t.delimiter,
        encode: typeof t.encode == "boolean" ? t.encode : Zn.encode,
        encoder: typeof t.encoder == "function" ? t.encoder : Zn.encoder,
        encodeValuesOnly:
          typeof t.encodeValuesOnly == "boolean"
            ? t.encodeValuesOnly
            : Zn.encodeValuesOnly,
        filter: a,
        format: r,
        formatter: i,
        serializeDate:
          typeof t.serializeDate == "function"
            ? t.serializeDate
            : Zn.serializeDate,
        skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : Zn.skipNulls,
        sort: typeof t.sort == "function" ? t.sort : null,
        strictNullHandling:
          typeof t.strictNullHandling == "boolean"
            ? t.strictNullHandling
            : Zn.strictNullHandling,
      }
    );
  },
  KP = function (e, t) {
    var n = e,
      r = zP(t),
      i,
      a;
    typeof r.filter == "function"
      ? ((a = r.filter), (n = a("", n)))
      : na(r.filter) && ((a = r.filter), (i = a));
    var s = [];
    if (typeof n != "object" || n === null) return "";
    var o;
    t && t.arrayFormat in b_
      ? (o = t.arrayFormat)
      : t && "indices" in t
      ? (o = t.indices ? "indices" : "repeat")
      : (o = "indices");
    var c = b_[o];
    if (t && "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean")
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var l = c === "comma" && t && t.commaRoundTrip;
    i || (i = Object.keys(n)), r.sort && i.sort(r.sort);
    for (var f = UI(), u = 0; u < i.length; ++u) {
      var d = i[u];
      (r.skipNulls && n[d] === null) ||
        FI(
          s,
          WP(
            n[d],
            d,
            c,
            l,
            r.strictNullHandling,
            r.skipNulls,
            r.encode ? r.encoder : null,
            r.filter,
            r.sort,
            r.allowDots,
            r.serializeDate,
            r.format,
            r.formatter,
            r.encodeValuesOnly,
            r.charset,
            f,
          ),
        );
    }
    var p = s.join(r.delimiter),
      h = r.addQueryPrefix === !0 ? "?" : "";
    return (
      r.charsetSentinel &&
        (r.charset === "iso-8859-1"
          ? (h += "utf8=%26%2310003%3B&")
          : (h += "utf8=%E2%9C%93&")),
      p.length > 0 ? h + p : ""
    );
  },
  Go = BI,
  Kg = Object.prototype.hasOwnProperty,
  VP = Array.isArray,
  qn = {
    allowDots: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decoder: Go.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictNullHandling: !1,
  },
  YP = function (e) {
    return e.replace(/&#(\d+);/g, function (t, n) {
      return String.fromCharCode(parseInt(n, 10));
    });
  },
  jI = function (e, t) {
    return e && typeof e == "string" && t.comma && e.indexOf(",") > -1
      ? e.split(",")
      : e;
  },
  XP = "utf8=%26%2310003%3B",
  JP = "utf8=%E2%9C%93",
  ZP = function (t, n) {
    var r = {},
      i = n.ignoreQueryPrefix ? t.replace(/^\?/, "") : t,
      a = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit,
      s = i.split(n.delimiter, a),
      o = -1,
      c,
      l = n.charset;
    if (n.charsetSentinel)
      for (c = 0; c < s.length; ++c)
        s[c].indexOf("utf8=") === 0 &&
          (s[c] === JP ? (l = "utf-8") : s[c] === XP && (l = "iso-8859-1"),
          (o = c),
          (c = s.length));
    for (c = 0; c < s.length; ++c)
      if (c !== o) {
        var f = s[c],
          u = f.indexOf("]="),
          d = u === -1 ? f.indexOf("=") : u + 1,
          p,
          h;
        d === -1
          ? ((p = n.decoder(f, qn.decoder, l, "key")),
            (h = n.strictNullHandling ? null : ""))
          : ((p = n.decoder(f.slice(0, d), qn.decoder, l, "key")),
            (h = Go.maybeMap(jI(f.slice(d + 1), n), function (m) {
              return n.decoder(m, qn.decoder, l, "value");
            }))),
          h && n.interpretNumericEntities && l === "iso-8859-1" && (h = YP(h)),
          f.indexOf("[]=") > -1 && (h = VP(h) ? [h] : h),
          Kg.call(r, p) ? (r[p] = Go.combine(r[p], h)) : (r[p] = h);
      }
    return r;
  },
  e8 = function (e, t, n, r) {
    for (var i = r ? t : jI(t, n), a = e.length - 1; a >= 0; --a) {
      var s,
        o = e[a];
      if (o === "[]" && n.parseArrays) s = [].concat(i);
      else {
        s = n.plainObjects ? Object.create(null) : {};
        var c =
            o.charAt(0) === "[" && o.charAt(o.length - 1) === "]"
              ? o.slice(1, -1)
              : o,
          l = parseInt(c, 10);
        !n.parseArrays && c === ""
          ? (s = { 0: i })
          : !isNaN(l) &&
            o !== c &&
            String(l) === c &&
            l >= 0 &&
            n.parseArrays &&
            l <= n.arrayLimit
          ? ((s = []), (s[l] = i))
          : c !== "__proto__" && (s[c] = i);
      }
      i = s;
    }
    return i;
  },
  t8 = function (t, n, r, i) {
    if (t) {
      var a = r.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t,
        s = /(\[[^[\]]*])/,
        o = /(\[[^[\]]*])/g,
        c = r.depth > 0 && s.exec(a),
        l = c ? a.slice(0, c.index) : a,
        f = [];
      if (l) {
        if (
          !r.plainObjects &&
          Kg.call(Object.prototype, l) &&
          !r.allowPrototypes
        )
          return;
        f.push(l);
      }
      for (
        var u = 0;
        r.depth > 0 && (c = o.exec(a)) !== null && u < r.depth;

      ) {
        if (
          ((u += 1),
          !r.plainObjects &&
            Kg.call(Object.prototype, c[1].slice(1, -1)) &&
            !r.allowPrototypes)
        )
          return;
        f.push(c[1]);
      }
      return c && f.push("[" + a.slice(c.index) + "]"), e8(f, n, r, i);
    }
  },
  n8 = function (t) {
    if (!t) return qn;
    if (
      t.decoder !== null &&
      t.decoder !== void 0 &&
      typeof t.decoder != "function"
    )
      throw new TypeError("Decoder has to be a function.");
    if (
      typeof t.charset < "u" &&
      t.charset !== "utf-8" &&
      t.charset !== "iso-8859-1"
    )
      throw new TypeError(
        "The charset option must be either utf-8, iso-8859-1, or undefined",
      );
    var n = typeof t.charset > "u" ? qn.charset : t.charset;
    return {
      allowDots: typeof t.allowDots > "u" ? qn.allowDots : !!t.allowDots,
      allowPrototypes:
        typeof t.allowPrototypes == "boolean"
          ? t.allowPrototypes
          : qn.allowPrototypes,
      allowSparse:
        typeof t.allowSparse == "boolean" ? t.allowSparse : qn.allowSparse,
      arrayLimit:
        typeof t.arrayLimit == "number" ? t.arrayLimit : qn.arrayLimit,
      charset: n,
      charsetSentinel:
        typeof t.charsetSentinel == "boolean"
          ? t.charsetSentinel
          : qn.charsetSentinel,
      comma: typeof t.comma == "boolean" ? t.comma : qn.comma,
      decoder: typeof t.decoder == "function" ? t.decoder : qn.decoder,
      delimiter:
        typeof t.delimiter == "string" || Go.isRegExp(t.delimiter)
          ? t.delimiter
          : qn.delimiter,
      depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : qn.depth,
      ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
      interpretNumericEntities:
        typeof t.interpretNumericEntities == "boolean"
          ? t.interpretNumericEntities
          : qn.interpretNumericEntities,
      parameterLimit:
        typeof t.parameterLimit == "number"
          ? t.parameterLimit
          : qn.parameterLimit,
      parseArrays: t.parseArrays !== !1,
      plainObjects:
        typeof t.plainObjects == "boolean" ? t.plainObjects : qn.plainObjects,
      strictNullHandling:
        typeof t.strictNullHandling == "boolean"
          ? t.strictNullHandling
          : qn.strictNullHandling,
    };
  },
  r8 = function (e, t) {
    var n = n8(t);
    if (e === "" || e === null || typeof e > "u")
      return n.plainObjects ? Object.create(null) : {};
    for (
      var r = typeof e == "string" ? ZP(e, n) : e,
        i = n.plainObjects ? Object.create(null) : {},
        a = Object.keys(r),
        s = 0;
      s < a.length;
      ++s
    ) {
      var o = a[s],
        c = t8(o, r[o], n, typeof e == "string");
      i = Go.merge(i, c, n);
    }
    return n.allowSparse === !0 ? i : Go.compact(i);
  },
  i8 = KP,
  a8 = r8,
  s8 = fv,
  dv = { formats: s8, parse: a8, stringify: i8 };
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Th, E_;
function o8() {
  if (E_) return Th;
  E_ = 1;
  var e = qi(),
    t = zs(),
    n = Gi,
    r = ma("body-parser:urlencoded"),
    i = wi("body-parser"),
    a = Gd(),
    s = ga;
  Th = c;
  var o = Object.create(null);
  function c(m) {
    var g = m || {};
    g.extended === void 0 && i("undefined extended: provide extended option");
    var v = g.extended !== !1,
      y = g.inflate !== !1,
      _ = typeof g.limit != "number" ? e.parse(g.limit || "100kb") : g.limit,
      E = g.type || "application/x-www-form-urlencoded",
      R = g.verify || !1;
    if (R !== !1 && typeof R != "function")
      throw new TypeError("option verify must be function");
    var A = v ? l(g) : p(g),
      I = typeof E != "function" ? h(E) : E;
    function S(w) {
      return w.length ? A(w) : {};
    }
    return function (O, Q, j) {
      if (O._body) {
        r("body already parsed"), j();
        return;
      }
      if (((O.body = O.body || {}), !s.hasBody(O))) {
        r("skip empty body"), j();
        return;
      }
      if ((r("content-type %j", O.headers["content-type"]), !I(O))) {
        r("skip parsing"), j();
        return;
      }
      var H = f(O) || "utf-8";
      if (H !== "utf-8") {
        r("invalid charset"),
          j(
            n(415, 'unsupported charset "' + H.toUpperCase() + '"', {
              charset: H,
              type: "charset.unsupported",
            }),
          );
        return;
      }
      a(O, Q, j, S, r, {
        debug: r,
        encoding: H,
        inflate: y,
        limit: _,
        verify: R,
      });
    };
  }
  function l(m) {
    var g = m.parameterLimit !== void 0 ? m.parameterLimit : 1e3,
      v = d("qs");
    if (isNaN(g) || g < 1)
      throw new TypeError("option parameterLimit must be a positive number");
    return (
      isFinite(g) && (g = g | 0),
      function (_) {
        var E = u(_, g);
        if (E === void 0)
          throw (
            (r("too many parameters"),
            n(413, "too many parameters", { type: "parameters.too.many" }))
          );
        var R = Math.max(100, E);
        return (
          r("parse extended urlencoding"),
          v(_, {
            allowPrototypes: !0,
            arrayLimit: R,
            depth: 1 / 0,
            parameterLimit: g,
          })
        );
      }
    );
  }
  function f(m) {
    try {
      return (t.parse(m).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function u(m, g) {
    for (var v = 0, y = 0; (y = m.indexOf("&", y)) !== -1; )
      if ((v++, y++, v === g)) return;
    return v;
  }
  function d(m) {
    var g = o[m];
    if (g !== void 0) return g.parse;
    switch (m) {
      case "qs":
        g = dv;
        break;
      case "querystring":
        g = X0;
        break;
    }
    return (o[m] = g), g.parse;
  }
  function p(m) {
    var g = m.parameterLimit !== void 0 ? m.parameterLimit : 1e3,
      v = d("querystring");
    if (isNaN(g) || g < 1)
      throw new TypeError("option parameterLimit must be a positive number");
    return (
      isFinite(g) && (g = g | 0),
      function (_) {
        var E = u(_, g);
        if (E === void 0)
          throw (
            (r("too many parameters"),
            n(413, "too many parameters", { type: "parameters.too.many" }))
          );
        return r("parse urlencoding"), v(_, void 0, void 0, { maxKeys: g });
      }
    );
  }
  function h(m) {
    return function (v) {
      return !!s(v, m);
    };
  }
  return Th;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e, t) {
  var n = wi("body-parser"),
    r = Object.create(null);
  (t = e.exports =
    n.function(i, "bodyParser: use individual json/urlencoded middlewares")),
    Object.defineProperty(t, "json", {
      configurable: !0,
      enumerable: !0,
      get: a("json"),
    }),
    Object.defineProperty(t, "raw", {
      configurable: !0,
      enumerable: !0,
      get: a("raw"),
    }),
    Object.defineProperty(t, "text", {
      configurable: !0,
      enumerable: !0,
      get: a("text"),
    }),
    Object.defineProperty(t, "urlencoded", {
      configurable: !0,
      enumerable: !0,
      get: a("urlencoded"),
    });
  function i(o) {
    var c = Object.create(o || null, {
        type: { configurable: !0, enumerable: !0, value: void 0, writable: !0 },
      }),
      l = t.urlencoded(c),
      f = t.json(c);
    return function (d, p, h) {
      f(d, p, function (m) {
        if (m) return h(m);
        l(d, p, h);
      });
    };
  }
  function a(o) {
    return function () {
      return s(o);
    };
  }
  function s(o) {
    var c = r[o];
    if (c !== void 0) return c;
    switch (o) {
      case "json":
        c = dO();
        break;
      case "raw":
        c = pO();
        break;
      case "text":
        c = hO();
        break;
      case "urlencoded":
        c = o8();
        break;
    }
    return (r[o] = c);
  }
})(Fg, Fg.exports);
var c8 = Fg.exports;
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var l8 = f8,
  u8 = Object.prototype.hasOwnProperty;
function f8(e, t, n) {
  if (!e) throw new TypeError("argument dest is required");
  if (!t) throw new TypeError("argument src is required");
  return (
    n === void 0 && (n = !0),
    Object.getOwnPropertyNames(t).forEach(function (i) {
      if (!(!n && u8.call(e, i))) {
        var a = Object.getOwnPropertyDescriptor(t, i);
        Object.defineProperty(e, i, a);
      }
    }),
    e
  );
}
var MI = { exports: {} },
  Vg = { exports: {} },
  Hu = { exports: {} },
  qu = { exports: {} },
  Nh,
  w_;
function d8() {
  if (w_) return Nh;
  w_ = 1;
  var e = 1e3,
    t = e * 60,
    n = t * 60,
    r = n * 24,
    i = r * 365.25;
  Nh = function (l, f) {
    f = f || {};
    var u = typeof l;
    if (u === "string" && l.length > 0) return a(l);
    if (u === "number" && isNaN(l) === !1) return f.long ? o(l) : s(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(l),
    );
  };
  function a(l) {
    if (((l = String(l)), !(l.length > 100))) {
      var f =
        /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
          l,
        );
      if (f) {
        var u = parseFloat(f[1]),
          d = (f[2] || "ms").toLowerCase();
        switch (d) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return u * i;
          case "days":
          case "day":
          case "d":
            return u * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return u * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return u * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return u * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return u;
          default:
            return;
        }
      }
    }
  }
  function s(l) {
    return l >= r
      ? Math.round(l / r) + "d"
      : l >= n
      ? Math.round(l / n) + "h"
      : l >= t
      ? Math.round(l / t) + "m"
      : l >= e
      ? Math.round(l / e) + "s"
      : l + "ms";
  }
  function o(l) {
    return (
      c(l, r, "day") ||
      c(l, n, "hour") ||
      c(l, t, "minute") ||
      c(l, e, "second") ||
      l + " ms"
    );
  }
  function c(l, f, u) {
    if (!(l < f))
      return l < f * 1.5
        ? Math.floor(l / f) + " " + u
        : Math.ceil(l / f) + " " + u + "s";
  }
  return Nh;
}
var x_;
function HI() {
  return (
    x_ ||
      ((x_ = 1),
      (function (e, t) {
        (t = e.exports = i.debug = i.default = i),
          (t.coerce = c),
          (t.disable = s),
          (t.enable = a),
          (t.enabled = o),
          (t.humanize = d8()),
          (t.names = []),
          (t.skips = []),
          (t.formatters = {});
        var n;
        function r(l) {
          var f = 0,
            u;
          for (u in l) (f = (f << 5) - f + l.charCodeAt(u)), (f |= 0);
          return t.colors[Math.abs(f) % t.colors.length];
        }
        function i(l) {
          function f() {
            if (f.enabled) {
              var u = f,
                d = +new Date(),
                p = d - (n || d);
              (u.diff = p), (u.prev = n), (u.curr = d), (n = d);
              for (
                var h = new Array(arguments.length), m = 0;
                m < h.length;
                m++
              )
                h[m] = arguments[m];
              (h[0] = t.coerce(h[0])),
                typeof h[0] != "string" && h.unshift("%O");
              var g = 0;
              (h[0] = h[0].replace(/%([a-zA-Z%])/g, function (y, _) {
                if (y === "%%") return y;
                g++;
                var E = t.formatters[_];
                if (typeof E == "function") {
                  var R = h[g];
                  (y = E.call(u, R)), h.splice(g, 1), g--;
                }
                return y;
              })),
                t.formatArgs.call(u, h);
              var v = f.log || t.log || console.log.bind(console);
              v.apply(u, h);
            }
          }
          return (
            (f.namespace = l),
            (f.enabled = t.enabled(l)),
            (f.useColors = t.useColors()),
            (f.color = r(l)),
            typeof t.init == "function" && t.init(f),
            f
          );
        }
        function a(l) {
          t.save(l), (t.names = []), (t.skips = []);
          for (
            var f = (typeof l == "string" ? l : "").split(/[\s,]+/),
              u = f.length,
              d = 0;
            d < u;
            d++
          )
            f[d] &&
              ((l = f[d].replace(/\*/g, ".*?")),
              l[0] === "-"
                ? t.skips.push(new RegExp("^" + l.substr(1) + "$"))
                : t.names.push(new RegExp("^" + l + "$")));
        }
        function s() {
          t.enable("");
        }
        function o(l) {
          var f, u;
          for (f = 0, u = t.skips.length; f < u; f++)
            if (t.skips[f].test(l)) return !1;
          for (f = 0, u = t.names.length; f < u; f++)
            if (t.names[f].test(l)) return !0;
          return !1;
        }
        function c(l) {
          return l instanceof Error ? l.stack || l.message : l;
        }
      })(qu, qu.exports)),
    qu.exports
  );
}
var A_;
function p8() {
  return (
    A_ ||
      ((A_ = 1),
      (function (e, t) {
        (t = e.exports = HI()),
          (t.log = i),
          (t.formatArgs = r),
          (t.save = a),
          (t.load = s),
          (t.useColors = n),
          (t.storage =
            typeof chrome < "u" && typeof chrome.storage < "u"
              ? chrome.storage.local
              : o()),
          (t.colors = [
            "lightseagreen",
            "forestgreen",
            "goldenrod",
            "dodgerblue",
            "darkorchid",
            "crimson",
          ]);
        function n() {
          return typeof window < "u" &&
            window.process &&
            window.process.type === "renderer"
            ? !0
            : (typeof document < "u" &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
                (typeof window < "u" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent
                    .toLowerCase()
                    .match(/applewebkit\/(\d+)/));
        }
        t.formatters.j = function (c) {
          try {
            return JSON.stringify(c);
          } catch (l) {
            return "[UnexpectedJSONParseError]: " + l.message;
          }
        };
        function r(c) {
          var l = this.useColors;
          if (
            ((c[0] =
              (l ? "%c" : "") +
              this.namespace +
              (l ? " %c" : " ") +
              c[0] +
              (l ? "%c " : " ") +
              "+" +
              t.humanize(this.diff)),
            !!l)
          ) {
            var f = "color: " + this.color;
            c.splice(1, 0, f, "color: inherit");
            var u = 0,
              d = 0;
            c[0].replace(/%[a-zA-Z%]/g, function (p) {
              p !== "%%" && (u++, p === "%c" && (d = u));
            }),
              c.splice(d, 0, f);
          }
        }
        function i() {
          return (
            typeof console == "object" &&
            console.log &&
            Function.prototype.apply.call(console.log, console, arguments)
          );
        }
        function a(c) {
          try {
            c == null ? t.storage.removeItem("debug") : (t.storage.debug = c);
          } catch {}
        }
        function s() {
          var c;
          try {
            c = t.storage.debug;
          } catch {}
          return (
            !c &&
              typeof process < "u" &&
              "env" in process &&
              (c = process.env.DEBUG),
            c
          );
        }
        t.enable(s());
        function o() {
          try {
            return window.localStorage;
          } catch {}
        }
      })(Hu, Hu.exports)),
    Hu.exports
  );
}
var Gu = { exports: {} },
  S_;
function h8() {
  return (
    S_ ||
      ((S_ = 1),
      (function (e, t) {
        var n = hc,
          r = wr;
        (t = e.exports = HI()),
          (t.init = d),
          (t.log = c),
          (t.formatArgs = o),
          (t.save = l),
          (t.load = f),
          (t.useColors = s),
          (t.colors = [6, 2, 3, 4, 5, 1]),
          (t.inspectOpts = Object.keys(process.env)
            .filter(function (p) {
              return /^debug_/i.test(p);
            })
            .reduce(function (p, h) {
              var m = h
                  .substring(6)
                  .toLowerCase()
                  .replace(/_([a-z])/g, function (v, y) {
                    return y.toUpperCase();
                  }),
                g = process.env[h];
              return (
                /^(yes|on|true|enabled)$/i.test(g)
                  ? (g = !0)
                  : /^(no|off|false|disabled)$/i.test(g)
                  ? (g = !1)
                  : g === "null"
                  ? (g = null)
                  : (g = Number(g)),
                (p[m] = g),
                p
              );
            }, {}));
        var i = parseInt(process.env.DEBUG_FD, 10) || 2;
        i !== 1 &&
          i !== 2 &&
          r.deprecate(
            function () {},
            "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)",
          )();
        var a = i === 1 ? process.stdout : i === 2 ? process.stderr : u(i);
        function s() {
          return "colors" in t.inspectOpts
            ? !!t.inspectOpts.colors
            : n.isatty(i);
        }
        (t.formatters.o = function (p) {
          return (
            (this.inspectOpts.colors = this.useColors),
            r
              .inspect(p, this.inspectOpts)
              .split(
                `
`,
              )
              .map(function (h) {
                return h.trim();
              })
              .join(" ")
          );
        }),
          (t.formatters.O = function (p) {
            return (
              (this.inspectOpts.colors = this.useColors),
              r.inspect(p, this.inspectOpts)
            );
          });
        function o(p) {
          var h = this.namespace,
            m = this.useColors;
          if (m) {
            var g = this.color,
              v = "  \x1B[3" + g + ";1m" + h + " \x1B[0m";
            (p[0] =
              v +
              p[0]
                .split(
                  `
`,
                )
                .join(
                  `
` + v,
                )),
              p.push("\x1B[3" + g + "m+" + t.humanize(this.diff) + "\x1B[0m");
          } else p[0] = new Date().toUTCString() + " " + h + " " + p[0];
        }
        function c() {
          return a.write(
            r.format.apply(r, arguments) +
              `
`,
          );
        }
        function l(p) {
          p == null ? delete process.env.DEBUG : (process.env.DEBUG = p);
        }
        function f() {
          return process.env.DEBUG;
        }
        function u(p) {
          var h,
            m = process.binding("tty_wrap");
          switch (m.guessHandleType(p)) {
            case "TTY":
              (h = new n.WriteStream(p)),
                (h._type = "tty"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            case "FILE":
              var g = Xt;
              (h = new g.SyncWriteStream(p, { autoClose: !1 })),
                (h._type = "fs");
              break;
            case "PIPE":
            case "TCP":
              var v = ha;
              (h = new v.Socket({ fd: p, readable: !1, writable: !0 })),
                (h.readable = !1),
                (h.read = null),
                (h._type = "pipe"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            default:
              throw new Error("Implement me. Unknown stream file type!");
          }
          return (h.fd = p), (h._isStdio = !0), h;
        }
        function d(p) {
          p.inspectOpts = {};
          for (var h = Object.keys(t.inspectOpts), m = 0; m < h.length; m++)
            p.inspectOpts[h[m]] = t.inspectOpts[h[m]];
        }
        t.enable(f());
      })(Gu, Gu.exports)),
    Gu.exports
  );
}
typeof process < "u" && process.type === "renderer"
  ? (Vg.exports = p8())
  : (Vg.exports = h8());
var m8 = Vg.exports;
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var Qd = b8,
  g8 =
    /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g,
  v8 =
    /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g,
  y8 = "$1�$2";
function b8(e) {
  return String(e).replace(v8, y8).replace(g8, encodeURI);
}
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */ var _8 = /["'&<>]/,
  Wd = E8;
function E8(e) {
  var t = "" + e,
    n = _8.exec(t);
  if (!n) return t;
  var r,
    i = "",
    a = 0,
    s = 0;
  for (a = n.index; a < t.length; a++) {
    switch (t.charCodeAt(a)) {
      case 34:
        r = "&quot;";
        break;
      case 38:
        r = "&amp;";
        break;
      case 39:
        r = "&#39;";
        break;
      case 60:
        r = "&lt;";
        break;
      case 62:
        r = "&gt;";
        break;
      default:
        continue;
    }
    s !== a && (i += t.substring(s, a)), (s = a + 1), (i += r);
  }
  return s !== a ? i + t.substring(s, a) : i;
}
var pv = { exports: {} };
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var qI = Ya,
  I_ = qI.parse,
  id = qI.Url;
pv.exports = GI;
pv.exports.original = w8;
function GI(e) {
  var t = e.url;
  if (t !== void 0) {
    var n = e._parsedUrl;
    return WI(t, n) ? n : ((n = QI(t)), (n._raw = t), (e._parsedUrl = n));
  }
}
function w8(e) {
  var t = e.originalUrl;
  if (typeof t != "string") return GI(e);
  var n = e._parsedOriginalUrl;
  return WI(t, n) ? n : ((n = QI(t)), (n._raw = t), (e._parsedOriginalUrl = n));
}
function QI(e) {
  if (typeof e != "string" || e.charCodeAt(0) !== 47) return I_(e);
  for (var t = e, n = null, r = null, i = 1; i < e.length; i++)
    switch (e.charCodeAt(i)) {
      case 63:
        r === null &&
          ((t = e.substring(0, i)),
          (n = e.substring(i + 1)),
          (r = e.substring(i)));
        break;
      case 9:
      case 10:
      case 12:
      case 13:
      case 32:
      case 35:
      case 160:
      case 65279:
        return I_(e);
    }
  var a = id !== void 0 ? new id() : {};
  return (
    (a.path = e),
    (a.href = e),
    (a.pathname = t),
    r !== null && ((a.query = n), (a.search = r)),
    a
  );
}
function WI(e, t) {
  return (
    typeof t == "object" &&
    t !== null &&
    (id === void 0 || t instanceof id) &&
    t._raw === e
  );
}
var Yl = pv.exports;
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var Oh = m8("finalhandler"),
  x8 = Qd,
  A8 = Wd,
  zI = Kl,
  S8 = Yl,
  KI = Hd,
  I8 = zl,
  $8 = /\x20{2}/g,
  C8 = /\n/g,
  R8 =
    typeof setImmediate == "function"
      ? setImmediate
      : function (e) {
          process.nextTick(e.bind.apply(e, arguments));
        },
  k8 = zI.isFinished;
function T8(e) {
  var t = A8(e).replace(C8, "<br>").replace($8, " &nbsp;");
  return (
    `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Error</title>
</head>
<body>
<pre>` +
    t +
    `</pre>
</body>
</html>
`
  );
}
var N8 = O8;
function O8(e, t, n) {
  var r = n || {},
    i = r.env || process.env.NODE_ENV || "development",
    a = r.onerror;
  return function (s) {
    var o, c, l;
    if (!s && $_(t)) {
      Oh("cannot 404 after headers sent");
      return;
    }
    if (
      (s
        ? ((l = L8(s)),
          l === void 0 ? (l = U8(t)) : (o = P8(s)),
          (c = D8(s, l, i)))
        : ((l = 404), (c = "Cannot " + e.method + " " + x8(B8(e)))),
      Oh("default %s", l),
      s && a && R8(a, s, e, t),
      $_(t))
    ) {
      Oh("cannot %d after headers sent", l), e.socket.destroy();
      return;
    }
    F8(e, t, l, o, c);
  };
}
function P8(e) {
  if (!(!e.headers || typeof e.headers != "object")) {
    for (
      var t = Object.create(null), n = Object.keys(e.headers), r = 0;
      r < n.length;
      r++
    ) {
      var i = n[r];
      t[i] = e.headers[i];
    }
    return t;
  }
}
function D8(e, t, n) {
  var r;
  return (
    n !== "production" &&
      ((r = e.stack),
      !r && typeof e.toString == "function" && (r = e.toString())),
    r || KI.message[t]
  );
}
function L8(e) {
  if (typeof e.status == "number" && e.status >= 400 && e.status < 600)
    return e.status;
  if (
    typeof e.statusCode == "number" &&
    e.statusCode >= 400 &&
    e.statusCode < 600
  )
    return e.statusCode;
}
function B8(e) {
  try {
    return S8.original(e).pathname;
  } catch {
    return "resource";
  }
}
function U8(e) {
  var t = e.statusCode;
  return (typeof t != "number" || t < 400 || t > 599) && (t = 500), t;
}
function $_(e) {
  return typeof e.headersSent != "boolean" ? !!e._header : e.headersSent;
}
function F8(e, t, n, r, i) {
  function a() {
    var s = T8(i);
    if (
      ((t.statusCode = n),
      (t.statusMessage = KI.message[n]),
      t.removeHeader("Content-Encoding"),
      t.removeHeader("Content-Language"),
      t.removeHeader("Content-Range"),
      j8(t, r),
      t.setHeader("Content-Security-Policy", "default-src 'none'"),
      t.setHeader("X-Content-Type-Options", "nosniff"),
      t.setHeader("Content-Type", "text/html; charset=utf-8"),
      t.setHeader("Content-Length", Buffer.byteLength(s, "utf8")),
      e.method === "HEAD")
    ) {
      t.end();
      return;
    }
    t.end(s, "utf8");
  }
  if (k8(e)) {
    a();
    return;
  }
  I8(e), zI(e, a), e.resume();
}
function j8(e, t) {
  if (t)
    for (var n = Object.keys(t), r = 0; r < n.length; r++) {
      var i = n[r];
      e.setHeader(i, t[i]);
    }
}
var VI = { exports: {} },
  zd = M8;
function YI(e, t, n) {
  for (var r = 0; r < e.length; r++) {
    var i = e[r];
    n > 0 && Array.isArray(i) ? YI(i, t, n - 1) : t.push(i);
  }
  return t;
}
function XI(e, t) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    Array.isArray(r) ? XI(r, t) : t.push(r);
  }
  return t;
}
function M8(e, t) {
  return t == null ? XI(e, []) : YI(e, [], t);
}
var H8 = JI,
  C_ = /\((?!\?)/g;
function JI(e, t, n) {
  (n = n || {}), (t = t || []);
  var r = n.strict,
    i = n.end !== !1,
    a = n.sensitive ? "" : "i",
    s = 0,
    o = t.length,
    c = 0,
    l = 0,
    f;
  if (e instanceof RegExp) {
    for (; (f = C_.exec(e.source)); )
      t.push({ name: l++, optional: !1, offset: f.index });
    return e;
  }
  if (Array.isArray(e))
    return (
      (e = e.map(function (p) {
        return JI(p, t, n).source;
      })),
      new RegExp("(?:" + e.join("|") + ")", a)
    );
  for (
    e = ("^" + e + (r ? "" : e[e.length - 1] === "/" ? "?" : "/?"))
      .replace(/\/\(/g, "/(?:")
      .replace(/([\/\.])/g, "\\$1")
      .replace(
        /(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g,
        function (p, h, m, g, v, y, _, E) {
          (h = h || ""),
            (m = m || ""),
            (v = v || "([^\\/" + m + "]+?)"),
            (_ = _ || ""),
            t.push({ name: g, optional: !!_, offset: E + s });
          var R =
            "" +
            (_ ? "" : h) +
            "(?:" +
            m +
            (_ ? h : "") +
            v +
            (y ? "((?:[\\/" + m + "].+?)?)" : "") +
            ")" +
            _;
          return (s += R.length - p.length), R;
        },
      )
      .replace(/\*/g, function (p, h) {
        for (var m = t.length; m-- > o && t[m].offset > h; ) t[m].offset += 3;
        return "(.*)";
      });
    (f = C_.exec(e));

  ) {
    for (var u = 0, d = f.index; e.charAt(--d) === "\\"; ) u++;
    u % 2 !== 1 &&
      ((o + c === t.length || t[o + c].offset > f.index) &&
        t.splice(o + c, 0, { name: l++, optional: !1, offset: f.index }),
      c++);
  }
  return (
    (e += i ? "$" : e[e.length - 1] === "/" ? "" : "(?=\\/|$)"),
    new RegExp(e, a)
  );
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var q8 = H8,
  G8 = ma("express:router:layer"),
  Q8 = Object.prototype.hasOwnProperty,
  ZI = Qo;
function Qo(e, t, n) {
  if (!(this instanceof Qo)) return new Qo(e, t, n);
  G8("new %o", e);
  var r = t || {};
  (this.handle = n),
    (this.name = n.name || "<anonymous>"),
    (this.params = void 0),
    (this.path = void 0),
    (this.regexp = q8(e, (this.keys = []), r)),
    (this.regexp.fast_star = e === "*"),
    (this.regexp.fast_slash = e === "/" && r.end === !1);
}
Qo.prototype.handle_error = function (t, n, r, i) {
  var a = this.handle;
  if (a.length !== 4) return i(t);
  try {
    a(t, n, r, i);
  } catch (s) {
    i(s);
  }
};
Qo.prototype.handle_request = function (t, n, r) {
  var i = this.handle;
  if (i.length > 3) return r();
  try {
    i(t, n, r);
  } catch (a) {
    r(a);
  }
};
Qo.prototype.match = function (t) {
  var n;
  if (t != null) {
    if (this.regexp.fast_slash) return (this.params = {}), (this.path = ""), !0;
    if (this.regexp.fast_star)
      return (this.params = { 0: R_(t) }), (this.path = t), !0;
    n = this.regexp.exec(t);
  }
  if (!n) return (this.params = void 0), (this.path = void 0), !1;
  (this.params = {}), (this.path = n[0]);
  for (var r = this.keys, i = this.params, a = 1; a < n.length; a++) {
    var s = r[a - 1],
      o = s.name,
      c = R_(n[a]);
    (c !== void 0 || !Q8.call(i, o)) && (i[o] = c);
  }
  return !0;
};
function R_(e) {
  if (typeof e != "string" || e.length === 0) return e;
  try {
    return decodeURIComponent(e);
  } catch (t) {
    throw (
      (t instanceof URIError &&
        ((t.message = "Failed to decode param '" + e + "'"),
        (t.status = t.statusCode = 400)),
      t)
    );
  }
}
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var k_ = Ws,
  hv = W8() || z8();
function W8() {
  return (
    k_.METHODS &&
    k_.METHODS.map(function (t) {
      return t.toLowerCase();
    })
  );
}
function z8() {
  return [
    "get",
    "post",
    "put",
    "head",
    "delete",
    "options",
    "trace",
    "copy",
    "lock",
    "mkcol",
    "move",
    "purge",
    "propfind",
    "proppatch",
    "unlock",
    "report",
    "mkactivity",
    "checkout",
    "merge",
    "m-search",
    "notify",
    "subscribe",
    "unsubscribe",
    "patch",
    "search",
    "connect",
  ];
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var e$ = ma("express:router:route"),
  t$ = zd,
  n$ = ZI,
  K8 = hv,
  r$ = Array.prototype.slice,
  i$ = Object.prototype.toString,
  a$ = bc;
function bc(e) {
  (this.path = e), (this.stack = []), e$("new %o", e), (this.methods = {});
}
bc.prototype._handles_method = function (t) {
  if (this.methods._all) return !0;
  var n = t.toLowerCase();
  return n === "head" && !this.methods.head && (n = "get"), !!this.methods[n];
};
bc.prototype._options = function () {
  var t = Object.keys(this.methods);
  this.methods.get && !this.methods.head && t.push("head");
  for (var n = 0; n < t.length; n++) t[n] = t[n].toUpperCase();
  return t;
};
bc.prototype.dispatch = function (t, n, r) {
  var i = 0,
    a = this.stack,
    s = 0;
  if (a.length === 0) return r();
  var o = t.method.toLowerCase();
  o === "head" && !this.methods.head && (o = "get"), (t.route = this), c();
  function c(l) {
    if (l && l === "route") return r();
    if (l && l === "router") return r(l);
    if (++s > 100) return setImmediate(c, l);
    var f = a[i++];
    if (!f) return r(l);
    f.method && f.method !== o
      ? c(l)
      : l
      ? f.handle_error(l, t, n, c)
      : f.handle_request(t, n, c),
      (s = 0);
  }
};
bc.prototype.all = function () {
  for (var t = t$(r$.call(arguments)), n = 0; n < t.length; n++) {
    var r = t[n];
    if (typeof r != "function") {
      var i = i$.call(r),
        a = "Route.all() requires a callback function but got a " + i;
      throw new TypeError(a);
    }
    var s = n$("/", {}, r);
    (s.method = void 0), (this.methods._all = !0), this.stack.push(s);
  }
  return this;
};
K8.forEach(function (e) {
  bc.prototype[e] = function () {
    for (var t = t$(r$.call(arguments)), n = 0; n < t.length; n++) {
      var r = t[n];
      if (typeof r != "function") {
        var i = i$.call(r),
          a = "Route." + e + "() requires a callback function but got a " + i;
        throw new Error(a);
      }
      e$("%s %o", e, this.path);
      var s = n$("/", {}, r);
      (s.method = e), (this.methods[e] = !0), this.stack.push(s);
    }
    return this;
  };
});
var s$ = { exports: {} };
(function (e, t) {
  e.exports = function (n, r) {
    if (n && r) for (var i in r) n[i] = r[i];
    return n;
  };
})(s$);
var Kd = s$.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var V8 = a$,
  o$ = ZI,
  Y8 = hv,
  Ph = Kd,
  Lf = ma("express:router"),
  T_ = wi("express"),
  X8 = zd,
  J8 = Yl,
  Z8 = Md,
  e6 = /^\[object (\S+)\]$/,
  c$ = Array.prototype.slice,
  t6 = Object.prototype.toString,
  Ks = (VI.exports = function (e) {
    var t = e || {};
    function n(r, i, a) {
      n.handle(r, i, a);
    }
    return (
      Z8(n, Ks),
      (n.params = {}),
      (n._params = []),
      (n.caseSensitive = t.caseSensitive),
      (n.mergeParams = t.mergeParams),
      (n.strict = t.strict),
      (n.stack = []),
      n
    );
  });
Ks.param = function (t, n) {
  if (typeof t == "function") {
    T_("router.param(fn): Refactor to use path params"), this._params.push(t);
    return;
  }
  var r = this._params,
    i = r.length,
    a;
  t[0] === ":" &&
    (T_(
      "router.param(" +
        JSON.stringify(t) +
        ", fn): Use router.param(" +
        JSON.stringify(t.slice(1)) +
        ", fn) instead",
    ),
    (t = t.slice(1)));
  for (var s = 0; s < i; ++s) (a = r[s](t, n)) && (n = a);
  if (typeof n != "function")
    throw new Error("invalid param() call for " + t + ", got " + n);
  return (this.params[t] = this.params[t] || []).push(n), this;
};
Ks.handle = function (t, n, r) {
  var i = this;
  Lf("dispatching %s %s", t.method, t.url);
  var a = 0,
    s = i6(t.url) || "",
    o = "",
    c = !1,
    l = 0,
    f = {},
    u = [],
    d = i.stack,
    p = t.params,
    h = t.baseUrl || "",
    m = c6(r, t, "baseUrl", "next", "params");
  (t.next = g),
    t.method === "OPTIONS" &&
      (m = u6(m, function (y, _) {
        if (_ || u.length === 0) return y(_);
        l6(n, u, y);
      })),
    (t.baseUrl = h),
    (t.originalUrl = t.originalUrl || t.url),
    g();
  function g(y) {
    var _ = y === "route" ? null : y;
    if (
      (c && ((t.url = t.url.slice(1)), (c = !1)),
      o.length !== 0 &&
        ((t.baseUrl = h), (t.url = s + o + t.url.slice(s.length)), (o = "")),
      _ === "router")
    ) {
      setImmediate(m, null);
      return;
    }
    if (a >= d.length) {
      setImmediate(m, _);
      return;
    }
    if (++l > 100) return setImmediate(g, y);
    var E = r6(t);
    if (E == null) return m(_);
    for (var R, A, I; A !== !0 && a < d.length; )
      if (
        ((R = d[a++]),
        (A = s6(R, E)),
        (I = R.route),
        typeof A != "boolean" && (_ = _ || A),
        A === !0 && I)
      ) {
        if (_) {
          A = !1;
          continue;
        }
        var S = t.method,
          w = I._handles_method(S);
        !w && S === "OPTIONS" && n6(u, I._options()),
          !w && S !== "HEAD" && (A = !1);
      }
    if (A !== !0) return m(_);
    I && (t.route = I), (t.params = i.mergeParams ? o6(R.params, p) : R.params);
    var O = R.path;
    i.process_params(R, f, t, n, function (Q) {
      Q ? g(_ || Q) : I ? R.handle_request(t, n, g) : v(R, _, O, E), (l = 0);
    });
  }
  function v(y, _, E, R) {
    if (E.length !== 0) {
      if (E !== R.slice(0, E.length)) {
        g(_);
        return;
      }
      var A = R[E.length];
      if (A && A !== "/" && A !== ".") return g(_);
      Lf("trim prefix (%s) from url %s", E, t.url),
        (o = E),
        (t.url = s + t.url.slice(s.length + o.length)),
        !s && t.url[0] !== "/" && ((t.url = "/" + t.url), (c = !0)),
        (t.baseUrl =
          h + (o[o.length - 1] === "/" ? o.substring(0, o.length - 1) : o));
    }
    Lf("%s %s : %s", y.name, E, t.originalUrl),
      _ ? y.handle_error(_, t, n, g) : y.handle_request(t, n, g);
  }
};
Ks.process_params = function (t, n, r, i, a) {
  var s = this.params,
    o = t.keys;
  if (!o || o.length === 0) return a();
  var c = 0,
    l,
    f = 0,
    u,
    d,
    p,
    h;
  function m(v) {
    if (v) return a(v);
    if (c >= o.length) return a();
    if (
      ((f = 0),
      (u = o[c++]),
      (l = u.name),
      (d = r.params[l]),
      (p = s[l]),
      (h = n[l]),
      d === void 0 || !p)
    )
      return m();
    if (h && (h.match === d || (h.error && h.error !== "route")))
      return (r.params[l] = h.value), m(h.error);
    (n[l] = h = { error: null, match: d, value: d }), g();
  }
  function g(v) {
    var y = p[f++];
    if (((h.value = r.params[u.name]), v)) {
      (h.error = v), m(v);
      return;
    }
    if (!y) return m();
    try {
      y(r, i, g, d, u.name);
    } catch (_) {
      g(_);
    }
  }
  m();
};
Ks.use = function (t) {
  var n = 0,
    r = "/";
  if (typeof t != "function") {
    for (var i = t; Array.isArray(i) && i.length !== 0; ) i = i[0];
    typeof i != "function" && ((n = 1), (r = t));
  }
  var a = X8(c$.call(arguments, n));
  if (a.length === 0)
    throw new TypeError("Router.use() requires a middleware function");
  for (var s = 0; s < a.length; s++) {
    var t = a[s];
    if (typeof t != "function")
      throw new TypeError(
        "Router.use() requires a middleware function but got a " + a6(t),
      );
    Lf("use %o %s", r, t.name || "<anonymous>");
    var o = new o$(
      r,
      { sensitive: this.caseSensitive, strict: !1, end: !1 },
      t,
    );
    (o.route = void 0), this.stack.push(o);
  }
  return this;
};
Ks.route = function (t) {
  var n = new V8(t),
    r = new o$(
      t,
      { sensitive: this.caseSensitive, strict: this.strict, end: !0 },
      n.dispatch.bind(n),
    );
  return (r.route = n), this.stack.push(r), n;
};
Y8.concat("all").forEach(function (e) {
  Ks[e] = function (t) {
    var n = this.route(t);
    return n[e].apply(n, c$.call(arguments, 1)), this;
  };
});
function n6(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    e.indexOf(r) === -1 && e.push(r);
  }
}
function r6(e) {
  try {
    return J8(e).pathname;
  } catch {
    return;
  }
}
function i6(e) {
  if (!(typeof e != "string" || e.length === 0 || e[0] === "/")) {
    var t = e.indexOf("?"),
      n = t !== -1 ? t : e.length,
      r = e.slice(0, n).indexOf("://");
    return r !== -1 ? e.substring(0, e.indexOf("/", 3 + r)) : void 0;
  }
}
function a6(e) {
  var t = typeof e;
  return t !== "object" ? t : t6.call(e).replace(e6, "$1");
}
function s6(e, t) {
  try {
    return e.match(t);
  } catch (n) {
    return n;
  }
}
function o6(e, t) {
  if (typeof t != "object" || !t) return e;
  var n = Ph({}, t);
  if (!(0 in e) || !(0 in t)) return Ph(n, e);
  for (var r = 0, i = 0; r in e; ) r++;
  for (; i in t; ) i++;
  for (r--; r >= 0; r--) (e[r + i] = e[r]), r < i && delete e[r];
  return Ph(n, e);
}
function c6(e, t) {
  for (
    var n = new Array(arguments.length - 2),
      r = new Array(arguments.length - 2),
      i = 0;
    i < n.length;
    i++
  )
    (n[i] = arguments[i + 2]), (r[i] = t[n[i]]);
  return function () {
    for (var a = 0; a < n.length; a++) t[n[a]] = r[a];
    return e.apply(this, arguments);
  };
}
function l6(e, t, n) {
  try {
    var r = t.join(",");
    e.set("Allow", r), e.send(r);
  } catch (i) {
    n(i);
  }
}
function u6(e, t) {
  return function () {
    var r = new Array(arguments.length + 1);
    r[0] = e;
    for (var i = 0, a = arguments.length; i < a; i++) r[i + 1] = arguments[i];
    t.apply(this, r);
  };
}
var l$ = VI.exports,
  u$ = {};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var N_ = Md;
u$.init = function (e) {
  return function (n, r, i) {
    e.enabled("x-powered-by") && r.setHeader("X-Powered-By", "Express"),
      (n.res = r),
      (r.req = n),
      (n.next = i),
      N_(n, e.request),
      N_(r, e.response),
      (r.locals = r.locals || Object.create(null)),
      i();
  };
};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var f6 = Kd,
  d6 = Yl,
  p6 = dv,
  f$ = function (t) {
    var n = f6({}, t),
      r = p6.parse;
    return (
      typeof t == "function" && ((r = t), (n = void 0)),
      n !== void 0 && n.allowPrototypes === void 0 && (n.allowPrototypes = !0),
      function (a, s, o) {
        if (!a.query) {
          var c = d6(a).query;
          a.query = r(c, n);
        }
        o();
      }
    );
  };
function d$(e) {
  throw new Error(
    'Could not dynamically require "' +
      e +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.',
  );
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Vd = ma("express:view"),
  Xl = pt,
  h6 = Xt,
  m6 = Xl.dirname,
  p$ = Xl.basename,
  g6 = Xl.extname,
  O_ = Xl.join,
  v6 = Xl.resolve,
  y6 = Yd;
function Yd(e, t) {
  var n = t || {};
  if (
    ((this.defaultEngine = n.defaultEngine),
    (this.ext = g6(e)),
    (this.name = e),
    (this.root = n.root),
    !this.ext && !this.defaultEngine)
  )
    throw new Error(
      "No default engine was specified and no extension was provided.",
    );
  var r = e;
  if (
    (this.ext ||
      ((this.ext =
        this.defaultEngine[0] !== "."
          ? "." + this.defaultEngine
          : this.defaultEngine),
      (r += this.ext)),
    !n.engines[this.ext])
  ) {
    var i = this.ext.slice(1);
    Vd('require "%s"', i);
    var a = d$(i).__express;
    if (typeof a != "function")
      throw new Error('Module "' + i + '" does not provide a view engine.');
    n.engines[this.ext] = a;
  }
  (this.engine = n.engines[this.ext]), (this.path = this.lookup(r));
}
Yd.prototype.lookup = function (t) {
  var n,
    r = [].concat(this.root);
  Vd('lookup "%s"', t);
  for (var i = 0; i < r.length && !n; i++) {
    var a = r[i],
      s = v6(a, t),
      o = m6(s),
      c = p$(s);
    n = this.resolve(o, c);
  }
  return n;
};
Yd.prototype.render = function (t, n) {
  Vd('render "%s"', this.path), this.engine(this.path, t, n);
};
Yd.prototype.resolve = function (t, n) {
  var r = this.ext,
    i = O_(t, n),
    a = P_(i);
  if (
    (a && a.isFile()) ||
    ((i = O_(t, p$(n, r), "index" + r)), (a = P_(i)), a && a.isFile())
  )
    return i;
};
function P_(e) {
  Vd('stat "%s"', e);
  try {
    return h6.statSync(e);
  } catch {
    return;
  }
}
var Ha = {},
  Yg = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ (function (
  e,
  t,
) {
  var n = ks,
    r = n.Buffer;
  function i(s, o) {
    for (var c in s) o[c] = s[c];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow
    ? (e.exports = n)
    : (i(n, t), (t.Buffer = a));
  function a(s, o, c) {
    return r(s, o, c);
  }
  (a.prototype = Object.create(r.prototype)),
    i(r, a),
    (a.from = function (s, o, c) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return r(s, o, c);
    }),
    (a.alloc = function (s, o, c) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var l = r(s);
      return (
        o !== void 0
          ? typeof c == "string"
            ? l.fill(o, c)
            : l.fill(o)
          : l.fill(0),
        l
      );
    }),
    (a.allocUnsafe = function (s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return r(s);
    }),
    (a.allocUnsafeSlow = function (s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return n.SlowBuffer(s);
    });
})(Yg, Yg.exports);
var mv = Yg.exports,
  gv = { exports: {} };
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ gv.exports = R6;
gv.exports.parse = O6;
var D_ = pt.basename,
  b6 = mv.Buffer,
  _6 = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g,
  E6 = /%[0-9A-Fa-f]{2}/,
  w6 = /%([0-9A-Fa-f]{2})/g,
  h$ = /[^\x20-\x7e\xa0-\xff]/g,
  x6 = /\\([\u0000-\u007f])/g,
  A6 = /([\\"])/g,
  L_ =
    /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g,
  S6 = /^[\x20-\x7e\x80-\xff]+$/,
  I6 = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/,
  $6 =
    /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/,
  C6 = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
function R6(e, t) {
  var n = t || {},
    r = n.type || "attachment",
    i = k6(e, n.fallback);
  return T6(new g$(r, i));
}
function k6(e, t) {
  if (e !== void 0) {
    var n = {};
    if (typeof e != "string") throw new TypeError("filename must be a string");
    if (
      (t === void 0 && (t = !0), typeof t != "string" && typeof t != "boolean")
    )
      throw new TypeError("fallback must be a string or boolean");
    if (typeof t == "string" && h$.test(t))
      throw new TypeError("fallback must be ISO-8859-1 string");
    var r = D_(e),
      i = S6.test(r),
      a = typeof t != "string" ? t && m$(r) : D_(t),
      s = typeof a == "string" && a !== r;
    return (
      (s || !i || E6.test(r)) && (n["filename*"] = r),
      (i || s) && (n.filename = s ? a : r),
      n
    );
  }
}
function T6(e) {
  var t = e.parameters,
    n = e.type;
  if (!n || typeof n != "string" || !I6.test(n))
    throw new TypeError("invalid type");
  var r = String(n).toLowerCase();
  if (t && typeof t == "object")
    for (var i, a = Object.keys(t).sort(), s = 0; s < a.length; s++) {
      i = a[s];
      var o = i.substr(-1) === "*" ? B6(t[i]) : L6(t[i]);
      r += "; " + i + "=" + o;
    }
  return r;
}
function N6(e) {
  var t = $6.exec(e);
  if (!t) throw new TypeError("invalid extended field value");
  var n = t[1].toLowerCase(),
    r = t[2],
    i,
    a = r.replace(w6, P6);
  switch (n) {
    case "iso-8859-1":
      i = m$(a);
      break;
    case "utf-8":
      i = b6.from(a, "binary").toString("utf8");
      break;
    default:
      throw new TypeError("unsupported charset in extended field");
  }
  return i;
}
function m$(e) {
  return String(e).replace(h$, "?");
}
function O6(e) {
  if (!e || typeof e != "string")
    throw new TypeError("argument string is required");
  var t = C6.exec(e);
  if (!t) throw new TypeError("invalid type format");
  var n = t[0].length,
    r = t[1].toLowerCase(),
    i,
    a = [],
    s = {},
    o;
  for (
    n = L_.lastIndex = t[0].substr(-1) === ";" ? n - 1 : n;
    (t = L_.exec(e));

  ) {
    if (t.index !== n) throw new TypeError("invalid parameter format");
    if (
      ((n += t[0].length),
      (i = t[1].toLowerCase()),
      (o = t[2]),
      a.indexOf(i) !== -1)
    )
      throw new TypeError("invalid duplicate parameter");
    if ((a.push(i), i.indexOf("*") + 1 === i.length)) {
      (i = i.slice(0, -1)), (o = N6(o)), (s[i] = o);
      continue;
    }
    typeof s[i] != "string" &&
      (o[0] === '"' && (o = o.substr(1, o.length - 2).replace(x6, "$1")),
      (s[i] = o));
  }
  if (n !== -1 && n !== e.length)
    throw new TypeError("invalid parameter format");
  return new g$(r, s);
}
function P6(e, t) {
  return String.fromCharCode(parseInt(t, 16));
}
function D6(e) {
  return "%" + String(e).charCodeAt(0).toString(16).toUpperCase();
}
function L6(e) {
  var t = String(e);
  return '"' + t.replace(A6, "\\$1") + '"';
}
function B6(e) {
  var t = String(e),
    n = encodeURIComponent(t).replace(_6, D6);
  return "UTF-8''" + n;
}
function g$(e, t) {
  (this.type = e), (this.parameters = t);
}
var v$ = gv.exports,
  vv = { exports: {} },
  Xg = { exports: {} },
  Qu = { exports: {} },
  Wu = { exports: {} },
  Dh,
  B_;
function U6() {
  if (B_) return Dh;
  B_ = 1;
  var e = 1e3,
    t = e * 60,
    n = t * 60,
    r = n * 24,
    i = r * 365.25;
  Dh = function (l, f) {
    f = f || {};
    var u = typeof l;
    if (u === "string" && l.length > 0) return a(l);
    if (u === "number" && isNaN(l) === !1) return f.long ? o(l) : s(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(l),
    );
  };
  function a(l) {
    if (((l = String(l)), !(l.length > 100))) {
      var f =
        /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
          l,
        );
      if (f) {
        var u = parseFloat(f[1]),
          d = (f[2] || "ms").toLowerCase();
        switch (d) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return u * i;
          case "days":
          case "day":
          case "d":
            return u * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return u * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return u * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return u * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return u;
          default:
            return;
        }
      }
    }
  }
  function s(l) {
    return l >= r
      ? Math.round(l / r) + "d"
      : l >= n
      ? Math.round(l / n) + "h"
      : l >= t
      ? Math.round(l / t) + "m"
      : l >= e
      ? Math.round(l / e) + "s"
      : l + "ms";
  }
  function o(l) {
    return (
      c(l, r, "day") ||
      c(l, n, "hour") ||
      c(l, t, "minute") ||
      c(l, e, "second") ||
      l + " ms"
    );
  }
  function c(l, f, u) {
    if (!(l < f))
      return l < f * 1.5
        ? Math.floor(l / f) + " " + u
        : Math.ceil(l / f) + " " + u + "s";
  }
  return Dh;
}
var U_;
function y$() {
  return (
    U_ ||
      ((U_ = 1),
      (function (e, t) {
        (t = e.exports = i.debug = i.default = i),
          (t.coerce = c),
          (t.disable = s),
          (t.enable = a),
          (t.enabled = o),
          (t.humanize = U6()),
          (t.names = []),
          (t.skips = []),
          (t.formatters = {});
        var n;
        function r(l) {
          var f = 0,
            u;
          for (u in l) (f = (f << 5) - f + l.charCodeAt(u)), (f |= 0);
          return t.colors[Math.abs(f) % t.colors.length];
        }
        function i(l) {
          function f() {
            if (f.enabled) {
              var u = f,
                d = +new Date(),
                p = d - (n || d);
              (u.diff = p), (u.prev = n), (u.curr = d), (n = d);
              for (
                var h = new Array(arguments.length), m = 0;
                m < h.length;
                m++
              )
                h[m] = arguments[m];
              (h[0] = t.coerce(h[0])),
                typeof h[0] != "string" && h.unshift("%O");
              var g = 0;
              (h[0] = h[0].replace(/%([a-zA-Z%])/g, function (y, _) {
                if (y === "%%") return y;
                g++;
                var E = t.formatters[_];
                if (typeof E == "function") {
                  var R = h[g];
                  (y = E.call(u, R)), h.splice(g, 1), g--;
                }
                return y;
              })),
                t.formatArgs.call(u, h);
              var v = f.log || t.log || console.log.bind(console);
              v.apply(u, h);
            }
          }
          return (
            (f.namespace = l),
            (f.enabled = t.enabled(l)),
            (f.useColors = t.useColors()),
            (f.color = r(l)),
            typeof t.init == "function" && t.init(f),
            f
          );
        }
        function a(l) {
          t.save(l), (t.names = []), (t.skips = []);
          for (
            var f = (typeof l == "string" ? l : "").split(/[\s,]+/),
              u = f.length,
              d = 0;
            d < u;
            d++
          )
            f[d] &&
              ((l = f[d].replace(/\*/g, ".*?")),
              l[0] === "-"
                ? t.skips.push(new RegExp("^" + l.substr(1) + "$"))
                : t.names.push(new RegExp("^" + l + "$")));
        }
        function s() {
          t.enable("");
        }
        function o(l) {
          var f, u;
          for (f = 0, u = t.skips.length; f < u; f++)
            if (t.skips[f].test(l)) return !1;
          for (f = 0, u = t.names.length; f < u; f++)
            if (t.names[f].test(l)) return !0;
          return !1;
        }
        function c(l) {
          return l instanceof Error ? l.stack || l.message : l;
        }
      })(Wu, Wu.exports)),
    Wu.exports
  );
}
var F_;
function F6() {
  return (
    F_ ||
      ((F_ = 1),
      (function (e, t) {
        (t = e.exports = y$()),
          (t.log = i),
          (t.formatArgs = r),
          (t.save = a),
          (t.load = s),
          (t.useColors = n),
          (t.storage =
            typeof chrome < "u" && typeof chrome.storage < "u"
              ? chrome.storage.local
              : o()),
          (t.colors = [
            "lightseagreen",
            "forestgreen",
            "goldenrod",
            "dodgerblue",
            "darkorchid",
            "crimson",
          ]);
        function n() {
          return typeof window < "u" &&
            window.process &&
            window.process.type === "renderer"
            ? !0
            : (typeof document < "u" &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
                (typeof window < "u" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent
                    .toLowerCase()
                    .match(/applewebkit\/(\d+)/));
        }
        t.formatters.j = function (c) {
          try {
            return JSON.stringify(c);
          } catch (l) {
            return "[UnexpectedJSONParseError]: " + l.message;
          }
        };
        function r(c) {
          var l = this.useColors;
          if (
            ((c[0] =
              (l ? "%c" : "") +
              this.namespace +
              (l ? " %c" : " ") +
              c[0] +
              (l ? "%c " : " ") +
              "+" +
              t.humanize(this.diff)),
            !!l)
          ) {
            var f = "color: " + this.color;
            c.splice(1, 0, f, "color: inherit");
            var u = 0,
              d = 0;
            c[0].replace(/%[a-zA-Z%]/g, function (p) {
              p !== "%%" && (u++, p === "%c" && (d = u));
            }),
              c.splice(d, 0, f);
          }
        }
        function i() {
          return (
            typeof console == "object" &&
            console.log &&
            Function.prototype.apply.call(console.log, console, arguments)
          );
        }
        function a(c) {
          try {
            c == null ? t.storage.removeItem("debug") : (t.storage.debug = c);
          } catch {}
        }
        function s() {
          var c;
          try {
            c = t.storage.debug;
          } catch {}
          return (
            !c &&
              typeof process < "u" &&
              "env" in process &&
              (c = process.env.DEBUG),
            c
          );
        }
        t.enable(s());
        function o() {
          try {
            return window.localStorage;
          } catch {}
        }
      })(Qu, Qu.exports)),
    Qu.exports
  );
}
var zu = { exports: {} },
  j_;
function j6() {
  return (
    j_ ||
      ((j_ = 1),
      (function (e, t) {
        var n = hc,
          r = wr;
        (t = e.exports = y$()),
          (t.init = d),
          (t.log = c),
          (t.formatArgs = o),
          (t.save = l),
          (t.load = f),
          (t.useColors = s),
          (t.colors = [6, 2, 3, 4, 5, 1]),
          (t.inspectOpts = Object.keys(process.env)
            .filter(function (p) {
              return /^debug_/i.test(p);
            })
            .reduce(function (p, h) {
              var m = h
                  .substring(6)
                  .toLowerCase()
                  .replace(/_([a-z])/g, function (v, y) {
                    return y.toUpperCase();
                  }),
                g = process.env[h];
              return (
                /^(yes|on|true|enabled)$/i.test(g)
                  ? (g = !0)
                  : /^(no|off|false|disabled)$/i.test(g)
                  ? (g = !1)
                  : g === "null"
                  ? (g = null)
                  : (g = Number(g)),
                (p[m] = g),
                p
              );
            }, {}));
        var i = parseInt(process.env.DEBUG_FD, 10) || 2;
        i !== 1 &&
          i !== 2 &&
          r.deprecate(
            function () {},
            "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)",
          )();
        var a = i === 1 ? process.stdout : i === 2 ? process.stderr : u(i);
        function s() {
          return "colors" in t.inspectOpts
            ? !!t.inspectOpts.colors
            : n.isatty(i);
        }
        (t.formatters.o = function (p) {
          return (
            (this.inspectOpts.colors = this.useColors),
            r
              .inspect(p, this.inspectOpts)
              .split(
                `
`,
              )
              .map(function (h) {
                return h.trim();
              })
              .join(" ")
          );
        }),
          (t.formatters.O = function (p) {
            return (
              (this.inspectOpts.colors = this.useColors),
              r.inspect(p, this.inspectOpts)
            );
          });
        function o(p) {
          var h = this.namespace,
            m = this.useColors;
          if (m) {
            var g = this.color,
              v = "  \x1B[3" + g + ";1m" + h + " \x1B[0m";
            (p[0] =
              v +
              p[0]
                .split(
                  `
`,
                )
                .join(
                  `
` + v,
                )),
              p.push("\x1B[3" + g + "m+" + t.humanize(this.diff) + "\x1B[0m");
          } else p[0] = new Date().toUTCString() + " " + h + " " + p[0];
        }
        function c() {
          return a.write(
            r.format.apply(r, arguments) +
              `
`,
          );
        }
        function l(p) {
          p == null ? delete process.env.DEBUG : (process.env.DEBUG = p);
        }
        function f() {
          return process.env.DEBUG;
        }
        function u(p) {
          var h,
            m = process.binding("tty_wrap");
          switch (m.guessHandleType(p)) {
            case "TTY":
              (h = new n.WriteStream(p)),
                (h._type = "tty"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            case "FILE":
              var g = Xt;
              (h = new g.SyncWriteStream(p, { autoClose: !1 })),
                (h._type = "fs");
              break;
            case "PIPE":
            case "TCP":
              var v = ha;
              (h = new v.Socket({ fd: p, readable: !1, writable: !0 })),
                (h.readable = !1),
                (h.read = null),
                (h._type = "pipe"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            default:
              throw new Error("Implement me. Unknown stream file type!");
          }
          return (h.fd = p), (h._isStdio = !0), h;
        }
        function d(p) {
          p.inspectOpts = {};
          for (var h = Object.keys(t.inspectOpts), m = 0; m < h.length; m++)
            p.inspectOpts[h[m]] = t.inspectOpts[h[m]];
        }
        t.enable(f());
      })(zu, zu.exports)),
    zu.exports
  );
}
typeof process < "u" && process.type === "renderer"
  ? (Xg.exports = F6())
  : (Xg.exports = j6());
var M6 = Xg.exports;
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var b$ = G6,
  H6 = pr,
  M_ = Xt.Stats,
  H_ = Object.prototype.toString;
function q6(e) {
  if (e.length === 0) return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
  var t = H6.createHash("sha1")
      .update(e, "utf8")
      .digest("base64")
      .substring(0, 27),
    n = typeof e == "string" ? Buffer.byteLength(e, "utf8") : e.length;
  return '"' + n.toString(16) + "-" + t + '"';
}
function G6(e, t) {
  if (e == null) throw new TypeError("argument entity is required");
  var n = Q6(e),
    r = t && typeof t.weak == "boolean" ? t.weak : n;
  if (!n && typeof e != "string" && !Buffer.isBuffer(e))
    throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
  var i = n ? W6(e) : q6(e);
  return r ? "W/" + i : i;
}
function Q6(e) {
  return typeof M_ == "function" && e instanceof M_
    ? !0
    : e &&
        typeof e == "object" &&
        "ctime" in e &&
        H_.call(e.ctime) === "[object Date]" &&
        "mtime" in e &&
        H_.call(e.mtime) === "[object Date]" &&
        "ino" in e &&
        typeof e.ino == "number" &&
        "size" in e &&
        typeof e.size == "number";
}
function W6(e) {
  var t = e.mtime.getTime().toString(16),
    n = e.size.toString(16);
  return '"' + n + "-" + t + '"';
}
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var z6 = /(?:^|,)\s*?no-cache\s*?(?:,|$)/,
  _$ = K6;
function K6(e, t) {
  var n = e["if-modified-since"],
    r = e["if-none-match"];
  if (!n && !r) return !1;
  var i = e["cache-control"];
  if (i && z6.test(i)) return !1;
  if (r && r !== "*") {
    var a = t.etag;
    if (!a) return !1;
    for (var s = !0, o = V6(r), c = 0; c < o.length; c++) {
      var l = o[c];
      if (l === a || l === "W/" + a || "W/" + l === a) {
        s = !1;
        break;
      }
    }
    if (s) return !1;
  }
  if (n) {
    var f = t["last-modified"],
      u = !f || !(q_(f) <= q_(n));
    if (u) return !1;
  }
  return !0;
}
function q_(e) {
  var t = e && Date.parse(e);
  return typeof t == "number" ? t : NaN;
}
function V6(e) {
  for (var t = 0, n = [], r = 0, i = 0, a = e.length; i < a; i++)
    switch (e.charCodeAt(i)) {
      case 32:
        r === t && (r = t = i + 1);
        break;
      case 44:
        n.push(e.substring(r, t)), (r = t = i + 1);
        break;
      default:
        t = i + 1;
        break;
    }
  return n.push(e.substring(r, t)), n;
}
const Y6 = {
  "application/andrew-inset": ["ez"],
  "application/applixware": ["aw"],
  "application/atom+xml": ["atom"],
  "application/atomcat+xml": ["atomcat"],
  "application/atomsvc+xml": ["atomsvc"],
  "application/bdoc": ["bdoc"],
  "application/ccxml+xml": ["ccxml"],
  "application/cdmi-capability": ["cdmia"],
  "application/cdmi-container": ["cdmic"],
  "application/cdmi-domain": ["cdmid"],
  "application/cdmi-object": ["cdmio"],
  "application/cdmi-queue": ["cdmiq"],
  "application/cu-seeme": ["cu"],
  "application/dash+xml": ["mpd"],
  "application/davmount+xml": ["davmount"],
  "application/docbook+xml": ["dbk"],
  "application/dssc+der": ["dssc"],
  "application/dssc+xml": ["xdssc"],
  "application/ecmascript": ["ecma"],
  "application/emma+xml": ["emma"],
  "application/epub+zip": ["epub"],
  "application/exi": ["exi"],
  "application/font-tdpfr": ["pfr"],
  "application/font-woff": [],
  "application/font-woff2": [],
  "application/geo+json": ["geojson"],
  "application/gml+xml": ["gml"],
  "application/gpx+xml": ["gpx"],
  "application/gxf": ["gxf"],
  "application/gzip": ["gz"],
  "application/hyperstudio": ["stk"],
  "application/inkml+xml": ["ink", "inkml"],
  "application/ipfix": ["ipfix"],
  "application/java-archive": ["jar", "war", "ear"],
  "application/java-serialized-object": ["ser"],
  "application/java-vm": ["class"],
  "application/javascript": ["js", "mjs"],
  "application/json": ["json", "map"],
  "application/json5": ["json5"],
  "application/jsonml+json": ["jsonml"],
  "application/ld+json": ["jsonld"],
  "application/lost+xml": ["lostxml"],
  "application/mac-binhex40": ["hqx"],
  "application/mac-compactpro": ["cpt"],
  "application/mads+xml": ["mads"],
  "application/manifest+json": ["webmanifest"],
  "application/marc": ["mrc"],
  "application/marcxml+xml": ["mrcx"],
  "application/mathematica": ["ma", "nb", "mb"],
  "application/mathml+xml": ["mathml"],
  "application/mbox": ["mbox"],
  "application/mediaservercontrol+xml": ["mscml"],
  "application/metalink+xml": ["metalink"],
  "application/metalink4+xml": ["meta4"],
  "application/mets+xml": ["mets"],
  "application/mods+xml": ["mods"],
  "application/mp21": ["m21", "mp21"],
  "application/mp4": ["mp4s", "m4p"],
  "application/msword": ["doc", "dot"],
  "application/mxf": ["mxf"],
  "application/octet-stream": [
    "bin",
    "dms",
    "lrf",
    "mar",
    "so",
    "dist",
    "distz",
    "pkg",
    "bpk",
    "dump",
    "elc",
    "deploy",
    "exe",
    "dll",
    "deb",
    "dmg",
    "iso",
    "img",
    "msi",
    "msp",
    "msm",
    "buffer",
  ],
  "application/oda": ["oda"],
  "application/oebps-package+xml": ["opf"],
  "application/ogg": ["ogx"],
  "application/omdoc+xml": ["omdoc"],
  "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
  "application/oxps": ["oxps"],
  "application/patch-ops-error+xml": ["xer"],
  "application/pdf": ["pdf"],
  "application/pgp-encrypted": ["pgp"],
  "application/pgp-signature": ["asc", "sig"],
  "application/pics-rules": ["prf"],
  "application/pkcs10": ["p10"],
  "application/pkcs7-mime": ["p7m", "p7c"],
  "application/pkcs7-signature": ["p7s"],
  "application/pkcs8": ["p8"],
  "application/pkix-attr-cert": ["ac"],
  "application/pkix-cert": ["cer"],
  "application/pkix-crl": ["crl"],
  "application/pkix-pkipath": ["pkipath"],
  "application/pkixcmp": ["pki"],
  "application/pls+xml": ["pls"],
  "application/postscript": ["ai", "eps", "ps"],
  "application/prs.cww": ["cww"],
  "application/pskc+xml": ["pskcxml"],
  "application/raml+yaml": ["raml"],
  "application/rdf+xml": ["rdf"],
  "application/reginfo+xml": ["rif"],
  "application/relax-ng-compact-syntax": ["rnc"],
  "application/resource-lists+xml": ["rl"],
  "application/resource-lists-diff+xml": ["rld"],
  "application/rls-services+xml": ["rs"],
  "application/rpki-ghostbusters": ["gbr"],
  "application/rpki-manifest": ["mft"],
  "application/rpki-roa": ["roa"],
  "application/rsd+xml": ["rsd"],
  "application/rss+xml": ["rss"],
  "application/rtf": ["rtf"],
  "application/sbml+xml": ["sbml"],
  "application/scvp-cv-request": ["scq"],
  "application/scvp-cv-response": ["scs"],
  "application/scvp-vp-request": ["spq"],
  "application/scvp-vp-response": ["spp"],
  "application/sdp": ["sdp"],
  "application/set-payment-initiation": ["setpay"],
  "application/set-registration-initiation": ["setreg"],
  "application/shf+xml": ["shf"],
  "application/smil+xml": ["smi", "smil"],
  "application/sparql-query": ["rq"],
  "application/sparql-results+xml": ["srx"],
  "application/srgs": ["gram"],
  "application/srgs+xml": ["grxml"],
  "application/sru+xml": ["sru"],
  "application/ssdl+xml": ["ssdl"],
  "application/ssml+xml": ["ssml"],
  "application/tei+xml": ["tei", "teicorpus"],
  "application/thraud+xml": ["tfi"],
  "application/timestamped-data": ["tsd"],
  "application/vnd.3gpp.pic-bw-large": ["plb"],
  "application/vnd.3gpp.pic-bw-small": ["psb"],
  "application/vnd.3gpp.pic-bw-var": ["pvb"],
  "application/vnd.3gpp2.tcap": ["tcap"],
  "application/vnd.3m.post-it-notes": ["pwn"],
  "application/vnd.accpac.simply.aso": ["aso"],
  "application/vnd.accpac.simply.imp": ["imp"],
  "application/vnd.acucobol": ["acu"],
  "application/vnd.acucorp": ["atc", "acutc"],
  "application/vnd.adobe.air-application-installer-package+zip": ["air"],
  "application/vnd.adobe.formscentral.fcdt": ["fcdt"],
  "application/vnd.adobe.fxp": ["fxp", "fxpl"],
  "application/vnd.adobe.xdp+xml": ["xdp"],
  "application/vnd.adobe.xfdf": ["xfdf"],
  "application/vnd.ahead.space": ["ahead"],
  "application/vnd.airzip.filesecure.azf": ["azf"],
  "application/vnd.airzip.filesecure.azs": ["azs"],
  "application/vnd.amazon.ebook": ["azw"],
  "application/vnd.americandynamics.acc": ["acc"],
  "application/vnd.amiga.ami": ["ami"],
  "application/vnd.android.package-archive": ["apk"],
  "application/vnd.anser-web-certificate-issue-initiation": ["cii"],
  "application/vnd.anser-web-funds-transfer-initiation": ["fti"],
  "application/vnd.antix.game-component": ["atx"],
  "application/vnd.apple.installer+xml": ["mpkg"],
  "application/vnd.apple.mpegurl": ["m3u8"],
  "application/vnd.apple.pkpass": ["pkpass"],
  "application/vnd.aristanetworks.swi": ["swi"],
  "application/vnd.astraea-software.iota": ["iota"],
  "application/vnd.audiograph": ["aep"],
  "application/vnd.blueice.multipass": ["mpm"],
  "application/vnd.bmi": ["bmi"],
  "application/vnd.businessobjects": ["rep"],
  "application/vnd.chemdraw+xml": ["cdxml"],
  "application/vnd.chipnuts.karaoke-mmd": ["mmd"],
  "application/vnd.cinderella": ["cdy"],
  "application/vnd.claymore": ["cla"],
  "application/vnd.cloanto.rp9": ["rp9"],
  "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"],
  "application/vnd.cluetrust.cartomobile-config": ["c11amc"],
  "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
  "application/vnd.commonspace": ["csp"],
  "application/vnd.contact.cmsg": ["cdbcmsg"],
  "application/vnd.cosmocaller": ["cmc"],
  "application/vnd.crick.clicker": ["clkx"],
  "application/vnd.crick.clicker.keyboard": ["clkk"],
  "application/vnd.crick.clicker.palette": ["clkp"],
  "application/vnd.crick.clicker.template": ["clkt"],
  "application/vnd.crick.clicker.wordbank": ["clkw"],
  "application/vnd.criticaltools.wbs+xml": ["wbs"],
  "application/vnd.ctc-posml": ["pml"],
  "application/vnd.cups-ppd": ["ppd"],
  "application/vnd.curl.car": ["car"],
  "application/vnd.curl.pcurl": ["pcurl"],
  "application/vnd.dart": ["dart"],
  "application/vnd.data-vision.rdz": ["rdz"],
  "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"],
  "application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
  "application/vnd.dece.unspecified": ["uvx", "uvvx"],
  "application/vnd.dece.zip": ["uvz", "uvvz"],
  "application/vnd.denovo.fcselayout-link": ["fe_launch"],
  "application/vnd.dna": ["dna"],
  "application/vnd.dolby.mlp": ["mlp"],
  "application/vnd.dpgraph": ["dpg"],
  "application/vnd.dreamfactory": ["dfac"],
  "application/vnd.ds-keypoint": ["kpxx"],
  "application/vnd.dvb.ait": ["ait"],
  "application/vnd.dvb.service": ["svc"],
  "application/vnd.dynageo": ["geo"],
  "application/vnd.ecowin.chart": ["mag"],
  "application/vnd.enliven": ["nml"],
  "application/vnd.epson.esf": ["esf"],
  "application/vnd.epson.msf": ["msf"],
  "application/vnd.epson.quickanime": ["qam"],
  "application/vnd.epson.salt": ["slt"],
  "application/vnd.epson.ssf": ["ssf"],
  "application/vnd.eszigno3+xml": ["es3", "et3"],
  "application/vnd.ezpix-album": ["ez2"],
  "application/vnd.ezpix-package": ["ez3"],
  "application/vnd.fdf": ["fdf"],
  "application/vnd.fdsn.mseed": ["mseed"],
  "application/vnd.fdsn.seed": ["seed", "dataless"],
  "application/vnd.flographit": ["gph"],
  "application/vnd.fluxtime.clip": ["ftc"],
  "application/vnd.framemaker": ["fm", "frame", "maker", "book"],
  "application/vnd.frogans.fnc": ["fnc"],
  "application/vnd.frogans.ltf": ["ltf"],
  "application/vnd.fsc.weblaunch": ["fsc"],
  "application/vnd.fujitsu.oasys": ["oas"],
  "application/vnd.fujitsu.oasys2": ["oa2"],
  "application/vnd.fujitsu.oasys3": ["oa3"],
  "application/vnd.fujitsu.oasysgp": ["fg5"],
  "application/vnd.fujitsu.oasysprs": ["bh2"],
  "application/vnd.fujixerox.ddd": ["ddd"],
  "application/vnd.fujixerox.docuworks": ["xdw"],
  "application/vnd.fujixerox.docuworks.binder": ["xbd"],
  "application/vnd.fuzzysheet": ["fzs"],
  "application/vnd.genomatix.tuxedo": ["txd"],
  "application/vnd.geogebra.file": ["ggb"],
  "application/vnd.geogebra.tool": ["ggt"],
  "application/vnd.geometry-explorer": ["gex", "gre"],
  "application/vnd.geonext": ["gxt"],
  "application/vnd.geoplan": ["g2w"],
  "application/vnd.geospace": ["g3w"],
  "application/vnd.gmx": ["gmx"],
  "application/vnd.google-apps.document": ["gdoc"],
  "application/vnd.google-apps.presentation": ["gslides"],
  "application/vnd.google-apps.spreadsheet": ["gsheet"],
  "application/vnd.google-earth.kml+xml": ["kml"],
  "application/vnd.google-earth.kmz": ["kmz"],
  "application/vnd.grafeq": ["gqf", "gqs"],
  "application/vnd.groove-account": ["gac"],
  "application/vnd.groove-help": ["ghf"],
  "application/vnd.groove-identity-message": ["gim"],
  "application/vnd.groove-injector": ["grv"],
  "application/vnd.groove-tool-message": ["gtm"],
  "application/vnd.groove-tool-template": ["tpl"],
  "application/vnd.groove-vcard": ["vcg"],
  "application/vnd.hal+xml": ["hal"],
  "application/vnd.handheld-entertainment+xml": ["zmm"],
  "application/vnd.hbci": ["hbci"],
  "application/vnd.hhe.lesson-player": ["les"],
  "application/vnd.hp-hpgl": ["hpgl"],
  "application/vnd.hp-hpid": ["hpid"],
  "application/vnd.hp-hps": ["hps"],
  "application/vnd.hp-jlyt": ["jlt"],
  "application/vnd.hp-pcl": ["pcl"],
  "application/vnd.hp-pclxl": ["pclxl"],
  "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"],
  "application/vnd.ibm.minipay": ["mpy"],
  "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"],
  "application/vnd.ibm.rights-management": ["irm"],
  "application/vnd.ibm.secure-container": ["sc"],
  "application/vnd.iccprofile": ["icc", "icm"],
  "application/vnd.igloader": ["igl"],
  "application/vnd.immervision-ivp": ["ivp"],
  "application/vnd.immervision-ivu": ["ivu"],
  "application/vnd.insors.igm": ["igm"],
  "application/vnd.intercon.formnet": ["xpw", "xpx"],
  "application/vnd.intergeo": ["i2g"],
  "application/vnd.intu.qbo": ["qbo"],
  "application/vnd.intu.qfx": ["qfx"],
  "application/vnd.ipunplugged.rcprofile": ["rcprofile"],
  "application/vnd.irepository.package+xml": ["irp"],
  "application/vnd.is-xpr": ["xpr"],
  "application/vnd.isac.fcs": ["fcs"],
  "application/vnd.jam": ["jam"],
  "application/vnd.jcp.javame.midlet-rms": ["rms"],
  "application/vnd.jisp": ["jisp"],
  "application/vnd.joost.joda-archive": ["joda"],
  "application/vnd.kahootz": ["ktz", "ktr"],
  "application/vnd.kde.karbon": ["karbon"],
  "application/vnd.kde.kchart": ["chrt"],
  "application/vnd.kde.kformula": ["kfo"],
  "application/vnd.kde.kivio": ["flw"],
  "application/vnd.kde.kontour": ["kon"],
  "application/vnd.kde.kpresenter": ["kpr", "kpt"],
  "application/vnd.kde.kspread": ["ksp"],
  "application/vnd.kde.kword": ["kwd", "kwt"],
  "application/vnd.kenameaapp": ["htke"],
  "application/vnd.kidspiration": ["kia"],
  "application/vnd.kinar": ["kne", "knp"],
  "application/vnd.koan": ["skp", "skd", "skt", "skm"],
  "application/vnd.kodak-descriptor": ["sse"],
  "application/vnd.las.las+xml": ["lasxml"],
  "application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
  "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
  "application/vnd.lotus-1-2-3": ["123"],
  "application/vnd.lotus-approach": ["apr"],
  "application/vnd.lotus-freelance": ["pre"],
  "application/vnd.lotus-notes": ["nsf"],
  "application/vnd.lotus-organizer": ["org"],
  "application/vnd.lotus-screencam": ["scm"],
  "application/vnd.lotus-wordpro": ["lwp"],
  "application/vnd.macports.portpkg": ["portpkg"],
  "application/vnd.mcd": ["mcd"],
  "application/vnd.medcalcdata": ["mc1"],
  "application/vnd.mediastation.cdkey": ["cdkey"],
  "application/vnd.mfer": ["mwf"],
  "application/vnd.mfmp": ["mfm"],
  "application/vnd.micrografx.flo": ["flo"],
  "application/vnd.micrografx.igx": ["igx"],
  "application/vnd.mif": ["mif"],
  "application/vnd.mobius.daf": ["daf"],
  "application/vnd.mobius.dis": ["dis"],
  "application/vnd.mobius.mbk": ["mbk"],
  "application/vnd.mobius.mqy": ["mqy"],
  "application/vnd.mobius.msl": ["msl"],
  "application/vnd.mobius.plc": ["plc"],
  "application/vnd.mobius.txf": ["txf"],
  "application/vnd.mophun.application": ["mpn"],
  "application/vnd.mophun.certificate": ["mpc"],
  "application/vnd.mozilla.xul+xml": ["xul"],
  "application/vnd.ms-artgalry": ["cil"],
  "application/vnd.ms-cab-compressed": ["cab"],
  "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
  "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
  "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
  "application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
  "application/vnd.ms-fontobject": ["eot"],
  "application/vnd.ms-htmlhelp": ["chm"],
  "application/vnd.ms-ims": ["ims"],
  "application/vnd.ms-lrm": ["lrm"],
  "application/vnd.ms-officetheme": ["thmx"],
  "application/vnd.ms-outlook": ["msg"],
  "application/vnd.ms-pki.seccat": ["cat"],
  "application/vnd.ms-pki.stl": ["stl"],
  "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"],
  "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
  "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
  "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
  "application/vnd.ms-project": ["mpp", "mpt"],
  "application/vnd.ms-word.document.macroenabled.12": ["docm"],
  "application/vnd.ms-word.template.macroenabled.12": ["dotm"],
  "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"],
  "application/vnd.ms-wpl": ["wpl"],
  "application/vnd.ms-xpsdocument": ["xps"],
  "application/vnd.mseq": ["mseq"],
  "application/vnd.musician": ["mus"],
  "application/vnd.muvee.style": ["msty"],
  "application/vnd.mynfc": ["taglet"],
  "application/vnd.neurolanguage.nlu": ["nlu"],
  "application/vnd.nitf": ["ntf", "nitf"],
  "application/vnd.noblenet-directory": ["nnd"],
  "application/vnd.noblenet-sealer": ["nns"],
  "application/vnd.noblenet-web": ["nnw"],
  "application/vnd.nokia.n-gage.data": ["ngdat"],
  "application/vnd.nokia.n-gage.symbian.install": ["n-gage"],
  "application/vnd.nokia.radio-preset": ["rpst"],
  "application/vnd.nokia.radio-presets": ["rpss"],
  "application/vnd.novadigm.edm": ["edm"],
  "application/vnd.novadigm.edx": ["edx"],
  "application/vnd.novadigm.ext": ["ext"],
  "application/vnd.oasis.opendocument.chart": ["odc"],
  "application/vnd.oasis.opendocument.chart-template": ["otc"],
  "application/vnd.oasis.opendocument.database": ["odb"],
  "application/vnd.oasis.opendocument.formula": ["odf"],
  "application/vnd.oasis.opendocument.formula-template": ["odft"],
  "application/vnd.oasis.opendocument.graphics": ["odg"],
  "application/vnd.oasis.opendocument.graphics-template": ["otg"],
  "application/vnd.oasis.opendocument.image": ["odi"],
  "application/vnd.oasis.opendocument.image-template": ["oti"],
  "application/vnd.oasis.opendocument.presentation": ["odp"],
  "application/vnd.oasis.opendocument.presentation-template": ["otp"],
  "application/vnd.oasis.opendocument.spreadsheet": ["ods"],
  "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
  "application/vnd.oasis.opendocument.text": ["odt"],
  "application/vnd.oasis.opendocument.text-master": ["odm"],
  "application/vnd.oasis.opendocument.text-template": ["ott"],
  "application/vnd.oasis.opendocument.text-web": ["oth"],
  "application/vnd.olpc-sugar": ["xo"],
  "application/vnd.oma.dd2+xml": ["dd2"],
  "application/vnd.openofficeorg.extension": ["oxt"],
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": [
    "pptx",
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slide": [
    "sldx",
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": [
    "ppsx",
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.template": [
    "potx",
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": [
    "xltx",
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
    "docx",
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": [
    "dotx",
  ],
  "application/vnd.osgeo.mapguide.package": ["mgp"],
  "application/vnd.osgi.dp": ["dp"],
  "application/vnd.osgi.subsystem": ["esa"],
  "application/vnd.palm": ["pdb", "pqa", "oprc"],
  "application/vnd.pawaafile": ["paw"],
  "application/vnd.pg.format": ["str"],
  "application/vnd.pg.osasli": ["ei6"],
  "application/vnd.picsel": ["efif"],
  "application/vnd.pmi.widget": ["wg"],
  "application/vnd.pocketlearn": ["plf"],
  "application/vnd.powerbuilder6": ["pbd"],
  "application/vnd.previewsystems.box": ["box"],
  "application/vnd.proteus.magazine": ["mgz"],
  "application/vnd.publishare-delta-tree": ["qps"],
  "application/vnd.pvi.ptid1": ["ptid"],
  "application/vnd.quark.quarkxpress": [
    "qxd",
    "qxt",
    "qwd",
    "qwt",
    "qxl",
    "qxb",
  ],
  "application/vnd.realvnc.bed": ["bed"],
  "application/vnd.recordare.musicxml": ["mxl"],
  "application/vnd.recordare.musicxml+xml": ["musicxml"],
  "application/vnd.rig.cryptonote": ["cryptonote"],
  "application/vnd.rim.cod": ["cod"],
  "application/vnd.rn-realmedia": ["rm"],
  "application/vnd.rn-realmedia-vbr": ["rmvb"],
  "application/vnd.route66.link66+xml": ["link66"],
  "application/vnd.sailingtracker.track": ["st"],
  "application/vnd.seemail": ["see"],
  "application/vnd.sema": ["sema"],
  "application/vnd.semd": ["semd"],
  "application/vnd.semf": ["semf"],
  "application/vnd.shana.informed.formdata": ["ifm"],
  "application/vnd.shana.informed.formtemplate": ["itp"],
  "application/vnd.shana.informed.interchange": ["iif"],
  "application/vnd.shana.informed.package": ["ipk"],
  "application/vnd.simtech-mindmapper": ["twd", "twds"],
  "application/vnd.smaf": ["mmf"],
  "application/vnd.smart.teacher": ["teacher"],
  "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
  "application/vnd.spotfire.dxp": ["dxp"],
  "application/vnd.spotfire.sfs": ["sfs"],
  "application/vnd.stardivision.calc": ["sdc"],
  "application/vnd.stardivision.draw": ["sda"],
  "application/vnd.stardivision.impress": ["sdd"],
  "application/vnd.stardivision.math": ["smf"],
  "application/vnd.stardivision.writer": ["sdw", "vor"],
  "application/vnd.stardivision.writer-global": ["sgl"],
  "application/vnd.stepmania.package": ["smzip"],
  "application/vnd.stepmania.stepchart": ["sm"],
  "application/vnd.sun.wadl+xml": ["wadl"],
  "application/vnd.sun.xml.calc": ["sxc"],
  "application/vnd.sun.xml.calc.template": ["stc"],
  "application/vnd.sun.xml.draw": ["sxd"],
  "application/vnd.sun.xml.draw.template": ["std"],
  "application/vnd.sun.xml.impress": ["sxi"],
  "application/vnd.sun.xml.impress.template": ["sti"],
  "application/vnd.sun.xml.math": ["sxm"],
  "application/vnd.sun.xml.writer": ["sxw"],
  "application/vnd.sun.xml.writer.global": ["sxg"],
  "application/vnd.sun.xml.writer.template": ["stw"],
  "application/vnd.sus-calendar": ["sus", "susp"],
  "application/vnd.svd": ["svd"],
  "application/vnd.symbian.install": ["sis", "sisx"],
  "application/vnd.syncml+xml": ["xsm"],
  "application/vnd.syncml.dm+wbxml": ["bdm"],
  "application/vnd.syncml.dm+xml": ["xdm"],
  "application/vnd.tao.intent-module-archive": ["tao"],
  "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"],
  "application/vnd.tmobile-livetv": ["tmo"],
  "application/vnd.trid.tpt": ["tpt"],
  "application/vnd.triscape.mxs": ["mxs"],
  "application/vnd.trueapp": ["tra"],
  "application/vnd.ufdl": ["ufd", "ufdl"],
  "application/vnd.uiq.theme": ["utz"],
  "application/vnd.umajin": ["umj"],
  "application/vnd.unity": ["unityweb"],
  "application/vnd.uoml+xml": ["uoml"],
  "application/vnd.vcx": ["vcx"],
  "application/vnd.visio": ["vsd", "vst", "vss", "vsw"],
  "application/vnd.visionary": ["vis"],
  "application/vnd.vsf": ["vsf"],
  "application/vnd.wap.wbxml": ["wbxml"],
  "application/vnd.wap.wmlc": ["wmlc"],
  "application/vnd.wap.wmlscriptc": ["wmlsc"],
  "application/vnd.webturbo": ["wtb"],
  "application/vnd.wolfram.player": ["nbp"],
  "application/vnd.wordperfect": ["wpd"],
  "application/vnd.wqd": ["wqd"],
  "application/vnd.wt.stf": ["stf"],
  "application/vnd.xara": ["xar"],
  "application/vnd.xfdl": ["xfdl"],
  "application/vnd.yamaha.hv-dic": ["hvd"],
  "application/vnd.yamaha.hv-script": ["hvs"],
  "application/vnd.yamaha.hv-voice": ["hvp"],
  "application/vnd.yamaha.openscoreformat": ["osf"],
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
  "application/vnd.yamaha.smaf-audio": ["saf"],
  "application/vnd.yamaha.smaf-phrase": ["spf"],
  "application/vnd.yellowriver-custom-menu": ["cmp"],
  "application/vnd.zul": ["zir", "zirz"],
  "application/vnd.zzazz.deck+xml": ["zaz"],
  "application/voicexml+xml": ["vxml"],
  "application/wasm": ["wasm"],
  "application/widget": ["wgt"],
  "application/winhlp": ["hlp"],
  "application/wsdl+xml": ["wsdl"],
  "application/wspolicy+xml": ["wspolicy"],
  "application/x-7z-compressed": ["7z"],
  "application/x-abiword": ["abw"],
  "application/x-ace-compressed": ["ace"],
  "application/x-apple-diskimage": [],
  "application/x-arj": ["arj"],
  "application/x-authorware-bin": ["aab", "x32", "u32", "vox"],
  "application/x-authorware-map": ["aam"],
  "application/x-authorware-seg": ["aas"],
  "application/x-bcpio": ["bcpio"],
  "application/x-bdoc": [],
  "application/x-bittorrent": ["torrent"],
  "application/x-blorb": ["blb", "blorb"],
  "application/x-bzip": ["bz"],
  "application/x-bzip2": ["bz2", "boz"],
  "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"],
  "application/x-cdlink": ["vcd"],
  "application/x-cfs-compressed": ["cfs"],
  "application/x-chat": ["chat"],
  "application/x-chess-pgn": ["pgn"],
  "application/x-chrome-extension": ["crx"],
  "application/x-cocoa": ["cco"],
  "application/x-conference": ["nsc"],
  "application/x-cpio": ["cpio"],
  "application/x-csh": ["csh"],
  "application/x-debian-package": ["udeb"],
  "application/x-dgc-compressed": ["dgc"],
  "application/x-director": [
    "dir",
    "dcr",
    "dxr",
    "cst",
    "cct",
    "cxt",
    "w3d",
    "fgd",
    "swa",
  ],
  "application/x-doom": ["wad"],
  "application/x-dtbncx+xml": ["ncx"],
  "application/x-dtbook+xml": ["dtb"],
  "application/x-dtbresource+xml": ["res"],
  "application/x-dvi": ["dvi"],
  "application/x-envoy": ["evy"],
  "application/x-eva": ["eva"],
  "application/x-font-bdf": ["bdf"],
  "application/x-font-ghostscript": ["gsf"],
  "application/x-font-linux-psf": ["psf"],
  "application/x-font-pcf": ["pcf"],
  "application/x-font-snf": ["snf"],
  "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"],
  "application/x-freearc": ["arc"],
  "application/x-futuresplash": ["spl"],
  "application/x-gca-compressed": ["gca"],
  "application/x-glulx": ["ulx"],
  "application/x-gnumeric": ["gnumeric"],
  "application/x-gramps-xml": ["gramps"],
  "application/x-gtar": ["gtar"],
  "application/x-hdf": ["hdf"],
  "application/x-httpd-php": ["php"],
  "application/x-install-instructions": ["install"],
  "application/x-iso9660-image": [],
  "application/x-java-archive-diff": ["jardiff"],
  "application/x-java-jnlp-file": ["jnlp"],
  "application/x-latex": ["latex"],
  "application/x-lua-bytecode": ["luac"],
  "application/x-lzh-compressed": ["lzh", "lha"],
  "application/x-makeself": ["run"],
  "application/x-mie": ["mie"],
  "application/x-mobipocket-ebook": ["prc", "mobi"],
  "application/x-ms-application": ["application"],
  "application/x-ms-shortcut": ["lnk"],
  "application/x-ms-wmd": ["wmd"],
  "application/x-ms-wmz": ["wmz"],
  "application/x-ms-xbap": ["xbap"],
  "application/x-msaccess": ["mdb"],
  "application/x-msbinder": ["obd"],
  "application/x-mscardfile": ["crd"],
  "application/x-msclip": ["clp"],
  "application/x-msdos-program": [],
  "application/x-msdownload": ["com", "bat"],
  "application/x-msmediaview": ["mvb", "m13", "m14"],
  "application/x-msmetafile": ["wmf", "emf", "emz"],
  "application/x-msmoney": ["mny"],
  "application/x-mspublisher": ["pub"],
  "application/x-msschedule": ["scd"],
  "application/x-msterminal": ["trm"],
  "application/x-mswrite": ["wri"],
  "application/x-netcdf": ["nc", "cdf"],
  "application/x-ns-proxy-autoconfig": ["pac"],
  "application/x-nzb": ["nzb"],
  "application/x-perl": ["pl", "pm"],
  "application/x-pilot": [],
  "application/x-pkcs12": ["p12", "pfx"],
  "application/x-pkcs7-certificates": ["p7b", "spc"],
  "application/x-pkcs7-certreqresp": ["p7r"],
  "application/x-rar-compressed": ["rar"],
  "application/x-redhat-package-manager": ["rpm"],
  "application/x-research-info-systems": ["ris"],
  "application/x-sea": ["sea"],
  "application/x-sh": ["sh"],
  "application/x-shar": ["shar"],
  "application/x-shockwave-flash": ["swf"],
  "application/x-silverlight-app": ["xap"],
  "application/x-sql": ["sql"],
  "application/x-stuffit": ["sit"],
  "application/x-stuffitx": ["sitx"],
  "application/x-subrip": ["srt"],
  "application/x-sv4cpio": ["sv4cpio"],
  "application/x-sv4crc": ["sv4crc"],
  "application/x-t3vm-image": ["t3"],
  "application/x-tads": ["gam"],
  "application/x-tar": ["tar"],
  "application/x-tcl": ["tcl", "tk"],
  "application/x-tex": ["tex"],
  "application/x-tex-tfm": ["tfm"],
  "application/x-texinfo": ["texinfo", "texi"],
  "application/x-tgif": ["obj"],
  "application/x-ustar": ["ustar"],
  "application/x-virtualbox-hdd": ["hdd"],
  "application/x-virtualbox-ova": ["ova"],
  "application/x-virtualbox-ovf": ["ovf"],
  "application/x-virtualbox-vbox": ["vbox"],
  "application/x-virtualbox-vbox-extpack": ["vbox-extpack"],
  "application/x-virtualbox-vdi": ["vdi"],
  "application/x-virtualbox-vhd": ["vhd"],
  "application/x-virtualbox-vmdk": ["vmdk"],
  "application/x-wais-source": ["src"],
  "application/x-web-app-manifest+json": ["webapp"],
  "application/x-x509-ca-cert": ["der", "crt", "pem"],
  "application/x-xfig": ["fig"],
  "application/x-xliff+xml": ["xlf"],
  "application/x-xpinstall": ["xpi"],
  "application/x-xz": ["xz"],
  "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
  "application/xaml+xml": ["xaml"],
  "application/xcap-diff+xml": ["xdf"],
  "application/xenc+xml": ["xenc"],
  "application/xhtml+xml": ["xhtml", "xht"],
  "application/xml": ["xml", "xsl", "xsd", "rng"],
  "application/xml-dtd": ["dtd"],
  "application/xop+xml": ["xop"],
  "application/xproc+xml": ["xpl"],
  "application/xslt+xml": ["xslt"],
  "application/xspf+xml": ["xspf"],
  "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
  "application/yang": ["yang"],
  "application/yin+xml": ["yin"],
  "application/zip": ["zip"],
  "audio/3gpp": [],
  "audio/adpcm": ["adp"],
  "audio/basic": ["au", "snd"],
  "audio/midi": ["mid", "midi", "kar", "rmi"],
  "audio/mp3": [],
  "audio/mp4": ["m4a", "mp4a"],
  "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  "audio/ogg": ["oga", "ogg", "spx"],
  "audio/s3m": ["s3m"],
  "audio/silk": ["sil"],
  "audio/vnd.dece.audio": ["uva", "uvva"],
  "audio/vnd.digital-winds": ["eol"],
  "audio/vnd.dra": ["dra"],
  "audio/vnd.dts": ["dts"],
  "audio/vnd.dts.hd": ["dtshd"],
  "audio/vnd.lucent.voice": ["lvp"],
  "audio/vnd.ms-playready.media.pya": ["pya"],
  "audio/vnd.nuera.ecelp4800": ["ecelp4800"],
  "audio/vnd.nuera.ecelp7470": ["ecelp7470"],
  "audio/vnd.nuera.ecelp9600": ["ecelp9600"],
  "audio/vnd.rip": ["rip"],
  "audio/wav": ["wav"],
  "audio/wave": [],
  "audio/webm": ["weba"],
  "audio/x-aac": ["aac"],
  "audio/x-aiff": ["aif", "aiff", "aifc"],
  "audio/x-caf": ["caf"],
  "audio/x-flac": ["flac"],
  "audio/x-m4a": [],
  "audio/x-matroska": ["mka"],
  "audio/x-mpegurl": ["m3u"],
  "audio/x-ms-wax": ["wax"],
  "audio/x-ms-wma": ["wma"],
  "audio/x-pn-realaudio": ["ram", "ra"],
  "audio/x-pn-realaudio-plugin": ["rmp"],
  "audio/x-realaudio": [],
  "audio/x-wav": [],
  "audio/xm": ["xm"],
  "chemical/x-cdx": ["cdx"],
  "chemical/x-cif": ["cif"],
  "chemical/x-cmdf": ["cmdf"],
  "chemical/x-cml": ["cml"],
  "chemical/x-csml": ["csml"],
  "chemical/x-xyz": ["xyz"],
  "font/collection": ["ttc"],
  "font/otf": ["otf"],
  "font/ttf": ["ttf"],
  "font/woff": ["woff"],
  "font/woff2": ["woff2"],
  "image/apng": ["apng"],
  "image/bmp": ["bmp"],
  "image/cgm": ["cgm"],
  "image/g3fax": ["g3"],
  "image/gif": ["gif"],
  "image/ief": ["ief"],
  "image/jp2": ["jp2", "jpg2"],
  "image/jpeg": ["jpeg", "jpg", "jpe"],
  "image/jpm": ["jpm"],
  "image/jpx": ["jpx", "jpf"],
  "image/ktx": ["ktx"],
  "image/png": ["png"],
  "image/prs.btif": ["btif"],
  "image/sgi": ["sgi"],
  "image/svg+xml": ["svg", "svgz"],
  "image/tiff": ["tiff", "tif"],
  "image/vnd.adobe.photoshop": ["psd"],
  "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"],
  "image/vnd.djvu": ["djvu", "djv"],
  "image/vnd.dvb.subtitle": [],
  "image/vnd.dwg": ["dwg"],
  "image/vnd.dxf": ["dxf"],
  "image/vnd.fastbidsheet": ["fbs"],
  "image/vnd.fpx": ["fpx"],
  "image/vnd.fst": ["fst"],
  "image/vnd.fujixerox.edmics-mmr": ["mmr"],
  "image/vnd.fujixerox.edmics-rlc": ["rlc"],
  "image/vnd.ms-modi": ["mdi"],
  "image/vnd.ms-photo": ["wdp"],
  "image/vnd.net-fpx": ["npx"],
  "image/vnd.wap.wbmp": ["wbmp"],
  "image/vnd.xiff": ["xif"],
  "image/webp": ["webp"],
  "image/x-3ds": ["3ds"],
  "image/x-cmu-raster": ["ras"],
  "image/x-cmx": ["cmx"],
  "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"],
  "image/x-icon": ["ico"],
  "image/x-jng": ["jng"],
  "image/x-mrsid-image": ["sid"],
  "image/x-ms-bmp": [],
  "image/x-pcx": ["pcx"],
  "image/x-pict": ["pic", "pct"],
  "image/x-portable-anymap": ["pnm"],
  "image/x-portable-bitmap": ["pbm"],
  "image/x-portable-graymap": ["pgm"],
  "image/x-portable-pixmap": ["ppm"],
  "image/x-rgb": ["rgb"],
  "image/x-tga": ["tga"],
  "image/x-xbitmap": ["xbm"],
  "image/x-xpixmap": ["xpm"],
  "image/x-xwindowdump": ["xwd"],
  "message/rfc822": ["eml", "mime"],
  "model/gltf+json": ["gltf"],
  "model/gltf-binary": ["glb"],
  "model/iges": ["igs", "iges"],
  "model/mesh": ["msh", "mesh", "silo"],
  "model/vnd.collada+xml": ["dae"],
  "model/vnd.dwf": ["dwf"],
  "model/vnd.gdl": ["gdl"],
  "model/vnd.gtw": ["gtw"],
  "model/vnd.mts": ["mts"],
  "model/vnd.vtu": ["vtu"],
  "model/vrml": ["wrl", "vrml"],
  "model/x3d+binary": ["x3db", "x3dbz"],
  "model/x3d+vrml": ["x3dv", "x3dvz"],
  "model/x3d+xml": ["x3d", "x3dz"],
  "text/cache-manifest": ["appcache", "manifest"],
  "text/calendar": ["ics", "ifb"],
  "text/coffeescript": ["coffee", "litcoffee"],
  "text/css": ["css"],
  "text/csv": ["csv"],
  "text/hjson": ["hjson"],
  "text/html": ["html", "htm", "shtml"],
  "text/jade": ["jade"],
  "text/jsx": ["jsx"],
  "text/less": ["less"],
  "text/markdown": ["markdown", "md"],
  "text/mathml": ["mml"],
  "text/n3": ["n3"],
  "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
  "text/prs.lines.tag": ["dsc"],
  "text/richtext": ["rtx"],
  "text/rtf": [],
  "text/sgml": ["sgml", "sgm"],
  "text/slim": ["slim", "slm"],
  "text/stylus": ["stylus", "styl"],
  "text/tab-separated-values": ["tsv"],
  "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
  "text/turtle": ["ttl"],
  "text/uri-list": ["uri", "uris", "urls"],
  "text/vcard": ["vcard"],
  "text/vnd.curl": ["curl"],
  "text/vnd.curl.dcurl": ["dcurl"],
  "text/vnd.curl.mcurl": ["mcurl"],
  "text/vnd.curl.scurl": ["scurl"],
  "text/vnd.dvb.subtitle": ["sub"],
  "text/vnd.fly": ["fly"],
  "text/vnd.fmi.flexstor": ["flx"],
  "text/vnd.graphviz": ["gv"],
  "text/vnd.in3d.3dml": ["3dml"],
  "text/vnd.in3d.spot": ["spot"],
  "text/vnd.sun.j2me.app-descriptor": ["jad"],
  "text/vnd.wap.wml": ["wml"],
  "text/vnd.wap.wmlscript": ["wmls"],
  "text/vtt": ["vtt"],
  "text/x-asm": ["s", "asm"],
  "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
  "text/x-component": ["htc"],
  "text/x-fortran": ["f", "for", "f77", "f90"],
  "text/x-handlebars-template": ["hbs"],
  "text/x-java-source": ["java"],
  "text/x-lua": ["lua"],
  "text/x-markdown": ["mkd"],
  "text/x-nfo": ["nfo"],
  "text/x-opml": ["opml"],
  "text/x-org": [],
  "text/x-pascal": ["p", "pas"],
  "text/x-processing": ["pde"],
  "text/x-sass": ["sass"],
  "text/x-scss": ["scss"],
  "text/x-setext": ["etx"],
  "text/x-sfv": ["sfv"],
  "text/x-suse-ymp": ["ymp"],
  "text/x-uuencode": ["uu"],
  "text/x-vcalendar": ["vcs"],
  "text/x-vcard": ["vcf"],
  "text/xml": [],
  "text/yaml": ["yaml", "yml"],
  "video/3gpp": ["3gp", "3gpp"],
  "video/3gpp2": ["3g2"],
  "video/h261": ["h261"],
  "video/h263": ["h263"],
  "video/h264": ["h264"],
  "video/jpeg": ["jpgv"],
  "video/jpm": ["jpgm"],
  "video/mj2": ["mj2", "mjp2"],
  "video/mp2t": ["ts"],
  "video/mp4": ["mp4", "mp4v", "mpg4"],
  "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  "video/ogg": ["ogv"],
  "video/quicktime": ["qt", "mov"],
  "video/vnd.dece.hd": ["uvh", "uvvh"],
  "video/vnd.dece.mobile": ["uvm", "uvvm"],
  "video/vnd.dece.pd": ["uvp", "uvvp"],
  "video/vnd.dece.sd": ["uvs", "uvvs"],
  "video/vnd.dece.video": ["uvv", "uvvv"],
  "video/vnd.dvb.file": ["dvb"],
  "video/vnd.fvt": ["fvt"],
  "video/vnd.mpegurl": ["mxu", "m4u"],
  "video/vnd.ms-playready.media.pyv": ["pyv"],
  "video/vnd.uvvu.mp4": ["uvu", "uvvu"],
  "video/vnd.vivo": ["viv"],
  "video/webm": ["webm"],
  "video/x-f4v": ["f4v"],
  "video/x-fli": ["fli"],
  "video/x-flv": ["flv"],
  "video/x-m4v": ["m4v"],
  "video/x-matroska": ["mkv", "mk3d", "mks"],
  "video/x-mng": ["mng"],
  "video/x-ms-asf": ["asf", "asx"],
  "video/x-ms-vob": ["vob"],
  "video/x-ms-wm": ["wm"],
  "video/x-ms-wmv": ["wmv"],
  "video/x-ms-wmx": ["wmx"],
  "video/x-ms-wvx": ["wvx"],
  "video/x-msvideo": ["avi"],
  "video/x-sgi-movie": ["movie"],
  "video/x-smv": ["smv"],
  "x-conference/x-cooltalk": ["ice"],
};
var X6 = Xt;
function _c() {
  (this.types = Object.create(null)), (this.extensions = Object.create(null));
}
_c.prototype.define = function (e) {
  for (var t in e) {
    for (var n = e[t], r = 0; r < n.length; r++)
      process.env.DEBUG_MIME &&
        this.types[n[r]] &&
        console.warn(
          (this._loading || "define()").replace(/.*\//, ""),
          'changes "' +
            n[r] +
            '" extension type from ' +
            this.types[n[r]] +
            " to " +
            t,
        ),
        (this.types[n[r]] = t);
    this.extensions[t] || (this.extensions[t] = n[0]);
  }
};
_c.prototype.load = function (e) {
  this._loading = e;
  var t = {},
    n = X6.readFileSync(e, "ascii"),
    r = n.split(/[\r\n]+/);
  r.forEach(function (i) {
    var a = i.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
    t[a.shift()] = a;
  }),
    this.define(t),
    (this._loading = null);
};
_c.prototype.lookup = function (e, t) {
  var n = e.replace(/^.*[\.\/\\]/, "").toLowerCase();
  return this.types[n] || t || this.default_type;
};
_c.prototype.extension = function (e) {
  var t = e.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[t];
};
var Wo = new _c();
Wo.define(Y6);
Wo.default_type = Wo.lookup("bin");
Wo.Mime = _c;
Wo.charsets = {
  lookup: function (e, t) {
    return /^text\/|^application\/(javascript|json)/.test(e) ? "UTF-8" : t;
  },
};
var J6 = Wo,
  zo = 1e3,
  Ko = zo * 60,
  Vo = Ko * 60,
  Ds = Vo * 24,
  Z6 = Ds * 7,
  e3 = Ds * 365.25,
  t3 = function (e, t) {
    t = t || {};
    var n = typeof e;
    if (n === "string" && e.length > 0) return n3(e);
    if (n === "number" && isFinite(e)) return t.long ? i3(e) : r3(e);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(e),
    );
  };
function n3(e) {
  if (((e = String(e)), !(e.length > 100))) {
    var t =
      /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        e,
      );
    if (t) {
      var n = parseFloat(t[1]),
        r = (t[2] || "ms").toLowerCase();
      switch (r) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * e3;
        case "weeks":
        case "week":
        case "w":
          return n * Z6;
        case "days":
        case "day":
        case "d":
          return n * Ds;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * Vo;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * Ko;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * zo;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return;
      }
    }
  }
}
function r3(e) {
  var t = Math.abs(e);
  return t >= Ds
    ? Math.round(e / Ds) + "d"
    : t >= Vo
    ? Math.round(e / Vo) + "h"
    : t >= Ko
    ? Math.round(e / Ko) + "m"
    : t >= zo
    ? Math.round(e / zo) + "s"
    : e + "ms";
}
function i3(e) {
  var t = Math.abs(e);
  return t >= Ds
    ? Ku(e, t, Ds, "day")
    : t >= Vo
    ? Ku(e, t, Vo, "hour")
    : t >= Ko
    ? Ku(e, t, Ko, "minute")
    : t >= zo
    ? Ku(e, t, zo, "second")
    : e + " ms";
}
function Ku(e, t, n, r) {
  var i = t >= n * 1.5;
  return Math.round(e / n) + " " + r + (i ? "s" : "");
}
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var E$ = a3;
function a3(e, t, n) {
  if (typeof t != "string")
    throw new TypeError("argument str must be a string");
  var r = t.indexOf("=");
  if (r === -1) return -2;
  var i = t.slice(r + 1).split(","),
    a = [];
  a.type = t.slice(0, r);
  for (var s = 0; s < i.length; s++) {
    var o = i[s].split("-"),
      c = parseInt(o[0], 10),
      l = parseInt(o[1], 10);
    isNaN(c) ? ((c = e - l), (l = e - 1)) : isNaN(l) && (l = e - 1),
      l > e - 1 && (l = e - 1),
      !(isNaN(c) || isNaN(l) || c > l || c < 0) && a.push({ start: c, end: l });
  }
  return a.length < 1 ? -1 : n && n.combine ? s3(a) : a;
}
function s3(e) {
  for (var t = e.map(o3).sort(u3), n = 0, r = 1; r < t.length; r++) {
    var i = t[r],
      a = t[n];
    i.start > a.end + 1
      ? (t[++n] = i)
      : i.end > a.end &&
        ((a.end = i.end), (a.index = Math.min(a.index, i.index)));
  }
  t.length = n + 1;
  var s = t.sort(l3).map(c3);
  return (s.type = e.type), s;
}
function o3(e, t) {
  return { start: e.start, end: e.end, index: t };
}
function c3(e) {
  return { start: e.start, end: e.end };
}
function l3(e, t) {
  return e.index - t.index;
}
function u3(e, t) {
  return e.start - t.start;
}
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var Lh = Gi,
  xn = M6("send"),
  Vs = wi("send"),
  f3 = ev,
  d3 = Qd,
  Jg = Wd,
  p3 = b$,
  h3 = _$,
  ad = Xt,
  Zg = J6,
  w$ = t3,
  m3 = Kl,
  g3 = E$,
  Jl = pt,
  v3 = Hd,
  x$ = Kr,
  y3 = wr,
  b3 = Jl.extname,
  A$ = Jl.join,
  Bh = Jl.normalize,
  yv = Jl.resolve,
  Bf = Jl.sep,
  _3 = /^ *bytes=/,
  S$ = 60 * 60 * 24 * 365 * 1e3,
  G_ = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
vv.exports = E3;
vv.exports.mime = Zg;
function E3(e, t, n) {
  return new Qt(e, t, n);
}
function Qt(e, t, n) {
  x$.call(this);
  var r = n || {};
  if (
    ((this.options = r),
    (this.path = t),
    (this.req = e),
    (this._acceptRanges = r.acceptRanges !== void 0 ? !!r.acceptRanges : !0),
    (this._cacheControl = r.cacheControl !== void 0 ? !!r.cacheControl : !0),
    (this._etag = r.etag !== void 0 ? !!r.etag : !0),
    (this._dotfiles = r.dotfiles !== void 0 ? r.dotfiles : "ignore"),
    this._dotfiles !== "ignore" &&
      this._dotfiles !== "allow" &&
      this._dotfiles !== "deny")
  )
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
  (this._hidden = !!r.hidden),
    r.hidden !== void 0 &&
      Vs(
        "hidden: use dotfiles: '" +
          (this._hidden ? "allow" : "ignore") +
          "' instead",
      ),
    r.dotfiles === void 0 && (this._dotfiles = void 0),
    (this._extensions =
      r.extensions !== void 0 ? e0(r.extensions, "extensions option") : []),
    (this._immutable = r.immutable !== void 0 ? !!r.immutable : !1),
    (this._index =
      r.index !== void 0 ? e0(r.index, "index option") : ["index.html"]),
    (this._lastModified = r.lastModified !== void 0 ? !!r.lastModified : !0),
    (this._maxage = r.maxAge || r.maxage),
    (this._maxage =
      typeof this._maxage == "string"
        ? w$(this._maxage)
        : Number(this._maxage)),
    (this._maxage = isNaN(this._maxage)
      ? 0
      : Math.min(Math.max(0, this._maxage), S$)),
    (this._root = r.root ? yv(r.root) : null),
    !this._root && r.from && this.from(r.from);
}
y3.inherits(Qt, x$);
Qt.prototype.etag = Vs.function(function (t) {
  return (this._etag = !!t), xn("etag %s", this._etag), this;
}, "send.etag: pass etag as option");
Qt.prototype.hidden = Vs.function(function (t) {
  return (
    (this._hidden = !!t),
    (this._dotfiles = void 0),
    xn("hidden %s", this._hidden),
    this
  );
}, "send.hidden: use dotfiles option");
Qt.prototype.index = Vs.function(function (t) {
  var n = t ? e0(t, "paths argument") : [];
  return xn("index %o", t), (this._index = n), this;
}, "send.index: pass index as option");
Qt.prototype.root = function (t) {
  return (this._root = yv(String(t))), xn("root %s", this._root), this;
};
Qt.prototype.from = Vs.function(
  Qt.prototype.root,
  "send.from: pass root as option",
);
Qt.prototype.root = Vs.function(
  Qt.prototype.root,
  "send.root: pass root as option",
);
Qt.prototype.maxage = Vs.function(function (t) {
  return (
    (this._maxage = typeof t == "string" ? w$(t) : Number(t)),
    (this._maxage = isNaN(this._maxage)
      ? 0
      : Math.min(Math.max(0, this._maxage), S$)),
    xn("max-age %d", this._maxage),
    this
  );
}, "send.maxage: pass maxAge as option");
Qt.prototype.error = function (t, n) {
  if ($$(this, "error")) return this.emit("error", S3(t, n));
  var r = this.res,
    i = v3.message[t] || String(t),
    a = I$("Error", Jg(i));
  w3(r),
    n && n.headers && k3(r, n.headers),
    (r.statusCode = t),
    r.setHeader("Content-Type", "text/html; charset=UTF-8"),
    r.setHeader("Content-Length", Buffer.byteLength(a)),
    r.setHeader("Content-Security-Policy", "default-src 'none'"),
    r.setHeader("X-Content-Type-Options", "nosniff"),
    r.end(a);
};
Qt.prototype.hasTrailingSlash = function () {
  return this.path[this.path.length - 1] === "/";
};
Qt.prototype.isConditionalGET = function () {
  return (
    this.req.headers["if-match"] ||
    this.req.headers["if-unmodified-since"] ||
    this.req.headers["if-none-match"] ||
    this.req.headers["if-modified-since"]
  );
};
Qt.prototype.isPreconditionFailure = function () {
  var t = this.req,
    n = this.res,
    r = t.headers["if-match"];
  if (r) {
    var i = n.getHeader("ETag");
    return (
      !i ||
      (r !== "*" &&
        R3(r).every(function (o) {
          return o !== i && o !== "W/" + i && "W/" + o !== i;
        }))
    );
  }
  var a = sd(t.headers["if-unmodified-since"]);
  if (!isNaN(a)) {
    var s = sd(n.getHeader("Last-Modified"));
    return isNaN(s) || s > a;
  }
  return !1;
};
Qt.prototype.removeContentHeaderFields = function () {
  var t = this.res;
  t.removeHeader("Content-Encoding"),
    t.removeHeader("Content-Language"),
    t.removeHeader("Content-Length"),
    t.removeHeader("Content-Range"),
    t.removeHeader("Content-Type");
};
Qt.prototype.notModified = function () {
  var t = this.res;
  xn("not modified"),
    this.removeContentHeaderFields(),
    (t.statusCode = 304),
    t.end();
};
Qt.prototype.headersAlreadySent = function () {
  var t = new Error("Can't set headers after they are sent.");
  xn("headers already sent"), this.error(500, t);
};
Qt.prototype.isCachable = function () {
  var t = this.res.statusCode;
  return (t >= 200 && t < 300) || t === 304;
};
Qt.prototype.onStatError = function (t) {
  switch (t.code) {
    case "ENAMETOOLONG":
    case "ENOENT":
    case "ENOTDIR":
      this.error(404, t);
      break;
    default:
      this.error(500, t);
      break;
  }
};
Qt.prototype.isFresh = function () {
  return h3(this.req.headers, {
    etag: this.res.getHeader("ETag"),
    "last-modified": this.res.getHeader("Last-Modified"),
  });
};
Qt.prototype.isRangeFresh = function () {
  var t = this.req.headers["if-range"];
  if (!t) return !0;
  if (t.indexOf('"') !== -1) {
    var n = this.res.getHeader("ETag");
    return !!(n && t.indexOf(n) !== -1);
  }
  var r = this.res.getHeader("Last-Modified");
  return sd(r) <= sd(t);
};
Qt.prototype.redirect = function (t) {
  var n = this.res;
  if ($$(this, "directory")) {
    this.emit("directory", n, t);
    return;
  }
  if (this.hasTrailingSlash()) {
    this.error(403);
    return;
  }
  var r = d3(x3(this.path + "/")),
    i = I$(
      "Redirecting",
      'Redirecting to <a href="' + Jg(r) + '">' + Jg(r) + "</a>",
    );
  (n.statusCode = 301),
    n.setHeader("Content-Type", "text/html; charset=UTF-8"),
    n.setHeader("Content-Length", Buffer.byteLength(i)),
    n.setHeader("Content-Security-Policy", "default-src 'none'"),
    n.setHeader("X-Content-Type-Options", "nosniff"),
    n.setHeader("Location", r),
    n.end(i);
};
Qt.prototype.pipe = function (t) {
  var n = this._root;
  this.res = t;
  var r = I3(this.path);
  if (r === -1) return this.error(400), t;
  if (~r.indexOf("\0")) return this.error(400), t;
  var i;
  if (n !== null) {
    if ((r && (r = Bh("." + Bf + r)), G_.test(r)))
      return xn('malicious path "%s"', r), this.error(403), t;
    (i = r.split(Bf)), (r = Bh(A$(n, r)));
  } else {
    if (G_.test(r)) return xn('malicious path "%s"', r), this.error(403), t;
    (i = Bh(r).split(Bf)), (r = yv(r));
  }
  if (A3(i)) {
    var a = this._dotfiles;
    switch (
      (a === void 0 &&
        (a =
          i[i.length - 1][0] === "."
            ? this._hidden
              ? "allow"
              : "ignore"
            : "allow"),
      xn('%s dotfile "%s"', a, r),
      a)
    ) {
      case "allow":
        break;
      case "deny":
        return this.error(403), t;
      case "ignore":
      default:
        return this.error(404), t;
    }
  }
  return this._index.length && this.hasTrailingSlash()
    ? (this.sendIndex(r), t)
    : (this.sendFile(r), t);
};
Qt.prototype.send = function (t, n) {
  var r = n.size,
    i = this.options,
    a = {},
    s = this.res,
    o = this.req,
    c = o.headers.range,
    l = i.start || 0;
  if (C3(s)) {
    this.headersAlreadySent();
    return;
  }
  if (
    (xn('pipe "%s"', t),
    this.setHeader(t, n),
    this.type(t),
    this.isConditionalGET())
  ) {
    if (this.isPreconditionFailure()) {
      this.error(412);
      return;
    }
    if (this.isCachable() && this.isFresh()) {
      this.notModified();
      return;
    }
  }
  if (((r = Math.max(0, r - l)), i.end !== void 0)) {
    var f = i.end - l + 1;
    r > f && (r = f);
  }
  if (this._acceptRanges && _3.test(c)) {
    if (
      ((c = g3(r, c, { combine: !0 })),
      this.isRangeFresh() || (xn("range stale"), (c = -2)),
      c === -1)
    )
      return (
        xn("range unsatisfiable"),
        s.setHeader("Content-Range", Q_("bytes", r)),
        this.error(416, {
          headers: { "Content-Range": s.getHeader("Content-Range") },
        })
      );
    c !== -2 &&
      c.length === 1 &&
      (xn("range %j", c),
      (s.statusCode = 206),
      s.setHeader("Content-Range", Q_("bytes", r, c[0])),
      (l += c[0].start),
      (r = c[0].end - c[0].start + 1));
  }
  for (var u in i) a[u] = i[u];
  if (
    ((a.start = l),
    (a.end = Math.max(l, l + r - 1)),
    s.setHeader("Content-Length", r),
    o.method === "HEAD")
  ) {
    s.end();
    return;
  }
  this.stream(t, a);
};
Qt.prototype.sendFile = function (t) {
  var n = 0,
    r = this;
  xn('stat "%s"', t),
    ad.stat(t, function (s, o) {
      if (s && s.code === "ENOENT" && !b3(t) && t[t.length - 1] !== Bf)
        return i(s);
      if (s) return r.onStatError(s);
      if (o.isDirectory()) return r.redirect(t);
      r.emit("file", t, o), r.send(t, o);
    });
  function i(a) {
    if (r._extensions.length <= n) return a ? r.onStatError(a) : r.error(404);
    var s = t + "." + r._extensions[n++];
    xn('stat "%s"', s),
      ad.stat(s, function (o, c) {
        if (o) return i(o);
        if (c.isDirectory()) return i();
        r.emit("file", s, c), r.send(s, c);
      });
  }
};
Qt.prototype.sendIndex = function (t) {
  var n = -1,
    r = this;
  function i(a) {
    if (++n >= r._index.length) return a ? r.onStatError(a) : r.error(404);
    var s = A$(t, r._index[n]);
    xn('stat "%s"', s),
      ad.stat(s, function (o, c) {
        if (o) return i(o);
        if (c.isDirectory()) return i();
        r.emit("file", s, c), r.send(s, c);
      });
  }
  i();
};
Qt.prototype.stream = function (t, n) {
  var r = this,
    i = this.res,
    a = ad.createReadStream(t, n);
  this.emit("stream", a), a.pipe(i);
  function s() {
    f3(a, !0);
  }
  m3(i, s),
    a.on("error", function (c) {
      s(), r.onStatError(c);
    }),
    a.on("end", function () {
      r.emit("end");
    });
};
Qt.prototype.type = function (t) {
  var n = this.res;
  if (!n.getHeader("Content-Type")) {
    var r = Zg.lookup(t);
    if (!r) {
      xn("no content-type");
      return;
    }
    var i = Zg.charsets.lookup(r);
    xn("content-type %s", r),
      n.setHeader("Content-Type", r + (i ? "; charset=" + i : ""));
  }
};
Qt.prototype.setHeader = function (t, n) {
  var r = this.res;
  if (
    (this.emit("headers", r, t, n),
    this._acceptRanges &&
      !r.getHeader("Accept-Ranges") &&
      (xn("accept ranges"), r.setHeader("Accept-Ranges", "bytes")),
    this._cacheControl && !r.getHeader("Cache-Control"))
  ) {
    var i = "public, max-age=" + Math.floor(this._maxage / 1e3);
    this._immutable && (i += ", immutable"),
      xn("cache-control %s", i),
      r.setHeader("Cache-Control", i);
  }
  if (this._lastModified && !r.getHeader("Last-Modified")) {
    var a = n.mtime.toUTCString();
    xn("modified %s", a), r.setHeader("Last-Modified", a);
  }
  if (this._etag && !r.getHeader("ETag")) {
    var s = p3(n);
    xn("etag %s", s), r.setHeader("ETag", s);
  }
};
function w3(e) {
  for (var t = $3(e), n = 0; n < t.length; n++) e.removeHeader(t[n]);
}
function x3(e) {
  for (var t = 0; t < e.length && e[t] === "/"; t++);
  return t > 1 ? "/" + e.substr(t) : e;
}
function A3(e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    if (n.length > 1 && n[0] === ".") return !0;
  }
  return !1;
}
function Q_(e, t, n) {
  return e + " " + (n ? n.start + "-" + n.end : "*") + "/" + t;
}
function I$(e, t) {
  return (
    `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>` +
    e +
    `</title>
</head>
<body>
<pre>` +
    t +
    `</pre>
</body>
</html>
`
  );
}
function S3(e, t) {
  return t ? (t instanceof Error ? Lh(e, t, { expose: !1 }) : Lh(e, t)) : Lh(e);
}
function I3(e) {
  try {
    return decodeURIComponent(e);
  } catch {
    return -1;
  }
}
function $3(e) {
  return typeof e.getHeaderNames != "function"
    ? Object.keys(e._headers || {})
    : e.getHeaderNames();
}
function $$(e, t) {
  var n =
    typeof e.listenerCount != "function"
      ? e.listeners(t).length
      : e.listenerCount(t);
  return n > 0;
}
function C3(e) {
  return typeof e.headersSent != "boolean" ? !!e._header : e.headersSent;
}
function e0(e, t) {
  for (var n = [].concat(e || []), r = 0; r < n.length; r++)
    if (typeof n[r] != "string")
      throw new TypeError(t + " must be array of strings or false");
  return n;
}
function sd(e) {
  var t = e && Date.parse(e);
  return typeof t == "number" ? t : NaN;
}
function R3(e) {
  for (var t = 0, n = [], r = 0, i = 0, a = e.length; i < a; i++)
    switch (e.charCodeAt(i)) {
      case 32:
        r === t && (r = t = i + 1);
        break;
      case 44:
        r !== t && n.push(e.substring(r, t)), (r = t = i + 1);
        break;
      default:
        t = i + 1;
        break;
    }
  return r !== t && n.push(e.substring(r, t)), n;
}
function k3(e, t) {
  for (var n = Object.keys(t), r = 0; r < n.length; r++) {
    var i = n[r];
    e.setHeader(i, t[i]);
  }
}
var bv = vv.exports,
  Xd = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var T3 = N3;
function N3(e) {
  if (!e) throw new TypeError("argument req is required");
  var t = P3(e.headers["x-forwarded-for"] || ""),
    n = O3(e),
    r = [n].concat(t);
  return r;
}
function O3(e) {
  return e.socket ? e.socket.remoteAddress : e.connection.remoteAddress;
}
function P3(e) {
  for (var t = e.length, n = [], r = e.length, i = e.length - 1; i >= 0; i--)
    switch (e.charCodeAt(i)) {
      case 32:
        r === t && (r = t = i);
        break;
      case 44:
        r !== t && n.push(e.substring(r, t)), (r = t = i);
        break;
      default:
        r = i;
        break;
    }
  return r !== t && n.push(e.substring(r, t)), n;
}
var _v = { exports: {} };
_v.exports;
(function (e) {
  (function () {
    var t, n, r, i, a, s, o, c, l;
    (n = {}),
      (c = this),
      e !== null && e.exports ? (e.exports = n) : (c.ipaddr = n),
      (o = function (f, u, d, p) {
        var h, m;
        if (f.length !== u.length)
          throw new Error(
            "ipaddr: cannot match CIDR for objects with different lengths",
          );
        for (h = 0; p > 0; ) {
          if (((m = d - p), m < 0 && (m = 0), f[h] >> m !== u[h] >> m))
            return !1;
          (p -= d), (h += 1);
        }
        return !0;
      }),
      (n.subnetMatch = function (f, u, d) {
        var p, h, m, g, v;
        d == null && (d = "unicast");
        for (m in u)
          for (
            g = u[m],
              g[0] && !(g[0] instanceof Array) && (g = [g]),
              p = 0,
              h = g.length;
            p < h;
            p++
          )
            if (((v = g[p]), f.kind() === v[0].kind() && f.match.apply(f, v)))
              return m;
        return d;
      }),
      (n.IPv4 = (function () {
        function f(u) {
          var d, p, h;
          if (u.length !== 4)
            throw new Error("ipaddr: ipv4 octet count should be 4");
          for (d = 0, p = u.length; d < p; d++)
            if (((h = u[d]), !(0 <= h && h <= 255)))
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          this.octets = u;
        }
        return (
          (f.prototype.kind = function () {
            return "ipv4";
          }),
          (f.prototype.toString = function () {
            return this.octets.join(".");
          }),
          (f.prototype.toNormalizedString = function () {
            return this.toString();
          }),
          (f.prototype.toByteArray = function () {
            return this.octets.slice(0);
          }),
          (f.prototype.match = function (u, d) {
            var p;
            if (
              (d === void 0 && ((p = u), (u = p[0]), (d = p[1])),
              u.kind() !== "ipv4")
            )
              throw new Error(
                "ipaddr: cannot match ipv4 address with non-ipv4 one",
              );
            return o(this.octets, u.octets, 8, d);
          }),
          (f.prototype.SpecialRanges = {
            unspecified: [[new f([0, 0, 0, 0]), 8]],
            broadcast: [[new f([255, 255, 255, 255]), 32]],
            multicast: [[new f([224, 0, 0, 0]), 4]],
            linkLocal: [[new f([169, 254, 0, 0]), 16]],
            loopback: [[new f([127, 0, 0, 0]), 8]],
            carrierGradeNat: [[new f([100, 64, 0, 0]), 10]],
            private: [
              [new f([10, 0, 0, 0]), 8],
              [new f([172, 16, 0, 0]), 12],
              [new f([192, 168, 0, 0]), 16],
            ],
            reserved: [
              [new f([192, 0, 0, 0]), 24],
              [new f([192, 0, 2, 0]), 24],
              [new f([192, 88, 99, 0]), 24],
              [new f([198, 51, 100, 0]), 24],
              [new f([203, 0, 113, 0]), 24],
              [new f([240, 0, 0, 0]), 4],
            ],
          }),
          (f.prototype.range = function () {
            return n.subnetMatch(this, this.SpecialRanges);
          }),
          (f.prototype.toIPv4MappedAddress = function () {
            return n.IPv6.parse("::ffff:" + this.toString());
          }),
          (f.prototype.prefixLengthFromSubnetMask = function () {
            var u, d, p, h, m, g, v;
            for (
              v = {
                0: 8,
                128: 7,
                192: 6,
                224: 5,
                240: 4,
                248: 3,
                252: 2,
                254: 1,
                255: 0,
              },
                u = 0,
                m = !1,
                d = p = 3;
              p >= 0;
              d = p += -1
            )
              if (((h = this.octets[d]), h in v)) {
                if (((g = v[h]), m && g !== 0)) return null;
                g !== 8 && (m = !0), (u += g);
              } else return null;
            return 32 - u;
          }),
          f
        );
      })()),
      (r = "(0?\\d+|0x[a-f0-9]+)"),
      (i = {
        fourOctet: new RegExp(
          "^" + r + "\\." + r + "\\." + r + "\\." + r + "$",
          "i",
        ),
        longValue: new RegExp("^" + r + "$", "i"),
      }),
      (n.IPv4.parser = function (f) {
        var u, d, p, h, m;
        if (
          ((d = function (g) {
            return g[0] === "0" && g[1] !== "x" ? parseInt(g, 8) : parseInt(g);
          }),
          (u = f.match(i.fourOctet)))
        )
          return (function () {
            var g, v, y, _;
            for (y = u.slice(1, 6), _ = [], g = 0, v = y.length; g < v; g++)
              (p = y[g]), _.push(d(p));
            return _;
          })();
        if ((u = f.match(i.longValue))) {
          if (((m = d(u[1])), m > 4294967295 || m < 0))
            throw new Error("ipaddr: address outside defined range");
          return (function () {
            var g, v;
            for (v = [], h = g = 0; g <= 24; h = g += 8) v.push((m >> h) & 255);
            return v;
          })().reverse();
        } else return null;
      }),
      (n.IPv6 = (function () {
        function f(u, d) {
          var p, h, m, g, v, y;
          if (u.length === 16)
            for (this.parts = [], p = h = 0; h <= 14; p = h += 2)
              this.parts.push((u[p] << 8) | u[p + 1]);
          else if (u.length === 8) this.parts = u;
          else throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          for (y = this.parts, m = 0, g = y.length; m < g; m++)
            if (((v = y[m]), !(0 <= v && v <= 65535)))
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          d && (this.zoneId = d);
        }
        return (
          (f.prototype.kind = function () {
            return "ipv6";
          }),
          (f.prototype.toString = function () {
            return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
          }),
          (f.prototype.toRFC5952String = function () {
            var u, d, p, h, m;
            for (
              h = /((^|:)(0(:|$)){2,})/g,
                m = this.toNormalizedString(),
                u = 0,
                d = -1;
              (p = h.exec(m));

            )
              p[0].length > d && ((u = p.index), (d = p[0].length));
            return d < 0 ? m : m.substring(0, u) + "::" + m.substring(u + d);
          }),
          (f.prototype.toByteArray = function () {
            var u, d, p, h, m;
            for (u = [], m = this.parts, d = 0, p = m.length; d < p; d++)
              (h = m[d]), u.push(h >> 8), u.push(h & 255);
            return u;
          }),
          (f.prototype.toNormalizedString = function () {
            var u, d, p;
            return (
              (u = function () {
                var h, m, g, v;
                for (g = this.parts, v = [], h = 0, m = g.length; h < m; h++)
                  (d = g[h]), v.push(d.toString(16));
                return v;
              }
                .call(this)
                .join(":")),
              (p = ""),
              this.zoneId && (p = "%" + this.zoneId),
              u + p
            );
          }),
          (f.prototype.toFixedLengthString = function () {
            var u, d, p;
            return (
              (u = function () {
                var h, m, g, v;
                for (g = this.parts, v = [], h = 0, m = g.length; h < m; h++)
                  (d = g[h]), v.push(d.toString(16).padStart(4, "0"));
                return v;
              }
                .call(this)
                .join(":")),
              (p = ""),
              this.zoneId && (p = "%" + this.zoneId),
              u + p
            );
          }),
          (f.prototype.match = function (u, d) {
            var p;
            if (
              (d === void 0 && ((p = u), (u = p[0]), (d = p[1])),
              u.kind() !== "ipv6")
            )
              throw new Error(
                "ipaddr: cannot match ipv6 address with non-ipv6 one",
              );
            return o(this.parts, u.parts, 16, d);
          }),
          (f.prototype.SpecialRanges = {
            unspecified: [new f([0, 0, 0, 0, 0, 0, 0, 0]), 128],
            linkLocal: [new f([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
            multicast: [new f([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
            loopback: [new f([0, 0, 0, 0, 0, 0, 0, 1]), 128],
            uniqueLocal: [new f([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
            ipv4Mapped: [new f([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
            rfc6145: [new f([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
            rfc6052: [new f([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
            "6to4": [new f([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
            teredo: [new f([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
            reserved: [[new f([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]],
          }),
          (f.prototype.range = function () {
            return n.subnetMatch(this, this.SpecialRanges);
          }),
          (f.prototype.isIPv4MappedAddress = function () {
            return this.range() === "ipv4Mapped";
          }),
          (f.prototype.toIPv4Address = function () {
            var u, d, p;
            if (!this.isIPv4MappedAddress())
              throw new Error(
                "ipaddr: trying to convert a generic ipv6 address to ipv4",
              );
            return (
              (p = this.parts.slice(-2)),
              (u = p[0]),
              (d = p[1]),
              new n.IPv4([u >> 8, u & 255, d >> 8, d & 255])
            );
          }),
          (f.prototype.prefixLengthFromSubnetMask = function () {
            var u, d, p, h, m, g, v;
            for (
              v = {
                0: 16,
                32768: 15,
                49152: 14,
                57344: 13,
                61440: 12,
                63488: 11,
                64512: 10,
                65024: 9,
                65280: 8,
                65408: 7,
                65472: 6,
                65504: 5,
                65520: 4,
                65528: 3,
                65532: 2,
                65534: 1,
                65535: 0,
              },
                u = 0,
                m = !1,
                d = p = 7;
              p >= 0;
              d = p += -1
            )
              if (((h = this.parts[d]), h in v)) {
                if (((g = v[h]), m && g !== 0)) return null;
                g !== 16 && (m = !0), (u += g);
              } else return null;
            return 128 - u;
          }),
          f
        );
      })()),
      (a = "(?:[0-9a-f]+::?)+"),
      (l = "%[0-9a-z]{1,}"),
      (s = {
        zoneIndex: new RegExp(l, "i"),
        native: new RegExp(
          "^(::)?(" + a + ")?([0-9a-f]+)?(::)?(" + l + ")?$",
          "i",
        ),
        transitional: new RegExp(
          "^((?:" +
            a +
            ")|(?:::)(?:" +
            a +
            ")?)" +
            (r + "\\." + r + "\\." + r + "\\." + r) +
            ("(" + l + ")?$"),
          "i",
        ),
      }),
      (t = function (f, u) {
        var d, p, h, m, g, v;
        if (f.indexOf("::") !== f.lastIndexOf("::")) return null;
        for (
          v = (f.match(s.zoneIndex) || [])[0],
            v && ((v = v.substring(1)), (f = f.replace(/%.+$/, ""))),
            d = 0,
            p = -1;
          (p = f.indexOf(":", p + 1)) >= 0;

        )
          d++;
        if (
          (f.substr(0, 2) === "::" && d--,
          f.substr(-2, 2) === "::" && d--,
          d > u)
        )
          return null;
        for (g = u - d, m = ":"; g--; ) m += "0:";
        return (
          (f = f.replace("::", m)),
          f[0] === ":" && (f = f.slice(1)),
          f[f.length - 1] === ":" && (f = f.slice(0, -1)),
          (u = (function () {
            var y, _, E, R;
            for (E = f.split(":"), R = [], y = 0, _ = E.length; y < _; y++)
              (h = E[y]), R.push(parseInt(h, 16));
            return R;
          })()),
          { parts: u, zoneId: v }
        );
      }),
      (n.IPv6.parser = function (f) {
        var u, d, p, h, m, g, v;
        if (s.native.test(f)) return t(f, 8);
        if (
          (h = f.match(s.transitional)) &&
          ((v = h[6] || ""), (u = t(h[1].slice(0, -1) + v, 6)), u.parts)
        ) {
          for (
            g = [
              parseInt(h[2]),
              parseInt(h[3]),
              parseInt(h[4]),
              parseInt(h[5]),
            ],
              d = 0,
              p = g.length;
            d < p;
            d++
          )
            if (((m = g[d]), !(0 <= m && m <= 255))) return null;
          return (
            u.parts.push((g[0] << 8) | g[1]),
            u.parts.push((g[2] << 8) | g[3]),
            { parts: u.parts, zoneId: u.zoneId }
          );
        }
        return null;
      }),
      (n.IPv4.isIPv4 = n.IPv6.isIPv6 =
        function (f) {
          return this.parser(f) !== null;
        }),
      (n.IPv4.isValid = function (f) {
        try {
          return new this(this.parser(f)), !0;
        } catch {
          return !1;
        }
      }),
      (n.IPv4.isValidFourPartDecimal = function (f) {
        return !!(
          n.IPv4.isValid(f) && f.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)
        );
      }),
      (n.IPv6.isValid = function (f) {
        var u;
        if (typeof f == "string" && f.indexOf(":") === -1) return !1;
        try {
          return (u = this.parser(f)), new this(u.parts, u.zoneId), !0;
        } catch {
          return !1;
        }
      }),
      (n.IPv4.parse = function (f) {
        var u;
        if (((u = this.parser(f)), u === null))
          throw new Error("ipaddr: string is not formatted like ip address");
        return new this(u);
      }),
      (n.IPv6.parse = function (f) {
        var u;
        if (((u = this.parser(f)), u.parts === null))
          throw new Error("ipaddr: string is not formatted like ip address");
        return new this(u.parts, u.zoneId);
      }),
      (n.IPv4.parseCIDR = function (f) {
        var u, d, p;
        if (
          (d = f.match(/^(.+)\/(\d+)$/)) &&
          ((u = parseInt(d[2])), u >= 0 && u <= 32)
        )
          return (
            (p = [this.parse(d[1]), u]),
            Object.defineProperty(p, "toString", {
              value: function () {
                return this.join("/");
              },
            }),
            p
          );
        throw new Error(
          "ipaddr: string is not formatted like an IPv4 CIDR range",
        );
      }),
      (n.IPv4.subnetMaskFromPrefixLength = function (f) {
        var u, d, p;
        if (((f = parseInt(f)), f < 0 || f > 32))
          throw new Error("ipaddr: invalid IPv4 prefix length");
        for (p = [0, 0, 0, 0], d = 0, u = Math.floor(f / 8); d < u; )
          (p[d] = 255), d++;
        return (
          u < 4 && (p[u] = (Math.pow(2, f % 8) - 1) << (8 - (f % 8))),
          new this(p)
        );
      }),
      (n.IPv4.broadcastAddressFromCIDR = function (f) {
        var u, d, p, h, m;
        try {
          for (
            u = this.parseCIDR(f),
              p = u[0].toByteArray(),
              m = this.subnetMaskFromPrefixLength(u[1]).toByteArray(),
              h = [],
              d = 0;
            d < 4;

          )
            h.push(parseInt(p[d], 10) | (parseInt(m[d], 10) ^ 255)), d++;
          return new this(h);
        } catch {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      }),
      (n.IPv4.networkAddressFromCIDR = function (f) {
        var u, d, p, h, m;
        try {
          for (
            u = this.parseCIDR(f),
              p = u[0].toByteArray(),
              m = this.subnetMaskFromPrefixLength(u[1]).toByteArray(),
              h = [],
              d = 0;
            d < 4;

          )
            h.push(parseInt(p[d], 10) & parseInt(m[d], 10)), d++;
          return new this(h);
        } catch {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      }),
      (n.IPv6.parseCIDR = function (f) {
        var u, d, p;
        if (
          (d = f.match(/^(.+)\/(\d+)$/)) &&
          ((u = parseInt(d[2])), u >= 0 && u <= 128)
        )
          return (
            (p = [this.parse(d[1]), u]),
            Object.defineProperty(p, "toString", {
              value: function () {
                return this.join("/");
              },
            }),
            p
          );
        throw new Error(
          "ipaddr: string is not formatted like an IPv6 CIDR range",
        );
      }),
      (n.isValid = function (f) {
        return n.IPv6.isValid(f) || n.IPv4.isValid(f);
      }),
      (n.parse = function (f) {
        if (n.IPv6.isValid(f)) return n.IPv6.parse(f);
        if (n.IPv4.isValid(f)) return n.IPv4.parse(f);
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }),
      (n.parseCIDR = function (f) {
        try {
          return n.IPv6.parseCIDR(f);
        } catch {
          try {
            return n.IPv4.parseCIDR(f);
          } catch {
            throw new Error(
              "ipaddr: the address has neither IPv6 nor IPv4 CIDR format",
            );
          }
        }
      }),
      (n.fromByteArray = function (f) {
        var u;
        if (((u = f.length), u === 4)) return new n.IPv4(f);
        if (u === 16) return new n.IPv6(f);
        throw new Error(
          "ipaddr: the binary input is neither an IPv6 nor IPv4 address",
        );
      }),
      (n.process = function (f) {
        var u;
        return (
          (u = this.parse(f)),
          u.kind() === "ipv6" && u.isIPv4MappedAddress() ? u.toIPv4Address() : u
        );
      });
  }).call(Tn);
})(_v);
var D3 = _v.exports;
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ Xd.exports = H3;
Xd.exports.all = R$;
Xd.exports.compile = k$;
var L3 = T3,
  C$ = D3,
  B3 = /^[0-9]+$/,
  od = C$.isValid,
  Jd = C$.parse,
  W_ = {
    linklocal: ["169.254.0.0/16", "fe80::/10"],
    loopback: ["127.0.0.1/8", "::1/128"],
    uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"],
  };
function R$(e, t) {
  var n = L3(e);
  if (!t) return n;
  typeof t != "function" && (t = k$(t));
  for (var r = 0; r < n.length - 1; r++) t(n[r], r) || (n.length = r + 1);
  return n;
}
function k$(e) {
  if (!e) throw new TypeError("argument is required");
  var t;
  if (typeof e == "string") t = [e];
  else if (Array.isArray(e)) t = e.slice();
  else throw new TypeError("unsupported trust argument");
  for (var n = 0; n < t.length; n++)
    (e = t[n]),
      Object.prototype.hasOwnProperty.call(W_, e) &&
        ((e = W_[e]), t.splice.apply(t, [n, 1].concat(e)), (n += e.length - 1));
  return F3(U3(t));
}
function U3(e) {
  for (var t = new Array(e.length), n = 0; n < e.length; n++) t[n] = j3(e[n]);
  return t;
}
function F3(e) {
  var t = e.length;
  return t === 0 ? q3 : t === 1 ? Q3(e[0]) : G3(e);
}
function j3(e) {
  var t = e.lastIndexOf("/"),
    n = t !== -1 ? e.substring(0, t) : e;
  if (!od(n)) throw new TypeError("invalid IP address: " + n);
  var r = Jd(n);
  t === -1 &&
    r.kind() === "ipv6" &&
    r.isIPv4MappedAddress() &&
    (r = r.toIPv4Address());
  var i = r.kind() === "ipv6" ? 128 : 32,
    a = t !== -1 ? e.substring(t + 1, e.length) : null;
  if (
    (a === null
      ? (a = i)
      : B3.test(a)
      ? (a = parseInt(a, 10))
      : r.kind() === "ipv4" && od(a)
      ? (a = M3(a))
      : (a = null),
    a <= 0 || a > i)
  )
    throw new TypeError("invalid range on address: " + e);
  return [r, a];
}
function M3(e) {
  var t = Jd(e),
    n = t.kind();
  return n === "ipv4" ? t.prefixLengthFromSubnetMask() : null;
}
function H3(e, t) {
  if (!e) throw new TypeError("req argument is required");
  if (!t) throw new TypeError("trust argument is required");
  var n = R$(e, t),
    r = n[n.length - 1];
  return r;
}
function q3() {
  return !1;
}
function G3(e) {
  return function (n) {
    if (!od(n)) return !1;
    for (var r = Jd(n), i, a = r.kind(), s = 0; s < e.length; s++) {
      var o = e[s],
        c = o[0],
        l = c.kind(),
        f = o[1],
        u = r;
      if (a !== l) {
        if (l === "ipv4" && !r.isIPv4MappedAddress()) continue;
        i || (i = l === "ipv4" ? r.toIPv4Address() : r.toIPv4MappedAddress()),
          (u = i);
      }
      if (u.match(c, f)) return !0;
    }
    return !1;
  };
}
function Q3(e) {
  var t = e[0],
    n = t.kind(),
    r = n === "ipv4",
    i = e[1];
  return function (s) {
    if (!od(s)) return !1;
    var o = Jd(s),
      c = o.kind();
    if (c !== n) {
      if (r && !o.isIPv4MappedAddress()) return !1;
      o = r ? o.toIPv4Address() : o.toIPv4MappedAddress();
    }
    return o.match(t, i);
  };
}
var T$ = Xd.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e) {
  var t = mv.Buffer,
    n = v$,
    r = zs(),
    i = wi("express"),
    a = zd,
    s = bv.mime,
    o = b$,
    c = T$,
    l = dv,
    f = X0;
  (e.etag = d({ weak: !1 })),
    (e.wetag = d({ weak: !0 })),
    (e.isAbsolute = function (m) {
      if (
        m[0] === "/" ||
        (m[1] === ":" && (m[2] === "\\" || m[2] === "/")) ||
        m.substring(0, 2) === "\\\\"
      )
        return !0;
    }),
    (e.flatten = i.function(
      a,
      "utils.flatten: use array-flatten npm module instead",
    )),
    (e.normalizeType = function (m) {
      return ~m.indexOf("/") ? u(m) : { value: s.lookup(m), params: {} };
    }),
    (e.normalizeTypes = function (m) {
      for (var g = [], v = 0; v < m.length; ++v) g.push(e.normalizeType(m[v]));
      return g;
    }),
    (e.contentDisposition = i.function(
      n,
      "utils.contentDisposition: use content-disposition npm module instead",
    ));
  function u(m, g) {
    for (
      var v = m.split(/ *; */),
        y = { value: v[0], quality: 1, params: {}, originalIndex: g },
        _ = 1;
      _ < v.length;
      ++_
    ) {
      var E = v[_].split(/ *= */);
      E[0] === "q" ? (y.quality = parseFloat(E[1])) : (y.params[E[0]] = E[1]);
    }
    return y;
  }
  (e.compileETag = function (m) {
    var g;
    if (typeof m == "function") return m;
    switch (m) {
      case !0:
      case "weak":
        g = e.wetag;
        break;
      case !1:
        break;
      case "strong":
        g = e.etag;
        break;
      default:
        throw new TypeError("unknown value for etag function: " + m);
    }
    return g;
  }),
    (e.compileQueryParser = function (g) {
      var v;
      if (typeof g == "function") return g;
      switch (g) {
        case !0:
        case "simple":
          v = f.parse;
          break;
        case !1:
          v = h;
          break;
        case "extended":
          v = p;
          break;
        default:
          throw new TypeError("unknown value for query parser function: " + g);
      }
      return v;
    }),
    (e.compileTrust = function (m) {
      return typeof m == "function"
        ? m
        : m === !0
        ? function () {
            return !0;
          }
        : typeof m == "number"
        ? function (g, v) {
            return v < m;
          }
        : (typeof m == "string" &&
            (m = m.split(",").map(function (g) {
              return g.trim();
            })),
          c.compile(m || []));
    }),
    (e.setCharset = function (g, v) {
      if (!g || !v) return g;
      var y = r.parse(g);
      return (y.parameters.charset = v), r.format(y);
    });
  function d(m) {
    return function (v, y) {
      var _ = t.isBuffer(v) ? v : t.from(v, y);
      return o(_, m);
    };
  }
  function p(m) {
    return l.parse(m, { allowPrototypes: !0 });
  }
  function h() {
    return {};
  }
})(Ha);
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e, t) {
  var n = N8,
    r = l$,
    i = hv,
    a = u$,
    s = f$,
    o = ma("express:application"),
    c = y6,
    l = Ws,
    f = Ha.compileETag,
    u = Ha.compileQueryParser,
    d = Ha.compileTrust,
    p = wi("express"),
    h = zd,
    m = Kd,
    g = pt.resolve,
    v = Md,
    y = Object.prototype.hasOwnProperty,
    _ = Array.prototype.slice,
    E = (e.exports = {}),
    R = "@@symbol:trust_proxy_default";
  (E.init = function () {
    (this.cache = {}),
      (this.engines = {}),
      (this.settings = {}),
      this.defaultConfiguration();
  }),
    (E.defaultConfiguration = function () {
      var w = process.env.NODE_ENV || "development";
      this.enable("x-powered-by"),
        this.set("etag", "weak"),
        this.set("env", w),
        this.set("query parser", "extended"),
        this.set("subdomain offset", 2),
        this.set("trust proxy", !1),
        Object.defineProperty(this.settings, R, {
          configurable: !0,
          value: !0,
        }),
        o("booting in %s mode", w),
        this.on("mount", function (Q) {
          this.settings[R] === !0 &&
            typeof Q.settings["trust proxy fn"] == "function" &&
            (delete this.settings["trust proxy"],
            delete this.settings["trust proxy fn"]),
            v(this.request, Q.request),
            v(this.response, Q.response),
            v(this.engines, Q.engines),
            v(this.settings, Q.settings);
        }),
        (this.locals = Object.create(null)),
        (this.mountpath = "/"),
        (this.locals.settings = this.settings),
        this.set("view", c),
        this.set("views", g("views")),
        this.set("jsonp callback name", "callback"),
        w === "production" && this.enable("view cache"),
        Object.defineProperty(this, "router", {
          get: function () {
            throw new Error(`'app.router' is deprecated!
Please see the 3.x to 4.x migration guide for details on how to update your app.`);
          },
        });
    }),
    (E.lazyrouter = function () {
      this._router ||
        ((this._router = new r({
          caseSensitive: this.enabled("case sensitive routing"),
          strict: this.enabled("strict routing"),
        })),
        this._router.use(s(this.get("query parser fn"))),
        this._router.use(a.init(this)));
    }),
    (E.handle = function (w, O, Q) {
      var j = this._router,
        H = Q || n(w, O, { env: this.get("env"), onerror: A.bind(this) });
      if (!j) {
        o("no routes defined on app"), H();
        return;
      }
      j.handle(w, O, H);
    }),
    (E.use = function (w) {
      var O = 0,
        Q = "/";
      if (typeof w != "function") {
        for (var j = w; Array.isArray(j) && j.length !== 0; ) j = j[0];
        typeof j != "function" && ((O = 1), (Q = w));
      }
      var H = h(_.call(arguments, O));
      if (H.length === 0)
        throw new TypeError("app.use() requires a middleware function");
      this.lazyrouter();
      var q = this._router;
      return (
        H.forEach(function (J) {
          if (!J || !J.handle || !J.set) return q.use(Q, J);
          o(".use app under %s", Q),
            (J.mountpath = Q),
            (J.parent = this),
            q.use(Q, function (z, U, G) {
              var L = z.app;
              J.handle(z, U, function (k) {
                v(z, L.request), v(U, L.response), G(k);
              });
            }),
            J.emit("mount", this);
        }, this),
        this
      );
    }),
    (E.route = function (w) {
      return this.lazyrouter(), this._router.route(w);
    }),
    (E.engine = function (w, O) {
      if (typeof O != "function") throw new Error("callback function required");
      var Q = w[0] !== "." ? "." + w : w;
      return (this.engines[Q] = O), this;
    }),
    (E.param = function (w, O) {
      if ((this.lazyrouter(), Array.isArray(w))) {
        for (var Q = 0; Q < w.length; Q++) this.param(w[Q], O);
        return this;
      }
      return this._router.param(w, O), this;
    }),
    (E.set = function (w, O) {
      if (arguments.length === 1) {
        for (var Q = this.settings; Q && Q !== Object.prototype; ) {
          if (y.call(Q, w)) return Q[w];
          Q = Object.getPrototypeOf(Q);
        }
        return;
      }
      switch ((o('set "%s" to %o', w, O), (this.settings[w] = O), w)) {
        case "etag":
          this.set("etag fn", f(O));
          break;
        case "query parser":
          this.set("query parser fn", u(O));
          break;
        case "trust proxy":
          this.set("trust proxy fn", d(O)),
            Object.defineProperty(this.settings, R, {
              configurable: !0,
              value: !1,
            });
          break;
      }
      return this;
    }),
    (E.path = function () {
      return this.parent ? this.parent.path() + this.mountpath : "";
    }),
    (E.enabled = function (w) {
      return !!this.set(w);
    }),
    (E.disabled = function (w) {
      return !this.set(w);
    }),
    (E.enable = function (w) {
      return this.set(w, !0);
    }),
    (E.disable = function (w) {
      return this.set(w, !1);
    }),
    i.forEach(function (S) {
      E[S] = function (w) {
        if (S === "get" && arguments.length === 1) return this.set(w);
        this.lazyrouter();
        var O = this._router.route(w);
        return O[S].apply(O, _.call(arguments, 1)), this;
      };
    }),
    (E.all = function (w) {
      this.lazyrouter();
      for (
        var O = this._router.route(w), Q = _.call(arguments, 1), j = 0;
        j < i.length;
        j++
      )
        O[i[j]].apply(O, Q);
      return this;
    }),
    (E.del = p.function(E.delete, "app.del: Use app.delete instead")),
    (E.render = function (w, O, Q) {
      var j = this.cache,
        H = Q,
        q = this.engines,
        J = O,
        Z = {},
        z;
      if (
        (typeof O == "function" && ((H = O), (J = {})),
        m(Z, this.locals),
        J._locals && m(Z, J._locals),
        m(Z, J),
        Z.cache == null && (Z.cache = this.enabled("view cache")),
        Z.cache && (z = j[w]),
        !z)
      ) {
        var U = this.get("view");
        if (
          ((z = new U(w, {
            defaultEngine: this.get("view engine"),
            root: this.get("views"),
            engines: q,
          })),
          !z.path)
        ) {
          var G =
              Array.isArray(z.root) && z.root.length > 1
                ? 'directories "' +
                  z.root.slice(0, -1).join('", "') +
                  '" or "' +
                  z.root[z.root.length - 1] +
                  '"'
                : 'directory "' + z.root + '"',
            L = new Error('Failed to lookup view "' + w + '" in views ' + G);
          return (L.view = z), H(L);
        }
        Z.cache && (j[w] = z);
      }
      I(z, Z, H);
    }),
    (E.listen = function () {
      var w = l.createServer(this);
      return w.listen.apply(w, arguments);
    });
  function A(S) {
    this.get("env") !== "test" && console.error(S.stack || S.toString());
  }
  function I(S, w, O) {
    try {
      S.render(w, O);
    } catch (Q) {
      O(Q);
    }
  }
})(MI);
var W3 = MI.exports,
  Ev = { exports: {} },
  wv = { exports: {} };
wv.exports = N$;
wv.exports.preferredCharsets = N$;
var z3 = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function K3(e) {
  for (var t = e.split(","), n = 0, r = 0; n < t.length; n++) {
    var i = V3(t[n].trim(), n);
    i && (t[r++] = i);
  }
  return (t.length = r), t;
}
function V3(e, t) {
  var n = z3.exec(e);
  if (!n) return null;
  var r = n[1],
    i = 1;
  if (n[2])
    for (var a = n[2].split(";"), s = 0; s < a.length; s++) {
      var o = a[s].trim().split("=");
      if (o[0] === "q") {
        i = parseFloat(o[1]);
        break;
      }
    }
  return { charset: r, q: i, i: t };
}
function Y3(e, t, n) {
  for (var r = { o: -1, q: 0, s: 0 }, i = 0; i < t.length; i++) {
    var a = X3(e, t[i], n);
    a && (r.s - a.s || r.q - a.q || r.o - a.o) < 0 && (r = a);
  }
  return r;
}
function X3(e, t, n) {
  var r = 0;
  if (t.charset.toLowerCase() === e.toLowerCase()) r |= 1;
  else if (t.charset !== "*") return null;
  return { i: n, o: t.i, q: t.q, s: r };
}
function N$(e, t) {
  var n = K3(e === void 0 ? "*" : e || "");
  if (!t) return n.filter(K_).sort(z_).map(J3);
  var r = t.map(function (a, s) {
    return Y3(a, n, s);
  });
  return r
    .filter(K_)
    .sort(z_)
    .map(function (a) {
      return t[r.indexOf(a)];
    });
}
function z_(e, t) {
  return t.q - e.q || t.s - e.s || e.o - t.o || e.i - t.i || 0;
}
function J3(e) {
  return e.charset;
}
function K_(e) {
  return e.q > 0;
}
var Z3 = wv.exports,
  xv = { exports: {} };
xv.exports = P$;
xv.exports.preferredEncodings = P$;
var e5 = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function t5(e) {
  for (var t = e.split(","), n = !1, r = 1, i = 0, a = 0; i < t.length; i++) {
    var s = n5(t[i].trim(), i);
    s &&
      ((t[a++] = s), (n = n || O$("identity", s)), (r = Math.min(r, s.q || 1)));
  }
  return n || (t[a++] = { encoding: "identity", q: r, i }), (t.length = a), t;
}
function n5(e, t) {
  var n = e5.exec(e);
  if (!n) return null;
  var r = n[1],
    i = 1;
  if (n[2])
    for (var a = n[2].split(";"), s = 0; s < a.length; s++) {
      var o = a[s].trim().split("=");
      if (o[0] === "q") {
        i = parseFloat(o[1]);
        break;
      }
    }
  return { encoding: r, q: i, i: t };
}
function r5(e, t, n) {
  for (var r = { o: -1, q: 0, s: 0 }, i = 0; i < t.length; i++) {
    var a = O$(e, t[i], n);
    a && (r.s - a.s || r.q - a.q || r.o - a.o) < 0 && (r = a);
  }
  return r;
}
function O$(e, t, n) {
  var r = 0;
  if (t.encoding.toLowerCase() === e.toLowerCase()) r |= 1;
  else if (t.encoding !== "*") return null;
  return { i: n, o: t.i, q: t.q, s: r };
}
function P$(e, t) {
  var n = t5(e || "");
  if (!t) return n.filter(Y_).sort(V_).map(i5);
  var r = t.map(function (a, s) {
    return r5(a, n, s);
  });
  return r
    .filter(Y_)
    .sort(V_)
    .map(function (a) {
      return t[r.indexOf(a)];
    });
}
function V_(e, t) {
  return t.q - e.q || t.s - e.s || e.o - t.o || e.i - t.i || 0;
}
function i5(e) {
  return e.encoding;
}
function Y_(e) {
  return e.q > 0;
}
var a5 = xv.exports,
  Av = { exports: {} };
Av.exports = L$;
Av.exports.preferredLanguages = L$;
var s5 = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
function o5(e) {
  for (var t = e.split(","), n = 0, r = 0; n < t.length; n++) {
    var i = D$(t[n].trim(), n);
    i && (t[r++] = i);
  }
  return (t.length = r), t;
}
function D$(e, t) {
  var n = s5.exec(e);
  if (!n) return null;
  var r = n[1],
    i = n[2],
    a = r;
  i && (a += "-" + i);
  var s = 1;
  if (n[3])
    for (var o = n[3].split(";"), c = 0; c < o.length; c++) {
      var l = o[c].split("=");
      l[0] === "q" && (s = parseFloat(l[1]));
    }
  return { prefix: r, suffix: i, q: s, i: t, full: a };
}
function c5(e, t, n) {
  for (var r = { o: -1, q: 0, s: 0 }, i = 0; i < t.length; i++) {
    var a = l5(e, t[i], n);
    a && (r.s - a.s || r.q - a.q || r.o - a.o) < 0 && (r = a);
  }
  return r;
}
function l5(e, t, n) {
  var r = D$(e);
  if (!r) return null;
  var i = 0;
  if (t.full.toLowerCase() === r.full.toLowerCase()) i |= 4;
  else if (t.prefix.toLowerCase() === r.full.toLowerCase()) i |= 2;
  else if (t.full.toLowerCase() === r.prefix.toLowerCase()) i |= 1;
  else if (t.full !== "*") return null;
  return { i: n, o: t.i, q: t.q, s: i };
}
function L$(e, t) {
  var n = o5(e === void 0 ? "*" : e || "");
  if (!t) return n.filter(J_).sort(X_).map(u5);
  var r = t.map(function (a, s) {
    return c5(a, n, s);
  });
  return r
    .filter(J_)
    .sort(X_)
    .map(function (a) {
      return t[r.indexOf(a)];
    });
}
function X_(e, t) {
  return t.q - e.q || t.s - e.s || e.o - t.o || e.i - t.i || 0;
}
function u5(e) {
  return e.full;
}
function J_(e) {
  return e.q > 0;
}
var f5 = Av.exports,
  Sv = { exports: {} };
Sv.exports = U$;
Sv.exports.preferredMediaTypes = U$;
var d5 = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
function p5(e) {
  for (var t = y5(e), n = 0, r = 0; n < t.length; n++) {
    var i = B$(t[n].trim(), n);
    i && (t[r++] = i);
  }
  return (t.length = r), t;
}
function B$(e, t) {
  var n = d5.exec(e);
  if (!n) return null;
  var r = Object.create(null),
    i = 1,
    a = n[2],
    s = n[1];
  if (n[3])
    for (var o = b5(n[3]).map(v5), c = 0; c < o.length; c++) {
      var l = o[c],
        f = l[0].toLowerCase(),
        u = l[1],
        d =
          u && u[0] === '"' && u[u.length - 1] === '"'
            ? u.substr(1, u.length - 2)
            : u;
      if (f === "q") {
        i = parseFloat(d);
        break;
      }
      r[f] = d;
    }
  return { type: s, subtype: a, params: r, q: i, i: t };
}
function h5(e, t, n) {
  for (var r = { o: -1, q: 0, s: 0 }, i = 0; i < t.length; i++) {
    var a = m5(e, t[i], n);
    a && (r.s - a.s || r.q - a.q || r.o - a.o) < 0 && (r = a);
  }
  return r;
}
function m5(e, t, n) {
  var r = B$(e),
    i = 0;
  if (!r) return null;
  if (t.type.toLowerCase() == r.type.toLowerCase()) i |= 4;
  else if (t.type != "*") return null;
  if (t.subtype.toLowerCase() == r.subtype.toLowerCase()) i |= 2;
  else if (t.subtype != "*") return null;
  var a = Object.keys(t.params);
  if (a.length > 0)
    if (
      a.every(function (s) {
        return (
          t.params[s] == "*" ||
          (t.params[s] || "").toLowerCase() == (r.params[s] || "").toLowerCase()
        );
      })
    )
      i |= 1;
    else return null;
  return { i: n, o: t.i, q: t.q, s: i };
}
function U$(e, t) {
  var n = p5(e === void 0 ? "*/*" : e || "");
  if (!t) return n.filter(eE).sort(Z_).map(g5);
  var r = t.map(function (a, s) {
    return h5(a, n, s);
  });
  return r
    .filter(eE)
    .sort(Z_)
    .map(function (a) {
      return t[r.indexOf(a)];
    });
}
function Z_(e, t) {
  return t.q - e.q || t.s - e.s || e.o - t.o || e.i - t.i || 0;
}
function g5(e) {
  return e.type + "/" + e.subtype;
}
function eE(e) {
  return e.q > 0;
}
function F$(e) {
  for (var t = 0, n = 0; (n = e.indexOf('"', n)) !== -1; ) t++, n++;
  return t;
}
function v5(e) {
  var t = e.indexOf("="),
    n,
    r;
  return (
    t === -1 ? (n = e) : ((n = e.substr(0, t)), (r = e.substr(t + 1))), [n, r]
  );
}
function y5(e) {
  for (var t = e.split(","), n = 1, r = 0; n < t.length; n++)
    F$(t[r]) % 2 == 0 ? (t[++r] = t[n]) : (t[r] += "," + t[n]);
  return (t.length = r + 1), t;
}
function b5(e) {
  for (var t = e.split(";"), n = 1, r = 0; n < t.length; n++)
    F$(t[r]) % 2 == 0 ? (t[++r] = t[n]) : (t[r] += ";" + t[n]);
  t.length = r + 1;
  for (var n = 0; n < t.length; n++) t[n] = t[n].trim();
  return t;
}
var _5 = Sv.exports;
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var E5 = Z3,
  w5 = a5,
  x5 = f5,
  A5 = _5;
Ev.exports = tn;
Ev.exports.Negotiator = tn;
function tn(e) {
  if (!(this instanceof tn)) return new tn(e);
  this.request = e;
}
tn.prototype.charset = function (t) {
  var n = this.charsets(t);
  return n && n[0];
};
tn.prototype.charsets = function (t) {
  return E5(this.request.headers["accept-charset"], t);
};
tn.prototype.encoding = function (t) {
  var n = this.encodings(t);
  return n && n[0];
};
tn.prototype.encodings = function (t) {
  return w5(this.request.headers["accept-encoding"], t);
};
tn.prototype.language = function (t) {
  var n = this.languages(t);
  return n && n[0];
};
tn.prototype.languages = function (t) {
  return x5(this.request.headers["accept-language"], t);
};
tn.prototype.mediaType = function (t) {
  var n = this.mediaTypes(t);
  return n && n[0];
};
tn.prototype.mediaTypes = function (t) {
  return A5(this.request.headers.accept, t);
};
tn.prototype.preferredCharset = tn.prototype.charset;
tn.prototype.preferredCharsets = tn.prototype.charsets;
tn.prototype.preferredEncoding = tn.prototype.encoding;
tn.prototype.preferredEncodings = tn.prototype.encodings;
tn.prototype.preferredLanguage = tn.prototype.language;
tn.prototype.preferredLanguages = tn.prototype.languages;
tn.prototype.preferredMediaType = tn.prototype.mediaType;
tn.prototype.preferredMediaTypes = tn.prototype.mediaTypes;
var S5 = Ev.exports;
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var I5 = S5,
  $5 = rv,
  C5 = zr;
function zr(e) {
  if (!(this instanceof zr)) return new zr(e);
  (this.headers = e.headers), (this.negotiator = new I5(e));
}
zr.prototype.type = zr.prototype.types = function (e) {
  var t = e;
  if (t && !Array.isArray(t)) {
    t = new Array(arguments.length);
    for (var n = 0; n < t.length; n++) t[n] = arguments[n];
  }
  if (!t || t.length === 0) return this.negotiator.mediaTypes();
  if (!this.headers.accept) return t[0];
  var r = t.map(R5),
    i = this.negotiator.mediaTypes(r.filter(k5)),
    a = i[0];
  return a ? t[r.indexOf(a)] : !1;
};
zr.prototype.encoding = zr.prototype.encodings = function (e) {
  var t = e;
  if (t && !Array.isArray(t)) {
    t = new Array(arguments.length);
    for (var n = 0; n < t.length; n++) t[n] = arguments[n];
  }
  return !t || t.length === 0
    ? this.negotiator.encodings()
    : this.negotiator.encodings(t)[0] || !1;
};
zr.prototype.charset = zr.prototype.charsets = function (e) {
  var t = e;
  if (t && !Array.isArray(t)) {
    t = new Array(arguments.length);
    for (var n = 0; n < t.length; n++) t[n] = arguments[n];
  }
  return !t || t.length === 0
    ? this.negotiator.charsets()
    : this.negotiator.charsets(t)[0] || !1;
};
zr.prototype.lang =
  zr.prototype.langs =
  zr.prototype.language =
  zr.prototype.languages =
    function (e) {
      var t = e;
      if (t && !Array.isArray(t)) {
        t = new Array(arguments.length);
        for (var n = 0; n < t.length; n++) t[n] = arguments[n];
      }
      return !t || t.length === 0
        ? this.negotiator.languages()
        : this.negotiator.languages(t)[0] || !1;
    };
function R5(e) {
  return e.indexOf("/") === -1 ? $5.lookup(e) : e;
}
function k5(e) {
  return typeof e == "string";
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Zd = C5,
  Zl = wi("express"),
  T5 = ha.isIP,
  N5 = ga,
  O5 = Ws,
  P5 = _$,
  D5 = E$,
  L5 = Yl,
  j$ = T$,
  rn = Object.create(O5.IncomingMessage.prototype),
  B5 = rn;
rn.get = rn.header = function (t) {
  if (!t) throw new TypeError("name argument is required to req.get");
  if (typeof t != "string")
    throw new TypeError("name must be a string to req.get");
  var n = t.toLowerCase();
  switch (n) {
    case "referer":
    case "referrer":
      return this.headers.referrer || this.headers.referer;
    default:
      return this.headers[n];
  }
};
rn.accepts = function () {
  var e = Zd(this);
  return e.types.apply(e, arguments);
};
rn.acceptsEncodings = function () {
  var e = Zd(this);
  return e.encodings.apply(e, arguments);
};
rn.acceptsEncoding = Zl.function(
  rn.acceptsEncodings,
  "req.acceptsEncoding: Use acceptsEncodings instead",
);
rn.acceptsCharsets = function () {
  var e = Zd(this);
  return e.charsets.apply(e, arguments);
};
rn.acceptsCharset = Zl.function(
  rn.acceptsCharsets,
  "req.acceptsCharset: Use acceptsCharsets instead",
);
rn.acceptsLanguages = function () {
  var e = Zd(this);
  return e.languages.apply(e, arguments);
};
rn.acceptsLanguage = Zl.function(
  rn.acceptsLanguages,
  "req.acceptsLanguage: Use acceptsLanguages instead",
);
rn.range = function (t, n) {
  var r = this.get("Range");
  if (r) return D5(t, r, n);
};
rn.param = function (t, n) {
  var r = this.params || {},
    i = this.body || {},
    a = this.query || {},
    s = arguments.length === 1 ? "name" : "name, default";
  return (
    Zl("req.param(" + s + "): Use req.params, req.body, or req.query instead"),
    r[t] != null && r.hasOwnProperty(t)
      ? r[t]
      : i[t] != null
      ? i[t]
      : a[t] != null
      ? a[t]
      : n
  );
};
rn.is = function (t) {
  var n = t;
  if (!Array.isArray(t)) {
    n = new Array(arguments.length);
    for (var r = 0; r < n.length; r++) n[r] = arguments[r];
  }
  return N5(this, n);
};
xi(rn, "protocol", function () {
  var t = this.connection.encrypted ? "https" : "http",
    n = this.app.get("trust proxy fn");
  if (!n(this.connection.remoteAddress, 0)) return t;
  var r = this.get("X-Forwarded-Proto") || t,
    i = r.indexOf(",");
  return i !== -1 ? r.substring(0, i).trim() : r.trim();
});
xi(rn, "secure", function () {
  return this.protocol === "https";
});
xi(rn, "ip", function () {
  var t = this.app.get("trust proxy fn");
  return j$(this, t);
});
xi(rn, "ips", function () {
  var t = this.app.get("trust proxy fn"),
    n = j$.all(this, t);
  return n.reverse().pop(), n;
});
xi(rn, "subdomains", function () {
  var t = this.hostname;
  if (!t) return [];
  var n = this.app.get("subdomain offset"),
    r = T5(t) ? [t] : t.split(".").reverse();
  return r.slice(n);
});
xi(rn, "path", function () {
  return L5(this).pathname;
});
xi(rn, "hostname", function () {
  var t = this.app.get("trust proxy fn"),
    n = this.get("X-Forwarded-Host");
  if (
    (!n || !t(this.connection.remoteAddress, 0)
      ? (n = this.get("Host"))
      : n.indexOf(",") !== -1 &&
        (n = n.substring(0, n.indexOf(",")).trimRight()),
    !!n)
  ) {
    var r = n[0] === "[" ? n.indexOf("]") + 1 : 0,
      i = n.indexOf(":", r);
    return i !== -1 ? n.substring(0, i) : n;
  }
});
xi(
  rn,
  "host",
  Zl.function(function () {
    return this.hostname;
  }, "req.host: Use req.hostname instead"),
);
xi(rn, "fresh", function () {
  var e = this.method,
    t = this.res,
    n = t.statusCode;
  return e !== "GET" && e !== "HEAD"
    ? !1
    : (n >= 200 && n < 300) || n === 304
    ? P5(this.headers, {
        etag: t.get("ETag"),
        "last-modified": t.get("Last-Modified"),
      })
    : !1;
});
xi(rn, "stale", function () {
  return !this.fresh;
});
xi(rn, "xhr", function () {
  var t = this.get("X-Requested-With") || "";
  return t.toLowerCase() === "xmlhttprequest";
});
function xi(e, t, n) {
  Object.defineProperty(e, t, { configurable: !0, enumerable: !0, get: n });
}
var M$ = {};
(function (e) {
  var t = pr;
  (e.sign = function (r, i) {
    if (typeof r != "string")
      throw new TypeError("Cookie value must be provided as a string.");
    if (typeof i != "string")
      throw new TypeError("Secret string must be provided.");
    return (
      r +
      "." +
      t.createHmac("sha256", i).update(r).digest("base64").replace(/\=+$/, "")
    );
  }),
    (e.unsign = function (r, i) {
      if (typeof r != "string")
        throw new TypeError("Signed cookie string must be provided.");
      if (typeof i != "string")
        throw new TypeError("Secret string must be provided.");
      var a = r.slice(0, r.lastIndexOf(".")),
        s = e.sign(a, i);
      return n(s) == n(r) ? a : !1;
    });
  function n(r) {
    return t.createHash("sha1").update(r).digest("hex");
  }
})(M$);
var Iv = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ Iv.parse = F5;
Iv.serialize = j5;
var U5 = Object.prototype.toString,
  Vu = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function F5(e, t) {
  if (typeof e != "string")
    throw new TypeError("argument str must be a string");
  for (var n = {}, r = t || {}, i = r.decode || M5, a = 0; a < e.length; ) {
    var s = e.indexOf("=", a);
    if (s === -1) break;
    var o = e.indexOf(";", a);
    if (o === -1) o = e.length;
    else if (o < s) {
      a = e.lastIndexOf(";", s - 1) + 1;
      continue;
    }
    var c = e.slice(a, s).trim();
    if (n[c] === void 0) {
      var l = e.slice(s + 1, o).trim();
      l.charCodeAt(0) === 34 && (l = l.slice(1, -1)), (n[c] = G5(l, i));
    }
    a = o + 1;
  }
  return n;
}
function j5(e, t, n) {
  var r = n || {},
    i = r.encode || H5;
  if (typeof i != "function") throw new TypeError("option encode is invalid");
  if (!Vu.test(e)) throw new TypeError("argument name is invalid");
  var a = i(t);
  if (a && !Vu.test(a)) throw new TypeError("argument val is invalid");
  var s = e + "=" + a;
  if (r.maxAge != null) {
    var o = r.maxAge - 0;
    if (isNaN(o) || !isFinite(o))
      throw new TypeError("option maxAge is invalid");
    s += "; Max-Age=" + Math.floor(o);
  }
  if (r.domain) {
    if (!Vu.test(r.domain)) throw new TypeError("option domain is invalid");
    s += "; Domain=" + r.domain;
  }
  if (r.path) {
    if (!Vu.test(r.path)) throw new TypeError("option path is invalid");
    s += "; Path=" + r.path;
  }
  if (r.expires) {
    var c = r.expires;
    if (!q5(c) || isNaN(c.valueOf()))
      throw new TypeError("option expires is invalid");
    s += "; Expires=" + c.toUTCString();
  }
  if (
    (r.httpOnly && (s += "; HttpOnly"),
    r.secure && (s += "; Secure"),
    r.priority)
  ) {
    var l =
      typeof r.priority == "string" ? r.priority.toLowerCase() : r.priority;
    switch (l) {
      case "low":
        s += "; Priority=Low";
        break;
      case "medium":
        s += "; Priority=Medium";
        break;
      case "high":
        s += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (r.sameSite) {
    var f =
      typeof r.sameSite == "string" ? r.sameSite.toLowerCase() : r.sameSite;
    switch (f) {
      case !0:
        s += "; SameSite=Strict";
        break;
      case "lax":
        s += "; SameSite=Lax";
        break;
      case "strict":
        s += "; SameSite=Strict";
        break;
      case "none":
        s += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return s;
}
function M5(e) {
  return e.indexOf("%") !== -1 ? decodeURIComponent(e) : e;
}
function H5(e) {
  return encodeURIComponent(e);
}
function q5(e) {
  return U5.call(e) === "[object Date]" || e instanceof Date;
}
function G5(e, t) {
  try {
    return t(e);
  } catch {
    return e;
  }
}
var $v = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ $v.exports = W5;
$v.exports.append = H$;
var Q5 = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function H$(e, t) {
  if (typeof e != "string") throw new TypeError("header argument is required");
  if (!t) throw new TypeError("field argument is required");
  for (var n = Array.isArray(t) ? t : tE(String(t)), r = 0; r < n.length; r++)
    if (!Q5.test(n[r]))
      throw new TypeError("field argument contains an invalid header name");
  if (e === "*") return e;
  var i = e,
    a = tE(e.toLowerCase());
  if (n.indexOf("*") !== -1 || a.indexOf("*") !== -1) return "*";
  for (var s = 0; s < n.length; s++) {
    var o = n[s].toLowerCase();
    a.indexOf(o) === -1 && (a.push(o), (i = i ? i + ", " + n[s] : n[s]));
  }
  return i;
}
function tE(e) {
  for (var t = 0, n = [], r = 0, i = 0, a = e.length; i < a; i++)
    switch (e.charCodeAt(i)) {
      case 32:
        r === t && (r = t = i + 1);
        break;
      case 44:
        n.push(e.substring(r, t)), (r = t = i + 1);
        break;
      default:
        t = i + 1;
        break;
    }
  return n.push(e.substring(r, t)), n;
}
function W5(e, t) {
  if (!e || !e.getHeader || !e.setHeader)
    throw new TypeError("res argument is required");
  var n = e.getHeader("Vary") || "",
    r = Array.isArray(n) ? n.join(", ") : String(n);
  (n = H$(r, t)) && e.setHeader("Vary", n);
}
var q$ = $v.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var tl = mv.Buffer,
  G$ = v$,
  z5 = Gi,
  vi = wi("express"),
  K5 = Qd,
  V5 = Wd,
  Y5 = Ws,
  X5 = Ha.isAbsolute,
  J5 = Kl,
  Q$ = pt,
  cd = Hd,
  W$ = Kd,
  Z5 = M$.sign,
  eD = Ha.normalizeType,
  tD = Ha.normalizeTypes,
  nD = Ha.setCharset,
  rD = Iv,
  Cv = bv,
  iD = Q$.extname,
  z$ = Cv.mime,
  aD = Q$.resolve,
  sD = q$,
  cn = Object.create(Y5.ServerResponse.prototype),
  oD = cn,
  cD = /;\s*charset\s*=/;
cn.status = function (t) {
  return (
    (typeof t == "string" || Math.floor(t) !== t) &&
      t > 99 &&
      t < 1e3 &&
      vi(
        "res.status(" +
          JSON.stringify(t) +
          "): use res.status(" +
          Math.floor(t) +
          ") instead",
      ),
    (this.statusCode = t),
    this
  );
};
cn.links = function (e) {
  var t = this.get("Link") || "";
  return (
    t && (t += ", "),
    this.set(
      "Link",
      t +
        Object.keys(e)
          .map(function (n) {
            return "<" + e[n] + '>; rel="' + n + '"';
          })
          .join(", "),
    )
  );
};
cn.send = function (t) {
  var n = t,
    r,
    i = this.req,
    a,
    s = this.app;
  switch (
    (arguments.length === 2 &&
      (typeof arguments[0] != "number" && typeof arguments[1] == "number"
        ? (vi(
            "res.send(body, status): Use res.status(status).send(body) instead",
          ),
          (this.statusCode = arguments[1]))
        : (vi(
            "res.send(status, body): Use res.status(status).send(body) instead",
          ),
          (this.statusCode = arguments[0]),
          (n = arguments[1]))),
    typeof n == "number" &&
      arguments.length === 1 &&
      (this.get("Content-Type") || this.type("txt"),
      vi("res.send(status): Use res.sendStatus(status) instead"),
      (this.statusCode = n),
      (n = cd.message[n])),
    typeof n)
  ) {
    case "string":
      this.get("Content-Type") || this.type("html");
      break;
    case "boolean":
    case "number":
    case "object":
      if (n === null) n = "";
      else if (tl.isBuffer(n)) this.get("Content-Type") || this.type("bin");
      else return this.json(n);
      break;
  }
  typeof n == "string" &&
    ((r = "utf8"),
    (a = this.get("Content-Type")),
    typeof a == "string" && this.set("Content-Type", nD(a, "utf-8")));
  var o = s.get("etag fn"),
    c = !this.get("ETag") && typeof o == "function",
    l;
  n !== void 0 &&
    (tl.isBuffer(n)
      ? (l = n.length)
      : !c && n.length < 1e3
      ? (l = tl.byteLength(n, r))
      : ((n = tl.from(n, r)), (r = void 0), (l = n.length)),
    this.set("Content-Length", l));
  var f;
  return (
    c && l !== void 0 && (f = o(n, r)) && this.set("ETag", f),
    i.fresh && (this.statusCode = 304),
    (this.statusCode === 204 || this.statusCode === 304) &&
      (this.removeHeader("Content-Type"),
      this.removeHeader("Content-Length"),
      this.removeHeader("Transfer-Encoding"),
      (n = "")),
    this.statusCode === 205 &&
      (this.set("Content-Length", "0"),
      this.removeHeader("Transfer-Encoding"),
      (n = "")),
    i.method === "HEAD" ? this.end() : this.end(n, r),
    this
  );
};
cn.json = function (t) {
  var n = t;
  arguments.length === 2 &&
    (typeof arguments[1] == "number"
      ? (vi("res.json(obj, status): Use res.status(status).json(obj) instead"),
        (this.statusCode = arguments[1]))
      : (vi("res.json(status, obj): Use res.status(status).json(obj) instead"),
        (this.statusCode = arguments[0]),
        (n = arguments[1])));
  var r = this.app,
    i = r.get("json escape"),
    a = r.get("json replacer"),
    s = r.get("json spaces"),
    o = V$(n, a, s, i);
  return (
    this.get("Content-Type") || this.set("Content-Type", "application/json"),
    this.send(o)
  );
};
cn.jsonp = function (t) {
  var n = t;
  arguments.length === 2 &&
    (typeof arguments[1] == "number"
      ? (vi(
          "res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead",
        ),
        (this.statusCode = arguments[1]))
      : (vi(
          "res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead",
        ),
        (this.statusCode = arguments[0]),
        (n = arguments[1])));
  var r = this.app,
    i = r.get("json escape"),
    a = r.get("json replacer"),
    s = r.get("json spaces"),
    o = V$(n, a, s, i),
    c = this.req.query[r.get("jsonp callback name")];
  return (
    this.get("Content-Type") ||
      (this.set("X-Content-Type-Options", "nosniff"),
      this.set("Content-Type", "application/json")),
    Array.isArray(c) && (c = c[0]),
    typeof c == "string" &&
      c.length !== 0 &&
      (this.set("X-Content-Type-Options", "nosniff"),
      this.set("Content-Type", "text/javascript"),
      (c = c.replace(/[^\[\]\w$.]/g, "")),
      o === void 0
        ? (o = "")
        : typeof o == "string" &&
          (o = o.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029")),
      (o = "/**/ typeof " + c + " === 'function' && " + c + "(" + o + ");")),
    this.send(o)
  );
};
cn.sendStatus = function (t) {
  var n = cd.message[t] || String(t);
  return (this.statusCode = t), this.type("txt"), this.send(n);
};
cn.sendFile = function (t, n, r) {
  var i = r,
    a = this.req,
    s = this,
    o = a.next,
    c = n || {};
  if (!t) throw new TypeError("path argument is required to res.sendFile");
  if (typeof t != "string")
    throw new TypeError("path must be a string to res.sendFile");
  if ((typeof n == "function" && ((i = n), (c = {})), !c.root && !X5(t)))
    throw new TypeError(
      "path must be absolute or specify root to res.sendFile",
    );
  var l = encodeURI(t),
    f = Cv(a, l, c);
  K$(s, f, c, function (u) {
    if (i) return i(u);
    if (u && u.code === "EISDIR") return o();
    u && u.code !== "ECONNABORTED" && u.syscall !== "write" && o(u);
  });
};
cn.sendfile = function (e, t, n) {
  var r = n,
    i = this.req,
    a = this,
    s = i.next,
    o = t || {};
  typeof t == "function" && ((r = t), (o = {}));
  var c = Cv(i, e, o);
  K$(a, c, o, function (l) {
    if (r) return r(l);
    if (l && l.code === "EISDIR") return s();
    l && l.code !== "ECONNABORTED" && l.syscall !== "write" && s(l);
  });
};
cn.sendfile = vi.function(
  cn.sendfile,
  "res.sendfile: Use res.sendFile instead",
);
cn.download = function (t, n, r, i) {
  var a = i,
    s = n,
    o = r || null;
  typeof n == "function"
    ? ((a = n), (s = null), (o = null))
    : typeof r == "function" && ((a = r), (o = null)),
    typeof n == "object" &&
      (typeof r == "function" || r === void 0) &&
      ((s = null), (o = n));
  var c = { "Content-Disposition": G$(s || t) };
  if (o && o.headers)
    for (var l = Object.keys(o.headers), f = 0; f < l.length; f++) {
      var u = l[f];
      u.toLowerCase() !== "content-disposition" && (c[u] = o.headers[u]);
    }
  (o = Object.create(o)), (o.headers = c);
  var d = o.root ? t : aD(t);
  return this.sendFile(d, o, a);
};
cn.contentType = cn.type = function (t) {
  var n = t.indexOf("/") === -1 ? z$.lookup(t) : t;
  return this.set("Content-Type", n);
};
cn.format = function (e) {
  var t = this.req,
    n = t.next,
    r = Object.keys(e).filter(function (a) {
      return a !== "default";
    }),
    i = r.length > 0 ? t.accepts(r) : !1;
  return (
    this.vary("Accept"),
    i
      ? (this.set("Content-Type", eD(i).value), e[i](t, this, n))
      : e.default
      ? e.default(t, this, n)
      : n(
          z5(406, {
            types: tD(r).map(function (a) {
              return a.value;
            }),
          }),
        ),
    this
  );
};
cn.attachment = function (t) {
  return t && this.type(iD(t)), this.set("Content-Disposition", G$(t)), this;
};
cn.append = function (t, n) {
  var r = this.get(t),
    i = n;
  return (
    r &&
      (i = Array.isArray(r)
        ? r.concat(n)
        : Array.isArray(n)
        ? [r].concat(n)
        : [r, n]),
    this.set(t, i)
  );
};
cn.set = cn.header = function (t, n) {
  if (arguments.length === 2) {
    var r = Array.isArray(n) ? n.map(String) : String(n);
    if (t.toLowerCase() === "content-type") {
      if (Array.isArray(r))
        throw new TypeError("Content-Type cannot be set to an Array");
      if (!cD.test(r)) {
        var i = z$.charsets.lookup(r.split(";")[0]);
        i && (r += "; charset=" + i.toLowerCase());
      }
    }
    this.setHeader(t, r);
  } else for (var a in t) this.set(a, t[a]);
  return this;
};
cn.get = function (e) {
  return this.getHeader(e);
};
cn.clearCookie = function (t, n) {
  var r = W$({ expires: new Date(1), path: "/" }, n);
  return this.cookie(t, "", r);
};
cn.cookie = function (e, t, n) {
  var r = W$({}, n),
    i = this.req.secret,
    a = r.signed;
  if (a && !i)
    throw new Error('cookieParser("secret") required for signed cookies');
  var s = typeof t == "object" ? "j:" + JSON.stringify(t) : String(t);
  if ((a && (s = "s:" + Z5(s, i)), r.maxAge != null)) {
    var o = r.maxAge - 0;
    isNaN(o) ||
      ((r.expires = new Date(Date.now() + o)),
      (r.maxAge = Math.floor(o / 1e3)));
  }
  return (
    r.path == null && (r.path = "/"),
    this.append("Set-Cookie", rD.serialize(e, String(s), r)),
    this
  );
};
cn.location = function (t) {
  var n = t;
  return (
    t === "back" && (n = this.req.get("Referrer") || "/"),
    this.set("Location", K5(n))
  );
};
cn.redirect = function (t) {
  var n = t,
    r,
    i = 302;
  arguments.length === 2 &&
    (typeof arguments[0] == "number"
      ? ((i = arguments[0]), (n = arguments[1]))
      : (vi("res.redirect(url, status): Use res.redirect(status, url) instead"),
        (i = arguments[1]))),
    (n = this.location(n).get("Location")),
    this.format({
      text: function () {
        r = cd.message[i] + ". Redirecting to " + n;
      },
      html: function () {
        var a = V5(n);
        r =
          "<p>" +
          cd.message[i] +
          '. Redirecting to <a href="' +
          a +
          '">' +
          a +
          "</a></p>";
      },
      default: function () {
        r = "";
      },
    }),
    (this.statusCode = i),
    this.set("Content-Length", tl.byteLength(r)),
    this.req.method === "HEAD" ? this.end() : this.end(r);
};
cn.vary = function (e) {
  return !e || (Array.isArray(e) && !e.length)
    ? (vi("res.vary(): Provide a field name"), this)
    : (sD(this, e), this);
};
cn.render = function (t, n, r) {
  var i = this.req.app,
    a = r,
    s = n || {},
    o = this.req,
    c = this;
  typeof n == "function" && ((a = n), (s = {})),
    (s._locals = c.locals),
    (a =
      a ||
      function (l, f) {
        if (l) return o.next(l);
        c.send(f);
      }),
    i.render(t, s, a);
};
function K$(e, t, n, r) {
  var i = !1,
    a;
  function s() {
    if (!i) {
      i = !0;
      var p = new Error("Request aborted");
      (p.code = "ECONNABORTED"), r(p);
    }
  }
  function o() {
    if (!i) {
      i = !0;
      var p = new Error("EISDIR, read");
      (p.code = "EISDIR"), r(p);
    }
  }
  function c(p) {
    i || ((i = !0), r(p));
  }
  function l() {
    i || ((i = !0), r());
  }
  function f() {
    a = !1;
  }
  function u(p) {
    if (p && p.code === "ECONNRESET") return s();
    if (p) return c(p);
    i ||
      setImmediate(function () {
        if (a !== !1 && !i) {
          s();
          return;
        }
        i || ((i = !0), r());
      });
  }
  function d() {
    a = !0;
  }
  t.on("directory", o),
    t.on("end", l),
    t.on("error", c),
    t.on("file", f),
    t.on("stream", d),
    J5(e, u),
    n.headers &&
      t.on("headers", function (h) {
        for (var m = n.headers, g = Object.keys(m), v = 0; v < g.length; v++) {
          var y = g[v];
          h.setHeader(y, m[y]);
        }
      }),
    t.pipe(e);
}
function V$(e, t, n, r) {
  var i = t || n ? JSON.stringify(e, t, n) : JSON.stringify(e);
  return (
    r &&
      typeof i == "string" &&
      (i = i.replace(/[<>&]/g, function (a) {
        switch (a.charCodeAt(0)) {
          case 60:
            return "\\u003c";
          case 62:
            return "\\u003e";
          case 38:
            return "\\u0026";
          default:
            return a;
        }
      })),
    i
  );
}
var Yu = { exports: {} };
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var nE;
function lD() {
  if (nE) return Yu.exports;
  nE = 1;
  var e = Qd,
    t = Wd,
    n = Yl,
    r = pt.resolve,
    i = bv,
    a = Ya;
  (Yu.exports = s), (Yu.exports.mime = i.mime);
  function s(u, d) {
    if (!u) throw new TypeError("root path required");
    if (typeof u != "string") throw new TypeError("root path must be a string");
    var p = Object.create(d || null),
      h = p.fallthrough !== !1,
      m = p.redirect !== !1,
      g = p.setHeaders;
    if (g && typeof g != "function")
      throw new TypeError("option setHeaders must be function");
    (p.maxage = p.maxage || p.maxAge || 0), (p.root = r(u));
    var v = m ? f() : l();
    return function (_, E, R) {
      if (_.method !== "GET" && _.method !== "HEAD") {
        if (h) return R();
        (E.statusCode = 405),
          E.setHeader("Allow", "GET, HEAD"),
          E.setHeader("Content-Length", "0"),
          E.end();
        return;
      }
      var A = !h,
        I = n.original(_),
        S = n(_).pathname;
      S === "/" && I.pathname.substr(-1) !== "/" && (S = "");
      var w = i(_, S, p);
      w.on("directory", v),
        g && w.on("headers", g),
        h &&
          w.on("file", function () {
            A = !0;
          }),
        w.on("error", function (Q) {
          if (A || !(Q.statusCode < 500)) {
            R(Q);
            return;
          }
          R();
        }),
        w.pipe(E);
    };
  }
  function o(u) {
    for (var d = 0; d < u.length && u.charCodeAt(d) === 47; d++);
    return d > 1 ? "/" + u.substr(d) : u;
  }
  function c(u, d) {
    return (
      `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>` +
      u +
      `</title>
</head>
<body>
<pre>` +
      d +
      `</pre>
</body>
</html>
`
    );
  }
  function l() {
    return function () {
      this.error(404);
    };
  }
  function f() {
    return function (d) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var p = n.original(this.req);
      (p.path = null), (p.pathname = o(p.pathname + "/"));
      var h = e(a.format(p)),
        m = c(
          "Redirecting",
          'Redirecting to <a href="' + t(h) + '">' + t(h) + "</a>",
        );
      (d.statusCode = 301),
        d.setHeader("Content-Type", "text/html; charset=UTF-8"),
        d.setHeader("Content-Length", Buffer.byteLength(m)),
        d.setHeader("Content-Security-Policy", "default-src 'none'"),
        d.setHeader("X-Content-Type-Options", "nosniff"),
        d.setHeader("Location", h),
        d.end(m);
    };
  }
  return Yu.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e, t) {
  var n = c8,
    r = Hi.EventEmitter,
    i = l8,
    a = W3,
    s = a$,
    o = l$,
    c = B5,
    l = oD;
  t = e.exports = f;
  function f() {
    var d = function (p, h, m) {
      d.handle(p, h, m);
    };
    return (
      i(d, r.prototype, !1),
      i(d, a, !1),
      (d.request = Object.create(c, {
        app: { configurable: !0, enumerable: !0, writable: !0, value: d },
      })),
      (d.response = Object.create(l, {
        app: { configurable: !0, enumerable: !0, writable: !0, value: d },
      })),
      d.init(),
      d
    );
  }
  (t.application = a),
    (t.request = c),
    (t.response = l),
    (t.Route = s),
    (t.Router = o),
    (t.json = n.json),
    (t.query = f$),
    (t.raw = n.raw),
    (t.static = lD()),
    (t.text = n.text),
    (t.urlencoded = n.urlencoded);
  var u = [
    "bodyParser",
    "compress",
    "cookieSession",
    "session",
    "logger",
    "cookieParser",
    "favicon",
    "responseTime",
    "errorHandler",
    "timeout",
    "methodOverride",
    "vhost",
    "csrf",
    "directory",
    "limit",
    "multipart",
    "staticCache",
  ];
  u.forEach(function (d) {
    Object.defineProperty(t, d, {
      get: function () {
        throw new Error(
          "Most middleware (like " +
            d +
            ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.",
        );
      },
      configurable: !0,
    });
  });
})(Ug, Ug.exports);
var uD = Ug.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var fD = uD;
const dD = Wl(fD);
var t0 = { exports: {} },
  Xu = { exports: {} },
  Ju = { exports: {} },
  Zu = { exports: {} },
  Uh,
  rE;
function pD() {
  if (rE) return Uh;
  rE = 1;
  var e = 1e3,
    t = e * 60,
    n = t * 60,
    r = n * 24,
    i = r * 365.25;
  Uh = function (l, f) {
    f = f || {};
    var u = typeof l;
    if (u === "string" && l.length > 0) return a(l);
    if (u === "number" && isNaN(l) === !1) return f.long ? o(l) : s(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(l),
    );
  };
  function a(l) {
    if (((l = String(l)), !(l.length > 100))) {
      var f =
        /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
          l,
        );
      if (f) {
        var u = parseFloat(f[1]),
          d = (f[2] || "ms").toLowerCase();
        switch (d) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return u * i;
          case "days":
          case "day":
          case "d":
            return u * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return u * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return u * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return u * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return u;
          default:
            return;
        }
      }
    }
  }
  function s(l) {
    return l >= r
      ? Math.round(l / r) + "d"
      : l >= n
      ? Math.round(l / n) + "h"
      : l >= t
      ? Math.round(l / t) + "m"
      : l >= e
      ? Math.round(l / e) + "s"
      : l + "ms";
  }
  function o(l) {
    return (
      c(l, r, "day") ||
      c(l, n, "hour") ||
      c(l, t, "minute") ||
      c(l, e, "second") ||
      l + " ms"
    );
  }
  function c(l, f, u) {
    if (!(l < f))
      return l < f * 1.5
        ? Math.floor(l / f) + " " + u
        : Math.ceil(l / f) + " " + u + "s";
  }
  return Uh;
}
var iE;
function Y$() {
  return (
    iE ||
      ((iE = 1),
      (function (e, t) {
        (t = e.exports = i.debug = i.default = i),
          (t.coerce = c),
          (t.disable = s),
          (t.enable = a),
          (t.enabled = o),
          (t.humanize = pD()),
          (t.names = []),
          (t.skips = []),
          (t.formatters = {});
        var n;
        function r(l) {
          var f = 0,
            u;
          for (u in l) (f = (f << 5) - f + l.charCodeAt(u)), (f |= 0);
          return t.colors[Math.abs(f) % t.colors.length];
        }
        function i(l) {
          function f() {
            if (f.enabled) {
              var u = f,
                d = +new Date(),
                p = d - (n || d);
              (u.diff = p), (u.prev = n), (u.curr = d), (n = d);
              for (
                var h = new Array(arguments.length), m = 0;
                m < h.length;
                m++
              )
                h[m] = arguments[m];
              (h[0] = t.coerce(h[0])),
                typeof h[0] != "string" && h.unshift("%O");
              var g = 0;
              (h[0] = h[0].replace(/%([a-zA-Z%])/g, function (y, _) {
                if (y === "%%") return y;
                g++;
                var E = t.formatters[_];
                if (typeof E == "function") {
                  var R = h[g];
                  (y = E.call(u, R)), h.splice(g, 1), g--;
                }
                return y;
              })),
                t.formatArgs.call(u, h);
              var v = f.log || t.log || console.log.bind(console);
              v.apply(u, h);
            }
          }
          return (
            (f.namespace = l),
            (f.enabled = t.enabled(l)),
            (f.useColors = t.useColors()),
            (f.color = r(l)),
            typeof t.init == "function" && t.init(f),
            f
          );
        }
        function a(l) {
          t.save(l), (t.names = []), (t.skips = []);
          for (
            var f = (typeof l == "string" ? l : "").split(/[\s,]+/),
              u = f.length,
              d = 0;
            d < u;
            d++
          )
            f[d] &&
              ((l = f[d].replace(/\*/g, ".*?")),
              l[0] === "-"
                ? t.skips.push(new RegExp("^" + l.substr(1) + "$"))
                : t.names.push(new RegExp("^" + l + "$")));
        }
        function s() {
          t.enable("");
        }
        function o(l) {
          var f, u;
          for (f = 0, u = t.skips.length; f < u; f++)
            if (t.skips[f].test(l)) return !1;
          for (f = 0, u = t.names.length; f < u; f++)
            if (t.names[f].test(l)) return !0;
          return !1;
        }
        function c(l) {
          return l instanceof Error ? l.stack || l.message : l;
        }
      })(Zu, Zu.exports)),
    Zu.exports
  );
}
var aE;
function hD() {
  return (
    aE ||
      ((aE = 1),
      (function (e, t) {
        (t = e.exports = Y$()),
          (t.log = i),
          (t.formatArgs = r),
          (t.save = a),
          (t.load = s),
          (t.useColors = n),
          (t.storage =
            typeof chrome < "u" && typeof chrome.storage < "u"
              ? chrome.storage.local
              : o()),
          (t.colors = [
            "lightseagreen",
            "forestgreen",
            "goldenrod",
            "dodgerblue",
            "darkorchid",
            "crimson",
          ]);
        function n() {
          return typeof window < "u" &&
            window.process &&
            window.process.type === "renderer"
            ? !0
            : (typeof document < "u" &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
                (typeof window < "u" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent
                    .toLowerCase()
                    .match(/applewebkit\/(\d+)/));
        }
        t.formatters.j = function (c) {
          try {
            return JSON.stringify(c);
          } catch (l) {
            return "[UnexpectedJSONParseError]: " + l.message;
          }
        };
        function r(c) {
          var l = this.useColors;
          if (
            ((c[0] =
              (l ? "%c" : "") +
              this.namespace +
              (l ? " %c" : " ") +
              c[0] +
              (l ? "%c " : " ") +
              "+" +
              t.humanize(this.diff)),
            !!l)
          ) {
            var f = "color: " + this.color;
            c.splice(1, 0, f, "color: inherit");
            var u = 0,
              d = 0;
            c[0].replace(/%[a-zA-Z%]/g, function (p) {
              p !== "%%" && (u++, p === "%c" && (d = u));
            }),
              c.splice(d, 0, f);
          }
        }
        function i() {
          return (
            typeof console == "object" &&
            console.log &&
            Function.prototype.apply.call(console.log, console, arguments)
          );
        }
        function a(c) {
          try {
            c == null ? t.storage.removeItem("debug") : (t.storage.debug = c);
          } catch {}
        }
        function s() {
          var c;
          try {
            c = t.storage.debug;
          } catch {}
          return (
            !c &&
              typeof process < "u" &&
              "env" in process &&
              (c = process.env.DEBUG),
            c
          );
        }
        t.enable(s());
        function o() {
          try {
            return window.localStorage;
          } catch {}
        }
      })(Ju, Ju.exports)),
    Ju.exports
  );
}
var ef = { exports: {} },
  sE;
function mD() {
  return (
    sE ||
      ((sE = 1),
      (function (e, t) {
        var n = hc,
          r = wr;
        (t = e.exports = Y$()),
          (t.init = d),
          (t.log = c),
          (t.formatArgs = o),
          (t.save = l),
          (t.load = f),
          (t.useColors = s),
          (t.colors = [6, 2, 3, 4, 5, 1]),
          (t.inspectOpts = Object.keys(process.env)
            .filter(function (p) {
              return /^debug_/i.test(p);
            })
            .reduce(function (p, h) {
              var m = h
                  .substring(6)
                  .toLowerCase()
                  .replace(/_([a-z])/g, function (v, y) {
                    return y.toUpperCase();
                  }),
                g = process.env[h];
              return (
                /^(yes|on|true|enabled)$/i.test(g)
                  ? (g = !0)
                  : /^(no|off|false|disabled)$/i.test(g)
                  ? (g = !1)
                  : g === "null"
                  ? (g = null)
                  : (g = Number(g)),
                (p[m] = g),
                p
              );
            }, {}));
        var i = parseInt(process.env.DEBUG_FD, 10) || 2;
        i !== 1 &&
          i !== 2 &&
          r.deprecate(
            function () {},
            "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)",
          )();
        var a = i === 1 ? process.stdout : i === 2 ? process.stderr : u(i);
        function s() {
          return "colors" in t.inspectOpts
            ? !!t.inspectOpts.colors
            : n.isatty(i);
        }
        (t.formatters.o = function (p) {
          return (
            (this.inspectOpts.colors = this.useColors),
            r
              .inspect(p, this.inspectOpts)
              .split(
                `
`,
              )
              .map(function (h) {
                return h.trim();
              })
              .join(" ")
          );
        }),
          (t.formatters.O = function (p) {
            return (
              (this.inspectOpts.colors = this.useColors),
              r.inspect(p, this.inspectOpts)
            );
          });
        function o(p) {
          var h = this.namespace,
            m = this.useColors;
          if (m) {
            var g = this.color,
              v = "  \x1B[3" + g + ";1m" + h + " \x1B[0m";
            (p[0] =
              v +
              p[0]
                .split(
                  `
`,
                )
                .join(
                  `
` + v,
                )),
              p.push("\x1B[3" + g + "m+" + t.humanize(this.diff) + "\x1B[0m");
          } else p[0] = new Date().toUTCString() + " " + h + " " + p[0];
        }
        function c() {
          return a.write(
            r.format.apply(r, arguments) +
              `
`,
          );
        }
        function l(p) {
          p == null ? delete process.env.DEBUG : (process.env.DEBUG = p);
        }
        function f() {
          return process.env.DEBUG;
        }
        function u(p) {
          var h,
            m = process.binding("tty_wrap");
          switch (m.guessHandleType(p)) {
            case "TTY":
              (h = new n.WriteStream(p)),
                (h._type = "tty"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            case "FILE":
              var g = Xt;
              (h = new g.SyncWriteStream(p, { autoClose: !1 })),
                (h._type = "fs");
              break;
            case "PIPE":
            case "TCP":
              var v = ha;
              (h = new v.Socket({ fd: p, readable: !1, writable: !0 })),
                (h.readable = !1),
                (h.read = null),
                (h._type = "pipe"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            default:
              throw new Error("Implement me. Unknown stream file type!");
          }
          return (h.fd = p), (h._isStdio = !0), h;
        }
        function d(p) {
          p.inspectOpts = {};
          for (var h = Object.keys(t.inspectOpts), m = 0; m < h.length; m++)
            p.inspectOpts[h[m]] = t.inspectOpts[h[m]];
        }
        t.enable(f());
      })(ef, ef.exports)),
    ef.exports
  );
}
var oE;
function ep() {
  return (
    oE ||
      ((oE = 1),
      typeof process < "u" && process.type === "renderer"
        ? (Xu.exports = hD())
        : (Xu.exports = mD())),
    Xu.exports
  );
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var Fh, cE;
function gD() {
  if (cE) return Fh;
  cE = 1;
  var e = f(),
    t = qi(),
    n = Gi,
    r = qd(),
    i = zl;
  Fh = o;
  var a = /^Encoding not recognized: /;
  function s(d) {
    if (!d) return null;
    try {
      return r.getDecoder(d);
    } catch (p) {
      throw a.test(p.message)
        ? n(415, "specified encoding unsupported", {
            encoding: d,
            type: "encoding.unsupported",
          })
        : p;
    }
  }
  function o(d, p, h) {
    var m = h,
      g = p || {};
    if (d === void 0) throw new TypeError("argument stream is required");
    if (typeof d != "object" || d === null || typeof d.on != "function")
      throw new TypeError("argument stream must be a stream");
    if (
      ((p === !0 || typeof p == "string") && (g = { encoding: p }),
      typeof p == "function" && ((m = p), (g = {})),
      m !== void 0 && typeof m != "function")
    )
      throw new TypeError("argument callback must be a function");
    if (!m && !Tn.Promise) throw new TypeError("argument callback is required");
    var v = g.encoding !== !0 ? g.encoding : "utf-8",
      y = t.parse(g.limit),
      _ = g.length != null && !isNaN(g.length) ? parseInt(g.length, 10) : null;
    return m
      ? l(d, v, _, y, u(m))
      : new Promise(function (R, A) {
          l(d, v, _, y, function (S, w) {
            if (S) return A(S);
            R(w);
          });
        });
  }
  function c(d) {
    i(d), typeof d.pause == "function" && d.pause();
  }
  function l(d, p, h, m, g) {
    var v = !1,
      y = !0;
    if (m !== null && h !== null && h > m)
      return I(
        n(413, "request entity too large", {
          expected: h,
          length: h,
          limit: m,
          type: "entity.too.large",
        }),
      );
    var _ = d._readableState;
    if (d._decoder || (_ && (_.encoding || _.decoder)))
      return I(
        n(500, "stream encoding should not be set", {
          type: "stream.encoding.set",
        }),
      );
    if (typeof d.readable < "u" && !d.readable)
      return I(
        n(500, "stream is not readable", { type: "stream.not.readable" }),
      );
    var E = 0,
      R;
    try {
      R = s(p);
    } catch (j) {
      return I(j);
    }
    var A = R ? "" : [];
    d.on("aborted", S),
      d.on("close", Q),
      d.on("data", w),
      d.on("end", O),
      d.on("error", O),
      (y = !1);
    function I() {
      for (var j = new Array(arguments.length), H = 0; H < j.length; H++)
        j[H] = arguments[H];
      (v = !0), y ? process.nextTick(q) : q();
      function q() {
        Q(), j[0] && c(d), g.apply(null, j);
      }
    }
    function S() {
      v ||
        I(
          n(400, "request aborted", {
            code: "ECONNABORTED",
            expected: h,
            length: h,
            received: E,
            type: "request.aborted",
          }),
        );
    }
    function w(j) {
      v ||
        ((E += j.length),
        m !== null && E > m
          ? I(
              n(413, "request entity too large", {
                limit: m,
                received: E,
                type: "entity.too.large",
              }),
            )
          : R
          ? (A += R.write(j))
          : A.push(j));
    }
    function O(j) {
      if (!v) {
        if (j) return I(j);
        if (h !== null && E !== h)
          I(
            n(400, "request size did not match content length", {
              expected: h,
              length: h,
              received: E,
              type: "request.size.invalid",
            }),
          );
        else {
          var H = R ? A + (R.end() || "") : Buffer.concat(A);
          I(null, H);
        }
      }
    }
    function Q() {
      (A = null),
        d.removeListener("aborted", S),
        d.removeListener("data", w),
        d.removeListener("end", O),
        d.removeListener("error", O),
        d.removeListener("close", Q);
    }
  }
  function f() {
    try {
      return require("async_hooks");
    } catch {
      return {};
    }
  }
  function u(d) {
    var p;
    return (
      e.AsyncResource &&
        (p = new e.AsyncResource(d.name || "bound-anonymous-fn")),
      !p || !p.runInAsyncScope ? d : p.runInAsyncScope.bind(p, d, null)
    );
  }
  return Fh;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var jh, lE;
function tp() {
  if (lE) return jh;
  lE = 1;
  var e = Gi,
    t = ev,
    n = gD(),
    r = qd(),
    i = Kl,
    a = zl,
    s = mc;
  jh = o;
  function o(f, u, d, p, h, m) {
    var g,
      v = m,
      y;
    f._body = !0;
    var _ = v.encoding !== null ? v.encoding : null,
      E = v.verify;
    try {
      (y = c(f, h, v.inflate)), (g = y.length), (y.length = void 0);
    } catch (R) {
      return d(R);
    }
    if (
      ((v.length = g),
      (v.encoding = E ? null : _),
      v.encoding === null && _ !== null && !r.encodingExists(_))
    )
      return d(
        e(415, 'unsupported charset "' + _.toUpperCase() + '"', {
          charset: _.toLowerCase(),
          type: "charset.unsupported",
        }),
      );
    h("read body"),
      n(y, v, function (R, A) {
        if (R) {
          var I;
          R.type === "encoding.unsupported"
            ? (I = e(415, 'unsupported charset "' + _.toUpperCase() + '"', {
                charset: _.toLowerCase(),
                type: "charset.unsupported",
              }))
            : (I = e(400, R)),
            y !== f && (a(f), t(y, !0)),
            l(f, function () {
              d(e(400, I));
            });
          return;
        }
        if (E)
          try {
            h("verify body"), E(f, u, A, _);
          } catch (w) {
            d(e(403, w, { body: A, type: w.type || "entity.verify.failed" }));
            return;
          }
        var S = A;
        try {
          h("parse body"),
            (S = typeof A != "string" && _ !== null ? r.decode(A, _) : A),
            (f.body = p(S));
        } catch (w) {
          d(e(400, w, { body: S, type: w.type || "entity.parse.failed" }));
          return;
        }
        d();
      });
  }
  function c(f, u, d) {
    var p = (f.headers["content-encoding"] || "identity").toLowerCase(),
      h = f.headers["content-length"],
      m;
    if ((u('content-encoding "%s"', p), d === !1 && p !== "identity"))
      throw e(415, "content encoding unsupported", {
        encoding: p,
        type: "encoding.unsupported",
      });
    switch (p) {
      case "deflate":
        (m = s.createInflate()), u("inflate body"), f.pipe(m);
        break;
      case "gzip":
        (m = s.createGunzip()), u("gunzip body"), f.pipe(m);
        break;
      case "identity":
        (m = f), (m.length = h);
        break;
      default:
        throw e(415, 'unsupported content encoding "' + p + '"', {
          encoding: p,
          type: "encoding.unsupported",
        });
    }
    return m;
  }
  function l(f, u) {
    i.isFinished(f) ? u(null) : (i(f, u), f.resume());
  }
  return jh;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Mh, uE;
function vD() {
  if (uE) return Mh;
  uE = 1;
  var e = qi(),
    t = zs(),
    n = Gi,
    r = ep()("body-parser:json"),
    i = tp(),
    a = ga;
  Mh = l;
  var s = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/,
    o = "#",
    c = /#+/g;
  function l(m) {
    var g = m || {},
      v = typeof g.limit != "number" ? e.parse(g.limit || "100kb") : g.limit,
      y = g.inflate !== !1,
      _ = g.reviver,
      E = g.strict !== !1,
      R = g.type || "application/json",
      A = g.verify || !1;
    if (A !== !1 && typeof A != "function")
      throw new TypeError("option verify must be function");
    var I = typeof R != "function" ? h(R) : R;
    function S(w) {
      if (w.length === 0) return {};
      if (E) {
        var O = u(w);
        if (O !== "{" && O !== "[") throw (r("strict violation"), f(w, O));
      }
      try {
        return r("parse json"), JSON.parse(w, _);
      } catch (Q) {
        throw p(Q, { message: Q.message, stack: Q.stack });
      }
    }
    return function (O, Q, j) {
      if (O._body) {
        r("body already parsed"), j();
        return;
      }
      if (((O.body = O.body || {}), !a.hasBody(O))) {
        r("skip empty body"), j();
        return;
      }
      if ((r("content-type %j", O.headers["content-type"]), !I(O))) {
        r("skip parsing"), j();
        return;
      }
      var H = d(O) || "utf-8";
      if (H.slice(0, 4) !== "utf-") {
        r("invalid charset"),
          j(
            n(415, 'unsupported charset "' + H.toUpperCase() + '"', {
              charset: H,
              type: "charset.unsupported",
            }),
          );
        return;
      }
      i(O, Q, j, S, r, { encoding: H, inflate: y, limit: v, verify: A });
    };
  }
  function f(m, g) {
    var v = m.indexOf(g),
      y = "";
    if (v !== -1) {
      y = m.substring(0, v) + o;
      for (var _ = v + 1; _ < m.length; _++) y += o;
    }
    try {
      throw (JSON.parse(y), new SyntaxError("strict violation"));
    } catch (E) {
      return p(E, {
        message: E.message.replace(c, function (R) {
          return m.substring(v, v + R.length);
        }),
        stack: E.stack,
      });
    }
  }
  function u(m) {
    var g = s.exec(m);
    return g ? g[1] : void 0;
  }
  function d(m) {
    try {
      return (t.parse(m).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function p(m, g) {
    for (var v = Object.getOwnPropertyNames(m), y = 0; y < v.length; y++) {
      var _ = v[y];
      _ !== "stack" && _ !== "message" && delete m[_];
    }
    return (
      (m.stack = g.stack.replace(m.message, g.message)),
      (m.message = g.message),
      m
    );
  }
  function h(m) {
    return function (v) {
      return !!a(v, m);
    };
  }
  return Mh;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Hh, fE;
function yD() {
  if (fE) return Hh;
  fE = 1;
  var e = qi(),
    t = ep()("body-parser:raw"),
    n = tp(),
    r = ga;
  Hh = i;
  function i(s) {
    var o = s || {},
      c = o.inflate !== !1,
      l = typeof o.limit != "number" ? e.parse(o.limit || "100kb") : o.limit,
      f = o.type || "application/octet-stream",
      u = o.verify || !1;
    if (u !== !1 && typeof u != "function")
      throw new TypeError("option verify must be function");
    var d = typeof f != "function" ? a(f) : f;
    function p(h) {
      return h;
    }
    return function (m, g, v) {
      if (m._body) {
        t("body already parsed"), v();
        return;
      }
      if (((m.body = m.body || {}), !r.hasBody(m))) {
        t("skip empty body"), v();
        return;
      }
      if ((t("content-type %j", m.headers["content-type"]), !d(m))) {
        t("skip parsing"), v();
        return;
      }
      n(m, g, v, p, t, { encoding: null, inflate: c, limit: l, verify: u });
    };
  }
  function a(s) {
    return function (c) {
      return !!r(c, s);
    };
  }
  return Hh;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var qh, dE;
function bD() {
  if (dE) return qh;
  dE = 1;
  var e = qi(),
    t = zs(),
    n = ep()("body-parser:text"),
    r = tp(),
    i = ga;
  qh = a;
  function a(c) {
    var l = c || {},
      f = l.defaultCharset || "utf-8",
      u = l.inflate !== !1,
      d = typeof l.limit != "number" ? e.parse(l.limit || "100kb") : l.limit,
      p = l.type || "text/plain",
      h = l.verify || !1;
    if (h !== !1 && typeof h != "function")
      throw new TypeError("option verify must be function");
    var m = typeof p != "function" ? o(p) : p;
    function g(v) {
      return v;
    }
    return function (y, _, E) {
      if (y._body) {
        n("body already parsed"), E();
        return;
      }
      if (((y.body = y.body || {}), !i.hasBody(y))) {
        n("skip empty body"), E();
        return;
      }
      if ((n("content-type %j", y.headers["content-type"]), !m(y))) {
        n("skip parsing"), E();
        return;
      }
      var R = s(y) || f;
      r(y, _, E, g, n, { encoding: R, inflate: u, limit: d, verify: h });
    };
  }
  function s(c) {
    try {
      return (t.parse(c).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function o(c) {
    return function (f) {
      return !!i(f, c);
    };
  }
  return qh;
}
var Gh, pE;
function Rv() {
  if (pE) return Gh;
  pE = 1;
  var e = String.prototype.replace,
    t = /%20/g,
    n = { RFC1738: "RFC1738", RFC3986: "RFC3986" };
  return (
    (Gh = {
      default: n.RFC3986,
      formatters: {
        RFC1738: function (r) {
          return e.call(r, t, "+");
        },
        RFC3986: function (r) {
          return String(r);
        },
      },
      RFC1738: n.RFC1738,
      RFC3986: n.RFC3986,
    }),
    Gh
  );
}
var Qh, hE;
function X$() {
  if (hE) return Qh;
  hE = 1;
  var e = Rv(),
    t = Object.prototype.hasOwnProperty,
    n = Array.isArray,
    r = (function () {
      for (var m = [], g = 0; g < 256; ++g)
        m.push("%" + ((g < 16 ? "0" : "") + g.toString(16)).toUpperCase());
      return m;
    })(),
    i = function (g) {
      for (; g.length > 1; ) {
        var v = g.pop(),
          y = v.obj[v.prop];
        if (n(y)) {
          for (var _ = [], E = 0; E < y.length; ++E)
            typeof y[E] < "u" && _.push(y[E]);
          v.obj[v.prop] = _;
        }
      }
    },
    a = function (g, v) {
      for (
        var y = v && v.plainObjects ? Object.create(null) : {}, _ = 0;
        _ < g.length;
        ++_
      )
        typeof g[_] < "u" && (y[_] = g[_]);
      return y;
    },
    s = function m(g, v, y) {
      if (!v) return g;
      if (typeof v != "object") {
        if (n(g)) g.push(v);
        else if (g && typeof g == "object")
          ((y && (y.plainObjects || y.allowPrototypes)) ||
            !t.call(Object.prototype, v)) &&
            (g[v] = !0);
        else return [g, v];
        return g;
      }
      if (!g || typeof g != "object") return [g].concat(v);
      var _ = g;
      return (
        n(g) && !n(v) && (_ = a(g, y)),
        n(g) && n(v)
          ? (v.forEach(function (E, R) {
              if (t.call(g, R)) {
                var A = g[R];
                A && typeof A == "object" && E && typeof E == "object"
                  ? (g[R] = m(A, E, y))
                  : g.push(E);
              } else g[R] = E;
            }),
            g)
          : Object.keys(v).reduce(function (E, R) {
              var A = v[R];
              return t.call(E, R) ? (E[R] = m(E[R], A, y)) : (E[R] = A), E;
            }, _)
      );
    },
    o = function (g, v) {
      return Object.keys(v).reduce(function (y, _) {
        return (y[_] = v[_]), y;
      }, g);
    },
    c = function (m, g, v) {
      var y = m.replace(/\+/g, " ");
      if (v === "iso-8859-1") return y.replace(/%[0-9a-f]{2}/gi, unescape);
      try {
        return decodeURIComponent(y);
      } catch {
        return y;
      }
    },
    l = function (g, v, y, _, E) {
      if (g.length === 0) return g;
      var R = g;
      if (
        (typeof g == "symbol"
          ? (R = Symbol.prototype.toString.call(g))
          : typeof g != "string" && (R = String(g)),
        y === "iso-8859-1")
      )
        return escape(R).replace(/%u[0-9a-f]{4}/gi, function (w) {
          return "%26%23" + parseInt(w.slice(2), 16) + "%3B";
        });
      for (var A = "", I = 0; I < R.length; ++I) {
        var S = R.charCodeAt(I);
        if (
          S === 45 ||
          S === 46 ||
          S === 95 ||
          S === 126 ||
          (S >= 48 && S <= 57) ||
          (S >= 65 && S <= 90) ||
          (S >= 97 && S <= 122) ||
          (E === e.RFC1738 && (S === 40 || S === 41))
        ) {
          A += R.charAt(I);
          continue;
        }
        if (S < 128) {
          A = A + r[S];
          continue;
        }
        if (S < 2048) {
          A = A + (r[192 | (S >> 6)] + r[128 | (S & 63)]);
          continue;
        }
        if (S < 55296 || S >= 57344) {
          A =
            A +
            (r[224 | (S >> 12)] + r[128 | ((S >> 6) & 63)] + r[128 | (S & 63)]);
          continue;
        }
        (I += 1),
          (S = 65536 + (((S & 1023) << 10) | (R.charCodeAt(I) & 1023))),
          (A +=
            r[240 | (S >> 18)] +
            r[128 | ((S >> 12) & 63)] +
            r[128 | ((S >> 6) & 63)] +
            r[128 | (S & 63)]);
      }
      return A;
    },
    f = function (g) {
      for (
        var v = [{ obj: { o: g }, prop: "o" }], y = [], _ = 0;
        _ < v.length;
        ++_
      )
        for (
          var E = v[_], R = E.obj[E.prop], A = Object.keys(R), I = 0;
          I < A.length;
          ++I
        ) {
          var S = A[I],
            w = R[S];
          typeof w == "object" &&
            w !== null &&
            y.indexOf(w) === -1 &&
            (v.push({ obj: R, prop: S }), y.push(w));
        }
      return i(v), g;
    },
    u = function (g) {
      return Object.prototype.toString.call(g) === "[object RegExp]";
    },
    d = function (g) {
      return !g || typeof g != "object"
        ? !1
        : !!(
            g.constructor &&
            g.constructor.isBuffer &&
            g.constructor.isBuffer(g)
          );
    },
    p = function (g, v) {
      return [].concat(g, v);
    },
    h = function (g, v) {
      if (n(g)) {
        for (var y = [], _ = 0; _ < g.length; _ += 1) y.push(v(g[_]));
        return y;
      }
      return v(g);
    };
  return (
    (Qh = {
      arrayToObject: a,
      assign: o,
      combine: p,
      compact: f,
      decode: c,
      encode: l,
      isBuffer: d,
      isRegExp: u,
      maybeMap: h,
      merge: s,
    }),
    Qh
  );
}
var Wh, mE;
function _D() {
  if (mE) return Wh;
  mE = 1;
  var e = DI,
    t = X$(),
    n = Rv(),
    r = Object.prototype.hasOwnProperty,
    i = {
      brackets: function (v) {
        return v + "[]";
      },
      comma: "comma",
      indices: function (v, y) {
        return v + "[" + y + "]";
      },
      repeat: function (v) {
        return v;
      },
    },
    a = Array.isArray,
    s = String.prototype.split,
    o = Array.prototype.push,
    c = function (g, v) {
      o.apply(g, a(v) ? v : [v]);
    },
    l = Date.prototype.toISOString,
    f = n.default,
    u = {
      addQueryPrefix: !1,
      allowDots: !1,
      charset: "utf-8",
      charsetSentinel: !1,
      delimiter: "&",
      encode: !0,
      encoder: t.encode,
      encodeValuesOnly: !1,
      format: f,
      formatter: n.formatters[f],
      indices: !1,
      serializeDate: function (v) {
        return l.call(v);
      },
      skipNulls: !1,
      strictNullHandling: !1,
    },
    d = function (v) {
      return (
        typeof v == "string" ||
        typeof v == "number" ||
        typeof v == "boolean" ||
        typeof v == "symbol" ||
        typeof v == "bigint"
      );
    },
    p = {},
    h = function g(v, y, _, E, R, A, I, S, w, O, Q, j, H, q, J, Z) {
      for (var z = v, U = Z, G = 0, L = !1; (U = U.get(p)) !== void 0 && !L; ) {
        var k = U.get(v);
        if (((G += 1), typeof k < "u")) {
          if (k === G) throw new RangeError("Cyclic object value");
          L = !0;
        }
        typeof U.get(p) > "u" && (G = 0);
      }
      if (
        (typeof S == "function"
          ? (z = S(y, z))
          : z instanceof Date
          ? (z = Q(z))
          : _ === "comma" &&
            a(z) &&
            (z = t.maybeMap(z, function (Ee) {
              return Ee instanceof Date ? Q(Ee) : Ee;
            })),
        z === null)
      ) {
        if (R) return I && !q ? I(y, u.encoder, J, "key", j) : y;
        z = "";
      }
      if (d(z) || t.isBuffer(z)) {
        if (I) {
          var W = q ? y : I(y, u.encoder, J, "key", j);
          if (_ === "comma" && q) {
            for (
              var F = s.call(String(z), ","), x = "", T = 0;
              T < F.length;
              ++T
            )
              x += (T === 0 ? "" : ",") + H(I(F[T], u.encoder, J, "value", j));
            return [H(W) + (E && a(z) && F.length === 1 ? "[]" : "") + "=" + x];
          }
          return [H(W) + "=" + H(I(z, u.encoder, J, "value", j))];
        }
        return [H(y) + "=" + H(String(z))];
      }
      var V = [];
      if (typeof z > "u") return V;
      var B;
      if (_ === "comma" && a(z))
        B = [{ value: z.length > 0 ? z.join(",") || null : void 0 }];
      else if (a(S)) B = S;
      else {
        var N = Object.keys(z);
        B = w ? N.sort(w) : N;
      }
      for (
        var ce = E && a(z) && z.length === 1 ? y + "[]" : y, re = 0;
        re < B.length;
        ++re
      ) {
        var ne = B[re],
          Y = typeof ne == "object" && typeof ne.value < "u" ? ne.value : z[ne];
        if (!(A && Y === null)) {
          var M = a(z)
            ? typeof _ == "function"
              ? _(ce, ne)
              : ce
            : ce + (O ? "." + ne : "[" + ne + "]");
          Z.set(v, G);
          var oe = e();
          oe.set(p, Z),
            c(V, g(Y, M, _, E, R, A, I, S, w, O, Q, j, H, q, J, oe));
        }
      }
      return V;
    },
    m = function (v) {
      if (!v) return u;
      if (
        v.encoder !== null &&
        typeof v.encoder < "u" &&
        typeof v.encoder != "function"
      )
        throw new TypeError("Encoder has to be a function.");
      var y = v.charset || u.charset;
      if (
        typeof v.charset < "u" &&
        v.charset !== "utf-8" &&
        v.charset !== "iso-8859-1"
      )
        throw new TypeError(
          "The charset option must be either utf-8, iso-8859-1, or undefined",
        );
      var _ = n.default;
      if (typeof v.format < "u") {
        if (!r.call(n.formatters, v.format))
          throw new TypeError("Unknown format option provided.");
        _ = v.format;
      }
      var E = n.formatters[_],
        R = u.filter;
      return (
        (typeof v.filter == "function" || a(v.filter)) && (R = v.filter),
        {
          addQueryPrefix:
            typeof v.addQueryPrefix == "boolean"
              ? v.addQueryPrefix
              : u.addQueryPrefix,
          allowDots: typeof v.allowDots > "u" ? u.allowDots : !!v.allowDots,
          charset: y,
          charsetSentinel:
            typeof v.charsetSentinel == "boolean"
              ? v.charsetSentinel
              : u.charsetSentinel,
          delimiter: typeof v.delimiter > "u" ? u.delimiter : v.delimiter,
          encode: typeof v.encode == "boolean" ? v.encode : u.encode,
          encoder: typeof v.encoder == "function" ? v.encoder : u.encoder,
          encodeValuesOnly:
            typeof v.encodeValuesOnly == "boolean"
              ? v.encodeValuesOnly
              : u.encodeValuesOnly,
          filter: R,
          format: _,
          formatter: E,
          serializeDate:
            typeof v.serializeDate == "function"
              ? v.serializeDate
              : u.serializeDate,
          skipNulls:
            typeof v.skipNulls == "boolean" ? v.skipNulls : u.skipNulls,
          sort: typeof v.sort == "function" ? v.sort : null,
          strictNullHandling:
            typeof v.strictNullHandling == "boolean"
              ? v.strictNullHandling
              : u.strictNullHandling,
        }
      );
    };
  return (
    (Wh = function (g, v) {
      var y = g,
        _ = m(v),
        E,
        R;
      typeof _.filter == "function"
        ? ((R = _.filter), (y = R("", y)))
        : a(_.filter) && ((R = _.filter), (E = R));
      var A = [];
      if (typeof y != "object" || y === null) return "";
      var I;
      v && v.arrayFormat in i
        ? (I = v.arrayFormat)
        : v && "indices" in v
        ? (I = v.indices ? "indices" : "repeat")
        : (I = "indices");
      var S = i[I];
      if (v && "commaRoundTrip" in v && typeof v.commaRoundTrip != "boolean")
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      var w = S === "comma" && v && v.commaRoundTrip;
      E || (E = Object.keys(y)), _.sort && E.sort(_.sort);
      for (var O = e(), Q = 0; Q < E.length; ++Q) {
        var j = E[Q];
        (_.skipNulls && y[j] === null) ||
          c(
            A,
            h(
              y[j],
              j,
              S,
              w,
              _.strictNullHandling,
              _.skipNulls,
              _.encode ? _.encoder : null,
              _.filter,
              _.sort,
              _.allowDots,
              _.serializeDate,
              _.format,
              _.formatter,
              _.encodeValuesOnly,
              _.charset,
              O,
            ),
          );
      }
      var H = A.join(_.delimiter),
        q = _.addQueryPrefix === !0 ? "?" : "";
      return (
        _.charsetSentinel &&
          (_.charset === "iso-8859-1"
            ? (q += "utf8=%26%2310003%3B&")
            : (q += "utf8=%E2%9C%93&")),
        H.length > 0 ? q + H : ""
      );
    }),
    Wh
  );
}
var zh, gE;
function ED() {
  if (gE) return zh;
  gE = 1;
  var e = X$(),
    t = Object.prototype.hasOwnProperty,
    n = Array.isArray,
    r = {
      allowDots: !1,
      allowPrototypes: !1,
      allowSparse: !1,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: !1,
      comma: !1,
      decoder: e.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: !1,
      interpretNumericEntities: !1,
      parameterLimit: 1e3,
      parseArrays: !0,
      plainObjects: !1,
      strictNullHandling: !1,
    },
    i = function (d) {
      return d.replace(/&#(\d+);/g, function (p, h) {
        return String.fromCharCode(parseInt(h, 10));
      });
    },
    a = function (d, p) {
      return d && typeof d == "string" && p.comma && d.indexOf(",") > -1
        ? d.split(",")
        : d;
    },
    s = "utf8=%26%2310003%3B",
    o = "utf8=%E2%9C%93",
    c = function (p, h) {
      var m = {},
        g = h.ignoreQueryPrefix ? p.replace(/^\?/, "") : p,
        v = h.parameterLimit === 1 / 0 ? void 0 : h.parameterLimit,
        y = g.split(h.delimiter, v),
        _ = -1,
        E,
        R = h.charset;
      if (h.charsetSentinel)
        for (E = 0; E < y.length; ++E)
          y[E].indexOf("utf8=") === 0 &&
            (y[E] === o ? (R = "utf-8") : y[E] === s && (R = "iso-8859-1"),
            (_ = E),
            (E = y.length));
      for (E = 0; E < y.length; ++E)
        if (E !== _) {
          var A = y[E],
            I = A.indexOf("]="),
            S = I === -1 ? A.indexOf("=") : I + 1,
            w,
            O;
          S === -1
            ? ((w = h.decoder(A, r.decoder, R, "key")),
              (O = h.strictNullHandling ? null : ""))
            : ((w = h.decoder(A.slice(0, S), r.decoder, R, "key")),
              (O = e.maybeMap(a(A.slice(S + 1), h), function (Q) {
                return h.decoder(Q, r.decoder, R, "value");
              }))),
            O && h.interpretNumericEntities && R === "iso-8859-1" && (O = i(O)),
            A.indexOf("[]=") > -1 && (O = n(O) ? [O] : O),
            t.call(m, w) ? (m[w] = e.combine(m[w], O)) : (m[w] = O);
        }
      return m;
    },
    l = function (d, p, h, m) {
      for (var g = m ? p : a(p, h), v = d.length - 1; v >= 0; --v) {
        var y,
          _ = d[v];
        if (_ === "[]" && h.parseArrays) y = [].concat(g);
        else {
          y = h.plainObjects ? Object.create(null) : {};
          var E =
              _.charAt(0) === "[" && _.charAt(_.length - 1) === "]"
                ? _.slice(1, -1)
                : _,
            R = parseInt(E, 10);
          !h.parseArrays && E === ""
            ? (y = { 0: g })
            : !isNaN(R) &&
              _ !== E &&
              String(R) === E &&
              R >= 0 &&
              h.parseArrays &&
              R <= h.arrayLimit
            ? ((y = []), (y[R] = g))
            : E !== "__proto__" && (y[E] = g);
        }
        g = y;
      }
      return g;
    },
    f = function (p, h, m, g) {
      if (p) {
        var v = m.allowDots ? p.replace(/\.([^.[]+)/g, "[$1]") : p,
          y = /(\[[^[\]]*])/,
          _ = /(\[[^[\]]*])/g,
          E = m.depth > 0 && y.exec(v),
          R = E ? v.slice(0, E.index) : v,
          A = [];
        if (R) {
          if (
            !m.plainObjects &&
            t.call(Object.prototype, R) &&
            !m.allowPrototypes
          )
            return;
          A.push(R);
        }
        for (
          var I = 0;
          m.depth > 0 && (E = _.exec(v)) !== null && I < m.depth;

        ) {
          if (
            ((I += 1),
            !m.plainObjects &&
              t.call(Object.prototype, E[1].slice(1, -1)) &&
              !m.allowPrototypes)
          )
            return;
          A.push(E[1]);
        }
        return E && A.push("[" + v.slice(E.index) + "]"), l(A, h, m, g);
      }
    },
    u = function (p) {
      if (!p) return r;
      if (
        p.decoder !== null &&
        p.decoder !== void 0 &&
        typeof p.decoder != "function"
      )
        throw new TypeError("Decoder has to be a function.");
      if (
        typeof p.charset < "u" &&
        p.charset !== "utf-8" &&
        p.charset !== "iso-8859-1"
      )
        throw new TypeError(
          "The charset option must be either utf-8, iso-8859-1, or undefined",
        );
      var h = typeof p.charset > "u" ? r.charset : p.charset;
      return {
        allowDots: typeof p.allowDots > "u" ? r.allowDots : !!p.allowDots,
        allowPrototypes:
          typeof p.allowPrototypes == "boolean"
            ? p.allowPrototypes
            : r.allowPrototypes,
        allowSparse:
          typeof p.allowSparse == "boolean" ? p.allowSparse : r.allowSparse,
        arrayLimit:
          typeof p.arrayLimit == "number" ? p.arrayLimit : r.arrayLimit,
        charset: h,
        charsetSentinel:
          typeof p.charsetSentinel == "boolean"
            ? p.charsetSentinel
            : r.charsetSentinel,
        comma: typeof p.comma == "boolean" ? p.comma : r.comma,
        decoder: typeof p.decoder == "function" ? p.decoder : r.decoder,
        delimiter:
          typeof p.delimiter == "string" || e.isRegExp(p.delimiter)
            ? p.delimiter
            : r.delimiter,
        depth:
          typeof p.depth == "number" || p.depth === !1 ? +p.depth : r.depth,
        ignoreQueryPrefix: p.ignoreQueryPrefix === !0,
        interpretNumericEntities:
          typeof p.interpretNumericEntities == "boolean"
            ? p.interpretNumericEntities
            : r.interpretNumericEntities,
        parameterLimit:
          typeof p.parameterLimit == "number"
            ? p.parameterLimit
            : r.parameterLimit,
        parseArrays: p.parseArrays !== !1,
        plainObjects:
          typeof p.plainObjects == "boolean" ? p.plainObjects : r.plainObjects,
        strictNullHandling:
          typeof p.strictNullHandling == "boolean"
            ? p.strictNullHandling
            : r.strictNullHandling,
      };
    };
  return (
    (zh = function (d, p) {
      var h = u(p);
      if (d === "" || d === null || typeof d > "u")
        return h.plainObjects ? Object.create(null) : {};
      for (
        var m = typeof d == "string" ? c(d, h) : d,
          g = h.plainObjects ? Object.create(null) : {},
          v = Object.keys(m),
          y = 0;
        y < v.length;
        ++y
      ) {
        var _ = v[y],
          E = f(_, m[_], h, typeof d == "string");
        g = e.merge(g, E, h);
      }
      return h.allowSparse === !0 ? g : e.compact(g);
    }),
    zh
  );
}
var Kh, vE;
function wD() {
  if (vE) return Kh;
  vE = 1;
  var e = _D(),
    t = ED(),
    n = Rv();
  return (Kh = { formats: n, parse: t, stringify: e }), Kh;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Vh, yE;
function xD() {
  if (yE) return Vh;
  yE = 1;
  var e = qi(),
    t = zs(),
    n = Gi,
    r = ep()("body-parser:urlencoded"),
    i = wi("body-parser"),
    a = tp(),
    s = ga;
  Vh = c;
  var o = Object.create(null);
  function c(m) {
    var g = m || {};
    g.extended === void 0 && i("undefined extended: provide extended option");
    var v = g.extended !== !1,
      y = g.inflate !== !1,
      _ = typeof g.limit != "number" ? e.parse(g.limit || "100kb") : g.limit,
      E = g.type || "application/x-www-form-urlencoded",
      R = g.verify || !1;
    if (R !== !1 && typeof R != "function")
      throw new TypeError("option verify must be function");
    var A = v ? l(g) : p(g),
      I = typeof E != "function" ? h(E) : E;
    function S(w) {
      return w.length ? A(w) : {};
    }
    return function (O, Q, j) {
      if (O._body) {
        r("body already parsed"), j();
        return;
      }
      if (((O.body = O.body || {}), !s.hasBody(O))) {
        r("skip empty body"), j();
        return;
      }
      if ((r("content-type %j", O.headers["content-type"]), !I(O))) {
        r("skip parsing"), j();
        return;
      }
      var H = f(O) || "utf-8";
      if (H !== "utf-8") {
        r("invalid charset"),
          j(
            n(415, 'unsupported charset "' + H.toUpperCase() + '"', {
              charset: H,
              type: "charset.unsupported",
            }),
          );
        return;
      }
      a(O, Q, j, S, r, {
        debug: r,
        encoding: H,
        inflate: y,
        limit: _,
        verify: R,
      });
    };
  }
  function l(m) {
    var g = m.parameterLimit !== void 0 ? m.parameterLimit : 1e3,
      v = d("qs");
    if (isNaN(g) || g < 1)
      throw new TypeError("option parameterLimit must be a positive number");
    return (
      isFinite(g) && (g = g | 0),
      function (_) {
        var E = u(_, g);
        if (E === void 0)
          throw (
            (r("too many parameters"),
            n(413, "too many parameters", { type: "parameters.too.many" }))
          );
        var R = Math.max(100, E);
        return (
          r("parse extended urlencoding"),
          v(_, {
            allowPrototypes: !0,
            arrayLimit: R,
            depth: 1 / 0,
            parameterLimit: g,
          })
        );
      }
    );
  }
  function f(m) {
    try {
      return (t.parse(m).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function u(m, g) {
    for (var v = 0, y = 0; (y = m.indexOf("&", y)) !== -1; )
      if ((v++, y++, v === g)) return;
    return v;
  }
  function d(m) {
    var g = o[m];
    if (g !== void 0) return g.parse;
    switch (m) {
      case "qs":
        g = wD();
        break;
      case "querystring":
        g = X0;
        break;
    }
    return (o[m] = g), g.parse;
  }
  function p(m) {
    var g = m.parameterLimit !== void 0 ? m.parameterLimit : 1e3,
      v = d("querystring");
    if (isNaN(g) || g < 1)
      throw new TypeError("option parameterLimit must be a positive number");
    return (
      isFinite(g) && (g = g | 0),
      function (_) {
        var E = u(_, g);
        if (E === void 0)
          throw (
            (r("too many parameters"),
            n(413, "too many parameters", { type: "parameters.too.many" }))
          );
        return r("parse urlencoding"), v(_, void 0, void 0, { maxKeys: g });
      }
    );
  }
  function h(m) {
    return function (v) {
      return !!s(v, m);
    };
  }
  return Vh;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e, t) {
  var n = wi("body-parser"),
    r = Object.create(null);
  (t = e.exports =
    n.function(i, "bodyParser: use individual json/urlencoded middlewares")),
    Object.defineProperty(t, "json", {
      configurable: !0,
      enumerable: !0,
      get: a("json"),
    }),
    Object.defineProperty(t, "raw", {
      configurable: !0,
      enumerable: !0,
      get: a("raw"),
    }),
    Object.defineProperty(t, "text", {
      configurable: !0,
      enumerable: !0,
      get: a("text"),
    }),
    Object.defineProperty(t, "urlencoded", {
      configurable: !0,
      enumerable: !0,
      get: a("urlencoded"),
    });
  function i(o) {
    var c = Object.create(o || null, {
        type: { configurable: !0, enumerable: !0, value: void 0, writable: !0 },
      }),
      l = t.urlencoded(c),
      f = t.json(c);
    return function (d, p, h) {
      f(d, p, function (m) {
        if (m) return h(m);
        l(d, p, h);
      });
    };
  }
  function a(o) {
    return function () {
      return s(o);
    };
  }
  function s(o) {
    var c = r[o];
    if (c !== void 0) return c;
    switch (o) {
      case "json":
        c = vD();
        break;
      case "raw":
        c = yD();
        break;
      case "text":
        c = bD();
        break;
      case "urlencoded":
        c = xD();
        break;
    }
    return (r[o] = c);
  }
})(t0, t0.exports);
var kv = t0.exports,
  J$ = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ var bE = Object.getOwnPropertySymbols,
  AD = Object.prototype.hasOwnProperty,
  SD = Object.prototype.propertyIsEnumerable;
function ID(e) {
  if (e == null)
    throw new TypeError(
      "Object.assign cannot be called with null or undefined",
    );
  return Object(e);
}
function $D() {
  try {
    if (!Object.assign) return !1;
    var e = new String("abc");
    if (((e[5] = "de"), Object.getOwnPropertyNames(e)[0] === "5")) return !1;
    for (var t = {}, n = 0; n < 10; n++) t["_" + String.fromCharCode(n)] = n;
    var r = Object.getOwnPropertyNames(t).map(function (a) {
      return t[a];
    });
    if (r.join("") !== "0123456789") return !1;
    var i = {};
    return (
      "abcdefghijklmnopqrst".split("").forEach(function (a) {
        i[a] = a;
      }),
      Object.keys(Object.assign({}, i)).join("") === "abcdefghijklmnopqrst"
    );
  } catch {
    return !1;
  }
}
var CD = $D()
  ? Object.assign
  : function (e, t) {
      for (var n, r = ID(e), i, a = 1; a < arguments.length; a++) {
        n = Object(arguments[a]);
        for (var s in n) AD.call(n, s) && (r[s] = n[s]);
        if (bE) {
          i = bE(n);
          for (var o = 0; o < i.length; o++)
            SD.call(n, i[o]) && (r[i[o]] = n[i[o]]);
        }
      }
      return r;
    };
(function () {
  var e = CD,
    t = q$,
    n = {
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      preflightContinue: !1,
      optionsSuccessStatus: 204,
    };
  function r(h) {
    return typeof h == "string" || h instanceof String;
  }
  function i(h, m) {
    if (Array.isArray(m)) {
      for (var g = 0; g < m.length; ++g) if (i(h, m[g])) return !0;
      return !1;
    } else return r(m) ? h === m : m instanceof RegExp ? m.test(h) : !!m;
  }
  function a(h, m) {
    var g = m.headers.origin,
      v = [],
      y;
    return (
      !h.origin || h.origin === "*"
        ? v.push([{ key: "Access-Control-Allow-Origin", value: "*" }])
        : r(h.origin)
        ? (v.push([{ key: "Access-Control-Allow-Origin", value: h.origin }]),
          v.push([{ key: "Vary", value: "Origin" }]))
        : ((y = i(g, h.origin)),
          v.push([{ key: "Access-Control-Allow-Origin", value: y ? g : !1 }]),
          v.push([{ key: "Vary", value: "Origin" }])),
      v
    );
  }
  function s(h) {
    var m = h.methods;
    return (
      m.join && (m = h.methods.join(",")),
      { key: "Access-Control-Allow-Methods", value: m }
    );
  }
  function o(h) {
    return h.credentials === !0
      ? { key: "Access-Control-Allow-Credentials", value: "true" }
      : null;
  }
  function c(h, m) {
    var g = h.allowedHeaders || h.headers,
      v = [];
    return (
      g
        ? g.join && (g = g.join(","))
        : ((g = m.headers["access-control-request-headers"]),
          v.push([{ key: "Vary", value: "Access-Control-Request-Headers" }])),
      g &&
        g.length &&
        v.push([{ key: "Access-Control-Allow-Headers", value: g }]),
      v
    );
  }
  function l(h) {
    var m = h.exposedHeaders;
    if (m) m.join && (m = m.join(","));
    else return null;
    return m && m.length
      ? { key: "Access-Control-Expose-Headers", value: m }
      : null;
  }
  function f(h) {
    var m = (typeof h.maxAge == "number" || h.maxAge) && h.maxAge.toString();
    return m && m.length ? { key: "Access-Control-Max-Age", value: m } : null;
  }
  function u(h, m) {
    for (var g = 0, v = h.length; g < v; g++) {
      var y = h[g];
      y &&
        (Array.isArray(y)
          ? u(y, m)
          : y.key === "Vary" && y.value
          ? t(m, y.value)
          : y.value && m.setHeader(y.key, y.value));
    }
  }
  function d(h, m, g, v) {
    var y = [],
      _ = m.method && m.method.toUpperCase && m.method.toUpperCase();
    _ === "OPTIONS"
      ? (y.push(a(h, m)),
        y.push(o(h)),
        y.push(s(h)),
        y.push(c(h, m)),
        y.push(f(h)),
        y.push(l(h)),
        u(y, g),
        h.preflightContinue
          ? v()
          : ((g.statusCode = h.optionsSuccessStatus),
            g.setHeader("Content-Length", "0"),
            g.end()))
      : (y.push(a(h, m)), y.push(o(h)), y.push(l(h)), u(y, g), v());
  }
  function p(h) {
    var m = null;
    return (
      typeof h == "function"
        ? (m = h)
        : (m = function (g, v) {
            v(null, h);
          }),
      function (v, y, _) {
        m(v, function (E, R) {
          if (E) _(E);
          else {
            var A = e({}, n, R),
              I = null;
            A.origin && typeof A.origin == "function"
              ? (I = A.origin)
              : A.origin &&
                (I = function (S, w) {
                  w(null, A.origin);
                }),
              I
                ? I(v.headers.origin, function (S, w) {
                    S || !w ? _(S) : ((A.origin = w), d(A, v, y, _));
                  })
                : _();
          }
        });
      }
    );
  }
  J$.exports = p;
})();
var RD = J$.exports;
const kD = Wl(RD);
var Yh = {},
  Xh = {},
  Ls = {};
Object.defineProperty(Ls, "__esModule", { value: !0 });
Ls.CancellationError = Ls.CancellationToken = void 0;
const TD = Hi;
class ND extends TD.EventEmitter {
  constructor(t) {
    super(),
      (this.parentCancelHandler = null),
      (this._parent = null),
      (this._cancelled = !1),
      t != null && (this.parent = t);
  }
  get cancelled() {
    return this._cancelled || (this._parent != null && this._parent.cancelled);
  }
  set parent(t) {
    this.removeParentCancelHandler(),
      (this._parent = t),
      (this.parentCancelHandler = () => this.cancel()),
      this._parent.onCancel(this.parentCancelHandler);
  }
  cancel() {
    (this._cancelled = !0), this.emit("cancel");
  }
  onCancel(t) {
    this.cancelled ? t() : this.once("cancel", t);
  }
  createPromise(t) {
    if (this.cancelled) return Promise.reject(new n0());
    const n = () => {
      if (r != null)
        try {
          this.removeListener("cancel", r), (r = null);
        } catch {}
    };
    let r = null;
    return new Promise((i, a) => {
      let s = null;
      if (
        ((r = () => {
          try {
            s != null && (s(), (s = null));
          } finally {
            a(new n0());
          }
        }),
        this.cancelled)
      ) {
        r();
        return;
      }
      this.onCancel(r),
        t(i, a, (o) => {
          s = o;
        });
    })
      .then((i) => (n(), i))
      .catch((i) => {
        throw (n(), i);
      });
  }
  removeParentCancelHandler() {
    const t = this._parent;
    t != null &&
      this.parentCancelHandler != null &&
      (t.removeListener("cancel", this.parentCancelHandler),
      (this.parentCancelHandler = null));
  }
  dispose() {
    try {
      this.removeParentCancelHandler();
    } finally {
      this.removeAllListeners(), (this._parent = null);
    }
  }
}
Ls.CancellationToken = ND;
class n0 extends Error {
  constructor() {
    super("cancelled");
  }
}
Ls.CancellationError = n0;
var bn = {},
  r0 = { exports: {} },
  tf = { exports: {} },
  Jh,
  _E;
function OD() {
  if (_E) return Jh;
  _E = 1;
  var e = 1e3,
    t = e * 60,
    n = t * 60,
    r = n * 24,
    i = r * 7,
    a = r * 365.25;
  Jh = function (f, u) {
    u = u || {};
    var d = typeof f;
    if (d === "string" && f.length > 0) return s(f);
    if (d === "number" && isFinite(f)) return u.long ? c(f) : o(f);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(f),
    );
  };
  function s(f) {
    if (((f = String(f)), !(f.length > 100))) {
      var u =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          f,
        );
      if (u) {
        var d = parseFloat(u[1]),
          p = (u[2] || "ms").toLowerCase();
        switch (p) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return d * a;
          case "weeks":
          case "week":
          case "w":
            return d * i;
          case "days":
          case "day":
          case "d":
            return d * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return d * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return d * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return d * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return d;
          default:
            return;
        }
      }
    }
  }
  function o(f) {
    var u = Math.abs(f);
    return u >= r
      ? Math.round(f / r) + "d"
      : u >= n
      ? Math.round(f / n) + "h"
      : u >= t
      ? Math.round(f / t) + "m"
      : u >= e
      ? Math.round(f / e) + "s"
      : f + "ms";
  }
  function c(f) {
    var u = Math.abs(f);
    return u >= r
      ? l(f, u, r, "day")
      : u >= n
      ? l(f, u, n, "hour")
      : u >= t
      ? l(f, u, t, "minute")
      : u >= e
      ? l(f, u, e, "second")
      : f + " ms";
  }
  function l(f, u, d, p) {
    var h = u >= d * 1.5;
    return Math.round(f / d) + " " + p + (h ? "s" : "");
  }
  return Jh;
}
var Zh, EE;
function Z$() {
  if (EE) return Zh;
  EE = 1;
  function e(t) {
    (r.debug = r),
      (r.default = r),
      (r.coerce = l),
      (r.disable = s),
      (r.enable = a),
      (r.enabled = o),
      (r.humanize = OD()),
      (r.destroy = f),
      Object.keys(t).forEach((u) => {
        r[u] = t[u];
      }),
      (r.names = []),
      (r.skips = []),
      (r.formatters = {});
    function n(u) {
      let d = 0;
      for (let p = 0; p < u.length; p++)
        (d = (d << 5) - d + u.charCodeAt(p)), (d |= 0);
      return r.colors[Math.abs(d) % r.colors.length];
    }
    r.selectColor = n;
    function r(u) {
      let d,
        p = null,
        h,
        m;
      function g(...v) {
        if (!g.enabled) return;
        const y = g,
          _ = Number(new Date()),
          E = _ - (d || _);
        (y.diff = E),
          (y.prev = d),
          (y.curr = _),
          (d = _),
          (v[0] = r.coerce(v[0])),
          typeof v[0] != "string" && v.unshift("%O");
        let R = 0;
        (v[0] = v[0].replace(/%([a-zA-Z%])/g, (I, S) => {
          if (I === "%%") return "%";
          R++;
          const w = r.formatters[S];
          if (typeof w == "function") {
            const O = v[R];
            (I = w.call(y, O)), v.splice(R, 1), R--;
          }
          return I;
        })),
          r.formatArgs.call(y, v),
          (y.log || r.log).apply(y, v);
      }
      return (
        (g.namespace = u),
        (g.useColors = r.useColors()),
        (g.color = r.selectColor(u)),
        (g.extend = i),
        (g.destroy = r.destroy),
        Object.defineProperty(g, "enabled", {
          enumerable: !0,
          configurable: !1,
          get: () =>
            p !== null
              ? p
              : (h !== r.namespaces && ((h = r.namespaces), (m = r.enabled(u))),
                m),
          set: (v) => {
            p = v;
          },
        }),
        typeof r.init == "function" && r.init(g),
        g
      );
    }
    function i(u, d) {
      const p = r(this.namespace + (typeof d > "u" ? ":" : d) + u);
      return (p.log = this.log), p;
    }
    function a(u) {
      r.save(u), (r.namespaces = u), (r.names = []), (r.skips = []);
      let d;
      const p = (typeof u == "string" ? u : "").split(/[\s,]+/),
        h = p.length;
      for (d = 0; d < h; d++)
        p[d] &&
          ((u = p[d].replace(/\*/g, ".*?")),
          u[0] === "-"
            ? r.skips.push(new RegExp("^" + u.slice(1) + "$"))
            : r.names.push(new RegExp("^" + u + "$")));
    }
    function s() {
      const u = [...r.names.map(c), ...r.skips.map(c).map((d) => "-" + d)].join(
        ",",
      );
      return r.enable(""), u;
    }
    function o(u) {
      if (u[u.length - 1] === "*") return !0;
      let d, p;
      for (d = 0, p = r.skips.length; d < p; d++)
        if (r.skips[d].test(u)) return !1;
      for (d = 0, p = r.names.length; d < p; d++)
        if (r.names[d].test(u)) return !0;
      return !1;
    }
    function c(u) {
      return u
        .toString()
        .substring(2, u.toString().length - 2)
        .replace(/\.\*\?$/, "*");
    }
    function l(u) {
      return u instanceof Error ? u.stack || u.message : u;
    }
    function f() {
      console.warn(
        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
      );
    }
    return r.enable(r.load()), r;
  }
  return (Zh = e), Zh;
}
var wE;
function PD() {
  return (
    wE ||
      ((wE = 1),
      (function (e, t) {
        (t.formatArgs = r),
          (t.save = i),
          (t.load = a),
          (t.useColors = n),
          (t.storage = s()),
          (t.destroy = (() => {
            let c = !1;
            return () => {
              c ||
                ((c = !0),
                console.warn(
                  "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
                ));
            };
          })()),
          (t.colors = [
            "#0000CC",
            "#0000FF",
            "#0033CC",
            "#0033FF",
            "#0066CC",
            "#0066FF",
            "#0099CC",
            "#0099FF",
            "#00CC00",
            "#00CC33",
            "#00CC66",
            "#00CC99",
            "#00CCCC",
            "#00CCFF",
            "#3300CC",
            "#3300FF",
            "#3333CC",
            "#3333FF",
            "#3366CC",
            "#3366FF",
            "#3399CC",
            "#3399FF",
            "#33CC00",
            "#33CC33",
            "#33CC66",
            "#33CC99",
            "#33CCCC",
            "#33CCFF",
            "#6600CC",
            "#6600FF",
            "#6633CC",
            "#6633FF",
            "#66CC00",
            "#66CC33",
            "#9900CC",
            "#9900FF",
            "#9933CC",
            "#9933FF",
            "#99CC00",
            "#99CC33",
            "#CC0000",
            "#CC0033",
            "#CC0066",
            "#CC0099",
            "#CC00CC",
            "#CC00FF",
            "#CC3300",
            "#CC3333",
            "#CC3366",
            "#CC3399",
            "#CC33CC",
            "#CC33FF",
            "#CC6600",
            "#CC6633",
            "#CC9900",
            "#CC9933",
            "#CCCC00",
            "#CCCC33",
            "#FF0000",
            "#FF0033",
            "#FF0066",
            "#FF0099",
            "#FF00CC",
            "#FF00FF",
            "#FF3300",
            "#FF3333",
            "#FF3366",
            "#FF3399",
            "#FF33CC",
            "#FF33FF",
            "#FF6600",
            "#FF6633",
            "#FF9900",
            "#FF9933",
            "#FFCC00",
            "#FFCC33",
          ]);
        function n() {
          return typeof window < "u" &&
            window.process &&
            (window.process.type === "renderer" || window.process.__nwjs)
            ? !0
            : typeof navigator < "u" &&
              navigator.userAgent &&
              navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
            ? !1
            : (typeof document < "u" &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
              (typeof window < "u" &&
                window.console &&
                (window.console.firebug ||
                  (window.console.exception && window.console.table))) ||
              (typeof navigator < "u" &&
                navigator.userAgent &&
                navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                parseInt(RegExp.$1, 10) >= 31) ||
              (typeof navigator < "u" &&
                navigator.userAgent &&
                navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
        }
        function r(c) {
          if (
            ((c[0] =
              (this.useColors ? "%c" : "") +
              this.namespace +
              (this.useColors ? " %c" : " ") +
              c[0] +
              (this.useColors ? "%c " : " ") +
              "+" +
              e.exports.humanize(this.diff)),
            !this.useColors)
          )
            return;
          const l = "color: " + this.color;
          c.splice(1, 0, l, "color: inherit");
          let f = 0,
            u = 0;
          c[0].replace(/%[a-zA-Z%]/g, (d) => {
            d !== "%%" && (f++, d === "%c" && (u = f));
          }),
            c.splice(u, 0, l);
        }
        t.log = console.debug || console.log || (() => {});
        function i(c) {
          try {
            c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
          } catch {}
        }
        function a() {
          let c;
          try {
            c = t.storage.getItem("debug");
          } catch {}
          return (
            !c &&
              typeof process < "u" &&
              "env" in process &&
              (c = process.env.DEBUG),
            c
          );
        }
        function s() {
          try {
            return localStorage;
          } catch {}
        }
        e.exports = Z$()(t);
        const { formatters: o } = e.exports;
        o.j = function (c) {
          try {
            return JSON.stringify(c);
          } catch (l) {
            return "[UnexpectedJSONParseError]: " + l.message;
          }
        };
      })(tf, tf.exports)),
    tf.exports
  );
}
var nf = { exports: {} },
  em,
  xE;
function DD() {
  return (
    xE ||
      ((xE = 1),
      (em = (e, t = process.argv) => {
        const n = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--",
          r = t.indexOf(n + e),
          i = t.indexOf("--");
        return r !== -1 && (i === -1 || r < i);
      })),
    em
  );
}
var tm, AE;
function LD() {
  if (AE) return tm;
  AE = 1;
  const e = Fr,
    t = hc,
    n = DD(),
    { env: r } = process;
  let i;
  n("no-color") || n("no-colors") || n("color=false") || n("color=never")
    ? (i = 0)
    : (n("color") || n("colors") || n("color=true") || n("color=always")) &&
      (i = 1),
    "FORCE_COLOR" in r &&
      (r.FORCE_COLOR === "true"
        ? (i = 1)
        : r.FORCE_COLOR === "false"
        ? (i = 0)
        : (i =
            r.FORCE_COLOR.length === 0
              ? 1
              : Math.min(parseInt(r.FORCE_COLOR, 10), 3)));
  function a(c) {
    return c === 0
      ? !1
      : { level: c, hasBasic: !0, has256: c >= 2, has16m: c >= 3 };
  }
  function s(c, l) {
    if (i === 0) return 0;
    if (n("color=16m") || n("color=full") || n("color=truecolor")) return 3;
    if (n("color=256")) return 2;
    if (c && !l && i === void 0) return 0;
    const f = i || 0;
    if (r.TERM === "dumb") return f;
    if (process.platform === "win32") {
      const u = e.release().split(".");
      return Number(u[0]) >= 10 && Number(u[2]) >= 10586
        ? Number(u[2]) >= 14931
          ? 3
          : 2
        : 1;
    }
    if ("CI" in r)
      return [
        "TRAVIS",
        "CIRCLECI",
        "APPVEYOR",
        "GITLAB_CI",
        "GITHUB_ACTIONS",
        "BUILDKITE",
      ].some((u) => u in r) || r.CI_NAME === "codeship"
        ? 1
        : f;
    if ("TEAMCITY_VERSION" in r)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(r.TEAMCITY_VERSION) ? 1 : 0;
    if (r.COLORTERM === "truecolor") return 3;
    if ("TERM_PROGRAM" in r) {
      const u = parseInt((r.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (r.TERM_PROGRAM) {
        case "iTerm.app":
          return u >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(r.TERM)
      ? 2
      : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
          r.TERM,
        ) || "COLORTERM" in r
      ? 1
      : f;
  }
  function o(c) {
    const l = s(c, c && c.isTTY);
    return a(l);
  }
  return (
    (tm = {
      supportsColor: o,
      stdout: a(s(!0, t.isatty(1))),
      stderr: a(s(!0, t.isatty(2))),
    }),
    tm
  );
}
var SE;
function BD() {
  return (
    SE ||
      ((SE = 1),
      (function (e, t) {
        const n = hc,
          r = wr;
        (t.init = f),
          (t.log = o),
          (t.formatArgs = a),
          (t.save = c),
          (t.load = l),
          (t.useColors = i),
          (t.destroy = r.deprecate(
            () => {},
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
          )),
          (t.colors = [6, 2, 3, 4, 5, 1]);
        try {
          const d = LD();
          d &&
            (d.stderr || d).level >= 2 &&
            (t.colors = [
              20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57,
              62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99,
              112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164,
              165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185,
              196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
              209, 214, 215, 220, 221,
            ]);
        } catch {}
        t.inspectOpts = Object.keys(process.env)
          .filter((d) => /^debug_/i.test(d))
          .reduce((d, p) => {
            const h = p
              .substring(6)
              .toLowerCase()
              .replace(/_([a-z])/g, (g, v) => v.toUpperCase());
            let m = process.env[p];
            return (
              /^(yes|on|true|enabled)$/i.test(m)
                ? (m = !0)
                : /^(no|off|false|disabled)$/i.test(m)
                ? (m = !1)
                : m === "null"
                ? (m = null)
                : (m = Number(m)),
              (d[h] = m),
              d
            );
          }, {});
        function i() {
          return "colors" in t.inspectOpts
            ? !!t.inspectOpts.colors
            : n.isatty(process.stderr.fd);
        }
        function a(d) {
          const { namespace: p, useColors: h } = this;
          if (h) {
            const m = this.color,
              g = "\x1B[3" + (m < 8 ? m : "8;5;" + m),
              v = `  ${g};1m${p} \x1B[0m`;
            (d[0] =
              v +
              d[0]
                .split(
                  `
`,
                )
                .join(
                  `
` + v,
                )),
              d.push(g + "m+" + e.exports.humanize(this.diff) + "\x1B[0m");
          } else d[0] = s() + p + " " + d[0];
        }
        function s() {
          return t.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
        }
        function o(...d) {
          return process.stderr.write(
            r.format(...d) +
              `
`,
          );
        }
        function c(d) {
          d ? (process.env.DEBUG = d) : delete process.env.DEBUG;
        }
        function l() {
          return process.env.DEBUG;
        }
        function f(d) {
          d.inspectOpts = {};
          const p = Object.keys(t.inspectOpts);
          for (let h = 0; h < p.length; h++)
            d.inspectOpts[p[h]] = t.inspectOpts[p[h]];
        }
        e.exports = Z$()(t);
        const { formatters: u } = e.exports;
        (u.o = function (d) {
          return (
            (this.inspectOpts.colors = this.useColors),
            r
              .inspect(d, this.inspectOpts)
              .split(
                `
`,
              )
              .map((p) => p.trim())
              .join(" ")
          );
        }),
          (u.O = function (d) {
            return (
              (this.inspectOpts.colors = this.useColors),
              r.inspect(d, this.inspectOpts)
            );
          });
      })(nf, nf.exports)),
    nf.exports
  );
}
typeof process > "u" ||
process.type === "renderer" ||
process.browser === !0 ||
process.__nwjs
  ? (r0.exports = PD())
  : (r0.exports = BD());
var UD = r0.exports,
  eu = {};
Object.defineProperty(eu, "__esModule", { value: !0 });
eu.ProgressCallbackTransform = void 0;
const FD = Kr;
class jD extends FD.Transform {
  constructor(t, n, r) {
    super(),
      (this.total = t),
      (this.cancellationToken = n),
      (this.onProgress = r),
      (this.start = Date.now()),
      (this.transferred = 0),
      (this.delta = 0),
      (this.nextUpdate = this.start + 1e3);
  }
  _transform(t, n, r) {
    if (this.cancellationToken.cancelled) {
      r(new Error("cancelled"), null);
      return;
    }
    (this.transferred += t.length), (this.delta += t.length);
    const i = Date.now();
    i >= this.nextUpdate &&
      this.transferred !== this.total &&
      ((this.nextUpdate = i + 1e3),
      this.onProgress({
        total: this.total,
        delta: this.delta,
        transferred: this.transferred,
        percent: (this.transferred / this.total) * 100,
        bytesPerSecond: Math.round(this.transferred / ((i - this.start) / 1e3)),
      }),
      (this.delta = 0)),
      r(null, t);
  }
  _flush(t) {
    if (this.cancellationToken.cancelled) {
      t(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.total,
      percent: 100,
      bytesPerSecond: Math.round(
        this.transferred / ((Date.now() - this.start) / 1e3),
      ),
    }),
      (this.delta = 0),
      t(null);
  }
}
eu.ProgressCallbackTransform = jD;
var IE;
function MD() {
  if (IE) return bn;
  (IE = 1),
    Object.defineProperty(bn, "__esModule", { value: !0 }),
    (bn.safeStringifyJson =
      bn.configureRequestOptions =
      bn.safeGetHeader =
      bn.DigestTransform =
      bn.configureRequestUrl =
      bn.configureRequestOptionsFromUrl =
      bn.HttpExecutor =
      bn.parseJson =
      bn.HttpError =
      bn.createHttpError =
        void 0);
  const e = pr,
    t = UD,
    n = Xt,
    r = Kr,
    i = Ya,
    a = Ls,
    s = Ln(),
    o = eu,
    c = (0, t.default)("electron-builder");
  function l(A, I = null) {
    return new u(
      A.statusCode || -1,
      `${A.statusCode} ${A.statusMessage}` +
        (I == null
          ? ""
          : `
` + JSON.stringify(I, null, "  ")) +
        `
Headers: ` +
        R(A.headers),
      I,
    );
  }
  bn.createHttpError = l;
  const f = new Map([
    [429, "Too many requests"],
    [400, "Bad request"],
    [403, "Forbidden"],
    [404, "Not found"],
    [405, "Method not allowed"],
    [406, "Not acceptable"],
    [408, "Request timeout"],
    [413, "Request entity too large"],
    [500, "Internal server error"],
    [502, "Bad gateway"],
    [503, "Service unavailable"],
    [504, "Gateway timeout"],
    [505, "HTTP version not supported"],
  ]);
  class u extends Error {
    constructor(I, S = `HTTP error: ${f.get(I) || I}`, w = null) {
      super(S),
        (this.statusCode = I),
        (this.description = w),
        (this.name = "HttpError"),
        (this.code = `HTTP_ERROR_${I}`);
    }
    isServerError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
  }
  bn.HttpError = u;
  function d(A) {
    return A.then((I) => (I == null || I.length === 0 ? null : JSON.parse(I)));
  }
  bn.parseJson = d;
  class p {
    constructor() {
      this.maxRedirects = 10;
    }
    request(I, S = new a.CancellationToken(), w) {
      E(I);
      const O = w == null ? void 0 : JSON.stringify(w),
        Q = O ? Buffer.from(O) : void 0;
      if (Q != null) {
        c(O);
        const { headers: j, ...H } = I;
        I = {
          method: "post",
          headers: {
            "Content-Type": "application/json",
            "Content-Length": Q.length,
            ...j,
          },
          ...H,
        };
      }
      return this.doApiRequest(I, S, (j) => j.end(Q));
    }
    doApiRequest(I, S, w, O = 0) {
      return (
        c.enabled && c(`Request: ${R(I)}`),
        S.createPromise((Q, j, H) => {
          const q = this.createRequest(I, (J) => {
            try {
              this.handleResponse(J, I, S, Q, j, O, w);
            } catch (Z) {
              j(Z);
            }
          });
          this.addErrorAndTimeoutHandlers(q, j, I.timeout),
            this.addRedirectHandlers(q, I, j, O, (J) => {
              this.doApiRequest(J, S, w, O).then(Q).catch(j);
            }),
            w(q, j),
            H(() => q.abort());
        })
      );
    }
    addRedirectHandlers(I, S, w, O, Q) {}
    addErrorAndTimeoutHandlers(I, S, w = 60 * 1e3) {
      this.addTimeOutHandler(I, S, w),
        I.on("error", S),
        I.on("aborted", () => {
          S(new Error("Request has been aborted by the server"));
        });
    }
    handleResponse(I, S, w, O, Q, j, H) {
      var q;
      if (
        (c.enabled &&
          c(
            `Response: ${I.statusCode} ${I.statusMessage}, request options: ${R(
              S,
            )}`,
          ),
        I.statusCode === 404)
      ) {
        Q(
          l(
            I,
            `method: ${S.method || "GET"} url: ${S.protocol || "https:"}//${
              S.hostname
            }${S.port ? `:${S.port}` : ""}${S.path}

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`,
          ),
        );
        return;
      } else if (I.statusCode === 204) {
        O();
        return;
      }
      const J = (q = I.statusCode) !== null && q !== void 0 ? q : 0,
        Z = J >= 300 && J < 400,
        z = y(I, "location");
      if (Z && z != null) {
        if (j > this.maxRedirects) {
          Q(this.createMaxRedirectError());
          return;
        }
        this.doApiRequest(p.prepareRedirectUrlOptions(z, S), w, H, j)
          .then(O)
          .catch(Q);
        return;
      }
      I.setEncoding("utf8");
      let U = "";
      I.on("error", Q),
        I.on("data", (G) => (U += G)),
        I.on("end", () => {
          try {
            if (I.statusCode != null && I.statusCode >= 400) {
              const G = y(I, "content-type"),
                L =
                  G != null &&
                  (Array.isArray(G)
                    ? G.find((k) => k.includes("json")) != null
                    : G.includes("json"));
              Q(
                l(
                  I,
                  `method: ${S.method || "GET"} url: ${
                    S.protocol || "https:"
                  }//${S.hostname}${S.port ? `:${S.port}` : ""}${S.path}

          Data:
          ${L ? JSON.stringify(JSON.parse(U)) : U}
          `,
                ),
              );
            } else O(U.length === 0 ? null : U);
          } catch (G) {
            Q(G);
          }
        });
    }
    async downloadToBuffer(I, S) {
      return await S.cancellationToken.createPromise((w, O, Q) => {
        const j = [],
          H = { headers: S.headers || void 0, redirect: "manual" };
        m(I, H),
          E(H),
          this.doDownload(
            H,
            {
              destination: null,
              options: S,
              onCancel: Q,
              callback: (q) => {
                q == null ? w(Buffer.concat(j)) : O(q);
              },
              responseHandler: (q, J) => {
                let Z = 0;
                q.on("data", (z) => {
                  if (((Z += z.length), Z > 524288e3)) {
                    J(new Error("Maximum allowed size is 500 MB"));
                    return;
                  }
                  j.push(z);
                }),
                  q.on("end", () => {
                    J(null);
                  });
              },
            },
            0,
          );
      });
    }
    doDownload(I, S, w) {
      const O = this.createRequest(I, (Q) => {
        if (Q.statusCode >= 400) {
          S.callback(
            new Error(
              `Cannot download "${I.protocol || "https:"}//${I.hostname}${
                I.path
              }", status ${Q.statusCode}: ${Q.statusMessage}`,
            ),
          );
          return;
        }
        Q.on("error", S.callback);
        const j = y(Q, "location");
        if (j != null) {
          w < this.maxRedirects
            ? this.doDownload(p.prepareRedirectUrlOptions(j, I), S, w++)
            : S.callback(this.createMaxRedirectError());
          return;
        }
        S.responseHandler == null ? _(S, Q) : S.responseHandler(Q, S.callback);
      });
      this.addErrorAndTimeoutHandlers(O, S.callback, I.timeout),
        this.addRedirectHandlers(O, I, S.callback, w, (Q) => {
          this.doDownload(Q, S, w++);
        }),
        O.end();
    }
    createMaxRedirectError() {
      return new Error(`Too many redirects (> ${this.maxRedirects})`);
    }
    addTimeOutHandler(I, S, w) {
      I.on("socket", (O) => {
        O.setTimeout(w, () => {
          I.abort(), S(new Error("Request timed out"));
        });
      });
    }
    static prepareRedirectUrlOptions(I, S) {
      const w = h(I, { ...S }),
        O = w.headers;
      if (O != null && O.authorization) {
        const Q = new i.URL(I);
        (Q.hostname.endsWith(".amazonaws.com") ||
          Q.searchParams.has("X-Amz-Credential")) &&
          delete O.authorization;
      }
      return w;
    }
    static retryOnServerError(I, S = 3) {
      for (let w = 0; ; w++)
        try {
          return I();
        } catch (O) {
          if (
            w < S &&
            ((O instanceof u && O.isServerError()) || O.code === "EPIPE")
          )
            continue;
          throw O;
        }
    }
  }
  bn.HttpExecutor = p;
  function h(A, I) {
    const S = E(I);
    return m(new i.URL(A), S), S;
  }
  bn.configureRequestOptionsFromUrl = h;
  function m(A, I) {
    (I.protocol = A.protocol),
      (I.hostname = A.hostname),
      A.port ? (I.port = A.port) : I.port && delete I.port,
      (I.path = A.pathname + A.search);
  }
  bn.configureRequestUrl = m;
  class g extends r.Transform {
    constructor(I, S = "sha512", w = "base64") {
      super(),
        (this.expected = I),
        (this.algorithm = S),
        (this.encoding = w),
        (this._actual = null),
        (this.isValidateOnEnd = !0),
        (this.digester = (0, e.createHash)(S));
    }
    get actual() {
      return this._actual;
    }
    _transform(I, S, w) {
      this.digester.update(I), w(null, I);
    }
    _flush(I) {
      if (
        ((this._actual = this.digester.digest(this.encoding)),
        this.isValidateOnEnd)
      )
        try {
          this.validate();
        } catch (S) {
          I(S);
          return;
        }
      I(null);
    }
    validate() {
      if (this._actual == null)
        throw (0, s.newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
      if (this._actual !== this.expected)
        throw (0, s.newError)(
          `${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`,
          "ERR_CHECKSUM_MISMATCH",
        );
      return null;
    }
  }
  bn.DigestTransform = g;
  function v(A, I, S) {
    return A != null && I != null && A !== I
      ? (S(
          new Error(
            `checksum mismatch: expected ${I} but got ${A} (X-Checksum-Sha2 header)`,
          ),
        ),
        !1)
      : !0;
  }
  function y(A, I) {
    const S = A.headers[I];
    return S == null
      ? null
      : Array.isArray(S)
      ? S.length === 0
        ? null
        : S[S.length - 1]
      : S;
  }
  bn.safeGetHeader = y;
  function _(A, I) {
    if (!v(y(I, "X-Checksum-Sha2"), A.options.sha2, A.callback)) return;
    const S = [];
    if (A.options.onProgress != null) {
      const j = y(I, "content-length");
      j != null &&
        S.push(
          new o.ProgressCallbackTransform(
            parseInt(j, 10),
            A.options.cancellationToken,
            A.options.onProgress,
          ),
        );
    }
    const w = A.options.sha512;
    w != null
      ? S.push(
          new g(
            w,
            "sha512",
            w.length === 128 &&
            !w.includes("+") &&
            !w.includes("Z") &&
            !w.includes("=")
              ? "hex"
              : "base64",
          ),
        )
      : A.options.sha2 != null &&
        S.push(new g(A.options.sha2, "sha256", "hex"));
    const O = (0, n.createWriteStream)(A.destination);
    S.push(O);
    let Q = I;
    for (const j of S)
      j.on("error", (H) => {
        O.close(), A.options.cancellationToken.cancelled || A.callback(H);
      }),
        (Q = Q.pipe(j));
    O.on("finish", () => {
      O.close(A.callback);
    });
  }
  function E(A, I, S) {
    S != null && (A.method = S), (A.headers = { ...A.headers });
    const w = A.headers;
    return (
      I != null &&
        (w.authorization =
          I.startsWith("Basic") || I.startsWith("Bearer") ? I : `token ${I}`),
      w["User-Agent"] == null && (w["User-Agent"] = "electron-builder"),
      (S == null || S === "GET" || w["Cache-Control"] == null) &&
        (w["Cache-Control"] = "no-cache"),
      A.protocol == null &&
        process.versions.electron != null &&
        (A.protocol = "https:"),
      A
    );
  }
  bn.configureRequestOptions = E;
  function R(A, I) {
    return JSON.stringify(
      A,
      (S, w) =>
        S.endsWith("Authorization") ||
        S.endsWith("authorization") ||
        S.endsWith("Password") ||
        S.endsWith("PASSWORD") ||
        S.endsWith("Token") ||
        S.includes("password") ||
        S.includes("token") ||
        (I != null && I.has(S))
          ? "<stripped sensitive data>"
          : w,
      2,
    );
  }
  return (bn.safeStringifyJson = R), bn;
}
var Yo = {};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.getS3LikeProviderBaseUrl = Yo.githubUrl = void 0;
function HD(e, t = "github.com") {
  return `${e.protocol || "https"}://${e.host || t}`;
}
Yo.githubUrl = HD;
function qD(e) {
  const t = e.provider;
  if (t === "s3") return GD(e);
  if (t === "spaces") return QD(e);
  throw new Error(`Not supported provider: ${t}`);
}
Yo.getS3LikeProviderBaseUrl = qD;
function GD(e) {
  let t;
  if (e.accelerate == !0) t = `https://${e.bucket}.s3-accelerate.amazonaws.com`;
  else if (e.endpoint != null) t = `${e.endpoint}/${e.bucket}`;
  else if (e.bucket.includes(".")) {
    if (e.region == null)
      throw new Error(
        `Bucket name "${e.bucket}" includes a dot, but S3 region is missing`,
      );
    e.region === "us-east-1"
      ? (t = `https://s3.amazonaws.com/${e.bucket}`)
      : (t = `https://s3-${e.region}.amazonaws.com/${e.bucket}`);
  } else
    e.region === "cn-north-1"
      ? (t = `https://${e.bucket}.s3.${e.region}.amazonaws.com.cn`)
      : (t = `https://${e.bucket}.s3.amazonaws.com`);
  return e2(t, e.path);
}
function e2(e, t) {
  return (
    t != null && t.length > 0 && (t.startsWith("/") || (e += "/"), (e += t)), e
  );
}
function QD(e) {
  if (e.name == null) throw new Error("name is missing");
  if (e.region == null) throw new Error("region is missing");
  return e2(`https://${e.name}.${e.region}.digitaloceanspaces.com`, e.path);
}
var np = {};
Object.defineProperty(np, "__esModule", { value: !0 });
np.parseDn = void 0;
function WD(e) {
  let t = !1,
    n = null,
    r = "",
    i = 0;
  e = e.trim();
  const a = new Map();
  for (let s = 0; s <= e.length; s++) {
    if (s === e.length) {
      n !== null && a.set(n, r);
      break;
    }
    const o = e[s];
    if (t) {
      if (o === '"') {
        t = !1;
        continue;
      }
    } else {
      if (o === '"') {
        t = !0;
        continue;
      }
      if (o === "\\") {
        s++;
        const c = parseInt(e.slice(s, s + 2), 16);
        Number.isNaN(c) ? (r += e[s]) : (s++, (r += String.fromCharCode(c)));
        continue;
      }
      if (n === null && o === "=") {
        (n = r), (r = "");
        continue;
      }
      if (o === "," || o === ";" || o === "+") {
        n !== null && a.set(n, r), (n = null), (r = "");
        continue;
      }
    }
    if (o === " " && !t) {
      if (r.length === 0) continue;
      if (s > i) {
        let c = s;
        for (; e[c] === " "; ) c++;
        i = c;
      }
      if (
        i >= e.length ||
        e[i] === "," ||
        e[i] === ";" ||
        (n === null && e[i] === "=") ||
        (n !== null && e[i] === "+")
      ) {
        s = i - 1;
        continue;
      }
    }
    r += o;
  }
  return a;
}
np.parseDn = WD;
var ss = {},
  $E;
function zD() {
  if ($E) return ss;
  ($E = 1),
    Object.defineProperty(ss, "__esModule", { value: !0 }),
    (ss.nil = ss.UUID = void 0);
  const e = pr,
    t = Ln(),
    n = "options.name must be either a string or a Buffer",
    r = (0, e.randomBytes)(16);
  r[0] = r[0] | 1;
  const i = {},
    a = [];
  for (let u = 0; u < 256; u++) {
    const d = (u + 256).toString(16).substr(1);
    (i[d] = u), (a[u] = d);
  }
  class s {
    constructor(d) {
      (this.ascii = null), (this.binary = null);
      const p = s.check(d);
      if (!p) throw new Error("not a UUID");
      (this.version = p.version),
        p.format === "ascii" ? (this.ascii = d) : (this.binary = d);
    }
    static v5(d, p) {
      return l(d, "sha1", 80, p);
    }
    toString() {
      return this.ascii == null && (this.ascii = f(this.binary)), this.ascii;
    }
    inspect() {
      return `UUID v${this.version} ${this.toString()}`;
    }
    static check(d, p = 0) {
      if (typeof d == "string")
        return (
          (d = d.toLowerCase()),
          /^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(d)
            ? d === "00000000-0000-0000-0000-000000000000"
              ? { version: void 0, variant: "nil", format: "ascii" }
              : {
                  version: (i[d[14] + d[15]] & 240) >> 4,
                  variant: o((i[d[19] + d[20]] & 224) >> 5),
                  format: "ascii",
                }
            : !1
        );
      if (Buffer.isBuffer(d)) {
        if (d.length < p + 16) return !1;
        let h = 0;
        for (; h < 16 && d[p + h] === 0; h++);
        return h === 16
          ? { version: void 0, variant: "nil", format: "binary" }
          : {
              version: (d[p + 6] & 240) >> 4,
              variant: o((d[p + 8] & 224) >> 5),
              format: "binary",
            };
      }
      throw (0, t.newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
    }
    static parse(d) {
      const p = Buffer.allocUnsafe(16);
      let h = 0;
      for (let m = 0; m < 16; m++)
        (p[m] = i[d[h++] + d[h++]]),
          (m === 3 || m === 5 || m === 7 || m === 9) && (h += 1);
      return p;
    }
  }
  (ss.UUID = s), (s.OID = s.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8"));
  function o(u) {
    switch (u) {
      case 0:
      case 1:
      case 3:
        return "ncs";
      case 4:
      case 5:
        return "rfc4122";
      case 6:
        return "microsoft";
      default:
        return "future";
    }
  }
  var c;
  (function (u) {
    (u[(u.ASCII = 0)] = "ASCII"),
      (u[(u.BINARY = 1)] = "BINARY"),
      (u[(u.OBJECT = 2)] = "OBJECT");
  })(c || (c = {}));
  function l(u, d, p, h, m = c.ASCII) {
    const g = (0, e.createHash)(d);
    if (typeof u != "string" && !Buffer.isBuffer(u))
      throw (0, t.newError)(n, "ERR_INVALID_UUID_NAME");
    g.update(h), g.update(u);
    const y = g.digest();
    let _;
    switch (m) {
      case c.BINARY:
        (y[6] = (y[6] & 15) | p), (y[8] = (y[8] & 63) | 128), (_ = y);
        break;
      case c.OBJECT:
        (y[6] = (y[6] & 15) | p), (y[8] = (y[8] & 63) | 128), (_ = new s(y));
        break;
      default:
        _ =
          a[y[0]] +
          a[y[1]] +
          a[y[2]] +
          a[y[3]] +
          "-" +
          a[y[4]] +
          a[y[5]] +
          "-" +
          a[(y[6] & 15) | p] +
          a[y[7]] +
          "-" +
          a[(y[8] & 63) | 128] +
          a[y[9]] +
          "-" +
          a[y[10]] +
          a[y[11]] +
          a[y[12]] +
          a[y[13]] +
          a[y[14]] +
          a[y[15]];
        break;
    }
    return _;
  }
  function f(u) {
    return (
      a[u[0]] +
      a[u[1]] +
      a[u[2]] +
      a[u[3]] +
      "-" +
      a[u[4]] +
      a[u[5]] +
      "-" +
      a[u[6]] +
      a[u[7]] +
      "-" +
      a[u[8]] +
      a[u[9]] +
      "-" +
      a[u[10]] +
      a[u[11]] +
      a[u[12]] +
      a[u[13]] +
      a[u[14]] +
      a[u[15]]
    );
  }
  return (ss.nil = new s("00000000-0000-0000-0000-000000000000")), ss;
}
var os = {},
  t2 = {};
(function (e) {
  (function (t) {
    (t.parser = function (B, N) {
      return new r(B, N);
    }),
      (t.SAXParser = r),
      (t.SAXStream = f),
      (t.createStream = l),
      (t.MAX_BUFFER_LENGTH = 64 * 1024);
    var n = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script",
    ];
    t.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace",
    ];
    function r(B, N) {
      if (!(this instanceof r)) return new r(B, N);
      var ce = this;
      a(ce),
        (ce.q = ce.c = ""),
        (ce.bufferCheckPosition = t.MAX_BUFFER_LENGTH),
        (ce.opt = N || {}),
        (ce.opt.lowercase = ce.opt.lowercase || ce.opt.lowercasetags),
        (ce.looseCase = ce.opt.lowercase ? "toLowerCase" : "toUpperCase"),
        (ce.tags = []),
        (ce.closed = ce.closedRoot = ce.sawRoot = !1),
        (ce.tag = ce.error = null),
        (ce.strict = !!B),
        (ce.noscript = !!(B || ce.opt.noscript)),
        (ce.state = w.BEGIN),
        (ce.strictEntities = ce.opt.strictEntities),
        (ce.ENTITIES = ce.strictEntities
          ? Object.create(t.XML_ENTITIES)
          : Object.create(t.ENTITIES)),
        (ce.attribList = []),
        ce.opt.xmlns && (ce.ns = Object.create(m)),
        (ce.trackPosition = ce.opt.position !== !1),
        ce.trackPosition && (ce.position = ce.line = ce.column = 0),
        Q(ce, "onready");
    }
    Object.create ||
      (Object.create = function (B) {
        function N() {}
        N.prototype = B;
        var ce = new N();
        return ce;
      }),
      Object.keys ||
        (Object.keys = function (B) {
          var N = [];
          for (var ce in B) B.hasOwnProperty(ce) && N.push(ce);
          return N;
        });
    function i(B) {
      for (
        var N = Math.max(t.MAX_BUFFER_LENGTH, 10),
          ce = 0,
          re = 0,
          ne = n.length;
        re < ne;
        re++
      ) {
        var Y = B[n[re]].length;
        if (Y > N)
          switch (n[re]) {
            case "textNode":
              H(B);
              break;
            case "cdata":
              j(B, "oncdata", B.cdata), (B.cdata = "");
              break;
            case "script":
              j(B, "onscript", B.script), (B.script = "");
              break;
            default:
              J(B, "Max buffer length exceeded: " + n[re]);
          }
        ce = Math.max(ce, Y);
      }
      var M = t.MAX_BUFFER_LENGTH - ce;
      B.bufferCheckPosition = M + B.position;
    }
    function a(B) {
      for (var N = 0, ce = n.length; N < ce; N++) B[n[N]] = "";
    }
    function s(B) {
      H(B),
        B.cdata !== "" && (j(B, "oncdata", B.cdata), (B.cdata = "")),
        B.script !== "" && (j(B, "onscript", B.script), (B.script = ""));
    }
    r.prototype = {
      end: function () {
        Z(this);
      },
      write: V,
      resume: function () {
        return (this.error = null), this;
      },
      close: function () {
        return this.write(null);
      },
      flush: function () {
        s(this);
      },
    };
    var o;
    try {
      o = require("stream").Stream;
    } catch {
      o = function () {};
    }
    var c = t.EVENTS.filter(function (B) {
      return B !== "error" && B !== "end";
    });
    function l(B, N) {
      return new f(B, N);
    }
    function f(B, N) {
      if (!(this instanceof f)) return new f(B, N);
      o.apply(this),
        (this._parser = new r(B, N)),
        (this.writable = !0),
        (this.readable = !0);
      var ce = this;
      (this._parser.onend = function () {
        ce.emit("end");
      }),
        (this._parser.onerror = function (re) {
          ce.emit("error", re), (ce._parser.error = null);
        }),
        (this._decoder = null),
        c.forEach(function (re) {
          Object.defineProperty(ce, "on" + re, {
            get: function () {
              return ce._parser["on" + re];
            },
            set: function (ne) {
              if (!ne)
                return (
                  ce.removeAllListeners(re), (ce._parser["on" + re] = ne), ne
                );
              ce.on(re, ne);
            },
            enumerable: !0,
            configurable: !1,
          });
        });
    }
    (f.prototype = Object.create(o.prototype, { constructor: { value: f } })),
      (f.prototype.write = function (B) {
        if (
          typeof Buffer == "function" &&
          typeof Buffer.isBuffer == "function" &&
          Buffer.isBuffer(B)
        ) {
          if (!this._decoder) {
            var N = dI.StringDecoder;
            this._decoder = new N("utf8");
          }
          B = this._decoder.write(B);
        }
        return this._parser.write(B.toString()), this.emit("data", B), !0;
      }),
      (f.prototype.end = function (B) {
        return B && B.length && this.write(B), this._parser.end(), !0;
      }),
      (f.prototype.on = function (B, N) {
        var ce = this;
        return (
          !ce._parser["on" + B] &&
            c.indexOf(B) !== -1 &&
            (ce._parser["on" + B] = function () {
              var re =
                arguments.length === 1
                  ? [arguments[0]]
                  : Array.apply(null, arguments);
              re.splice(0, 0, B), ce.emit.apply(ce, re);
            }),
          o.prototype.on.call(ce, B, N)
        );
      });
    var u = "[CDATA[",
      d = "DOCTYPE",
      p = "http://www.w3.org/XML/1998/namespace",
      h = "http://www.w3.org/2000/xmlns/",
      m = { xml: p, xmlns: h },
      g =
        /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
      v =
        /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/,
      y =
        /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
      _ =
        /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function E(B) {
      return (
        B === " " ||
        B ===
          `
` ||
        B === "\r" ||
        B === "	"
      );
    }
    function R(B) {
      return B === '"' || B === "'";
    }
    function A(B) {
      return B === ">" || E(B);
    }
    function I(B, N) {
      return B.test(N);
    }
    function S(B, N) {
      return !I(B, N);
    }
    var w = 0;
    (t.STATE = {
      BEGIN: w++,
      BEGIN_WHITESPACE: w++,
      TEXT: w++,
      TEXT_ENTITY: w++,
      OPEN_WAKA: w++,
      SGML_DECL: w++,
      SGML_DECL_QUOTED: w++,
      DOCTYPE: w++,
      DOCTYPE_QUOTED: w++,
      DOCTYPE_DTD: w++,
      DOCTYPE_DTD_QUOTED: w++,
      COMMENT_STARTING: w++,
      COMMENT: w++,
      COMMENT_ENDING: w++,
      COMMENT_ENDED: w++,
      CDATA: w++,
      CDATA_ENDING: w++,
      CDATA_ENDING_2: w++,
      PROC_INST: w++,
      PROC_INST_BODY: w++,
      PROC_INST_ENDING: w++,
      OPEN_TAG: w++,
      OPEN_TAG_SLASH: w++,
      ATTRIB: w++,
      ATTRIB_NAME: w++,
      ATTRIB_NAME_SAW_WHITE: w++,
      ATTRIB_VALUE: w++,
      ATTRIB_VALUE_QUOTED: w++,
      ATTRIB_VALUE_CLOSED: w++,
      ATTRIB_VALUE_UNQUOTED: w++,
      ATTRIB_VALUE_ENTITY_Q: w++,
      ATTRIB_VALUE_ENTITY_U: w++,
      CLOSE_TAG: w++,
      CLOSE_TAG_SAW_WHITE: w++,
      SCRIPT: w++,
      SCRIPT_ENDING: w++,
    }),
      (t.XML_ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'" }),
      (t.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830,
      }),
      Object.keys(t.ENTITIES).forEach(function (B) {
        var N = t.ENTITIES[B],
          ce = typeof N == "number" ? String.fromCharCode(N) : N;
        t.ENTITIES[B] = ce;
      });
    for (var O in t.STATE) t.STATE[t.STATE[O]] = O;
    w = t.STATE;
    function Q(B, N, ce) {
      B[N] && B[N](ce);
    }
    function j(B, N, ce) {
      B.textNode && H(B), Q(B, N, ce);
    }
    function H(B) {
      (B.textNode = q(B.opt, B.textNode)),
        B.textNode && Q(B, "ontext", B.textNode),
        (B.textNode = "");
    }
    function q(B, N) {
      return (
        B.trim && (N = N.trim()), B.normalize && (N = N.replace(/\s+/g, " ")), N
      );
    }
    function J(B, N) {
      return (
        H(B),
        B.trackPosition &&
          (N +=
            `
Line: ` +
            B.line +
            `
Column: ` +
            B.column +
            `
Char: ` +
            B.c),
        (N = new Error(N)),
        (B.error = N),
        Q(B, "onerror", N),
        B
      );
    }
    function Z(B) {
      return (
        B.sawRoot && !B.closedRoot && z(B, "Unclosed root tag"),
        B.state !== w.BEGIN &&
          B.state !== w.BEGIN_WHITESPACE &&
          B.state !== w.TEXT &&
          J(B, "Unexpected end"),
        H(B),
        (B.c = ""),
        (B.closed = !0),
        Q(B, "onend"),
        r.call(B, B.strict, B.opt),
        B
      );
    }
    function z(B, N) {
      if (typeof B != "object" || !(B instanceof r))
        throw new Error("bad call to strictFail");
      B.strict && J(B, N);
    }
    function U(B) {
      B.strict || (B.tagName = B.tagName[B.looseCase]());
      var N = B.tags[B.tags.length - 1] || B,
        ce = (B.tag = { name: B.tagName, attributes: {} });
      B.opt.xmlns && (ce.ns = N.ns),
        (B.attribList.length = 0),
        j(B, "onopentagstart", ce);
    }
    function G(B, N) {
      var ce = B.indexOf(":"),
        re = ce < 0 ? ["", B] : B.split(":"),
        ne = re[0],
        Y = re[1];
      return (
        N && B === "xmlns" && ((ne = "xmlns"), (Y = "")),
        { prefix: ne, local: Y }
      );
    }
    function L(B) {
      if (
        (B.strict || (B.attribName = B.attribName[B.looseCase]()),
        B.attribList.indexOf(B.attribName) !== -1 ||
          B.tag.attributes.hasOwnProperty(B.attribName))
      ) {
        B.attribName = B.attribValue = "";
        return;
      }
      if (B.opt.xmlns) {
        var N = G(B.attribName, !0),
          ce = N.prefix,
          re = N.local;
        if (ce === "xmlns")
          if (re === "xml" && B.attribValue !== p)
            z(
              B,
              "xml: prefix must be bound to " +
                p +
                `
Actual: ` +
                B.attribValue,
            );
          else if (re === "xmlns" && B.attribValue !== h)
            z(
              B,
              "xmlns: prefix must be bound to " +
                h +
                `
Actual: ` +
                B.attribValue,
            );
          else {
            var ne = B.tag,
              Y = B.tags[B.tags.length - 1] || B;
            ne.ns === Y.ns && (ne.ns = Object.create(Y.ns)),
              (ne.ns[re] = B.attribValue);
          }
        B.attribList.push([B.attribName, B.attribValue]);
      } else
        (B.tag.attributes[B.attribName] = B.attribValue),
          j(B, "onattribute", { name: B.attribName, value: B.attribValue });
      B.attribName = B.attribValue = "";
    }
    function k(B, N) {
      if (B.opt.xmlns) {
        var ce = B.tag,
          re = G(B.tagName);
        (ce.prefix = re.prefix),
          (ce.local = re.local),
          (ce.uri = ce.ns[re.prefix] || ""),
          ce.prefix &&
            !ce.uri &&
            (z(B, "Unbound namespace prefix: " + JSON.stringify(B.tagName)),
            (ce.uri = re.prefix));
        var ne = B.tags[B.tags.length - 1] || B;
        ce.ns &&
          ne.ns !== ce.ns &&
          Object.keys(ce.ns).forEach(function (ye) {
            j(B, "onopennamespace", { prefix: ye, uri: ce.ns[ye] });
          });
        for (var Y = 0, M = B.attribList.length; Y < M; Y++) {
          var oe = B.attribList[Y],
            Ee = oe[0],
            le = oe[1],
            te = G(Ee, !0),
            ie = te.prefix,
            X = te.local,
            he = ie === "" ? "" : ce.ns[ie] || "",
            be = { name: Ee, value: le, prefix: ie, local: X, uri: he };
          ie &&
            ie !== "xmlns" &&
            !he &&
            (z(B, "Unbound namespace prefix: " + JSON.stringify(ie)),
            (be.uri = ie)),
            (B.tag.attributes[Ee] = be),
            j(B, "onattribute", be);
        }
        B.attribList.length = 0;
      }
      (B.tag.isSelfClosing = !!N),
        (B.sawRoot = !0),
        B.tags.push(B.tag),
        j(B, "onopentag", B.tag),
        N ||
          (!B.noscript && B.tagName.toLowerCase() === "script"
            ? (B.state = w.SCRIPT)
            : (B.state = w.TEXT),
          (B.tag = null),
          (B.tagName = "")),
        (B.attribName = B.attribValue = ""),
        (B.attribList.length = 0);
    }
    function W(B) {
      if (!B.tagName) {
        z(B, "Weird empty close tag."),
          (B.textNode += "</>"),
          (B.state = w.TEXT);
        return;
      }
      if (B.script) {
        if (B.tagName !== "script") {
          (B.script += "</" + B.tagName + ">"),
            (B.tagName = ""),
            (B.state = w.SCRIPT);
          return;
        }
        j(B, "onscript", B.script), (B.script = "");
      }
      var N = B.tags.length,
        ce = B.tagName;
      B.strict || (ce = ce[B.looseCase]());
      for (var re = ce; N--; ) {
        var ne = B.tags[N];
        if (ne.name !== re) z(B, "Unexpected close tag");
        else break;
      }
      if (N < 0) {
        z(B, "Unmatched closing tag: " + B.tagName),
          (B.textNode += "</" + B.tagName + ">"),
          (B.state = w.TEXT);
        return;
      }
      B.tagName = ce;
      for (var Y = B.tags.length; Y-- > N; ) {
        var M = (B.tag = B.tags.pop());
        (B.tagName = B.tag.name), j(B, "onclosetag", B.tagName);
        var oe = {};
        for (var Ee in M.ns) oe[Ee] = M.ns[Ee];
        var le = B.tags[B.tags.length - 1] || B;
        B.opt.xmlns &&
          M.ns !== le.ns &&
          Object.keys(M.ns).forEach(function (te) {
            var ie = M.ns[te];
            j(B, "onclosenamespace", { prefix: te, uri: ie });
          });
      }
      N === 0 && (B.closedRoot = !0),
        (B.tagName = B.attribValue = B.attribName = ""),
        (B.attribList.length = 0),
        (B.state = w.TEXT);
    }
    function F(B) {
      var N = B.entity,
        ce = N.toLowerCase(),
        re,
        ne = "";
      return B.ENTITIES[N]
        ? B.ENTITIES[N]
        : B.ENTITIES[ce]
        ? B.ENTITIES[ce]
        : ((N = ce),
          N.charAt(0) === "#" &&
            (N.charAt(1) === "x"
              ? ((N = N.slice(2)),
                (re = parseInt(N, 16)),
                (ne = re.toString(16)))
              : ((N = N.slice(1)),
                (re = parseInt(N, 10)),
                (ne = re.toString(10)))),
          (N = N.replace(/^0+/, "")),
          isNaN(re) || ne.toLowerCase() !== N
            ? (z(B, "Invalid character entity"), "&" + B.entity + ";")
            : String.fromCodePoint(re));
    }
    function x(B, N) {
      N === "<"
        ? ((B.state = w.OPEN_WAKA), (B.startTagPosition = B.position))
        : E(N) ||
          (z(B, "Non-whitespace before first tag."),
          (B.textNode = N),
          (B.state = w.TEXT));
    }
    function T(B, N) {
      var ce = "";
      return N < B.length && (ce = B.charAt(N)), ce;
    }
    function V(B) {
      var N = this;
      if (this.error) throw this.error;
      if (N.closed)
        return J(N, "Cannot write after close. Assign an onready handler.");
      if (B === null) return Z(N);
      typeof B == "object" && (B = B.toString());
      for (var ce = 0, re = ""; (re = T(B, ce++)), (N.c = re), !!re; )
        switch (
          (N.trackPosition &&
            (N.position++,
            re ===
            `
`
              ? (N.line++, (N.column = 0))
              : N.column++),
          N.state)
        ) {
          case w.BEGIN:
            if (((N.state = w.BEGIN_WHITESPACE), re === "\uFEFF")) continue;
            x(N, re);
            continue;
          case w.BEGIN_WHITESPACE:
            x(N, re);
            continue;
          case w.TEXT:
            if (N.sawRoot && !N.closedRoot) {
              for (var ne = ce - 1; re && re !== "<" && re !== "&"; )
                (re = T(B, ce++)),
                  re &&
                    N.trackPosition &&
                    (N.position++,
                    re ===
                    `
`
                      ? (N.line++, (N.column = 0))
                      : N.column++);
              N.textNode += B.substring(ne, ce - 1);
            }
            re === "<" && !(N.sawRoot && N.closedRoot && !N.strict)
              ? ((N.state = w.OPEN_WAKA), (N.startTagPosition = N.position))
              : (!E(re) &&
                  (!N.sawRoot || N.closedRoot) &&
                  z(N, "Text data outside of root node."),
                re === "&" ? (N.state = w.TEXT_ENTITY) : (N.textNode += re));
            continue;
          case w.SCRIPT:
            re === "<" ? (N.state = w.SCRIPT_ENDING) : (N.script += re);
            continue;
          case w.SCRIPT_ENDING:
            re === "/"
              ? (N.state = w.CLOSE_TAG)
              : ((N.script += "<" + re), (N.state = w.SCRIPT));
            continue;
          case w.OPEN_WAKA:
            if (re === "!") (N.state = w.SGML_DECL), (N.sgmlDecl = "");
            else if (!E(re))
              if (I(g, re)) (N.state = w.OPEN_TAG), (N.tagName = re);
              else if (re === "/") (N.state = w.CLOSE_TAG), (N.tagName = "");
              else if (re === "?")
                (N.state = w.PROC_INST), (N.procInstName = N.procInstBody = "");
              else {
                if (
                  (z(N, "Unencoded <"), N.startTagPosition + 1 < N.position)
                ) {
                  var Y = N.position - N.startTagPosition;
                  re = new Array(Y).join(" ") + re;
                }
                (N.textNode += "<" + re), (N.state = w.TEXT);
              }
            continue;
          case w.SGML_DECL:
            (N.sgmlDecl + re).toUpperCase() === u
              ? (j(N, "onopencdata"),
                (N.state = w.CDATA),
                (N.sgmlDecl = ""),
                (N.cdata = ""))
              : N.sgmlDecl + re === "--"
              ? ((N.state = w.COMMENT), (N.comment = ""), (N.sgmlDecl = ""))
              : (N.sgmlDecl + re).toUpperCase() === d
              ? ((N.state = w.DOCTYPE),
                (N.doctype || N.sawRoot) &&
                  z(N, "Inappropriately located doctype declaration"),
                (N.doctype = ""),
                (N.sgmlDecl = ""))
              : re === ">"
              ? (j(N, "onsgmldeclaration", N.sgmlDecl),
                (N.sgmlDecl = ""),
                (N.state = w.TEXT))
              : (R(re) && (N.state = w.SGML_DECL_QUOTED), (N.sgmlDecl += re));
            continue;
          case w.SGML_DECL_QUOTED:
            re === N.q && ((N.state = w.SGML_DECL), (N.q = "")),
              (N.sgmlDecl += re);
            continue;
          case w.DOCTYPE:
            re === ">"
              ? ((N.state = w.TEXT),
                j(N, "ondoctype", N.doctype),
                (N.doctype = !0))
              : ((N.doctype += re),
                re === "["
                  ? (N.state = w.DOCTYPE_DTD)
                  : R(re) && ((N.state = w.DOCTYPE_QUOTED), (N.q = re)));
            continue;
          case w.DOCTYPE_QUOTED:
            (N.doctype += re),
              re === N.q && ((N.q = ""), (N.state = w.DOCTYPE));
            continue;
          case w.DOCTYPE_DTD:
            (N.doctype += re),
              re === "]"
                ? (N.state = w.DOCTYPE)
                : R(re) && ((N.state = w.DOCTYPE_DTD_QUOTED), (N.q = re));
            continue;
          case w.DOCTYPE_DTD_QUOTED:
            (N.doctype += re),
              re === N.q && ((N.state = w.DOCTYPE_DTD), (N.q = ""));
            continue;
          case w.COMMENT:
            re === "-" ? (N.state = w.COMMENT_ENDING) : (N.comment += re);
            continue;
          case w.COMMENT_ENDING:
            re === "-"
              ? ((N.state = w.COMMENT_ENDED),
                (N.comment = q(N.opt, N.comment)),
                N.comment && j(N, "oncomment", N.comment),
                (N.comment = ""))
              : ((N.comment += "-" + re), (N.state = w.COMMENT));
            continue;
          case w.COMMENT_ENDED:
            re !== ">"
              ? (z(N, "Malformed comment"),
                (N.comment += "--" + re),
                (N.state = w.COMMENT))
              : (N.state = w.TEXT);
            continue;
          case w.CDATA:
            re === "]" ? (N.state = w.CDATA_ENDING) : (N.cdata += re);
            continue;
          case w.CDATA_ENDING:
            re === "]"
              ? (N.state = w.CDATA_ENDING_2)
              : ((N.cdata += "]" + re), (N.state = w.CDATA));
            continue;
          case w.CDATA_ENDING_2:
            re === ">"
              ? (N.cdata && j(N, "oncdata", N.cdata),
                j(N, "onclosecdata"),
                (N.cdata = ""),
                (N.state = w.TEXT))
              : re === "]"
              ? (N.cdata += "]")
              : ((N.cdata += "]]" + re), (N.state = w.CDATA));
            continue;
          case w.PROC_INST:
            re === "?"
              ? (N.state = w.PROC_INST_ENDING)
              : E(re)
              ? (N.state = w.PROC_INST_BODY)
              : (N.procInstName += re);
            continue;
          case w.PROC_INST_BODY:
            if (!N.procInstBody && E(re)) continue;
            re === "?"
              ? (N.state = w.PROC_INST_ENDING)
              : (N.procInstBody += re);
            continue;
          case w.PROC_INST_ENDING:
            re === ">"
              ? (j(N, "onprocessinginstruction", {
                  name: N.procInstName,
                  body: N.procInstBody,
                }),
                (N.procInstName = N.procInstBody = ""),
                (N.state = w.TEXT))
              : ((N.procInstBody += "?" + re), (N.state = w.PROC_INST_BODY));
            continue;
          case w.OPEN_TAG:
            I(v, re)
              ? (N.tagName += re)
              : (U(N),
                re === ">"
                  ? k(N)
                  : re === "/"
                  ? (N.state = w.OPEN_TAG_SLASH)
                  : (E(re) || z(N, "Invalid character in tag name"),
                    (N.state = w.ATTRIB)));
            continue;
          case w.OPEN_TAG_SLASH:
            re === ">"
              ? (k(N, !0), W(N))
              : (z(N, "Forward-slash in opening tag not followed by >"),
                (N.state = w.ATTRIB));
            continue;
          case w.ATTRIB:
            if (E(re)) continue;
            re === ">"
              ? k(N)
              : re === "/"
              ? (N.state = w.OPEN_TAG_SLASH)
              : I(g, re)
              ? ((N.attribName = re),
                (N.attribValue = ""),
                (N.state = w.ATTRIB_NAME))
              : z(N, "Invalid attribute name");
            continue;
          case w.ATTRIB_NAME:
            re === "="
              ? (N.state = w.ATTRIB_VALUE)
              : re === ">"
              ? (z(N, "Attribute without value"),
                (N.attribValue = N.attribName),
                L(N),
                k(N))
              : E(re)
              ? (N.state = w.ATTRIB_NAME_SAW_WHITE)
              : I(v, re)
              ? (N.attribName += re)
              : z(N, "Invalid attribute name");
            continue;
          case w.ATTRIB_NAME_SAW_WHITE:
            if (re === "=") N.state = w.ATTRIB_VALUE;
            else {
              if (E(re)) continue;
              z(N, "Attribute without value"),
                (N.tag.attributes[N.attribName] = ""),
                (N.attribValue = ""),
                j(N, "onattribute", { name: N.attribName, value: "" }),
                (N.attribName = ""),
                re === ">"
                  ? k(N)
                  : I(g, re)
                  ? ((N.attribName = re), (N.state = w.ATTRIB_NAME))
                  : (z(N, "Invalid attribute name"), (N.state = w.ATTRIB));
            }
            continue;
          case w.ATTRIB_VALUE:
            if (E(re)) continue;
            R(re)
              ? ((N.q = re), (N.state = w.ATTRIB_VALUE_QUOTED))
              : (z(N, "Unquoted attribute value"),
                (N.state = w.ATTRIB_VALUE_UNQUOTED),
                (N.attribValue = re));
            continue;
          case w.ATTRIB_VALUE_QUOTED:
            if (re !== N.q) {
              re === "&"
                ? (N.state = w.ATTRIB_VALUE_ENTITY_Q)
                : (N.attribValue += re);
              continue;
            }
            L(N), (N.q = ""), (N.state = w.ATTRIB_VALUE_CLOSED);
            continue;
          case w.ATTRIB_VALUE_CLOSED:
            E(re)
              ? (N.state = w.ATTRIB)
              : re === ">"
              ? k(N)
              : re === "/"
              ? (N.state = w.OPEN_TAG_SLASH)
              : I(g, re)
              ? (z(N, "No whitespace between attributes"),
                (N.attribName = re),
                (N.attribValue = ""),
                (N.state = w.ATTRIB_NAME))
              : z(N, "Invalid attribute name");
            continue;
          case w.ATTRIB_VALUE_UNQUOTED:
            if (!A(re)) {
              re === "&"
                ? (N.state = w.ATTRIB_VALUE_ENTITY_U)
                : (N.attribValue += re);
              continue;
            }
            L(N), re === ">" ? k(N) : (N.state = w.ATTRIB);
            continue;
          case w.CLOSE_TAG:
            if (N.tagName)
              re === ">"
                ? W(N)
                : I(v, re)
                ? (N.tagName += re)
                : N.script
                ? ((N.script += "</" + N.tagName),
                  (N.tagName = ""),
                  (N.state = w.SCRIPT))
                : (E(re) || z(N, "Invalid tagname in closing tag"),
                  (N.state = w.CLOSE_TAG_SAW_WHITE));
            else {
              if (E(re)) continue;
              S(g, re)
                ? N.script
                  ? ((N.script += "</" + re), (N.state = w.SCRIPT))
                  : z(N, "Invalid tagname in closing tag.")
                : (N.tagName = re);
            }
            continue;
          case w.CLOSE_TAG_SAW_WHITE:
            if (E(re)) continue;
            re === ">" ? W(N) : z(N, "Invalid characters in closing tag");
            continue;
          case w.TEXT_ENTITY:
          case w.ATTRIB_VALUE_ENTITY_Q:
          case w.ATTRIB_VALUE_ENTITY_U:
            var M, oe;
            switch (N.state) {
              case w.TEXT_ENTITY:
                (M = w.TEXT), (oe = "textNode");
                break;
              case w.ATTRIB_VALUE_ENTITY_Q:
                (M = w.ATTRIB_VALUE_QUOTED), (oe = "attribValue");
                break;
              case w.ATTRIB_VALUE_ENTITY_U:
                (M = w.ATTRIB_VALUE_UNQUOTED), (oe = "attribValue");
                break;
            }
            re === ";"
              ? ((N[oe] += F(N)), (N.entity = ""), (N.state = M))
              : I(N.entity.length ? _ : y, re)
              ? (N.entity += re)
              : (z(N, "Invalid character in entity name"),
                (N[oe] += "&" + N.entity + re),
                (N.entity = ""),
                (N.state = M));
            continue;
          default:
            throw new Error(N, "Unknown state: " + N.state);
        }
      return N.position >= N.bufferCheckPosition && i(N), N;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */ String.fromCodePoint ||
      (function () {
        var B = String.fromCharCode,
          N = Math.floor,
          ce = function () {
            var re = 16384,
              ne = [],
              Y,
              M,
              oe = -1,
              Ee = arguments.length;
            if (!Ee) return "";
            for (var le = ""; ++oe < Ee; ) {
              var te = Number(arguments[oe]);
              if (!isFinite(te) || te < 0 || te > 1114111 || N(te) !== te)
                throw RangeError("Invalid code point: " + te);
              te <= 65535
                ? ne.push(te)
                : ((te -= 65536),
                  (Y = (te >> 10) + 55296),
                  (M = (te % 1024) + 56320),
                  ne.push(Y, M)),
                (oe + 1 === Ee || ne.length > re) &&
                  ((le += B.apply(null, ne)), (ne.length = 0));
            }
            return le;
          };
        Object.defineProperty
          ? Object.defineProperty(String, "fromCodePoint", {
              value: ce,
              configurable: !0,
              writable: !0,
            })
          : (String.fromCodePoint = ce);
      })();
  })(e);
})(t2);
var CE;
function KD() {
  if (CE) return os;
  (CE = 1),
    Object.defineProperty(os, "__esModule", { value: !0 }),
    (os.parseXml = os.XElement = void 0);
  const e = t2,
    t = Ln();
  class n {
    constructor(c) {
      if (
        ((this.name = c),
        (this.value = ""),
        (this.attributes = null),
        (this.isCData = !1),
        (this.elements = null),
        !c)
      )
        throw (0, t.newError)(
          "Element name cannot be empty",
          "ERR_XML_ELEMENT_NAME_EMPTY",
        );
      if (!i(c))
        throw (0, t.newError)(
          `Invalid element name: ${c}`,
          "ERR_XML_ELEMENT_INVALID_NAME",
        );
    }
    attribute(c) {
      const l = this.attributes === null ? null : this.attributes[c];
      if (l == null)
        throw (0, t.newError)(
          `No attribute "${c}"`,
          "ERR_XML_MISSED_ATTRIBUTE",
        );
      return l;
    }
    removeAttribute(c) {
      this.attributes !== null && delete this.attributes[c];
    }
    element(c, l = !1, f = null) {
      const u = this.elementOrNull(c, l);
      if (u === null)
        throw (0, t.newError)(
          f || `No element "${c}"`,
          "ERR_XML_MISSED_ELEMENT",
        );
      return u;
    }
    elementOrNull(c, l = !1) {
      if (this.elements === null) return null;
      for (const f of this.elements) if (a(f, c, l)) return f;
      return null;
    }
    getElements(c, l = !1) {
      return this.elements === null
        ? []
        : this.elements.filter((f) => a(f, c, l));
    }
    elementValueOrEmpty(c, l = !1) {
      const f = this.elementOrNull(c, l);
      return f === null ? "" : f.value;
    }
  }
  os.XElement = n;
  const r = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
  function i(o) {
    return r.test(o);
  }
  function a(o, c, l) {
    const f = o.name;
    return (
      f === c ||
      (l === !0 && f.length === c.length && f.toLowerCase() === c.toLowerCase())
    );
  }
  function s(o) {
    let c = null;
    const l = e.parser(!0, {}),
      f = [];
    return (
      (l.onopentag = (u) => {
        const d = new n(u.name);
        if (((d.attributes = u.attributes), c === null)) c = d;
        else {
          const p = f[f.length - 1];
          p.elements == null && (p.elements = []), p.elements.push(d);
        }
        f.push(d);
      }),
      (l.onclosetag = () => {
        f.pop();
      }),
      (l.ontext = (u) => {
        f.length > 0 && (f[f.length - 1].value = u);
      }),
      (l.oncdata = (u) => {
        const d = f[f.length - 1];
        (d.value = u), (d.isCData = !0);
      }),
      (l.onerror = (u) => {
        throw u;
      }),
      l.write(o),
      c
    );
  }
  return (os.parseXml = s), os;
}
var RE;
function Ln() {
  return (
    RE ||
      ((RE = 1),
      (function (e) {
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.newError =
            e.asArray =
            e.CURRENT_APP_PACKAGE_FILE_NAME =
            e.CURRENT_APP_INSTALLER_FILE_NAME =
            e.XElement =
            e.parseXml =
            e.ProgressCallbackTransform =
            e.UUID =
            e.parseDn =
            e.githubUrl =
            e.getS3LikeProviderBaseUrl =
            e.configureRequestUrl =
            e.parseJson =
            e.safeStringifyJson =
            e.configureRequestOptionsFromUrl =
            e.configureRequestOptions =
            e.safeGetHeader =
            e.DigestTransform =
            e.HttpExecutor =
            e.createHttpError =
            e.HttpError =
            e.CancellationError =
            e.CancellationToken =
              void 0);
        var t = Ls;
        Object.defineProperty(e, "CancellationToken", {
          enumerable: !0,
          get: function () {
            return t.CancellationToken;
          },
        }),
          Object.defineProperty(e, "CancellationError", {
            enumerable: !0,
            get: function () {
              return t.CancellationError;
            },
          });
        var n = MD();
        Object.defineProperty(e, "HttpError", {
          enumerable: !0,
          get: function () {
            return n.HttpError;
          },
        }),
          Object.defineProperty(e, "createHttpError", {
            enumerable: !0,
            get: function () {
              return n.createHttpError;
            },
          }),
          Object.defineProperty(e, "HttpExecutor", {
            enumerable: !0,
            get: function () {
              return n.HttpExecutor;
            },
          }),
          Object.defineProperty(e, "DigestTransform", {
            enumerable: !0,
            get: function () {
              return n.DigestTransform;
            },
          }),
          Object.defineProperty(e, "safeGetHeader", {
            enumerable: !0,
            get: function () {
              return n.safeGetHeader;
            },
          }),
          Object.defineProperty(e, "configureRequestOptions", {
            enumerable: !0,
            get: function () {
              return n.configureRequestOptions;
            },
          }),
          Object.defineProperty(e, "configureRequestOptionsFromUrl", {
            enumerable: !0,
            get: function () {
              return n.configureRequestOptionsFromUrl;
            },
          }),
          Object.defineProperty(e, "safeStringifyJson", {
            enumerable: !0,
            get: function () {
              return n.safeStringifyJson;
            },
          }),
          Object.defineProperty(e, "parseJson", {
            enumerable: !0,
            get: function () {
              return n.parseJson;
            },
          }),
          Object.defineProperty(e, "configureRequestUrl", {
            enumerable: !0,
            get: function () {
              return n.configureRequestUrl;
            },
          });
        var r = Yo;
        Object.defineProperty(e, "getS3LikeProviderBaseUrl", {
          enumerable: !0,
          get: function () {
            return r.getS3LikeProviderBaseUrl;
          },
        }),
          Object.defineProperty(e, "githubUrl", {
            enumerable: !0,
            get: function () {
              return r.githubUrl;
            },
          });
        var i = np;
        Object.defineProperty(e, "parseDn", {
          enumerable: !0,
          get: function () {
            return i.parseDn;
          },
        });
        var a = zD();
        Object.defineProperty(e, "UUID", {
          enumerable: !0,
          get: function () {
            return a.UUID;
          },
        });
        var s = eu;
        Object.defineProperty(e, "ProgressCallbackTransform", {
          enumerable: !0,
          get: function () {
            return s.ProgressCallbackTransform;
          },
        });
        var o = KD();
        Object.defineProperty(e, "parseXml", {
          enumerable: !0,
          get: function () {
            return o.parseXml;
          },
        }),
          Object.defineProperty(e, "XElement", {
            enumerable: !0,
            get: function () {
              return o.XElement;
            },
          }),
          (e.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe"),
          (e.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z");
        function c(f) {
          return f == null ? [] : Array.isArray(f) ? f : [f];
        }
        e.asArray = c;
        function l(f, u) {
          const d = new Error(f);
          return (d.code = u), d;
        }
        e.newError = l;
      })(Xh)),
    Xh
  );
}
var Ys = {},
  xr = {};
xr.fromCallback = function (e) {
  return Object.defineProperty(
    function (...t) {
      if (typeof t[t.length - 1] == "function") e.apply(this, t);
      else
        return new Promise((n, r) => {
          e.call(this, ...t, (i, a) => (i != null ? r(i) : n(a)));
        });
    },
    "name",
    { value: e.name },
  );
};
xr.fromPromise = function (e) {
  return Object.defineProperty(
    function (...t) {
      const n = t[t.length - 1];
      if (typeof n != "function") return e.apply(this, t);
      e.apply(this, t.slice(0, -1)).then((r) => n(null, r), n);
    },
    "name",
    { value: e.name },
  );
};
var ba = $T,
  VD = process.cwd,
  Uf = null,
  YD = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function () {
  return Uf || (Uf = VD.call(process)), Uf;
};
try {
  process.cwd();
} catch {}
if (typeof process.chdir == "function") {
  var kE = process.chdir;
  (process.chdir = function (e) {
    (Uf = null), kE.call(process, e);
  }),
    Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, kE);
}
var XD = JD;
function JD(e) {
  ba.hasOwnProperty("O_SYMLINK") &&
    process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) &&
    t(e),
    e.lutimes || n(e),
    (e.chown = a(e.chown)),
    (e.fchown = a(e.fchown)),
    (e.lchown = a(e.lchown)),
    (e.chmod = r(e.chmod)),
    (e.fchmod = r(e.fchmod)),
    (e.lchmod = r(e.lchmod)),
    (e.chownSync = s(e.chownSync)),
    (e.fchownSync = s(e.fchownSync)),
    (e.lchownSync = s(e.lchownSync)),
    (e.chmodSync = i(e.chmodSync)),
    (e.fchmodSync = i(e.fchmodSync)),
    (e.lchmodSync = i(e.lchmodSync)),
    (e.stat = o(e.stat)),
    (e.fstat = o(e.fstat)),
    (e.lstat = o(e.lstat)),
    (e.statSync = c(e.statSync)),
    (e.fstatSync = c(e.fstatSync)),
    (e.lstatSync = c(e.lstatSync)),
    e.chmod &&
      !e.lchmod &&
      ((e.lchmod = function (f, u, d) {
        d && process.nextTick(d);
      }),
      (e.lchmodSync = function () {})),
    e.chown &&
      !e.lchown &&
      ((e.lchown = function (f, u, d, p) {
        p && process.nextTick(p);
      }),
      (e.lchownSync = function () {})),
    YD === "win32" &&
      (e.rename =
        typeof e.rename != "function"
          ? e.rename
          : (function (f) {
              function u(d, p, h) {
                var m = Date.now(),
                  g = 0;
                f(d, p, function v(y) {
                  if (
                    y &&
                    (y.code === "EACCES" ||
                      y.code === "EPERM" ||
                      y.code === "EBUSY") &&
                    Date.now() - m < 6e4
                  ) {
                    setTimeout(function () {
                      e.stat(p, function (_, E) {
                        _ && _.code === "ENOENT" ? f(d, p, v) : h(y);
                      });
                    }, g),
                      g < 100 && (g += 10);
                    return;
                  }
                  h && h(y);
                });
              }
              return Object.setPrototypeOf && Object.setPrototypeOf(u, f), u;
            })(e.rename)),
    (e.read =
      typeof e.read != "function"
        ? e.read
        : (function (f) {
            function u(d, p, h, m, g, v) {
              var y;
              if (v && typeof v == "function") {
                var _ = 0;
                y = function (E, R, A) {
                  if (E && E.code === "EAGAIN" && _ < 10)
                    return _++, f.call(e, d, p, h, m, g, y);
                  v.apply(this, arguments);
                };
              }
              return f.call(e, d, p, h, m, g, y);
            }
            return Object.setPrototypeOf && Object.setPrototypeOf(u, f), u;
          })(e.read)),
    (e.readSync =
      typeof e.readSync != "function"
        ? e.readSync
        : (function (f) {
            return function (u, d, p, h, m) {
              for (var g = 0; ; )
                try {
                  return f.call(e, u, d, p, h, m);
                } catch (v) {
                  if (v.code === "EAGAIN" && g < 10) {
                    g++;
                    continue;
                  }
                  throw v;
                }
            };
          })(e.readSync));
  function t(f) {
    (f.lchmod = function (u, d, p) {
      f.open(u, ba.O_WRONLY | ba.O_SYMLINK, d, function (h, m) {
        if (h) {
          p && p(h);
          return;
        }
        f.fchmod(m, d, function (g) {
          f.close(m, function (v) {
            p && p(g || v);
          });
        });
      });
    }),
      (f.lchmodSync = function (u, d) {
        var p = f.openSync(u, ba.O_WRONLY | ba.O_SYMLINK, d),
          h = !0,
          m;
        try {
          (m = f.fchmodSync(p, d)), (h = !1);
        } finally {
          if (h)
            try {
              f.closeSync(p);
            } catch {}
          else f.closeSync(p);
        }
        return m;
      });
  }
  function n(f) {
    ba.hasOwnProperty("O_SYMLINK") && f.futimes
      ? ((f.lutimes = function (u, d, p, h) {
          f.open(u, ba.O_SYMLINK, function (m, g) {
            if (m) {
              h && h(m);
              return;
            }
            f.futimes(g, d, p, function (v) {
              f.close(g, function (y) {
                h && h(v || y);
              });
            });
          });
        }),
        (f.lutimesSync = function (u, d, p) {
          var h = f.openSync(u, ba.O_SYMLINK),
            m,
            g = !0;
          try {
            (m = f.futimesSync(h, d, p)), (g = !1);
          } finally {
            if (g)
              try {
                f.closeSync(h);
              } catch {}
            else f.closeSync(h);
          }
          return m;
        }))
      : f.futimes &&
        ((f.lutimes = function (u, d, p, h) {
          h && process.nextTick(h);
        }),
        (f.lutimesSync = function () {}));
  }
  function r(f) {
    return (
      f &&
      function (u, d, p) {
        return f.call(e, u, d, function (h) {
          l(h) && (h = null), p && p.apply(this, arguments);
        });
      }
    );
  }
  function i(f) {
    return (
      f &&
      function (u, d) {
        try {
          return f.call(e, u, d);
        } catch (p) {
          if (!l(p)) throw p;
        }
      }
    );
  }
  function a(f) {
    return (
      f &&
      function (u, d, p, h) {
        return f.call(e, u, d, p, function (m) {
          l(m) && (m = null), h && h.apply(this, arguments);
        });
      }
    );
  }
  function s(f) {
    return (
      f &&
      function (u, d, p) {
        try {
          return f.call(e, u, d, p);
        } catch (h) {
          if (!l(h)) throw h;
        }
      }
    );
  }
  function o(f) {
    return (
      f &&
      function (u, d, p) {
        typeof d == "function" && ((p = d), (d = null));
        function h(m, g) {
          g &&
            (g.uid < 0 && (g.uid += 4294967296),
            g.gid < 0 && (g.gid += 4294967296)),
            p && p.apply(this, arguments);
        }
        return d ? f.call(e, u, d, h) : f.call(e, u, h);
      }
    );
  }
  function c(f) {
    return (
      f &&
      function (u, d) {
        var p = d ? f.call(e, u, d) : f.call(e, u);
        return (
          p &&
            (p.uid < 0 && (p.uid += 4294967296),
            p.gid < 0 && (p.gid += 4294967296)),
          p
        );
      }
    );
  }
  function l(f) {
    if (!f || f.code === "ENOSYS") return !0;
    var u = !process.getuid || process.getuid() !== 0;
    return !!(u && (f.code === "EINVAL" || f.code === "EPERM"));
  }
}
var TE = Kr.Stream,
  ZD = eL;
function eL(e) {
  return { ReadStream: t, WriteStream: n };
  function t(r, i) {
    if (!(this instanceof t)) return new t(r, i);
    TE.call(this);
    var a = this;
    (this.path = r),
      (this.fd = null),
      (this.readable = !0),
      (this.paused = !1),
      (this.flags = "r"),
      (this.mode = 438),
      (this.bufferSize = 64 * 1024),
      (i = i || {});
    for (var s = Object.keys(i), o = 0, c = s.length; o < c; o++) {
      var l = s[o];
      this[l] = i[l];
    }
    if (
      (this.encoding && this.setEncoding(this.encoding), this.start !== void 0)
    ) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.end === void 0) this.end = 1 / 0;
      else if (typeof this.end != "number")
        throw TypeError("end must be a Number");
      if (this.start > this.end) throw new Error("start must be <= end");
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function () {
        a._read();
      });
      return;
    }
    e.open(this.path, this.flags, this.mode, function (f, u) {
      if (f) {
        a.emit("error", f), (a.readable = !1);
        return;
      }
      (a.fd = u), a.emit("open", u), a._read();
    });
  }
  function n(r, i) {
    if (!(this instanceof n)) return new n(r, i);
    TE.call(this),
      (this.path = r),
      (this.fd = null),
      (this.writable = !0),
      (this.flags = "w"),
      (this.encoding = "binary"),
      (this.mode = 438),
      (this.bytesWritten = 0),
      (i = i || {});
    for (var a = Object.keys(i), s = 0, o = a.length; s < o; s++) {
      var c = a[s];
      this[c] = i[c];
    }
    if (this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.start < 0) throw new Error("start must be >= zero");
      this.pos = this.start;
    }
    (this.busy = !1),
      (this._queue = []),
      this.fd === null &&
        ((this._open = e.open),
        this._queue.push([
          this._open,
          this.path,
          this.flags,
          this.mode,
          void 0,
        ]),
        this.flush());
  }
}
var tL = rL,
  nL =
    Object.getPrototypeOf ||
    function (e) {
      return e.__proto__;
    };
function rL(e) {
  if (e === null || typeof e != "object") return e;
  if (e instanceof Object) var t = { __proto__: nL(e) };
  else var t = Object.create(null);
  return (
    Object.getOwnPropertyNames(e).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n));
    }),
    t
  );
}
var En = Xt,
  iL = XD,
  aL = ZD,
  sL = tL,
  rf = wr,
  ir,
  ld;
typeof Symbol == "function" && typeof Symbol.for == "function"
  ? ((ir = Symbol.for("graceful-fs.queue")),
    (ld = Symbol.for("graceful-fs.previous")))
  : ((ir = "___graceful-fs.queue"), (ld = "___graceful-fs.previous"));
function oL() {}
function n2(e, t) {
  Object.defineProperty(e, ir, {
    get: function () {
      return t;
    },
  });
}
var Os = oL;
rf.debuglog
  ? (Os = rf.debuglog("gfs4"))
  : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") &&
    (Os = function () {
      var e = rf.format.apply(rf, arguments);
      (e =
        "GFS4: " +
        e.split(/\n/).join(`
GFS4: `)),
        console.error(e);
    });
if (!En[ir]) {
  var cL = Tn[ir] || [];
  n2(En, cL),
    (En.close = (function (e) {
      function t(n, r) {
        return e.call(En, n, function (i) {
          i || NE(), typeof r == "function" && r.apply(this, arguments);
        });
      }
      return Object.defineProperty(t, ld, { value: e }), t;
    })(En.close)),
    (En.closeSync = (function (e) {
      function t(n) {
        e.apply(En, arguments), NE();
      }
      return Object.defineProperty(t, ld, { value: e }), t;
    })(En.closeSync)),
    /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") &&
      process.on("exit", function () {
        Os(En[ir]), gc.equal(En[ir].length, 0);
      });
}
Tn[ir] || n2(Tn, En[ir]);
var Ar = Tv(sL(En));
process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH &&
  !En.__patched &&
  ((Ar = Tv(En)), (En.__patched = !0));
function Tv(e) {
  iL(e),
    (e.gracefulify = Tv),
    (e.createReadStream = R),
    (e.createWriteStream = A);
  var t = e.readFile;
  e.readFile = n;
  function n(w, O, Q) {
    return typeof O == "function" && ((Q = O), (O = null)), j(w, O, Q);
    function j(H, q, J, Z) {
      return t(H, q, function (z) {
        z && (z.code === "EMFILE" || z.code === "ENFILE")
          ? io([j, [H, q, J], z, Z || Date.now(), Date.now()])
          : typeof J == "function" && J.apply(this, arguments);
      });
    }
  }
  var r = e.writeFile;
  e.writeFile = i;
  function i(w, O, Q, j) {
    return typeof Q == "function" && ((j = Q), (Q = null)), H(w, O, Q, j);
    function H(q, J, Z, z, U) {
      return r(q, J, Z, function (G) {
        G && (G.code === "EMFILE" || G.code === "ENFILE")
          ? io([H, [q, J, Z, z], G, U || Date.now(), Date.now()])
          : typeof z == "function" && z.apply(this, arguments);
      });
    }
  }
  var a = e.appendFile;
  a && (e.appendFile = s);
  function s(w, O, Q, j) {
    return typeof Q == "function" && ((j = Q), (Q = null)), H(w, O, Q, j);
    function H(q, J, Z, z, U) {
      return a(q, J, Z, function (G) {
        G && (G.code === "EMFILE" || G.code === "ENFILE")
          ? io([H, [q, J, Z, z], G, U || Date.now(), Date.now()])
          : typeof z == "function" && z.apply(this, arguments);
      });
    }
  }
  var o = e.copyFile;
  o && (e.copyFile = c);
  function c(w, O, Q, j) {
    return typeof Q == "function" && ((j = Q), (Q = 0)), H(w, O, Q, j);
    function H(q, J, Z, z, U) {
      return o(q, J, Z, function (G) {
        G && (G.code === "EMFILE" || G.code === "ENFILE")
          ? io([H, [q, J, Z, z], G, U || Date.now(), Date.now()])
          : typeof z == "function" && z.apply(this, arguments);
      });
    }
  }
  var l = e.readdir;
  e.readdir = u;
  var f = /^v[0-5]\./;
  function u(w, O, Q) {
    typeof O == "function" && ((Q = O), (O = null));
    var j = f.test(process.version)
      ? function (J, Z, z, U) {
          return l(J, H(J, Z, z, U));
        }
      : function (J, Z, z, U) {
          return l(J, Z, H(J, Z, z, U));
        };
    return j(w, O, Q);
    function H(q, J, Z, z) {
      return function (U, G) {
        U && (U.code === "EMFILE" || U.code === "ENFILE")
          ? io([j, [q, J, Z], U, z || Date.now(), Date.now()])
          : (G && G.sort && G.sort(),
            typeof Z == "function" && Z.call(this, U, G));
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var d = aL(e);
    (v = d.ReadStream), (_ = d.WriteStream);
  }
  var p = e.ReadStream;
  p && ((v.prototype = Object.create(p.prototype)), (v.prototype.open = y));
  var h = e.WriteStream;
  h && ((_.prototype = Object.create(h.prototype)), (_.prototype.open = E)),
    Object.defineProperty(e, "ReadStream", {
      get: function () {
        return v;
      },
      set: function (w) {
        v = w;
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(e, "WriteStream", {
      get: function () {
        return _;
      },
      set: function (w) {
        _ = w;
      },
      enumerable: !0,
      configurable: !0,
    });
  var m = v;
  Object.defineProperty(e, "FileReadStream", {
    get: function () {
      return m;
    },
    set: function (w) {
      m = w;
    },
    enumerable: !0,
    configurable: !0,
  });
  var g = _;
  Object.defineProperty(e, "FileWriteStream", {
    get: function () {
      return g;
    },
    set: function (w) {
      g = w;
    },
    enumerable: !0,
    configurable: !0,
  });
  function v(w, O) {
    return this instanceof v
      ? (p.apply(this, arguments), this)
      : v.apply(Object.create(v.prototype), arguments);
  }
  function y() {
    var w = this;
    S(w.path, w.flags, w.mode, function (O, Q) {
      O
        ? (w.autoClose && w.destroy(), w.emit("error", O))
        : ((w.fd = Q), w.emit("open", Q), w.read());
    });
  }
  function _(w, O) {
    return this instanceof _
      ? (h.apply(this, arguments), this)
      : _.apply(Object.create(_.prototype), arguments);
  }
  function E() {
    var w = this;
    S(w.path, w.flags, w.mode, function (O, Q) {
      O ? (w.destroy(), w.emit("error", O)) : ((w.fd = Q), w.emit("open", Q));
    });
  }
  function R(w, O) {
    return new e.ReadStream(w, O);
  }
  function A(w, O) {
    return new e.WriteStream(w, O);
  }
  var I = e.open;
  e.open = S;
  function S(w, O, Q, j) {
    return typeof Q == "function" && ((j = Q), (Q = null)), H(w, O, Q, j);
    function H(q, J, Z, z, U) {
      return I(q, J, Z, function (G, L) {
        G && (G.code === "EMFILE" || G.code === "ENFILE")
          ? io([H, [q, J, Z, z], G, U || Date.now(), Date.now()])
          : typeof z == "function" && z.apply(this, arguments);
      });
    }
  }
  return e;
}
function io(e) {
  Os("ENQUEUE", e[0].name, e[1]), En[ir].push(e), Nv();
}
var af;
function NE() {
  for (var e = Date.now(), t = 0; t < En[ir].length; ++t)
    En[ir][t].length > 2 && ((En[ir][t][3] = e), (En[ir][t][4] = e));
  Nv();
}
function Nv() {
  if ((clearTimeout(af), (af = void 0), En[ir].length !== 0)) {
    var e = En[ir].shift(),
      t = e[0],
      n = e[1],
      r = e[2],
      i = e[3],
      a = e[4];
    if (i === void 0) Os("RETRY", t.name, n), t.apply(null, n);
    else if (Date.now() - i >= 6e4) {
      Os("TIMEOUT", t.name, n);
      var s = n.pop();
      typeof s == "function" && s.call(null, r);
    } else {
      var o = Date.now() - a,
        c = Math.max(a - i, 1),
        l = Math.min(c * 1.2, 100);
      o >= l
        ? (Os("RETRY", t.name, n), t.apply(null, n.concat([i])))
        : En[ir].push(e);
    }
    af === void 0 && (af = setTimeout(Nv, 0));
  }
}
(function (e) {
  const t = xr.fromCallback,
    n = Ar,
    r = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile",
    ].filter((i) => typeof n[i] == "function");
  Object.assign(e, n),
    r.forEach((i) => {
      e[i] = t(n[i]);
    }),
    (e.exists = function (i, a) {
      return typeof a == "function"
        ? n.exists(i, a)
        : new Promise((s) => n.exists(i, s));
    }),
    (e.read = function (i, a, s, o, c, l) {
      return typeof l == "function"
        ? n.read(i, a, s, o, c, l)
        : new Promise((f, u) => {
            n.read(i, a, s, o, c, (d, p, h) => {
              if (d) return u(d);
              f({ bytesRead: p, buffer: h });
            });
          });
    }),
    (e.write = function (i, a, ...s) {
      return typeof s[s.length - 1] == "function"
        ? n.write(i, a, ...s)
        : new Promise((o, c) => {
            n.write(i, a, ...s, (l, f, u) => {
              if (l) return c(l);
              o({ bytesWritten: f, buffer: u });
            });
          });
    }),
    typeof n.writev == "function" &&
      (e.writev = function (i, a, ...s) {
        return typeof s[s.length - 1] == "function"
          ? n.writev(i, a, ...s)
          : new Promise((o, c) => {
              n.writev(i, a, ...s, (l, f, u) => {
                if (l) return c(l);
                o({ bytesWritten: f, buffers: u });
              });
            });
      }),
    typeof n.realpath.native == "function"
      ? (e.realpath.native = t(n.realpath.native))
      : process.emitWarning(
          "fs.realpath.native is not a function. Is fs being monkey-patched?",
          "Warning",
          "fs-extra-WARN0003",
        );
})(Ys);
var Ov = {},
  r2 = {};
const lL = pt;
r2.checkPath = function (t) {
  if (
    process.platform === "win32" &&
    /[<>:"|?*]/.test(t.replace(lL.parse(t).root, ""))
  ) {
    const r = new Error(`Path contains invalid characters: ${t}`);
    throw ((r.code = "EINVAL"), r);
  }
};
const i2 = Ys,
  { checkPath: a2 } = r2,
  s2 = (e) => {
    const t = { mode: 511 };
    return typeof e == "number" ? e : { ...t, ...e }.mode;
  };
Ov.makeDir = async (e, t) => (
  a2(e), i2.mkdir(e, { mode: s2(t), recursive: !0 })
);
Ov.makeDirSync = (e, t) => (
  a2(e), i2.mkdirSync(e, { mode: s2(t), recursive: !0 })
);
const uL = xr.fromPromise,
  { makeDir: fL, makeDirSync: nm } = Ov,
  rm = uL(fL);
var Qi = {
  mkdirs: rm,
  mkdirsSync: nm,
  mkdirp: rm,
  mkdirpSync: nm,
  ensureDir: rm,
  ensureDirSync: nm,
};
const dL = xr.fromPromise,
  o2 = Ys;
function pL(e) {
  return o2
    .access(e)
    .then(() => !0)
    .catch(() => !1);
}
var Xs = { pathExists: dL(pL), pathExistsSync: o2.existsSync };
const Do = Ar;
function hL(e, t, n, r) {
  Do.open(e, "r+", (i, a) => {
    if (i) return r(i);
    Do.futimes(a, t, n, (s) => {
      Do.close(a, (o) => {
        r && r(s || o);
      });
    });
  });
}
function mL(e, t, n) {
  const r = Do.openSync(e, "r+");
  return Do.futimesSync(r, t, n), Do.closeSync(r);
}
var c2 = { utimesMillis: hL, utimesMillisSync: mL };
const Xo = Ys,
  zn = pt,
  gL = wr;
function vL(e, t, n) {
  const r = n.dereference
    ? (i) => Xo.stat(i, { bigint: !0 })
    : (i) => Xo.lstat(i, { bigint: !0 });
  return Promise.all([
    r(e),
    r(t).catch((i) => {
      if (i.code === "ENOENT") return null;
      throw i;
    }),
  ]).then(([i, a]) => ({ srcStat: i, destStat: a }));
}
function yL(e, t, n) {
  let r;
  const i = n.dereference
      ? (s) => Xo.statSync(s, { bigint: !0 })
      : (s) => Xo.lstatSync(s, { bigint: !0 }),
    a = i(e);
  try {
    r = i(t);
  } catch (s) {
    if (s.code === "ENOENT") return { srcStat: a, destStat: null };
    throw s;
  }
  return { srcStat: a, destStat: r };
}
function bL(e, t, n, r, i) {
  gL.callbackify(vL)(e, t, r, (a, s) => {
    if (a) return i(a);
    const { srcStat: o, destStat: c } = s;
    if (c) {
      if (tu(o, c)) {
        const l = zn.basename(e),
          f = zn.basename(t);
        return n === "move" && l !== f && l.toLowerCase() === f.toLowerCase()
          ? i(null, { srcStat: o, destStat: c, isChangingCase: !0 })
          : i(new Error("Source and destination must not be the same."));
      }
      if (o.isDirectory() && !c.isDirectory())
        return i(
          new Error(
            `Cannot overwrite non-directory '${t}' with directory '${e}'.`,
          ),
        );
      if (!o.isDirectory() && c.isDirectory())
        return i(
          new Error(
            `Cannot overwrite directory '${t}' with non-directory '${e}'.`,
          ),
        );
    }
    return o.isDirectory() && Pv(e, t)
      ? i(new Error(rp(e, t, n)))
      : i(null, { srcStat: o, destStat: c });
  });
}
function _L(e, t, n, r) {
  const { srcStat: i, destStat: a } = yL(e, t, r);
  if (a) {
    if (tu(i, a)) {
      const s = zn.basename(e),
        o = zn.basename(t);
      if (n === "move" && s !== o && s.toLowerCase() === o.toLowerCase())
        return { srcStat: i, destStat: a, isChangingCase: !0 };
      throw new Error("Source and destination must not be the same.");
    }
    if (i.isDirectory() && !a.isDirectory())
      throw new Error(
        `Cannot overwrite non-directory '${t}' with directory '${e}'.`,
      );
    if (!i.isDirectory() && a.isDirectory())
      throw new Error(
        `Cannot overwrite directory '${t}' with non-directory '${e}'.`,
      );
  }
  if (i.isDirectory() && Pv(e, t)) throw new Error(rp(e, t, n));
  return { srcStat: i, destStat: a };
}
function l2(e, t, n, r, i) {
  const a = zn.resolve(zn.dirname(e)),
    s = zn.resolve(zn.dirname(n));
  if (s === a || s === zn.parse(s).root) return i();
  Xo.stat(s, { bigint: !0 }, (o, c) =>
    o
      ? o.code === "ENOENT"
        ? i()
        : i(o)
      : tu(t, c)
      ? i(new Error(rp(e, n, r)))
      : l2(e, t, s, r, i),
  );
}
function u2(e, t, n, r) {
  const i = zn.resolve(zn.dirname(e)),
    a = zn.resolve(zn.dirname(n));
  if (a === i || a === zn.parse(a).root) return;
  let s;
  try {
    s = Xo.statSync(a, { bigint: !0 });
  } catch (o) {
    if (o.code === "ENOENT") return;
    throw o;
  }
  if (tu(t, s)) throw new Error(rp(e, n, r));
  return u2(e, t, a, r);
}
function tu(e, t) {
  return t.ino && t.dev && t.ino === e.ino && t.dev === e.dev;
}
function Pv(e, t) {
  const n = zn
      .resolve(e)
      .split(zn.sep)
      .filter((i) => i),
    r = zn
      .resolve(t)
      .split(zn.sep)
      .filter((i) => i);
  return n.reduce((i, a, s) => i && r[s] === a, !0);
}
function rp(e, t, n) {
  return `Cannot ${n} '${e}' to a subdirectory of itself, '${t}'.`;
}
var Ec = {
  checkPaths: bL,
  checkPathsSync: _L,
  checkParentPaths: l2,
  checkParentPathsSync: u2,
  isSrcSubdir: Pv,
  areIdentical: tu,
};
const Br = Ar,
  Nl = pt,
  EL = Qi.mkdirs,
  wL = Xs.pathExists,
  xL = c2.utimesMillis,
  Ol = Ec;
function AL(e, t, n, r) {
  typeof n == "function" && !r
    ? ((r = n), (n = {}))
    : typeof n == "function" && (n = { filter: n }),
    (r = r || function () {}),
    (n = n || {}),
    (n.clobber = "clobber" in n ? !!n.clobber : !0),
    (n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber),
    n.preserveTimestamps &&
      process.arch === "ia32" &&
      process.emitWarning(
        `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
        "Warning",
        "fs-extra-WARN0001",
      ),
    Ol.checkPaths(e, t, "copy", n, (i, a) => {
      if (i) return r(i);
      const { srcStat: s, destStat: o } = a;
      Ol.checkParentPaths(e, s, t, "copy", (c) =>
        c ? r(c) : n.filter ? f2(OE, o, e, t, n, r) : OE(o, e, t, n, r),
      );
    });
}
function OE(e, t, n, r, i) {
  const a = Nl.dirname(n);
  wL(a, (s, o) => {
    if (s) return i(s);
    if (o) return ud(e, t, n, r, i);
    EL(a, (c) => (c ? i(c) : ud(e, t, n, r, i)));
  });
}
function f2(e, t, n, r, i, a) {
  Promise.resolve(i.filter(n, r)).then(
    (s) => (s ? e(t, n, r, i, a) : a()),
    (s) => a(s),
  );
}
function SL(e, t, n, r, i) {
  return r.filter ? f2(ud, e, t, n, r, i) : ud(e, t, n, r, i);
}
function ud(e, t, n, r, i) {
  (r.dereference ? Br.stat : Br.lstat)(t, (s, o) =>
    s
      ? i(s)
      : o.isDirectory()
      ? NL(o, e, t, n, r, i)
      : o.isFile() || o.isCharacterDevice() || o.isBlockDevice()
      ? IL(o, e, t, n, r, i)
      : o.isSymbolicLink()
      ? DL(e, t, n, r, i)
      : o.isSocket()
      ? i(new Error(`Cannot copy a socket file: ${t}`))
      : o.isFIFO()
      ? i(new Error(`Cannot copy a FIFO pipe: ${t}`))
      : i(new Error(`Unknown file: ${t}`)),
  );
}
function IL(e, t, n, r, i, a) {
  return t ? $L(e, n, r, i, a) : d2(e, n, r, i, a);
}
function $L(e, t, n, r, i) {
  if (r.overwrite) Br.unlink(n, (a) => (a ? i(a) : d2(e, t, n, r, i)));
  else return r.errorOnExist ? i(new Error(`'${n}' already exists`)) : i();
}
function d2(e, t, n, r, i) {
  Br.copyFile(t, n, (a) =>
    a ? i(a) : r.preserveTimestamps ? CL(e.mode, t, n, i) : ip(n, e.mode, i),
  );
}
function CL(e, t, n, r) {
  return RL(e) ? kL(n, e, (i) => (i ? r(i) : PE(e, t, n, r))) : PE(e, t, n, r);
}
function RL(e) {
  return (e & 128) === 0;
}
function kL(e, t, n) {
  return ip(e, t | 128, n);
}
function PE(e, t, n, r) {
  TL(t, n, (i) => (i ? r(i) : ip(n, e, r)));
}
function ip(e, t, n) {
  return Br.chmod(e, t, n);
}
function TL(e, t, n) {
  Br.stat(e, (r, i) => (r ? n(r) : xL(t, i.atime, i.mtime, n)));
}
function NL(e, t, n, r, i, a) {
  return t ? p2(n, r, i, a) : OL(e.mode, n, r, i, a);
}
function OL(e, t, n, r, i) {
  Br.mkdir(n, (a) => {
    if (a) return i(a);
    p2(t, n, r, (s) => (s ? i(s) : ip(n, e, i)));
  });
}
function p2(e, t, n, r) {
  Br.readdir(e, (i, a) => (i ? r(i) : h2(a, e, t, n, r)));
}
function h2(e, t, n, r, i) {
  const a = e.pop();
  return a ? PL(e, a, t, n, r, i) : i();
}
function PL(e, t, n, r, i, a) {
  const s = Nl.join(n, t),
    o = Nl.join(r, t);
  Ol.checkPaths(s, o, "copy", i, (c, l) => {
    if (c) return a(c);
    const { destStat: f } = l;
    SL(f, s, o, i, (u) => (u ? a(u) : h2(e, n, r, i, a)));
  });
}
function DL(e, t, n, r, i) {
  Br.readlink(t, (a, s) => {
    if (a) return i(a);
    if ((r.dereference && (s = Nl.resolve(process.cwd(), s)), e))
      Br.readlink(n, (o, c) =>
        o
          ? o.code === "EINVAL" || o.code === "UNKNOWN"
            ? Br.symlink(s, n, i)
            : i(o)
          : (r.dereference && (c = Nl.resolve(process.cwd(), c)),
            Ol.isSrcSubdir(s, c)
              ? i(
                  new Error(
                    `Cannot copy '${s}' to a subdirectory of itself, '${c}'.`,
                  ),
                )
              : e.isDirectory() && Ol.isSrcSubdir(c, s)
              ? i(new Error(`Cannot overwrite '${c}' with '${s}'.`))
              : LL(s, n, i)),
      );
    else return Br.symlink(s, n, i);
  });
}
function LL(e, t, n) {
  Br.unlink(t, (r) => (r ? n(r) : Br.symlink(e, t, n)));
}
var BL = AL;
const ur = Ar,
  Pl = pt,
  UL = Qi.mkdirsSync,
  FL = c2.utimesMillisSync,
  Dl = Ec;
function jL(e, t, n) {
  typeof n == "function" && (n = { filter: n }),
    (n = n || {}),
    (n.clobber = "clobber" in n ? !!n.clobber : !0),
    (n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber),
    n.preserveTimestamps &&
      process.arch === "ia32" &&
      process.emitWarning(
        `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
        "Warning",
        "fs-extra-WARN0002",
      );
  const { srcStat: r, destStat: i } = Dl.checkPathsSync(e, t, "copy", n);
  return Dl.checkParentPathsSync(e, r, t, "copy"), ML(i, e, t, n);
}
function ML(e, t, n, r) {
  if (r.filter && !r.filter(t, n)) return;
  const i = Pl.dirname(n);
  return ur.existsSync(i) || UL(i), m2(e, t, n, r);
}
function HL(e, t, n, r) {
  if (!(r.filter && !r.filter(t, n))) return m2(e, t, n, r);
}
function m2(e, t, n, r) {
  const a = (r.dereference ? ur.statSync : ur.lstatSync)(t);
  if (a.isDirectory()) return VL(a, e, t, n, r);
  if (a.isFile() || a.isCharacterDevice() || a.isBlockDevice())
    return qL(a, e, t, n, r);
  if (a.isSymbolicLink()) return JL(e, t, n, r);
  throw a.isSocket()
    ? new Error(`Cannot copy a socket file: ${t}`)
    : a.isFIFO()
    ? new Error(`Cannot copy a FIFO pipe: ${t}`)
    : new Error(`Unknown file: ${t}`);
}
function qL(e, t, n, r, i) {
  return t ? GL(e, n, r, i) : g2(e, n, r, i);
}
function GL(e, t, n, r) {
  if (r.overwrite) return ur.unlinkSync(n), g2(e, t, n, r);
  if (r.errorOnExist) throw new Error(`'${n}' already exists`);
}
function g2(e, t, n, r) {
  return (
    ur.copyFileSync(t, n),
    r.preserveTimestamps && QL(e.mode, t, n),
    Dv(n, e.mode)
  );
}
function QL(e, t, n) {
  return WL(e) && zL(n, e), KL(t, n);
}
function WL(e) {
  return (e & 128) === 0;
}
function zL(e, t) {
  return Dv(e, t | 128);
}
function Dv(e, t) {
  return ur.chmodSync(e, t);
}
function KL(e, t) {
  const n = ur.statSync(e);
  return FL(t, n.atime, n.mtime);
}
function VL(e, t, n, r, i) {
  return t ? v2(n, r, i) : YL(e.mode, n, r, i);
}
function YL(e, t, n, r) {
  return ur.mkdirSync(n), v2(t, n, r), Dv(n, e);
}
function v2(e, t, n) {
  ur.readdirSync(e).forEach((r) => XL(r, e, t, n));
}
function XL(e, t, n, r) {
  const i = Pl.join(t, e),
    a = Pl.join(n, e),
    { destStat: s } = Dl.checkPathsSync(i, a, "copy", r);
  return HL(s, i, a, r);
}
function JL(e, t, n, r) {
  let i = ur.readlinkSync(t);
  if ((r.dereference && (i = Pl.resolve(process.cwd(), i)), e)) {
    let a;
    try {
      a = ur.readlinkSync(n);
    } catch (s) {
      if (s.code === "EINVAL" || s.code === "UNKNOWN")
        return ur.symlinkSync(i, n);
      throw s;
    }
    if (
      (r.dereference && (a = Pl.resolve(process.cwd(), a)),
      Dl.isSrcSubdir(i, a))
    )
      throw new Error(
        `Cannot copy '${i}' to a subdirectory of itself, '${a}'.`,
      );
    if (ur.statSync(n).isDirectory() && Dl.isSrcSubdir(a, i))
      throw new Error(`Cannot overwrite '${a}' with '${i}'.`);
    return ZL(i, n);
  } else return ur.symlinkSync(i, n);
}
function ZL(e, t) {
  return ur.unlinkSync(t), ur.symlinkSync(e, t);
}
var eB = jL;
const tB = xr.fromCallback;
var Lv = { copy: tB(BL), copySync: eB };
const DE = Ar,
  y2 = pt,
  nn = gc,
  Ll = process.platform === "win32";
function b2(e) {
  ["unlink", "chmod", "stat", "lstat", "rmdir", "readdir"].forEach((n) => {
    (e[n] = e[n] || DE[n]), (n = n + "Sync"), (e[n] = e[n] || DE[n]);
  }),
    (e.maxBusyTries = e.maxBusyTries || 3);
}
function Bv(e, t, n) {
  let r = 0;
  typeof t == "function" && ((n = t), (t = {})),
    nn(e, "rimraf: missing path"),
    nn.strictEqual(typeof e, "string", "rimraf: path should be a string"),
    nn.strictEqual(typeof n, "function", "rimraf: callback function required"),
    nn(t, "rimraf: invalid options argument provided"),
    nn.strictEqual(typeof t, "object", "rimraf: options should be object"),
    b2(t),
    LE(e, t, function i(a) {
      if (a) {
        if (
          (a.code === "EBUSY" ||
            a.code === "ENOTEMPTY" ||
            a.code === "EPERM") &&
          r < t.maxBusyTries
        ) {
          r++;
          const s = r * 100;
          return setTimeout(() => LE(e, t, i), s);
        }
        a.code === "ENOENT" && (a = null);
      }
      n(a);
    });
}
function LE(e, t, n) {
  nn(e),
    nn(t),
    nn(typeof n == "function"),
    t.lstat(e, (r, i) => {
      if (r && r.code === "ENOENT") return n(null);
      if (r && r.code === "EPERM" && Ll) return BE(e, t, r, n);
      if (i && i.isDirectory()) return Ff(e, t, r, n);
      t.unlink(e, (a) => {
        if (a) {
          if (a.code === "ENOENT") return n(null);
          if (a.code === "EPERM") return Ll ? BE(e, t, a, n) : Ff(e, t, a, n);
          if (a.code === "EISDIR") return Ff(e, t, a, n);
        }
        return n(a);
      });
    });
}
function BE(e, t, n, r) {
  nn(e),
    nn(t),
    nn(typeof r == "function"),
    t.chmod(e, 438, (i) => {
      i
        ? r(i.code === "ENOENT" ? null : n)
        : t.stat(e, (a, s) => {
            a
              ? r(a.code === "ENOENT" ? null : n)
              : s.isDirectory()
              ? Ff(e, t, n, r)
              : t.unlink(e, r);
          });
    });
}
function UE(e, t, n) {
  let r;
  nn(e), nn(t);
  try {
    t.chmodSync(e, 438);
  } catch (i) {
    if (i.code === "ENOENT") return;
    throw n;
  }
  try {
    r = t.statSync(e);
  } catch (i) {
    if (i.code === "ENOENT") return;
    throw n;
  }
  r.isDirectory() ? jf(e, t, n) : t.unlinkSync(e);
}
function Ff(e, t, n, r) {
  nn(e),
    nn(t),
    nn(typeof r == "function"),
    t.rmdir(e, (i) => {
      i && (i.code === "ENOTEMPTY" || i.code === "EEXIST" || i.code === "EPERM")
        ? nB(e, t, r)
        : i && i.code === "ENOTDIR"
        ? r(n)
        : r(i);
    });
}
function nB(e, t, n) {
  nn(e),
    nn(t),
    nn(typeof n == "function"),
    t.readdir(e, (r, i) => {
      if (r) return n(r);
      let a = i.length,
        s;
      if (a === 0) return t.rmdir(e, n);
      i.forEach((o) => {
        Bv(y2.join(e, o), t, (c) => {
          if (!s) {
            if (c) return n((s = c));
            --a === 0 && t.rmdir(e, n);
          }
        });
      });
    });
}
function _2(e, t) {
  let n;
  (t = t || {}),
    b2(t),
    nn(e, "rimraf: missing path"),
    nn.strictEqual(typeof e, "string", "rimraf: path should be a string"),
    nn(t, "rimraf: missing options"),
    nn.strictEqual(typeof t, "object", "rimraf: options should be object");
  try {
    n = t.lstatSync(e);
  } catch (r) {
    if (r.code === "ENOENT") return;
    r.code === "EPERM" && Ll && UE(e, t, r);
  }
  try {
    n && n.isDirectory() ? jf(e, t, null) : t.unlinkSync(e);
  } catch (r) {
    if (r.code === "ENOENT") return;
    if (r.code === "EPERM") return Ll ? UE(e, t, r) : jf(e, t, r);
    if (r.code !== "EISDIR") throw r;
    jf(e, t, r);
  }
}
function jf(e, t, n) {
  nn(e), nn(t);
  try {
    t.rmdirSync(e);
  } catch (r) {
    if (r.code === "ENOTDIR") throw n;
    if (r.code === "ENOTEMPTY" || r.code === "EEXIST" || r.code === "EPERM")
      rB(e, t);
    else if (r.code !== "ENOENT") throw r;
  }
}
function rB(e, t) {
  if (
    (nn(e), nn(t), t.readdirSync(e).forEach((n) => _2(y2.join(e, n), t)), Ll)
  ) {
    const n = Date.now();
    do
      try {
        return t.rmdirSync(e, t);
      } catch {}
    while (Date.now() - n < 500);
  } else return t.rmdirSync(e, t);
}
var iB = Bv;
Bv.sync = _2;
const fd = Ar,
  aB = xr.fromCallback,
  E2 = iB;
function sB(e, t) {
  if (fd.rm) return fd.rm(e, { recursive: !0, force: !0 }, t);
  E2(e, t);
}
function oB(e) {
  if (fd.rmSync) return fd.rmSync(e, { recursive: !0, force: !0 });
  E2.sync(e);
}
var ap = { remove: aB(sB), removeSync: oB };
const cB = xr.fromPromise,
  w2 = Ys,
  x2 = pt,
  A2 = Qi,
  S2 = ap,
  FE = cB(async function (t) {
    let n;
    try {
      n = await w2.readdir(t);
    } catch {
      return A2.mkdirs(t);
    }
    return Promise.all(n.map((r) => S2.remove(x2.join(t, r))));
  });
function jE(e) {
  let t;
  try {
    t = w2.readdirSync(e);
  } catch {
    return A2.mkdirsSync(e);
  }
  t.forEach((n) => {
    (n = x2.join(e, n)), S2.removeSync(n);
  });
}
var lB = { emptyDirSync: jE, emptydirSync: jE, emptyDir: FE, emptydir: FE };
const uB = xr.fromCallback,
  I2 = pt,
  Da = Ar,
  $2 = Qi;
function fB(e, t) {
  function n() {
    Da.writeFile(e, "", (r) => {
      if (r) return t(r);
      t();
    });
  }
  Da.stat(e, (r, i) => {
    if (!r && i.isFile()) return t();
    const a = I2.dirname(e);
    Da.stat(a, (s, o) => {
      if (s)
        return s.code === "ENOENT"
          ? $2.mkdirs(a, (c) => {
              if (c) return t(c);
              n();
            })
          : t(s);
      o.isDirectory()
        ? n()
        : Da.readdir(a, (c) => {
            if (c) return t(c);
          });
    });
  });
}
function dB(e) {
  let t;
  try {
    t = Da.statSync(e);
  } catch {}
  if (t && t.isFile()) return;
  const n = I2.dirname(e);
  try {
    Da.statSync(n).isDirectory() || Da.readdirSync(n);
  } catch (r) {
    if (r && r.code === "ENOENT") $2.mkdirsSync(n);
    else throw r;
  }
  Da.writeFileSync(e, "");
}
var pB = { createFile: uB(fB), createFileSync: dB };
const hB = xr.fromCallback,
  C2 = pt,
  Ta = Ar,
  R2 = Qi,
  mB = Xs.pathExists,
  { areIdentical: k2 } = Ec;
function gB(e, t, n) {
  function r(i, a) {
    Ta.link(i, a, (s) => {
      if (s) return n(s);
      n(null);
    });
  }
  Ta.lstat(t, (i, a) => {
    Ta.lstat(e, (s, o) => {
      if (s)
        return (s.message = s.message.replace("lstat", "ensureLink")), n(s);
      if (a && k2(o, a)) return n(null);
      const c = C2.dirname(t);
      mB(c, (l, f) => {
        if (l) return n(l);
        if (f) return r(e, t);
        R2.mkdirs(c, (u) => {
          if (u) return n(u);
          r(e, t);
        });
      });
    });
  });
}
function vB(e, t) {
  let n;
  try {
    n = Ta.lstatSync(t);
  } catch {}
  try {
    const a = Ta.lstatSync(e);
    if (n && k2(a, n)) return;
  } catch (a) {
    throw ((a.message = a.message.replace("lstat", "ensureLink")), a);
  }
  const r = C2.dirname(t);
  return Ta.existsSync(r) || R2.mkdirsSync(r), Ta.linkSync(e, t);
}
var yB = { createLink: hB(gB), createLinkSync: vB };
const La = pt,
  dl = Ar,
  bB = Xs.pathExists;
function _B(e, t, n) {
  if (La.isAbsolute(e))
    return dl.lstat(e, (r) =>
      r
        ? ((r.message = r.message.replace("lstat", "ensureSymlink")), n(r))
        : n(null, { toCwd: e, toDst: e }),
    );
  {
    const r = La.dirname(t),
      i = La.join(r, e);
    return bB(i, (a, s) =>
      a
        ? n(a)
        : s
        ? n(null, { toCwd: i, toDst: e })
        : dl.lstat(e, (o) =>
            o
              ? ((o.message = o.message.replace("lstat", "ensureSymlink")),
                n(o))
              : n(null, { toCwd: e, toDst: La.relative(r, e) }),
          ),
    );
  }
}
function EB(e, t) {
  let n;
  if (La.isAbsolute(e)) {
    if (((n = dl.existsSync(e)), !n))
      throw new Error("absolute srcpath does not exist");
    return { toCwd: e, toDst: e };
  } else {
    const r = La.dirname(t),
      i = La.join(r, e);
    if (((n = dl.existsSync(i)), n)) return { toCwd: i, toDst: e };
    if (((n = dl.existsSync(e)), !n))
      throw new Error("relative srcpath does not exist");
    return { toCwd: e, toDst: La.relative(r, e) };
  }
}
var wB = { symlinkPaths: _B, symlinkPathsSync: EB };
const T2 = Ar;
function xB(e, t, n) {
  if (
    ((n = typeof t == "function" ? t : n),
    (t = typeof t == "function" ? !1 : t),
    t)
  )
    return n(null, t);
  T2.lstat(e, (r, i) => {
    if (r) return n(null, "file");
    (t = i && i.isDirectory() ? "dir" : "file"), n(null, t);
  });
}
function AB(e, t) {
  let n;
  if (t) return t;
  try {
    n = T2.lstatSync(e);
  } catch {
    return "file";
  }
  return n && n.isDirectory() ? "dir" : "file";
}
var SB = { symlinkType: xB, symlinkTypeSync: AB };
const IB = xr.fromCallback,
  N2 = pt,
  di = Ys,
  O2 = Qi,
  $B = O2.mkdirs,
  CB = O2.mkdirsSync,
  P2 = wB,
  RB = P2.symlinkPaths,
  kB = P2.symlinkPathsSync,
  D2 = SB,
  TB = D2.symlinkType,
  NB = D2.symlinkTypeSync,
  OB = Xs.pathExists,
  { areIdentical: L2 } = Ec;
function PB(e, t, n, r) {
  (r = typeof n == "function" ? n : r),
    (n = typeof n == "function" ? !1 : n),
    di.lstat(t, (i, a) => {
      !i && a.isSymbolicLink()
        ? Promise.all([di.stat(e), di.stat(t)]).then(([s, o]) => {
            if (L2(s, o)) return r(null);
            ME(e, t, n, r);
          })
        : ME(e, t, n, r);
    });
}
function ME(e, t, n, r) {
  RB(e, t, (i, a) => {
    if (i) return r(i);
    (e = a.toDst),
      TB(a.toCwd, n, (s, o) => {
        if (s) return r(s);
        const c = N2.dirname(t);
        OB(c, (l, f) => {
          if (l) return r(l);
          if (f) return di.symlink(e, t, o, r);
          $B(c, (u) => {
            if (u) return r(u);
            di.symlink(e, t, o, r);
          });
        });
      });
  });
}
function DB(e, t, n) {
  let r;
  try {
    r = di.lstatSync(t);
  } catch {}
  if (r && r.isSymbolicLink()) {
    const o = di.statSync(e),
      c = di.statSync(t);
    if (L2(o, c)) return;
  }
  const i = kB(e, t);
  (e = i.toDst), (n = NB(i.toCwd, n));
  const a = N2.dirname(t);
  return di.existsSync(a) || CB(a), di.symlinkSync(e, t, n);
}
var LB = { createSymlink: IB(PB), createSymlinkSync: DB };
const { createFile: HE, createFileSync: qE } = pB,
  { createLink: GE, createLinkSync: QE } = yB,
  { createSymlink: WE, createSymlinkSync: zE } = LB;
var BB = {
  createFile: HE,
  createFileSync: qE,
  ensureFile: HE,
  ensureFileSync: qE,
  createLink: GE,
  createLinkSync: QE,
  ensureLink: GE,
  ensureLinkSync: QE,
  createSymlink: WE,
  createSymlinkSync: zE,
  ensureSymlink: WE,
  ensureSymlinkSync: zE,
};
function UB(
  e,
  {
    EOL: t = `
`,
    finalEOL: n = !0,
    replacer: r = null,
    spaces: i,
  } = {},
) {
  const a = n ? t : "";
  return JSON.stringify(e, r, i).replace(/\n/g, t) + a;
}
function FB(e) {
  return (
    Buffer.isBuffer(e) && (e = e.toString("utf8")), e.replace(/^\uFEFF/, "")
  );
}
var Uv = { stringify: UB, stripBom: FB };
let Jo;
try {
  Jo = Ar;
} catch {
  Jo = Xt;
}
const sp = xr,
  { stringify: B2, stripBom: U2 } = Uv;
async function jB(e, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const n = t.fs || Jo,
    r = "throws" in t ? t.throws : !0;
  let i = await sp.fromCallback(n.readFile)(e, t);
  i = U2(i);
  let a;
  try {
    a = JSON.parse(i, t ? t.reviver : null);
  } catch (s) {
    if (r) throw ((s.message = `${e}: ${s.message}`), s);
    return null;
  }
  return a;
}
const MB = sp.fromPromise(jB);
function HB(e, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const n = t.fs || Jo,
    r = "throws" in t ? t.throws : !0;
  try {
    let i = n.readFileSync(e, t);
    return (i = U2(i)), JSON.parse(i, t.reviver);
  } catch (i) {
    if (r) throw ((i.message = `${e}: ${i.message}`), i);
    return null;
  }
}
async function qB(e, t, n = {}) {
  const r = n.fs || Jo,
    i = B2(t, n);
  await sp.fromCallback(r.writeFile)(e, i, n);
}
const GB = sp.fromPromise(qB);
function QB(e, t, n = {}) {
  const r = n.fs || Jo,
    i = B2(t, n);
  return r.writeFileSync(e, i, n);
}
const WB = { readFile: MB, readFileSync: HB, writeFile: GB, writeFileSync: QB };
var zB = WB;
const sf = zB;
var KB = {
  readJson: sf.readFile,
  readJsonSync: sf.readFileSync,
  writeJson: sf.writeFile,
  writeJsonSync: sf.writeFileSync,
};
const VB = xr.fromCallback,
  pl = Ar,
  F2 = pt,
  j2 = Qi,
  YB = Xs.pathExists;
function XB(e, t, n, r) {
  typeof n == "function" && ((r = n), (n = "utf8"));
  const i = F2.dirname(e);
  YB(i, (a, s) => {
    if (a) return r(a);
    if (s) return pl.writeFile(e, t, n, r);
    j2.mkdirs(i, (o) => {
      if (o) return r(o);
      pl.writeFile(e, t, n, r);
    });
  });
}
function JB(e, ...t) {
  const n = F2.dirname(e);
  if (pl.existsSync(n)) return pl.writeFileSync(e, ...t);
  j2.mkdirsSync(n), pl.writeFileSync(e, ...t);
}
var Fv = { outputFile: VB(XB), outputFileSync: JB };
const { stringify: ZB } = Uv,
  { outputFile: eU } = Fv;
async function tU(e, t, n = {}) {
  const r = ZB(t, n);
  await eU(e, r, n);
}
var nU = tU;
const { stringify: rU } = Uv,
  { outputFileSync: iU } = Fv;
function aU(e, t, n) {
  const r = rU(t, n);
  iU(e, r, n);
}
var sU = aU;
const oU = xr.fromPromise,
  Er = KB;
Er.outputJson = oU(nU);
Er.outputJsonSync = sU;
Er.outputJSON = Er.outputJson;
Er.outputJSONSync = Er.outputJsonSync;
Er.writeJSON = Er.writeJson;
Er.writeJSONSync = Er.writeJsonSync;
Er.readJSON = Er.readJson;
Er.readJSONSync = Er.readJsonSync;
var cU = Er;
const lU = Ar,
  i0 = pt,
  uU = Lv.copy,
  M2 = ap.remove,
  fU = Qi.mkdirp,
  dU = Xs.pathExists,
  KE = Ec;
function pU(e, t, n, r) {
  typeof n == "function" && ((r = n), (n = {})), (n = n || {});
  const i = n.overwrite || n.clobber || !1;
  KE.checkPaths(e, t, "move", n, (a, s) => {
    if (a) return r(a);
    const { srcStat: o, isChangingCase: c = !1 } = s;
    KE.checkParentPaths(e, o, t, "move", (l) => {
      if (l) return r(l);
      if (hU(t)) return VE(e, t, i, c, r);
      fU(i0.dirname(t), (f) => (f ? r(f) : VE(e, t, i, c, r)));
    });
  });
}
function hU(e) {
  const t = i0.dirname(e);
  return i0.parse(t).root === t;
}
function VE(e, t, n, r, i) {
  if (r) return im(e, t, n, i);
  if (n) return M2(t, (a) => (a ? i(a) : im(e, t, n, i)));
  dU(t, (a, s) =>
    a ? i(a) : s ? i(new Error("dest already exists.")) : im(e, t, n, i),
  );
}
function im(e, t, n, r) {
  lU.rename(e, t, (i) =>
    i ? (i.code !== "EXDEV" ? r(i) : mU(e, t, n, r)) : r(),
  );
}
function mU(e, t, n, r) {
  uU(e, t, { overwrite: n, errorOnExist: !0 }, (a) => (a ? r(a) : M2(e, r)));
}
var gU = pU;
const H2 = Ar,
  a0 = pt,
  vU = Lv.copySync,
  q2 = ap.removeSync,
  yU = Qi.mkdirpSync,
  YE = Ec;
function bU(e, t, n) {
  n = n || {};
  const r = n.overwrite || n.clobber || !1,
    { srcStat: i, isChangingCase: a = !1 } = YE.checkPathsSync(e, t, "move", n);
  return (
    YE.checkParentPathsSync(e, i, t, "move"),
    _U(t) || yU(a0.dirname(t)),
    EU(e, t, r, a)
  );
}
function _U(e) {
  const t = a0.dirname(e);
  return a0.parse(t).root === t;
}
function EU(e, t, n, r) {
  if (r) return am(e, t, n);
  if (n) return q2(t), am(e, t, n);
  if (H2.existsSync(t)) throw new Error("dest already exists.");
  return am(e, t, n);
}
function am(e, t, n) {
  try {
    H2.renameSync(e, t);
  } catch (r) {
    if (r.code !== "EXDEV") throw r;
    return wU(e, t, n);
  }
}
function wU(e, t, n) {
  return vU(e, t, { overwrite: n, errorOnExist: !0 }), q2(e);
}
var xU = bU;
const AU = xr.fromCallback;
var SU = { move: AU(gU), moveSync: xU },
  Za = { ...Ys, ...Lv, ...lB, ...BB, ...cU, ...Qi, ...SU, ...Fv, ...Xs, ...ap },
  cs = {},
  ar = {},
  jv = {},
  Ai = {};
function G2(e) {
  return typeof e > "u" || e === null;
}
function IU(e) {
  return typeof e == "object" && e !== null;
}
function $U(e) {
  return Array.isArray(e) ? e : G2(e) ? [] : [e];
}
function CU(e, t) {
  var n, r, i, a;
  if (t)
    for (a = Object.keys(t), n = 0, r = a.length; n < r; n += 1)
      (i = a[n]), (e[i] = t[i]);
  return e;
}
function RU(e, t) {
  var n = "",
    r;
  for (r = 0; r < t; r += 1) n += e;
  return n;
}
function kU(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
Ai.isNothing = G2;
Ai.isObject = IU;
Ai.toArray = $U;
Ai.repeat = RU;
Ai.isNegativeZero = kU;
Ai.extend = CU;
function Q2(e, t) {
  var n = "",
    r = e.reason || "(unknown reason)";
  return e.mark
    ? (e.mark.name && (n += 'in "' + e.mark.name + '" '),
      (n += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")"),
      !t &&
        e.mark.snippet &&
        (n +=
          `

` + e.mark.snippet),
      r + " " + n)
    : r;
}
function Bl(e, t) {
  Error.call(this),
    (this.name = "YAMLException"),
    (this.reason = e),
    (this.mark = t),
    (this.message = Q2(this, !1)),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack || "");
}
Bl.prototype = Object.create(Error.prototype);
Bl.prototype.constructor = Bl;
Bl.prototype.toString = function (t) {
  return this.name + ": " + Q2(this, t);
};
var nu = Bl,
  nl = Ai;
function sm(e, t, n, r, i) {
  var a = "",
    s = "",
    o = Math.floor(i / 2) - 1;
  return (
    r - t > o && ((a = " ... "), (t = r - o + a.length)),
    n - r > o && ((s = " ..."), (n = r + o - s.length)),
    { str: a + e.slice(t, n).replace(/\t/g, "→") + s, pos: r - t + a.length }
  );
}
function om(e, t) {
  return nl.repeat(" ", t - e.length) + e;
}
function TU(e, t) {
  if (((t = Object.create(t || null)), !e.buffer)) return null;
  t.maxLength || (t.maxLength = 79),
    typeof t.indent != "number" && (t.indent = 1),
    typeof t.linesBefore != "number" && (t.linesBefore = 3),
    typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (
    var n = /\r?\n|\r|\0/g, r = [0], i = [], a, s = -1;
    (a = n.exec(e.buffer));

  )
    i.push(a.index),
      r.push(a.index + a[0].length),
      e.position <= a.index && s < 0 && (s = r.length - 2);
  s < 0 && (s = r.length - 1);
  var o = "",
    c,
    l,
    f = Math.min(e.line + t.linesAfter, i.length).toString().length,
    u = t.maxLength - (t.indent + f + 3);
  for (c = 1; c <= t.linesBefore && !(s - c < 0); c++)
    (l = sm(e.buffer, r[s - c], i[s - c], e.position - (r[s] - r[s - c]), u)),
      (o =
        nl.repeat(" ", t.indent) +
        om((e.line - c + 1).toString(), f) +
        " | " +
        l.str +
        `
` +
        o);
  for (
    l = sm(e.buffer, r[s], i[s], e.position, u),
      o +=
        nl.repeat(" ", t.indent) +
        om((e.line + 1).toString(), f) +
        " | " +
        l.str +
        `
`,
      o +=
        nl.repeat("-", t.indent + f + 3 + l.pos) +
        `^
`,
      c = 1;
    c <= t.linesAfter && !(s + c >= i.length);
    c++
  )
    (l = sm(e.buffer, r[s + c], i[s + c], e.position - (r[s] - r[s + c]), u)),
      (o +=
        nl.repeat(" ", t.indent) +
        om((e.line + c + 1).toString(), f) +
        " | " +
        l.str +
        `
`);
  return o.replace(/\n$/, "");
}
var NU = TU,
  XE = nu,
  OU = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases",
  ],
  PU = ["scalar", "sequence", "mapping"];
function DU(e) {
  var t = {};
  return (
    e !== null &&
      Object.keys(e).forEach(function (n) {
        e[n].forEach(function (r) {
          t[String(r)] = n;
        });
      }),
    t
  );
}
function LU(e, t) {
  if (
    ((t = t || {}),
    Object.keys(t).forEach(function (n) {
      if (OU.indexOf(n) === -1)
        throw new XE(
          'Unknown option "' +
            n +
            '" is met in definition of "' +
            e +
            '" YAML type.',
        );
    }),
    (this.options = t),
    (this.tag = e),
    (this.kind = t.kind || null),
    (this.resolve =
      t.resolve ||
      function () {
        return !0;
      }),
    (this.construct =
      t.construct ||
      function (n) {
        return n;
      }),
    (this.instanceOf = t.instanceOf || null),
    (this.predicate = t.predicate || null),
    (this.represent = t.represent || null),
    (this.representName = t.representName || null),
    (this.defaultStyle = t.defaultStyle || null),
    (this.multi = t.multi || !1),
    (this.styleAliases = DU(t.styleAliases || null)),
    PU.indexOf(this.kind) === -1)
  )
    throw new XE(
      'Unknown kind "' +
        this.kind +
        '" is specified for "' +
        e +
        '" YAML type.',
    );
}
var Sr = LU,
  Dc = nu,
  cm = Sr;
function JE(e, t) {
  var n = [];
  return (
    e[t].forEach(function (r) {
      var i = n.length;
      n.forEach(function (a, s) {
        a.tag === r.tag && a.kind === r.kind && a.multi === r.multi && (i = s);
      }),
        (n[i] = r);
    }),
    n
  );
}
function BU() {
  var e = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: { scalar: [], sequence: [], mapping: [], fallback: [] },
    },
    t,
    n;
  function r(i) {
    i.multi
      ? (e.multi[i.kind].push(i), e.multi.fallback.push(i))
      : (e[i.kind][i.tag] = e.fallback[i.tag] = i);
  }
  for (t = 0, n = arguments.length; t < n; t += 1) arguments[t].forEach(r);
  return e;
}
function s0(e) {
  return this.extend(e);
}
s0.prototype.extend = function (t) {
  var n = [],
    r = [];
  if (t instanceof cm) r.push(t);
  else if (Array.isArray(t)) r = r.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (n = n.concat(t.implicit)),
      t.explicit && (r = r.concat(t.explicit));
  else
    throw new Dc(
      "Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })",
    );
  n.forEach(function (a) {
    if (!(a instanceof cm))
      throw new Dc(
        "Specified list of YAML types (or a single Type object) contains a non-Type object.",
      );
    if (a.loadKind && a.loadKind !== "scalar")
      throw new Dc(
        "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.",
      );
    if (a.multi)
      throw new Dc(
        "There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.",
      );
  }),
    r.forEach(function (a) {
      if (!(a instanceof cm))
        throw new Dc(
          "Specified list of YAML types (or a single Type object) contains a non-Type object.",
        );
    });
  var i = Object.create(s0.prototype);
  return (
    (i.implicit = (this.implicit || []).concat(n)),
    (i.explicit = (this.explicit || []).concat(r)),
    (i.compiledImplicit = JE(i, "implicit")),
    (i.compiledExplicit = JE(i, "explicit")),
    (i.compiledTypeMap = BU(i.compiledImplicit, i.compiledExplicit)),
    i
  );
};
var W2 = s0,
  UU = Sr,
  z2 = new UU("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function (e) {
      return e !== null ? e : "";
    },
  }),
  FU = Sr,
  K2 = new FU("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function (e) {
      return e !== null ? e : [];
    },
  }),
  jU = Sr,
  V2 = new jU("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function (e) {
      return e !== null ? e : {};
    },
  }),
  MU = W2,
  Y2 = new MU({ explicit: [z2, K2, V2] }),
  HU = Sr;
function qU(e) {
  if (e === null) return !0;
  var t = e.length;
  return (
    (t === 1 && e === "~") ||
    (t === 4 && (e === "null" || e === "Null" || e === "NULL"))
  );
}
function GU() {
  return null;
}
function QU(e) {
  return e === null;
}
var X2 = new HU("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: qU,
    construct: GU,
    predicate: QU,
    represent: {
      canonical: function () {
        return "~";
      },
      lowercase: function () {
        return "null";
      },
      uppercase: function () {
        return "NULL";
      },
      camelcase: function () {
        return "Null";
      },
      empty: function () {
        return "";
      },
    },
    defaultStyle: "lowercase",
  }),
  WU = Sr;
function zU(e) {
  if (e === null) return !1;
  var t = e.length;
  return (
    (t === 4 && (e === "true" || e === "True" || e === "TRUE")) ||
    (t === 5 && (e === "false" || e === "False" || e === "FALSE"))
  );
}
function KU(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function VU(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var J2 = new WU("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: zU,
    construct: KU,
    predicate: VU,
    represent: {
      lowercase: function (e) {
        return e ? "true" : "false";
      },
      uppercase: function (e) {
        return e ? "TRUE" : "FALSE";
      },
      camelcase: function (e) {
        return e ? "True" : "False";
      },
    },
    defaultStyle: "lowercase",
  }),
  YU = Ai,
  XU = Sr;
function JU(e) {
  return (48 <= e && e <= 57) || (65 <= e && e <= 70) || (97 <= e && e <= 102);
}
function ZU(e) {
  return 48 <= e && e <= 55;
}
function eF(e) {
  return 48 <= e && e <= 57;
}
function tF(e) {
  if (e === null) return !1;
  var t = e.length,
    n = 0,
    r = !1,
    i;
  if (!t) return !1;
  if (((i = e[n]), (i === "-" || i === "+") && (i = e[++n]), i === "0")) {
    if (n + 1 === t) return !0;
    if (((i = e[++n]), i === "b")) {
      for (n++; n < t; n++)
        if (((i = e[n]), i !== "_")) {
          if (i !== "0" && i !== "1") return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "x") {
      for (n++; n < t; n++)
        if (((i = e[n]), i !== "_")) {
          if (!JU(e.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "o") {
      for (n++; n < t; n++)
        if (((i = e[n]), i !== "_")) {
          if (!ZU(e.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
  }
  if (i === "_") return !1;
  for (; n < t; n++)
    if (((i = e[n]), i !== "_")) {
      if (!eF(e.charCodeAt(n))) return !1;
      r = !0;
    }
  return !(!r || i === "_");
}
function nF(e) {
  var t = e,
    n = 1,
    r;
  if (
    (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")),
    (r = t[0]),
    (r === "-" || r === "+") &&
      (r === "-" && (n = -1), (t = t.slice(1)), (r = t[0])),
    t === "0")
  )
    return 0;
  if (r === "0") {
    if (t[1] === "b") return n * parseInt(t.slice(2), 2);
    if (t[1] === "x") return n * parseInt(t.slice(2), 16);
    if (t[1] === "o") return n * parseInt(t.slice(2), 8);
  }
  return n * parseInt(t, 10);
}
function rF(e) {
  return (
    Object.prototype.toString.call(e) === "[object Number]" &&
    e % 1 === 0 &&
    !YU.isNegativeZero(e)
  );
}
var Z2 = new XU("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: tF,
    construct: nF,
    predicate: rF,
    represent: {
      binary: function (e) {
        return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
      },
      octal: function (e) {
        return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
      },
      decimal: function (e) {
        return e.toString(10);
      },
      hexadecimal: function (e) {
        return e >= 0
          ? "0x" + e.toString(16).toUpperCase()
          : "-0x" + e.toString(16).toUpperCase().slice(1);
      },
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"],
    },
  }),
  eC = Ai,
  iF = Sr,
  aF = new RegExp(
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$",
  );
function sF(e) {
  return !(e === null || !aF.test(e) || e[e.length - 1] === "_");
}
function oF(e) {
  var t, n;
  return (
    (t = e.replace(/_/g, "").toLowerCase()),
    (n = t[0] === "-" ? -1 : 1),
    "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)),
    t === ".inf"
      ? n === 1
        ? Number.POSITIVE_INFINITY
        : Number.NEGATIVE_INFINITY
      : t === ".nan"
      ? NaN
      : n * parseFloat(t, 10)
  );
}
var cF = /^[-+]?[0-9]+e/;
function lF(e, t) {
  var n;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (eC.isNegativeZero(e)) return "-0.0";
  return (n = e.toString(10)), cF.test(n) ? n.replace("e", ".e") : n;
}
function uF(e) {
  return (
    Object.prototype.toString.call(e) === "[object Number]" &&
    (e % 1 !== 0 || eC.isNegativeZero(e))
  );
}
var tC = new iF("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: sF,
    construct: oF,
    predicate: uF,
    represent: lF,
    defaultStyle: "lowercase",
  }),
  nC = Y2.extend({ implicit: [X2, J2, Z2, tC] }),
  rC = nC,
  fF = Sr,
  iC = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
  aC = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$",
  );
function dF(e) {
  return e === null ? !1 : iC.exec(e) !== null || aC.exec(e) !== null;
}
function pF(e) {
  var t,
    n,
    r,
    i,
    a,
    s,
    o,
    c = 0,
    l = null,
    f,
    u,
    d;
  if (((t = iC.exec(e)), t === null && (t = aC.exec(e)), t === null))
    throw new Error("Date resolve error");
  if (((n = +t[1]), (r = +t[2] - 1), (i = +t[3]), !t[4]))
    return new Date(Date.UTC(n, r, i));
  if (((a = +t[4]), (s = +t[5]), (o = +t[6]), t[7])) {
    for (c = t[7].slice(0, 3); c.length < 3; ) c += "0";
    c = +c;
  }
  return (
    t[9] &&
      ((f = +t[10]),
      (u = +(t[11] || 0)),
      (l = (f * 60 + u) * 6e4),
      t[9] === "-" && (l = -l)),
    (d = new Date(Date.UTC(n, r, i, a, s, o, c))),
    l && d.setTime(d.getTime() - l),
    d
  );
}
function hF(e) {
  return e.toISOString();
}
var sC = new fF("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: dF,
    construct: pF,
    instanceOf: Date,
    represent: hF,
  }),
  mF = Sr;
function gF(e) {
  return e === "<<" || e === null;
}
var oC = new mF("tag:yaml.org,2002:merge", { kind: "scalar", resolve: gF }),
  vF = Sr,
  Mv = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function yF(e) {
  if (e === null) return !1;
  var t,
    n,
    r = 0,
    i = e.length,
    a = Mv;
  for (n = 0; n < i; n++)
    if (((t = a.indexOf(e.charAt(n))), !(t > 64))) {
      if (t < 0) return !1;
      r += 6;
    }
  return r % 8 === 0;
}
function bF(e) {
  var t,
    n,
    r = e.replace(/[\r\n=]/g, ""),
    i = r.length,
    a = Mv,
    s = 0,
    o = [];
  for (t = 0; t < i; t++)
    t % 4 === 0 &&
      t &&
      (o.push((s >> 16) & 255), o.push((s >> 8) & 255), o.push(s & 255)),
      (s = (s << 6) | a.indexOf(r.charAt(t)));
  return (
    (n = (i % 4) * 6),
    n === 0
      ? (o.push((s >> 16) & 255), o.push((s >> 8) & 255), o.push(s & 255))
      : n === 18
      ? (o.push((s >> 10) & 255), o.push((s >> 2) & 255))
      : n === 12 && o.push((s >> 4) & 255),
    new Uint8Array(o)
  );
}
function _F(e) {
  var t = "",
    n = 0,
    r,
    i,
    a = e.length,
    s = Mv;
  for (r = 0; r < a; r++)
    r % 3 === 0 &&
      r &&
      ((t += s[(n >> 18) & 63]),
      (t += s[(n >> 12) & 63]),
      (t += s[(n >> 6) & 63]),
      (t += s[n & 63])),
      (n = (n << 8) + e[r]);
  return (
    (i = a % 3),
    i === 0
      ? ((t += s[(n >> 18) & 63]),
        (t += s[(n >> 12) & 63]),
        (t += s[(n >> 6) & 63]),
        (t += s[n & 63]))
      : i === 2
      ? ((t += s[(n >> 10) & 63]),
        (t += s[(n >> 4) & 63]),
        (t += s[(n << 2) & 63]),
        (t += s[64]))
      : i === 1 &&
        ((t += s[(n >> 2) & 63]),
        (t += s[(n << 4) & 63]),
        (t += s[64]),
        (t += s[64])),
    t
  );
}
function EF(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var cC = new vF("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: yF,
    construct: bF,
    predicate: EF,
    represent: _F,
  }),
  wF = Sr,
  xF = Object.prototype.hasOwnProperty,
  AF = Object.prototype.toString;
function SF(e) {
  if (e === null) return !0;
  var t = [],
    n,
    r,
    i,
    a,
    s,
    o = e;
  for (n = 0, r = o.length; n < r; n += 1) {
    if (((i = o[n]), (s = !1), AF.call(i) !== "[object Object]")) return !1;
    for (a in i)
      if (xF.call(i, a))
        if (!s) s = !0;
        else return !1;
    if (!s) return !1;
    if (t.indexOf(a) === -1) t.push(a);
    else return !1;
  }
  return !0;
}
function IF(e) {
  return e !== null ? e : [];
}
var lC = new wF("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: SF,
    construct: IF,
  }),
  $F = Sr,
  CF = Object.prototype.toString;
function RF(e) {
  if (e === null) return !0;
  var t,
    n,
    r,
    i,
    a,
    s = e;
  for (a = new Array(s.length), t = 0, n = s.length; t < n; t += 1) {
    if (
      ((r = s[t]),
      CF.call(r) !== "[object Object]" ||
        ((i = Object.keys(r)), i.length !== 1))
    )
      return !1;
    a[t] = [i[0], r[i[0]]];
  }
  return !0;
}
function kF(e) {
  if (e === null) return [];
  var t,
    n,
    r,
    i,
    a,
    s = e;
  for (a = new Array(s.length), t = 0, n = s.length; t < n; t += 1)
    (r = s[t]), (i = Object.keys(r)), (a[t] = [i[0], r[i[0]]]);
  return a;
}
var uC = new $F("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: RF,
    construct: kF,
  }),
  TF = Sr,
  NF = Object.prototype.hasOwnProperty;
function OF(e) {
  if (e === null) return !0;
  var t,
    n = e;
  for (t in n) if (NF.call(n, t) && n[t] !== null) return !1;
  return !0;
}
function PF(e) {
  return e !== null ? e : {};
}
var fC = new TF("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: OF,
    construct: PF,
  }),
  Hv = rC.extend({ implicit: [sC, oC], explicit: [cC, lC, uC, fC] }),
  ms = Ai,
  dC = nu,
  DF = NU,
  LF = Hv,
  za = Object.prototype.hasOwnProperty,
  dd = 1,
  pC = 2,
  hC = 3,
  pd = 4,
  lm = 1,
  BF = 2,
  ZE = 3,
  UF =
    /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
  FF = /[\x85\u2028\u2029]/,
  jF = /[,\[\]\{\}]/,
  mC = /^(?:!|!!|![a-z\-]+!)$/i,
  gC =
    /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function ew(e) {
  return Object.prototype.toString.call(e);
}
function Mi(e) {
  return e === 10 || e === 13;
}
function Ps(e) {
  return e === 9 || e === 32;
}
function Ur(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function Io(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function MF(e) {
  var t;
  return 48 <= e && e <= 57
    ? e - 48
    : ((t = e | 32), 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function HF(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function qF(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function tw(e) {
  return e === 48
    ? "\0"
    : e === 97
    ? "\x07"
    : e === 98
    ? "\b"
    : e === 116 || e === 9
    ? "	"
    : e === 110
    ? `
`
    : e === 118
    ? "\v"
    : e === 102
    ? "\f"
    : e === 114
    ? "\r"
    : e === 101
    ? "\x1B"
    : e === 32
    ? " "
    : e === 34
    ? '"'
    : e === 47
    ? "/"
    : e === 92
    ? "\\"
    : e === 78
    ? ""
    : e === 95
    ? " "
    : e === 76
    ? "\u2028"
    : e === 80
    ? "\u2029"
    : "";
}
function GF(e) {
  return e <= 65535
    ? String.fromCharCode(e)
    : String.fromCharCode(
        ((e - 65536) >> 10) + 55296,
        ((e - 65536) & 1023) + 56320,
      );
}
var vC = new Array(256),
  yC = new Array(256);
for (var ao = 0; ao < 256; ao++) (vC[ao] = tw(ao) ? 1 : 0), (yC[ao] = tw(ao));
function QF(e, t) {
  (this.input = e),
    (this.filename = t.filename || null),
    (this.schema = t.schema || LF),
    (this.onWarning = t.onWarning || null),
    (this.legacy = t.legacy || !1),
    (this.json = t.json || !1),
    (this.listener = t.listener || null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.typeMap = this.schema.compiledTypeMap),
    (this.length = e.length),
    (this.position = 0),
    (this.line = 0),
    (this.lineStart = 0),
    (this.lineIndent = 0),
    (this.firstTabInLine = -1),
    (this.documents = []);
}
function bC(e, t) {
  var n = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart,
  };
  return (n.snippet = DF(n)), new dC(t, n);
}
function Ze(e, t) {
  throw bC(e, t);
}
function hd(e, t) {
  e.onWarning && e.onWarning.call(null, bC(e, t));
}
var nw = {
  YAML: function (t, n, r) {
    var i, a, s;
    t.version !== null && Ze(t, "duplication of %YAML directive"),
      r.length !== 1 && Ze(t, "YAML directive accepts exactly one argument"),
      (i = /^([0-9]+)\.([0-9]+)$/.exec(r[0])),
      i === null && Ze(t, "ill-formed argument of the YAML directive"),
      (a = parseInt(i[1], 10)),
      (s = parseInt(i[2], 10)),
      a !== 1 && Ze(t, "unacceptable YAML version of the document"),
      (t.version = r[0]),
      (t.checkLineBreaks = s < 2),
      s !== 1 && s !== 2 && hd(t, "unsupported YAML version of the document");
  },
  TAG: function (t, n, r) {
    var i, a;
    r.length !== 2 && Ze(t, "TAG directive accepts exactly two arguments"),
      (i = r[0]),
      (a = r[1]),
      mC.test(i) ||
        Ze(t, "ill-formed tag handle (first argument) of the TAG directive"),
      za.call(t.tagMap, i) &&
        Ze(
          t,
          'there is a previously declared suffix for "' + i + '" tag handle',
        ),
      gC.test(a) ||
        Ze(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      a = decodeURIComponent(a);
    } catch {
      Ze(t, "tag prefix is malformed: " + a);
    }
    t.tagMap[i] = a;
  },
};
function qa(e, t, n, r) {
  var i, a, s, o;
  if (t < n) {
    if (((o = e.input.slice(t, n)), r))
      for (i = 0, a = o.length; i < a; i += 1)
        (s = o.charCodeAt(i)),
          s === 9 ||
            (32 <= s && s <= 1114111) ||
            Ze(e, "expected valid JSON character");
    else UF.test(o) && Ze(e, "the stream contains non-printable characters");
    e.result += o;
  }
}
function rw(e, t, n, r) {
  var i, a, s, o;
  for (
    ms.isObject(n) ||
      Ze(
        e,
        "cannot merge mappings; the provided source object is unacceptable",
      ),
      i = Object.keys(n),
      s = 0,
      o = i.length;
    s < o;
    s += 1
  )
    (a = i[s]), za.call(t, a) || ((t[a] = n[a]), (r[a] = !0));
}
function $o(e, t, n, r, i, a, s, o, c) {
  var l, f;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), l = 0, f = i.length; l < f; l += 1)
      Array.isArray(i[l]) &&
        Ze(e, "nested arrays are not supported inside keys"),
        typeof i == "object" &&
          ew(i[l]) === "[object Object]" &&
          (i[l] = "[object Object]");
  if (
    (typeof i == "object" &&
      ew(i) === "[object Object]" &&
      (i = "[object Object]"),
    (i = String(i)),
    t === null && (t = {}),
    r === "tag:yaml.org,2002:merge")
  )
    if (Array.isArray(a))
      for (l = 0, f = a.length; l < f; l += 1) rw(e, t, a[l], n);
    else rw(e, t, a, n);
  else
    !e.json &&
      !za.call(n, i) &&
      za.call(t, i) &&
      ((e.line = s || e.line),
      (e.lineStart = o || e.lineStart),
      (e.position = c || e.position),
      Ze(e, "duplicated mapping key")),
      i === "__proto__"
        ? Object.defineProperty(t, i, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: a,
          })
        : (t[i] = a),
      delete n[i];
  return t;
}
function qv(e) {
  var t;
  (t = e.input.charCodeAt(e.position)),
    t === 10
      ? e.position++
      : t === 13
      ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++)
      : Ze(e, "a line break is expected"),
    (e.line += 1),
    (e.lineStart = e.position),
    (e.firstTabInLine = -1);
}
function Dn(e, t, n) {
  for (var r = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; Ps(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position),
        (i = e.input.charCodeAt(++e.position));
    if (t && i === 35)
      do i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (Mi(i))
      for (
        qv(e), i = e.input.charCodeAt(e.position), r++, e.lineIndent = 0;
        i === 32;

      )
        e.lineIndent++, (i = e.input.charCodeAt(++e.position));
    else break;
  }
  return (
    n !== -1 && r !== 0 && e.lineIndent < n && hd(e, "deficient indentation"), r
  );
}
function op(e) {
  var t = e.position,
    n;
  return (
    (n = e.input.charCodeAt(t)),
    !!(
      (n === 45 || n === 46) &&
      n === e.input.charCodeAt(t + 1) &&
      n === e.input.charCodeAt(t + 2) &&
      ((t += 3), (n = e.input.charCodeAt(t)), n === 0 || Ur(n))
    )
  );
}
function Gv(e, t) {
  t === 1
    ? (e.result += " ")
    : t > 1 &&
      (e.result += ms.repeat(
        `
`,
        t - 1,
      ));
}
function WF(e, t, n) {
  var r,
    i,
    a,
    s,
    o,
    c,
    l,
    f,
    u = e.kind,
    d = e.result,
    p;
  if (
    ((p = e.input.charCodeAt(e.position)),
    Ur(p) ||
      Io(p) ||
      p === 35 ||
      p === 38 ||
      p === 42 ||
      p === 33 ||
      p === 124 ||
      p === 62 ||
      p === 39 ||
      p === 34 ||
      p === 37 ||
      p === 64 ||
      p === 96 ||
      ((p === 63 || p === 45) &&
        ((i = e.input.charCodeAt(e.position + 1)), Ur(i) || (n && Io(i)))))
  )
    return !1;
  for (
    e.kind = "scalar", e.result = "", a = s = e.position, o = !1;
    p !== 0;

  ) {
    if (p === 58) {
      if (((i = e.input.charCodeAt(e.position + 1)), Ur(i) || (n && Io(i))))
        break;
    } else if (p === 35) {
      if (((r = e.input.charCodeAt(e.position - 1)), Ur(r))) break;
    } else {
      if ((e.position === e.lineStart && op(e)) || (n && Io(p))) break;
      if (Mi(p))
        if (
          ((c = e.line),
          (l = e.lineStart),
          (f = e.lineIndent),
          Dn(e, !1, -1),
          e.lineIndent >= t)
        ) {
          (o = !0), (p = e.input.charCodeAt(e.position));
          continue;
        } else {
          (e.position = s), (e.line = c), (e.lineStart = l), (e.lineIndent = f);
          break;
        }
    }
    o && (qa(e, a, s, !1), Gv(e, e.line - c), (a = s = e.position), (o = !1)),
      Ps(p) || (s = e.position + 1),
      (p = e.input.charCodeAt(++e.position));
  }
  return qa(e, a, s, !1), e.result ? !0 : ((e.kind = u), (e.result = d), !1);
}
function zF(e, t) {
  var n, r, i;
  if (((n = e.input.charCodeAt(e.position)), n !== 39)) return !1;
  for (
    e.kind = "scalar", e.result = "", e.position++, r = i = e.position;
    (n = e.input.charCodeAt(e.position)) !== 0;

  )
    if (n === 39)
      if (
        (qa(e, r, e.position, !0),
        (n = e.input.charCodeAt(++e.position)),
        n === 39)
      )
        (r = e.position), e.position++, (i = e.position);
      else return !0;
    else
      Mi(n)
        ? (qa(e, r, i, !0), Gv(e, Dn(e, !1, t)), (r = i = e.position))
        : e.position === e.lineStart && op(e)
        ? Ze(e, "unexpected end of the document within a single quoted scalar")
        : (e.position++, (i = e.position));
  Ze(e, "unexpected end of the stream within a single quoted scalar");
}
function KF(e, t) {
  var n, r, i, a, s, o;
  if (((o = e.input.charCodeAt(e.position)), o !== 34)) return !1;
  for (
    e.kind = "scalar", e.result = "", e.position++, n = r = e.position;
    (o = e.input.charCodeAt(e.position)) !== 0;

  ) {
    if (o === 34) return qa(e, n, e.position, !0), e.position++, !0;
    if (o === 92) {
      if (
        (qa(e, n, e.position, !0),
        (o = e.input.charCodeAt(++e.position)),
        Mi(o))
      )
        Dn(e, !1, t);
      else if (o < 256 && vC[o]) (e.result += yC[o]), e.position++;
      else if ((s = HF(o)) > 0) {
        for (i = s, a = 0; i > 0; i--)
          (o = e.input.charCodeAt(++e.position)),
            (s = MF(o)) >= 0
              ? (a = (a << 4) + s)
              : Ze(e, "expected hexadecimal character");
        (e.result += GF(a)), e.position++;
      } else Ze(e, "unknown escape sequence");
      n = r = e.position;
    } else
      Mi(o)
        ? (qa(e, n, r, !0), Gv(e, Dn(e, !1, t)), (n = r = e.position))
        : e.position === e.lineStart && op(e)
        ? Ze(e, "unexpected end of the document within a double quoted scalar")
        : (e.position++, (r = e.position));
  }
  Ze(e, "unexpected end of the stream within a double quoted scalar");
}
function VF(e, t) {
  var n = !0,
    r,
    i,
    a,
    s = e.tag,
    o,
    c = e.anchor,
    l,
    f,
    u,
    d,
    p,
    h = Object.create(null),
    m,
    g,
    v,
    y;
  if (((y = e.input.charCodeAt(e.position)), y === 91))
    (f = 93), (p = !1), (o = []);
  else if (y === 123) (f = 125), (p = !0), (o = {});
  else return !1;
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = o),
      y = e.input.charCodeAt(++e.position);
    y !== 0;

  ) {
    if ((Dn(e, !0, t), (y = e.input.charCodeAt(e.position)), y === f))
      return (
        e.position++,
        (e.tag = s),
        (e.anchor = c),
        (e.kind = p ? "mapping" : "sequence"),
        (e.result = o),
        !0
      );
    n
      ? y === 44 && Ze(e, "expected the node content, but found ','")
      : Ze(e, "missed comma between flow collection entries"),
      (g = m = v = null),
      (u = d = !1),
      y === 63 &&
        ((l = e.input.charCodeAt(e.position + 1)),
        Ur(l) && ((u = d = !0), e.position++, Dn(e, !0, t))),
      (r = e.line),
      (i = e.lineStart),
      (a = e.position),
      Zo(e, t, dd, !1, !0),
      (g = e.tag),
      (m = e.result),
      Dn(e, !0, t),
      (y = e.input.charCodeAt(e.position)),
      (d || e.line === r) &&
        y === 58 &&
        ((u = !0),
        (y = e.input.charCodeAt(++e.position)),
        Dn(e, !0, t),
        Zo(e, t, dd, !1, !0),
        (v = e.result)),
      p
        ? $o(e, o, h, g, m, v, r, i, a)
        : u
        ? o.push($o(e, null, h, g, m, v, r, i, a))
        : o.push(m),
      Dn(e, !0, t),
      (y = e.input.charCodeAt(e.position)),
      y === 44 ? ((n = !0), (y = e.input.charCodeAt(++e.position))) : (n = !1);
  }
  Ze(e, "unexpected end of the stream within a flow collection");
}
function YF(e, t) {
  var n,
    r,
    i = lm,
    a = !1,
    s = !1,
    o = t,
    c = 0,
    l = !1,
    f,
    u;
  if (((u = e.input.charCodeAt(e.position)), u === 124)) r = !1;
  else if (u === 62) r = !0;
  else return !1;
  for (e.kind = "scalar", e.result = ""; u !== 0; )
    if (((u = e.input.charCodeAt(++e.position)), u === 43 || u === 45))
      lm === i
        ? (i = u === 43 ? ZE : BF)
        : Ze(e, "repeat of a chomping mode identifier");
    else if ((f = qF(u)) >= 0)
      f === 0
        ? Ze(
            e,
            "bad explicit indentation width of a block scalar; it cannot be less than one",
          )
        : s
        ? Ze(e, "repeat of an indentation width identifier")
        : ((o = t + f - 1), (s = !0));
    else break;
  if (Ps(u)) {
    do u = e.input.charCodeAt(++e.position);
    while (Ps(u));
    if (u === 35)
      do u = e.input.charCodeAt(++e.position);
      while (!Mi(u) && u !== 0);
  }
  for (; u !== 0; ) {
    for (
      qv(e), e.lineIndent = 0, u = e.input.charCodeAt(e.position);
      (!s || e.lineIndent < o) && u === 32;

    )
      e.lineIndent++, (u = e.input.charCodeAt(++e.position));
    if ((!s && e.lineIndent > o && (o = e.lineIndent), Mi(u))) {
      c++;
      continue;
    }
    if (e.lineIndent < o) {
      i === ZE
        ? (e.result += ms.repeat(
            `
`,
            a ? 1 + c : c,
          ))
        : i === lm &&
          a &&
          (e.result += `
`);
      break;
    }
    for (
      r
        ? Ps(u)
          ? ((l = !0),
            (e.result += ms.repeat(
              `
`,
              a ? 1 + c : c,
            )))
          : l
          ? ((l = !1),
            (e.result += ms.repeat(
              `
`,
              c + 1,
            )))
          : c === 0
          ? a && (e.result += " ")
          : (e.result += ms.repeat(
              `
`,
              c,
            ))
        : (e.result += ms.repeat(
            `
`,
            a ? 1 + c : c,
          )),
        a = !0,
        s = !0,
        c = 0,
        n = e.position;
      !Mi(u) && u !== 0;

    )
      u = e.input.charCodeAt(++e.position);
    qa(e, n, e.position, !1);
  }
  return !0;
}
function iw(e, t) {
  var n,
    r = e.tag,
    i = e.anchor,
    a = [],
    s,
    o = !1,
    c;
  if (e.firstTabInLine !== -1) return !1;
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = a),
      c = e.input.charCodeAt(e.position);
    c !== 0 &&
    (e.firstTabInLine !== -1 &&
      ((e.position = e.firstTabInLine),
      Ze(e, "tab characters must not be used in indentation")),
    !(c !== 45 || ((s = e.input.charCodeAt(e.position + 1)), !Ur(s))));

  ) {
    if (((o = !0), e.position++, Dn(e, !0, -1) && e.lineIndent <= t)) {
      a.push(null), (c = e.input.charCodeAt(e.position));
      continue;
    }
    if (
      ((n = e.line),
      Zo(e, t, hC, !1, !0),
      a.push(e.result),
      Dn(e, !0, -1),
      (c = e.input.charCodeAt(e.position)),
      (e.line === n || e.lineIndent > t) && c !== 0)
    )
      Ze(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t) break;
  }
  return o
    ? ((e.tag = r), (e.anchor = i), (e.kind = "sequence"), (e.result = a), !0)
    : !1;
}
function XF(e, t, n) {
  var r,
    i,
    a,
    s,
    o,
    c,
    l = e.tag,
    f = e.anchor,
    u = {},
    d = Object.create(null),
    p = null,
    h = null,
    m = null,
    g = !1,
    v = !1,
    y;
  if (e.firstTabInLine !== -1) return !1;
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = u),
      y = e.input.charCodeAt(e.position);
    y !== 0;

  ) {
    if (
      (!g &&
        e.firstTabInLine !== -1 &&
        ((e.position = e.firstTabInLine),
        Ze(e, "tab characters must not be used in indentation")),
      (r = e.input.charCodeAt(e.position + 1)),
      (a = e.line),
      (y === 63 || y === 58) && Ur(r))
    )
      y === 63
        ? (g && ($o(e, u, d, p, h, null, s, o, c), (p = h = m = null)),
          (v = !0),
          (g = !0),
          (i = !0))
        : g
        ? ((g = !1), (i = !0))
        : Ze(
            e,
            "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line",
          ),
        (e.position += 1),
        (y = r);
    else {
      if (
        ((s = e.line),
        (o = e.lineStart),
        (c = e.position),
        !Zo(e, n, pC, !1, !0))
      )
        break;
      if (e.line === a) {
        for (y = e.input.charCodeAt(e.position); Ps(y); )
          y = e.input.charCodeAt(++e.position);
        if (y === 58)
          (y = e.input.charCodeAt(++e.position)),
            Ur(y) ||
              Ze(
                e,
                "a whitespace character is expected after the key-value separator within a block mapping",
              ),
            g && ($o(e, u, d, p, h, null, s, o, c), (p = h = m = null)),
            (v = !0),
            (g = !1),
            (i = !1),
            (p = e.tag),
            (h = e.result);
        else if (v)
          Ze(e, "can not read an implicit mapping pair; a colon is missed");
        else return (e.tag = l), (e.anchor = f), !0;
      } else if (v)
        Ze(
          e,
          "can not read a block mapping entry; a multiline key may not be an implicit key",
        );
      else return (e.tag = l), (e.anchor = f), !0;
    }
    if (
      ((e.line === a || e.lineIndent > t) &&
        (g && ((s = e.line), (o = e.lineStart), (c = e.position)),
        Zo(e, t, pd, !0, i) && (g ? (h = e.result) : (m = e.result)),
        g || ($o(e, u, d, p, h, m, s, o, c), (p = h = m = null)),
        Dn(e, !0, -1),
        (y = e.input.charCodeAt(e.position))),
      (e.line === a || e.lineIndent > t) && y !== 0)
    )
      Ze(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t) break;
  }
  return (
    g && $o(e, u, d, p, h, null, s, o, c),
    v && ((e.tag = l), (e.anchor = f), (e.kind = "mapping"), (e.result = u)),
    v
  );
}
function JF(e) {
  var t,
    n = !1,
    r = !1,
    i,
    a,
    s;
  if (((s = e.input.charCodeAt(e.position)), s !== 33)) return !1;
  if (
    (e.tag !== null && Ze(e, "duplication of a tag property"),
    (s = e.input.charCodeAt(++e.position)),
    s === 60
      ? ((n = !0), (s = e.input.charCodeAt(++e.position)))
      : s === 33
      ? ((r = !0), (i = "!!"), (s = e.input.charCodeAt(++e.position)))
      : (i = "!"),
    (t = e.position),
    n)
  ) {
    do s = e.input.charCodeAt(++e.position);
    while (s !== 0 && s !== 62);
    e.position < e.length
      ? ((a = e.input.slice(t, e.position)),
        (s = e.input.charCodeAt(++e.position)))
      : Ze(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; s !== 0 && !Ur(s); )
      s === 33 &&
        (r
          ? Ze(e, "tag suffix cannot contain exclamation marks")
          : ((i = e.input.slice(t - 1, e.position + 1)),
            mC.test(i) ||
              Ze(e, "named tag handle cannot contain such characters"),
            (r = !0),
            (t = e.position + 1))),
        (s = e.input.charCodeAt(++e.position));
    (a = e.input.slice(t, e.position)),
      jF.test(a) &&
        Ze(e, "tag suffix cannot contain flow indicator characters");
  }
  a && !gC.test(a) && Ze(e, "tag name cannot contain such characters: " + a);
  try {
    a = decodeURIComponent(a);
  } catch {
    Ze(e, "tag name is malformed: " + a);
  }
  return (
    n
      ? (e.tag = a)
      : za.call(e.tagMap, i)
      ? (e.tag = e.tagMap[i] + a)
      : i === "!"
      ? (e.tag = "!" + a)
      : i === "!!"
      ? (e.tag = "tag:yaml.org,2002:" + a)
      : Ze(e, 'undeclared tag handle "' + i + '"'),
    !0
  );
}
function ZF(e) {
  var t, n;
  if (((n = e.input.charCodeAt(e.position)), n !== 38)) return !1;
  for (
    e.anchor !== null && Ze(e, "duplication of an anchor property"),
      n = e.input.charCodeAt(++e.position),
      t = e.position;
    n !== 0 && !Ur(n) && !Io(n);

  )
    n = e.input.charCodeAt(++e.position);
  return (
    e.position === t &&
      Ze(e, "name of an anchor node must contain at least one character"),
    (e.anchor = e.input.slice(t, e.position)),
    !0
  );
}
function e9(e) {
  var t, n, r;
  if (((r = e.input.charCodeAt(e.position)), r !== 42)) return !1;
  for (
    r = e.input.charCodeAt(++e.position), t = e.position;
    r !== 0 && !Ur(r) && !Io(r);

  )
    r = e.input.charCodeAt(++e.position);
  return (
    e.position === t &&
      Ze(e, "name of an alias node must contain at least one character"),
    (n = e.input.slice(t, e.position)),
    za.call(e.anchorMap, n) || Ze(e, 'unidentified alias "' + n + '"'),
    (e.result = e.anchorMap[n]),
    Dn(e, !0, -1),
    !0
  );
}
function Zo(e, t, n, r, i) {
  var a,
    s,
    o,
    c = 1,
    l = !1,
    f = !1,
    u,
    d,
    p,
    h,
    m,
    g;
  if (
    (e.listener !== null && e.listener("open", e),
    (e.tag = null),
    (e.anchor = null),
    (e.kind = null),
    (e.result = null),
    (a = s = o = pd === n || hC === n),
    r &&
      Dn(e, !0, -1) &&
      ((l = !0),
      e.lineIndent > t
        ? (c = 1)
        : e.lineIndent === t
        ? (c = 0)
        : e.lineIndent < t && (c = -1)),
    c === 1)
  )
    for (; JF(e) || ZF(e); )
      Dn(e, !0, -1)
        ? ((l = !0),
          (o = a),
          e.lineIndent > t
            ? (c = 1)
            : e.lineIndent === t
            ? (c = 0)
            : e.lineIndent < t && (c = -1))
        : (o = !1);
  if (
    (o && (o = l || i),
    (c === 1 || pd === n) &&
      (dd === n || pC === n ? (m = t) : (m = t + 1),
      (g = e.position - e.lineStart),
      c === 1
        ? (o && (iw(e, g) || XF(e, g, m))) || VF(e, m)
          ? (f = !0)
          : ((s && YF(e, m)) || zF(e, m) || KF(e, m)
              ? (f = !0)
              : e9(e)
              ? ((f = !0),
                (e.tag !== null || e.anchor !== null) &&
                  Ze(e, "alias node should not have any properties"))
              : WF(e, m, dd === n) &&
                ((f = !0), e.tag === null && (e.tag = "?")),
            e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
        : c === 0 && (f = o && iw(e, g))),
    e.tag === null)
  )
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (
      e.result !== null &&
        e.kind !== "scalar" &&
        Ze(
          e,
          'unacceptable node kind for !<?> tag; it should be "scalar", not "' +
            e.kind +
            '"',
        ),
        u = 0,
        d = e.implicitTypes.length;
      u < d;
      u += 1
    )
      if (((h = e.implicitTypes[u]), h.resolve(e.result))) {
        (e.result = h.construct(e.result)),
          (e.tag = h.tag),
          e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (za.call(e.typeMap[e.kind || "fallback"], e.tag))
      h = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (
        h = null,
          p = e.typeMap.multi[e.kind || "fallback"],
          u = 0,
          d = p.length;
        u < d;
        u += 1
      )
        if (e.tag.slice(0, p[u].tag.length) === p[u].tag) {
          h = p[u];
          break;
        }
    h || Ze(e, "unknown tag !<" + e.tag + ">"),
      e.result !== null &&
        h.kind !== e.kind &&
        Ze(
          e,
          "unacceptable node kind for !<" +
            e.tag +
            '> tag; it should be "' +
            h.kind +
            '", not "' +
            e.kind +
            '"',
        ),
      h.resolve(e.result, e.tag)
        ? ((e.result = h.construct(e.result, e.tag)),
          e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
        : Ze(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return (
    e.listener !== null && e.listener("close", e),
    e.tag !== null || e.anchor !== null || f
  );
}
function t9(e) {
  var t = e.position,
    n,
    r,
    i,
    a = !1,
    s;
  for (
    e.version = null,
      e.checkLineBreaks = e.legacy,
      e.tagMap = Object.create(null),
      e.anchorMap = Object.create(null);
    (s = e.input.charCodeAt(e.position)) !== 0 &&
    (Dn(e, !0, -1),
    (s = e.input.charCodeAt(e.position)),
    !(e.lineIndent > 0 || s !== 37));

  ) {
    for (
      a = !0, s = e.input.charCodeAt(++e.position), n = e.position;
      s !== 0 && !Ur(s);

    )
      s = e.input.charCodeAt(++e.position);
    for (
      r = e.input.slice(n, e.position),
        i = [],
        r.length < 1 &&
          Ze(e, "directive name must not be less than one character in length");
      s !== 0;

    ) {
      for (; Ps(s); ) s = e.input.charCodeAt(++e.position);
      if (s === 35) {
        do s = e.input.charCodeAt(++e.position);
        while (s !== 0 && !Mi(s));
        break;
      }
      if (Mi(s)) break;
      for (n = e.position; s !== 0 && !Ur(s); )
        s = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(n, e.position));
    }
    s !== 0 && qv(e),
      za.call(nw, r)
        ? nw[r](e, r, i)
        : hd(e, 'unknown document directive "' + r + '"');
  }
  if (
    (Dn(e, !0, -1),
    e.lineIndent === 0 &&
    e.input.charCodeAt(e.position) === 45 &&
    e.input.charCodeAt(e.position + 1) === 45 &&
    e.input.charCodeAt(e.position + 2) === 45
      ? ((e.position += 3), Dn(e, !0, -1))
      : a && Ze(e, "directives end mark is expected"),
    Zo(e, e.lineIndent - 1, pd, !1, !0),
    Dn(e, !0, -1),
    e.checkLineBreaks &&
      FF.test(e.input.slice(t, e.position)) &&
      hd(e, "non-ASCII line breaks are interpreted as content"),
    e.documents.push(e.result),
    e.position === e.lineStart && op(e))
  ) {
    e.input.charCodeAt(e.position) === 46 && ((e.position += 3), Dn(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    Ze(e, "end of the stream or a document separator is expected");
  else return;
}
function _C(e, t) {
  (e = String(e)),
    (t = t || {}),
    e.length !== 0 &&
      (e.charCodeAt(e.length - 1) !== 10 &&
        e.charCodeAt(e.length - 1) !== 13 &&
        (e += `
`),
      e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var n = new QF(e, t),
    r = e.indexOf("\0");
  for (
    r !== -1 && ((n.position = r), Ze(n, "null byte is not allowed in input")),
      n.input += "\0";
    n.input.charCodeAt(n.position) === 32;

  )
    (n.lineIndent += 1), (n.position += 1);
  for (; n.position < n.length - 1; ) t9(n);
  return n.documents;
}
function n9(e, t, n) {
  t !== null && typeof t == "object" && typeof n > "u" && ((n = t), (t = null));
  var r = _C(e, n);
  if (typeof t != "function") return r;
  for (var i = 0, a = r.length; i < a; i += 1) t(r[i]);
}
function r9(e, t) {
  var n = _C(e, t);
  if (n.length !== 0) {
    if (n.length === 1) return n[0];
    throw new dC("expected a single document in the stream, but found more");
  }
}
jv.loadAll = n9;
jv.load = r9;
var EC = {},
  cp = Ai,
  ru = nu,
  i9 = Hv,
  wC = Object.prototype.toString,
  xC = Object.prototype.hasOwnProperty,
  Qv = 65279,
  a9 = 9,
  Ul = 10,
  s9 = 13,
  o9 = 32,
  c9 = 33,
  l9 = 34,
  o0 = 35,
  u9 = 37,
  f9 = 38,
  d9 = 39,
  p9 = 42,
  AC = 44,
  h9 = 45,
  md = 58,
  m9 = 61,
  g9 = 62,
  v9 = 63,
  y9 = 64,
  SC = 91,
  IC = 93,
  b9 = 96,
  $C = 123,
  _9 = 124,
  CC = 125,
  hr = {};
hr[0] = "\\0";
hr[7] = "\\a";
hr[8] = "\\b";
hr[9] = "\\t";
hr[10] = "\\n";
hr[11] = "\\v";
hr[12] = "\\f";
hr[13] = "\\r";
hr[27] = "\\e";
hr[34] = '\\"';
hr[92] = "\\\\";
hr[133] = "\\N";
hr[160] = "\\_";
hr[8232] = "\\L";
hr[8233] = "\\P";
var E9 = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF",
  ],
  w9 = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function x9(e, t) {
  var n, r, i, a, s, o, c;
  if (t === null) return {};
  for (n = {}, r = Object.keys(t), i = 0, a = r.length; i < a; i += 1)
    (s = r[i]),
      (o = String(t[s])),
      s.slice(0, 2) === "!!" && (s = "tag:yaml.org,2002:" + s.slice(2)),
      (c = e.compiledTypeMap.fallback[s]),
      c && xC.call(c.styleAliases, o) && (o = c.styleAliases[o]),
      (n[s] = o);
  return n;
}
function A9(e) {
  var t, n, r;
  if (((t = e.toString(16).toUpperCase()), e <= 255)) (n = "x"), (r = 2);
  else if (e <= 65535) (n = "u"), (r = 4);
  else if (e <= 4294967295) (n = "U"), (r = 8);
  else
    throw new ru(
      "code point within a string may not be greater than 0xFFFFFFFF",
    );
  return "\\" + n + cp.repeat("0", r - t.length) + t;
}
var S9 = 1,
  Fl = 2;
function I9(e) {
  (this.schema = e.schema || i9),
    (this.indent = Math.max(1, e.indent || 2)),
    (this.noArrayIndent = e.noArrayIndent || !1),
    (this.skipInvalid = e.skipInvalid || !1),
    (this.flowLevel = cp.isNothing(e.flowLevel) ? -1 : e.flowLevel),
    (this.styleMap = x9(this.schema, e.styles || null)),
    (this.sortKeys = e.sortKeys || !1),
    (this.lineWidth = e.lineWidth || 80),
    (this.noRefs = e.noRefs || !1),
    (this.noCompatMode = e.noCompatMode || !1),
    (this.condenseFlow = e.condenseFlow || !1),
    (this.quotingType = e.quotingType === '"' ? Fl : S9),
    (this.forceQuotes = e.forceQuotes || !1),
    (this.replacer = typeof e.replacer == "function" ? e.replacer : null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.explicitTypes = this.schema.compiledExplicit),
    (this.tag = null),
    (this.result = ""),
    (this.duplicates = []),
    (this.usedDuplicates = null);
}
function aw(e, t) {
  for (
    var n = cp.repeat(" ", t), r = 0, i = -1, a = "", s, o = e.length;
    r < o;

  )
    (i = e.indexOf(
      `
`,
      r,
    )),
      i === -1
        ? ((s = e.slice(r)), (r = o))
        : ((s = e.slice(r, i + 1)), (r = i + 1)),
      s.length &&
        s !==
          `
` &&
        (a += n),
      (a += s);
  return a;
}
function c0(e, t) {
  return (
    `
` + cp.repeat(" ", e.indent * t)
  );
}
function $9(e, t) {
  var n, r, i;
  for (n = 0, r = e.implicitTypes.length; n < r; n += 1)
    if (((i = e.implicitTypes[n]), i.resolve(t))) return !0;
  return !1;
}
function gd(e) {
  return e === o9 || e === a9;
}
function jl(e) {
  return (
    (32 <= e && e <= 126) ||
    (161 <= e && e <= 55295 && e !== 8232 && e !== 8233) ||
    (57344 <= e && e <= 65533 && e !== Qv) ||
    (65536 <= e && e <= 1114111)
  );
}
function sw(e) {
  return jl(e) && e !== Qv && e !== s9 && e !== Ul;
}
function ow(e, t, n) {
  var r = sw(e),
    i = r && !gd(e);
  return (
    ((n ? r : r && e !== AC && e !== SC && e !== IC && e !== $C && e !== CC) &&
      e !== o0 &&
      !(t === md && !i)) ||
    (sw(t) && !gd(t) && e === o0) ||
    (t === md && i)
  );
}
function C9(e) {
  return (
    jl(e) &&
    e !== Qv &&
    !gd(e) &&
    e !== h9 &&
    e !== v9 &&
    e !== md &&
    e !== AC &&
    e !== SC &&
    e !== IC &&
    e !== $C &&
    e !== CC &&
    e !== o0 &&
    e !== f9 &&
    e !== p9 &&
    e !== c9 &&
    e !== _9 &&
    e !== m9 &&
    e !== g9 &&
    e !== d9 &&
    e !== l9 &&
    e !== u9 &&
    e !== y9 &&
    e !== b9
  );
}
function R9(e) {
  return !gd(e) && e !== md;
}
function rl(e, t) {
  var n = e.charCodeAt(t),
    r;
  return n >= 55296 &&
    n <= 56319 &&
    t + 1 < e.length &&
    ((r = e.charCodeAt(t + 1)), r >= 56320 && r <= 57343)
    ? (n - 55296) * 1024 + r - 56320 + 65536
    : n;
}
function RC(e) {
  var t = /^\n* /;
  return t.test(e);
}
var kC = 1,
  l0 = 2,
  TC = 3,
  NC = 4,
  xo = 5;
function k9(e, t, n, r, i, a, s, o) {
  var c,
    l = 0,
    f = null,
    u = !1,
    d = !1,
    p = r !== -1,
    h = -1,
    m = C9(rl(e, 0)) && R9(rl(e, e.length - 1));
  if (t || s)
    for (c = 0; c < e.length; l >= 65536 ? (c += 2) : c++) {
      if (((l = rl(e, c)), !jl(l))) return xo;
      (m = m && ow(l, f, o)), (f = l);
    }
  else {
    for (c = 0; c < e.length; l >= 65536 ? (c += 2) : c++) {
      if (((l = rl(e, c)), l === Ul))
        (u = !0),
          p && ((d = d || (c - h - 1 > r && e[h + 1] !== " ")), (h = c));
      else if (!jl(l)) return xo;
      (m = m && ow(l, f, o)), (f = l);
    }
    d = d || (p && c - h - 1 > r && e[h + 1] !== " ");
  }
  return !u && !d
    ? m && !s && !i(e)
      ? kC
      : a === Fl
      ? xo
      : l0
    : n > 9 && RC(e)
    ? xo
    : s
    ? a === Fl
      ? xo
      : l0
    : d
    ? NC
    : TC;
}
function T9(e, t, n, r, i) {
  e.dump = (function () {
    if (t.length === 0) return e.quotingType === Fl ? '""' : "''";
    if (!e.noCompatMode && (E9.indexOf(t) !== -1 || w9.test(t)))
      return e.quotingType === Fl ? '"' + t + '"' : "'" + t + "'";
    var a = e.indent * Math.max(1, n),
      s =
        e.lineWidth === -1
          ? -1
          : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - a),
      o = r || (e.flowLevel > -1 && n >= e.flowLevel);
    function c(l) {
      return $9(e, l);
    }
    switch (k9(t, o, e.indent, s, c, e.quotingType, e.forceQuotes && !r, i)) {
      case kC:
        return t;
      case l0:
        return "'" + t.replace(/'/g, "''") + "'";
      case TC:
        return "|" + cw(t, e.indent) + lw(aw(t, a));
      case NC:
        return ">" + cw(t, e.indent) + lw(aw(N9(t, s), a));
      case xo:
        return '"' + O9(t) + '"';
      default:
        throw new ru("impossible error: invalid scalar style");
    }
  })();
}
function cw(e, t) {
  var n = RC(e) ? String(t) : "",
    r =
      e[e.length - 1] ===
      `
`,
    i =
      r &&
      (e[e.length - 2] ===
        `
` ||
        e ===
          `
`),
    a = i ? "+" : r ? "" : "-";
  return (
    n +
    a +
    `
`
  );
}
function lw(e) {
  return e[e.length - 1] ===
    `
`
    ? e.slice(0, -1)
    : e;
}
function N9(e, t) {
  for (
    var n = /(\n+)([^\n]*)/g,
      r = (function () {
        var l = e.indexOf(`
`);
        return (
          (l = l !== -1 ? l : e.length), (n.lastIndex = l), uw(e.slice(0, l), t)
        );
      })(),
      i =
        e[0] ===
          `
` || e[0] === " ",
      a,
      s;
    (s = n.exec(e));

  ) {
    var o = s[1],
      c = s[2];
    (a = c[0] === " "),
      (r +=
        o +
        (!i && !a && c !== ""
          ? `
`
          : "") +
        uw(c, t)),
      (i = a);
  }
  return r;
}
function uw(e, t) {
  if (e === "" || e[0] === " ") return e;
  for (var n = / [^ ]/g, r, i = 0, a, s = 0, o = 0, c = ""; (r = n.exec(e)); )
    (o = r.index),
      o - i > t &&
        ((a = s > i ? s : o),
        (c +=
          `
` + e.slice(i, a)),
        (i = a + 1)),
      (s = o);
  return (
    (c += `
`),
    e.length - i > t && s > i
      ? (c +=
          e.slice(i, s) +
          `
` +
          e.slice(s + 1))
      : (c += e.slice(i)),
    c.slice(1)
  );
}
function O9(e) {
  for (var t = "", n = 0, r, i = 0; i < e.length; n >= 65536 ? (i += 2) : i++)
    (n = rl(e, i)),
      (r = hr[n]),
      !r && jl(n)
        ? ((t += e[i]), n >= 65536 && (t += e[i + 1]))
        : (t += r || A9(n));
  return t;
}
function P9(e, t, n) {
  var r = "",
    i = e.tag,
    a,
    s,
    o;
  for (a = 0, s = n.length; a < s; a += 1)
    (o = n[a]),
      e.replacer && (o = e.replacer.call(n, String(a), o)),
      (pa(e, t, o, !1, !1) || (typeof o > "u" && pa(e, t, null, !1, !1))) &&
        (r !== "" && (r += "," + (e.condenseFlow ? "" : " ")), (r += e.dump));
  (e.tag = i), (e.dump = "[" + r + "]");
}
function fw(e, t, n, r) {
  var i = "",
    a = e.tag,
    s,
    o,
    c;
  for (s = 0, o = n.length; s < o; s += 1)
    (c = n[s]),
      e.replacer && (c = e.replacer.call(n, String(s), c)),
      (pa(e, t + 1, c, !0, !0, !1, !0) ||
        (typeof c > "u" && pa(e, t + 1, null, !0, !0, !1, !0))) &&
        ((!r || i !== "") && (i += c0(e, t)),
        e.dump && Ul === e.dump.charCodeAt(0) ? (i += "-") : (i += "- "),
        (i += e.dump));
  (e.tag = a), (e.dump = i || "[]");
}
function D9(e, t, n) {
  var r = "",
    i = e.tag,
    a = Object.keys(n),
    s,
    o,
    c,
    l,
    f;
  for (s = 0, o = a.length; s < o; s += 1)
    (f = ""),
      r !== "" && (f += ", "),
      e.condenseFlow && (f += '"'),
      (c = a[s]),
      (l = n[c]),
      e.replacer && (l = e.replacer.call(n, c, l)),
      pa(e, t, c, !1, !1) &&
        (e.dump.length > 1024 && (f += "? "),
        (f +=
          e.dump +
          (e.condenseFlow ? '"' : "") +
          ":" +
          (e.condenseFlow ? "" : " ")),
        pa(e, t, l, !1, !1) && ((f += e.dump), (r += f)));
  (e.tag = i), (e.dump = "{" + r + "}");
}
function L9(e, t, n, r) {
  var i = "",
    a = e.tag,
    s = Object.keys(n),
    o,
    c,
    l,
    f,
    u,
    d;
  if (e.sortKeys === !0) s.sort();
  else if (typeof e.sortKeys == "function") s.sort(e.sortKeys);
  else if (e.sortKeys) throw new ru("sortKeys must be a boolean or a function");
  for (o = 0, c = s.length; o < c; o += 1)
    (d = ""),
      (!r || i !== "") && (d += c0(e, t)),
      (l = s[o]),
      (f = n[l]),
      e.replacer && (f = e.replacer.call(n, l, f)),
      pa(e, t + 1, l, !0, !0, !0) &&
        ((u =
          (e.tag !== null && e.tag !== "?") ||
          (e.dump && e.dump.length > 1024)),
        u && (e.dump && Ul === e.dump.charCodeAt(0) ? (d += "?") : (d += "? ")),
        (d += e.dump),
        u && (d += c0(e, t)),
        pa(e, t + 1, f, !0, u) &&
          (e.dump && Ul === e.dump.charCodeAt(0) ? (d += ":") : (d += ": "),
          (d += e.dump),
          (i += d)));
  (e.tag = a), (e.dump = i || "{}");
}
function dw(e, t, n) {
  var r, i, a, s, o, c;
  for (
    i = n ? e.explicitTypes : e.implicitTypes, a = 0, s = i.length;
    a < s;
    a += 1
  )
    if (
      ((o = i[a]),
      (o.instanceOf || o.predicate) &&
        (!o.instanceOf ||
          (typeof t == "object" && t instanceof o.instanceOf)) &&
        (!o.predicate || o.predicate(t)))
    ) {
      if (
        (n
          ? o.multi && o.representName
            ? (e.tag = o.representName(t))
            : (e.tag = o.tag)
          : (e.tag = "?"),
        o.represent)
      ) {
        if (
          ((c = e.styleMap[o.tag] || o.defaultStyle),
          wC.call(o.represent) === "[object Function]")
        )
          r = o.represent(t, c);
        else if (xC.call(o.represent, c)) r = o.represent[c](t, c);
        else
          throw new ru(
            "!<" + o.tag + '> tag resolver accepts not "' + c + '" style',
          );
        e.dump = r;
      }
      return !0;
    }
  return !1;
}
function pa(e, t, n, r, i, a, s) {
  (e.tag = null), (e.dump = n), dw(e, n, !1) || dw(e, n, !0);
  var o = wC.call(e.dump),
    c = r,
    l;
  r && (r = e.flowLevel < 0 || e.flowLevel > t);
  var f = o === "[object Object]" || o === "[object Array]",
    u,
    d;
  if (
    (f && ((u = e.duplicates.indexOf(n)), (d = u !== -1)),
    ((e.tag !== null && e.tag !== "?") || d || (e.indent !== 2 && t > 0)) &&
      (i = !1),
    d && e.usedDuplicates[u])
  )
    e.dump = "*ref_" + u;
  else {
    if (
      (f && d && !e.usedDuplicates[u] && (e.usedDuplicates[u] = !0),
      o === "[object Object]")
    )
      r && Object.keys(e.dump).length !== 0
        ? (L9(e, t, e.dump, i), d && (e.dump = "&ref_" + u + e.dump))
        : (D9(e, t, e.dump), d && (e.dump = "&ref_" + u + " " + e.dump));
    else if (o === "[object Array]")
      r && e.dump.length !== 0
        ? (e.noArrayIndent && !s && t > 0
            ? fw(e, t - 1, e.dump, i)
            : fw(e, t, e.dump, i),
          d && (e.dump = "&ref_" + u + e.dump))
        : (P9(e, t, e.dump), d && (e.dump = "&ref_" + u + " " + e.dump));
    else if (o === "[object String]") e.tag !== "?" && T9(e, e.dump, t, a, c);
    else {
      if (o === "[object Undefined]") return !1;
      if (e.skipInvalid) return !1;
      throw new ru("unacceptable kind of an object to dump " + o);
    }
    e.tag !== null &&
      e.tag !== "?" &&
      ((l = encodeURI(e.tag[0] === "!" ? e.tag.slice(1) : e.tag).replace(
        /!/g,
        "%21",
      )),
      e.tag[0] === "!"
        ? (l = "!" + l)
        : l.slice(0, 18) === "tag:yaml.org,2002:"
        ? (l = "!!" + l.slice(18))
        : (l = "!<" + l + ">"),
      (e.dump = l + " " + e.dump));
  }
  return !0;
}
function B9(e, t) {
  var n = [],
    r = [],
    i,
    a;
  for (u0(e, n, r), i = 0, a = r.length; i < a; i += 1)
    t.duplicates.push(n[r[i]]);
  t.usedDuplicates = new Array(a);
}
function u0(e, t, n) {
  var r, i, a;
  if (e !== null && typeof e == "object")
    if (((i = t.indexOf(e)), i !== -1)) n.indexOf(i) === -1 && n.push(i);
    else if ((t.push(e), Array.isArray(e)))
      for (i = 0, a = e.length; i < a; i += 1) u0(e[i], t, n);
    else
      for (r = Object.keys(e), i = 0, a = r.length; i < a; i += 1)
        u0(e[r[i]], t, n);
}
function U9(e, t) {
  t = t || {};
  var n = new I9(t);
  n.noRefs || B9(e, n);
  var r = e;
  return (
    n.replacer && (r = n.replacer.call({ "": r }, "", r)),
    pa(n, 0, r, !0, !0)
      ? n.dump +
        `
`
      : ""
  );
}
EC.dump = U9;
var OC = jv,
  F9 = EC;
function Wv(e, t) {
  return function () {
    throw new Error(
      "Function yaml." +
        e +
        " is removed in js-yaml 4. Use yaml." +
        t +
        " instead, which is now safe by default.",
    );
  };
}
ar.Type = Sr;
ar.Schema = W2;
ar.FAILSAFE_SCHEMA = Y2;
ar.JSON_SCHEMA = nC;
ar.CORE_SCHEMA = rC;
ar.DEFAULT_SCHEMA = Hv;
ar.load = OC.load;
ar.loadAll = OC.loadAll;
ar.dump = F9.dump;
ar.YAMLException = nu;
ar.types = {
  binary: cC,
  float: tC,
  map: V2,
  null: X2,
  pairs: uC,
  set: fC,
  timestamp: sC,
  bool: J2,
  int: Z2,
  merge: oC,
  omap: lC,
  seq: K2,
  str: z2,
};
ar.safeLoad = Wv("safeLoad", "load");
ar.safeLoadAll = Wv("safeLoadAll", "loadAll");
ar.safeDump = Wv("safeDump", "dump");
var lp = {};
Object.defineProperty(lp, "__esModule", { value: !0 });
lp.Lazy = void 0;
class j9 {
  constructor(t) {
    (this._value = null), (this.creator = t);
  }
  get hasValue() {
    return this.creator == null;
  }
  get value() {
    if (this.creator == null) return this._value;
    const t = this.creator();
    return (this.value = t), t;
  }
  set value(t) {
    (this._value = t), (this.creator = null);
  }
}
lp.Lazy = j9;
var f0 = { exports: {} };
const M9 = "2.0.0",
  PC = 256,
  H9 = Number.MAX_SAFE_INTEGER || 9007199254740991,
  q9 = 16,
  G9 = PC - 6,
  Q9 = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease",
  ];
var up = {
  MAX_LENGTH: PC,
  MAX_SAFE_COMPONENT_LENGTH: q9,
  MAX_SAFE_BUILD_LENGTH: G9,
  MAX_SAFE_INTEGER: H9,
  RELEASE_TYPES: Q9,
  SEMVER_SPEC_VERSION: M9,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2,
};
const W9 =
  typeof process == "object" &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
    ? (...e) => console.error("SEMVER", ...e)
    : () => {};
var fp = W9;
(function (e, t) {
  const {
      MAX_SAFE_COMPONENT_LENGTH: n,
      MAX_SAFE_BUILD_LENGTH: r,
      MAX_LENGTH: i,
    } = up,
    a = fp;
  t = e.exports = {};
  const s = (t.re = []),
    o = (t.safeRe = []),
    c = (t.src = []),
    l = (t.t = {});
  let f = 0;
  const u = "[a-zA-Z0-9-]",
    d = [
      ["\\s", 1],
      ["\\d", i],
      [u, r],
    ],
    p = (m) => {
      for (const [g, v] of d)
        m = m
          .split(`${g}*`)
          .join(`${g}{0,${v}}`)
          .split(`${g}+`)
          .join(`${g}{1,${v}}`);
      return m;
    },
    h = (m, g, v) => {
      const y = p(g),
        _ = f++;
      a(m, _, g),
        (l[m] = _),
        (c[_] = g),
        (s[_] = new RegExp(g, v ? "g" : void 0)),
        (o[_] = new RegExp(y, v ? "g" : void 0));
    };
  h("NUMERICIDENTIFIER", "0|[1-9]\\d*"),
    h("NUMERICIDENTIFIERLOOSE", "\\d+"),
    h("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${u}*`),
    h(
      "MAINVERSION",
      `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${
        c[l.NUMERICIDENTIFIER]
      })`,
    ),
    h(
      "MAINVERSIONLOOSE",
      `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${
        c[l.NUMERICIDENTIFIERLOOSE]
      })`,
    ),
    h(
      "PRERELEASEIDENTIFIER",
      `(?:${c[l.NUMERICIDENTIFIER]}|${c[l.NONNUMERICIDENTIFIER]})`,
    ),
    h(
      "PRERELEASEIDENTIFIERLOOSE",
      `(?:${c[l.NUMERICIDENTIFIERLOOSE]}|${c[l.NONNUMERICIDENTIFIER]})`,
    ),
    h(
      "PRERELEASE",
      `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`,
    ),
    h(
      "PRERELEASELOOSE",
      `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${
        c[l.PRERELEASEIDENTIFIERLOOSE]
      })*))`,
    ),
    h("BUILDIDENTIFIER", `${u}+`),
    h(
      "BUILD",
      `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`,
    ),
    h("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`),
    h("FULL", `^${c[l.FULLPLAIN]}$`),
    h(
      "LOOSEPLAIN",
      `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`,
    ),
    h("LOOSE", `^${c[l.LOOSEPLAIN]}$`),
    h("GTLT", "((?:<|>)?=?)"),
    h("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
    h("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`),
    h(
      "XRANGEPLAIN",
      `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${
        c[l.XRANGEIDENTIFIER]
      })(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${
        c[l.BUILD]
      }?)?)?`,
    ),
    h(
      "XRANGEPLAINLOOSE",
      `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${
        c[l.XRANGEIDENTIFIERLOOSE]
      })(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${
        c[l.BUILD]
      }?)?)?`,
    ),
    h("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`),
    h("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`),
    h(
      "COERCE",
      `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`,
    ),
    h("COERCERTL", c[l.COERCE], !0),
    h("LONETILDE", "(?:~>?)"),
    h("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0),
    (t.tildeTrimReplace = "$1~"),
    h("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`),
    h("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`),
    h("LONECARET", "(?:\\^)"),
    h("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0),
    (t.caretTrimReplace = "$1^"),
    h("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`),
    h("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`),
    h("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`),
    h("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`),
    h(
      "COMPARATORTRIM",
      `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`,
      !0,
    ),
    (t.comparatorTrimReplace = "$1$2$3"),
    h(
      "HYPHENRANGE",
      `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`,
    ),
    h(
      "HYPHENRANGELOOSE",
      `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`,
    ),
    h("STAR", "(<|>)?=?\\s*\\*"),
    h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"),
    h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(f0, f0.exports);
var iu = f0.exports;
const z9 = Object.freeze({ loose: !0 }),
  K9 = Object.freeze({}),
  V9 = (e) => (e ? (typeof e != "object" ? z9 : e) : K9);
var zv = V9;
const pw = /^[0-9]+$/,
  DC = (e, t) => {
    const n = pw.test(e),
      r = pw.test(t);
    return (
      n && r && ((e = +e), (t = +t)),
      e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1
    );
  },
  Y9 = (e, t) => DC(t, e);
var LC = { compareIdentifiers: DC, rcompareIdentifiers: Y9 };
const of = fp,
  { MAX_LENGTH: hw, MAX_SAFE_INTEGER: cf } = up,
  { safeRe: mw, t: gw } = iu,
  X9 = zv,
  { compareIdentifiers: so } = LC;
let J9 = class ki {
  constructor(t, n) {
    if (((n = X9(n)), t instanceof ki)) {
      if (
        t.loose === !!n.loose &&
        t.includePrerelease === !!n.includePrerelease
      )
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(
        `Invalid version. Must be a string. Got type "${typeof t}".`,
      );
    if (t.length > hw)
      throw new TypeError(`version is longer than ${hw} characters`);
    of("SemVer", t, n),
      (this.options = n),
      (this.loose = !!n.loose),
      (this.includePrerelease = !!n.includePrerelease);
    const r = t.trim().match(n.loose ? mw[gw.LOOSE] : mw[gw.FULL]);
    if (!r) throw new TypeError(`Invalid Version: ${t}`);
    if (
      ((this.raw = t),
      (this.major = +r[1]),
      (this.minor = +r[2]),
      (this.patch = +r[3]),
      this.major > cf || this.major < 0)
    )
      throw new TypeError("Invalid major version");
    if (this.minor > cf || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > cf || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4]
      ? (this.prerelease = r[4].split(".").map((i) => {
          if (/^[0-9]+$/.test(i)) {
            const a = +i;
            if (a >= 0 && a < cf) return a;
          }
          return i;
        }))
      : (this.prerelease = []),
      (this.build = r[5] ? r[5].split(".") : []),
      this.format();
  }
  format() {
    return (
      (this.version = `${this.major}.${this.minor}.${this.patch}`),
      this.prerelease.length &&
        (this.version += `-${this.prerelease.join(".")}`),
      this.version
    );
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (
      (of("SemVer.compare", this.version, this.options, t), !(t instanceof ki))
    ) {
      if (typeof t == "string" && t === this.version) return 0;
      t = new ki(t, this.options);
    }
    return t.version === this.version
      ? 0
      : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return (
      t instanceof ki || (t = new ki(t, this.options)),
      so(this.major, t.major) ||
        so(this.minor, t.minor) ||
        so(this.patch, t.patch)
    );
  }
  comparePre(t) {
    if (
      (t instanceof ki || (t = new ki(t, this.options)),
      this.prerelease.length && !t.prerelease.length)
    )
      return -1;
    if (!this.prerelease.length && t.prerelease.length) return 1;
    if (!this.prerelease.length && !t.prerelease.length) return 0;
    let n = 0;
    do {
      const r = this.prerelease[n],
        i = t.prerelease[n];
      if ((of("prerelease compare", n, r, i), r === void 0 && i === void 0))
        return 0;
      if (i === void 0) return 1;
      if (r === void 0) return -1;
      if (r === i) continue;
      return so(r, i);
    } while (++n);
  }
  compareBuild(t) {
    t instanceof ki || (t = new ki(t, this.options));
    let n = 0;
    do {
      const r = this.build[n],
        i = t.build[n];
      if ((of("prerelease compare", n, r, i), r === void 0 && i === void 0))
        return 0;
      if (i === void 0) return 1;
      if (r === void 0) return -1;
      if (r === i) continue;
      return so(r, i);
    } while (++n);
  }
  inc(t, n, r) {
    switch (t) {
      case "premajor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          (this.minor = 0),
          this.major++,
          this.inc("pre", n, r);
        break;
      case "preminor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          this.minor++,
          this.inc("pre", n, r);
        break;
      case "prepatch":
        (this.prerelease.length = 0),
          this.inc("patch", n, r),
          this.inc("pre", n, r);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", n, r),
          this.inc("pre", n, r);
        break;
      case "major":
        (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) &&
          this.major++,
          (this.minor = 0),
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, (this.prerelease = []);
        break;
      case "pre": {
        const i = Number(r) ? 1 : 0;
        if (!n && r === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0) this.prerelease = [i];
        else {
          let a = this.prerelease.length;
          for (; --a >= 0; )
            typeof this.prerelease[a] == "number" &&
              (this.prerelease[a]++, (a = -2));
          if (a === -1) {
            if (n === this.prerelease.join(".") && r === !1)
              throw new Error(
                "invalid increment argument: identifier already exists",
              );
            this.prerelease.push(i);
          }
        }
        if (n) {
          let a = [n, i];
          r === !1 && (a = [n]),
            so(this.prerelease[0], n) === 0
              ? isNaN(this.prerelease[1]) && (this.prerelease = a)
              : (this.prerelease = a);
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return (
      (this.raw = this.format()),
      this.build.length && (this.raw += `+${this.build.join(".")}`),
      this
    );
  }
};
var Ir = J9;
const vw = Ir,
  Z9 = (e, t, n = !1) => {
    if (e instanceof vw) return e;
    try {
      return new vw(e, t);
    } catch (r) {
      if (!n) return null;
      throw r;
    }
  };
var wc = Z9;
const ej = wc,
  tj = (e, t) => {
    const n = ej(e, t);
    return n ? n.version : null;
  };
var nj = tj;
const rj = wc,
  ij = (e, t) => {
    const n = rj(e.trim().replace(/^[=v]+/, ""), t);
    return n ? n.version : null;
  };
var aj = ij;
const yw = Ir,
  sj = (e, t, n, r, i) => {
    typeof n == "string" && ((i = r), (r = n), (n = void 0));
    try {
      return new yw(e instanceof yw ? e.version : e, n).inc(t, r, i).version;
    } catch {
      return null;
    }
  };
var oj = sj;
const bw = wc,
  cj = (e, t) => {
    const n = bw(e, null, !0),
      r = bw(t, null, !0),
      i = n.compare(r);
    if (i === 0) return null;
    const a = i > 0,
      s = a ? n : r,
      o = a ? r : n,
      c = !!s.prerelease.length;
    if (!!o.prerelease.length && !c)
      return !o.patch && !o.minor
        ? "major"
        : s.patch
        ? "patch"
        : s.minor
        ? "minor"
        : "major";
    const f = c ? "pre" : "";
    return n.major !== r.major
      ? f + "major"
      : n.minor !== r.minor
      ? f + "minor"
      : n.patch !== r.patch
      ? f + "patch"
      : "prerelease";
  };
var lj = cj;
const uj = Ir,
  fj = (e, t) => new uj(e, t).major;
var dj = fj;
const pj = Ir,
  hj = (e, t) => new pj(e, t).minor;
var mj = hj;
const gj = Ir,
  vj = (e, t) => new gj(e, t).patch;
var yj = vj;
const bj = wc,
  _j = (e, t) => {
    const n = bj(e, t);
    return n && n.prerelease.length ? n.prerelease : null;
  };
var Ej = _j;
const _w = Ir,
  wj = (e, t, n) => new _w(e, n).compare(new _w(t, n));
var Si = wj;
const xj = Si,
  Aj = (e, t, n) => xj(t, e, n);
var Sj = Aj;
const Ij = Si,
  $j = (e, t) => Ij(e, t, !0);
var Cj = $j;
const Ew = Ir,
  Rj = (e, t, n) => {
    const r = new Ew(e, n),
      i = new Ew(t, n);
    return r.compare(i) || r.compareBuild(i);
  };
var Kv = Rj;
const kj = Kv,
  Tj = (e, t) => e.sort((n, r) => kj(n, r, t));
var Nj = Tj;
const Oj = Kv,
  Pj = (e, t) => e.sort((n, r) => Oj(r, n, t));
var Dj = Pj;
const Lj = Si,
  Bj = (e, t, n) => Lj(e, t, n) > 0;
var dp = Bj;
const Uj = Si,
  Fj = (e, t, n) => Uj(e, t, n) < 0;
var Vv = Fj;
const jj = Si,
  Mj = (e, t, n) => jj(e, t, n) === 0;
var BC = Mj;
const Hj = Si,
  qj = (e, t, n) => Hj(e, t, n) !== 0;
var UC = qj;
const Gj = Si,
  Qj = (e, t, n) => Gj(e, t, n) >= 0;
var Yv = Qj;
const Wj = Si,
  zj = (e, t, n) => Wj(e, t, n) <= 0;
var Xv = zj;
const Kj = BC,
  Vj = UC,
  Yj = dp,
  Xj = Yv,
  Jj = Vv,
  Zj = Xv,
  eM = (e, t, n, r) => {
    switch (t) {
      case "===":
        return (
          typeof e == "object" && (e = e.version),
          typeof n == "object" && (n = n.version),
          e === n
        );
      case "!==":
        return (
          typeof e == "object" && (e = e.version),
          typeof n == "object" && (n = n.version),
          e !== n
        );
      case "":
      case "=":
      case "==":
        return Kj(e, n, r);
      case "!=":
        return Vj(e, n, r);
      case ">":
        return Yj(e, n, r);
      case ">=":
        return Xj(e, n, r);
      case "<":
        return Jj(e, n, r);
      case "<=":
        return Zj(e, n, r);
      default:
        throw new TypeError(`Invalid operator: ${t}`);
    }
  };
var FC = eM;
const tM = Ir,
  nM = wc,
  { safeRe: lf, t: uf } = iu,
  rM = (e, t) => {
    if (e instanceof tM) return e;
    if ((typeof e == "number" && (e = String(e)), typeof e != "string"))
      return null;
    t = t || {};
    let n = null;
    if (!t.rtl) n = e.match(lf[uf.COERCE]);
    else {
      let r;
      for (
        ;
        (r = lf[uf.COERCERTL].exec(e)) &&
        (!n || n.index + n[0].length !== e.length);

      )
        (!n || r.index + r[0].length !== n.index + n[0].length) && (n = r),
          (lf[uf.COERCERTL].lastIndex = r.index + r[1].length + r[2].length);
      lf[uf.COERCERTL].lastIndex = -1;
    }
    return n === null ? null : nM(`${n[2]}.${n[3] || "0"}.${n[4] || "0"}`, t);
  };
var iM = rM,
  um,
  ww;
function aM() {
  return (
    ww ||
      ((ww = 1),
      (um = function (e) {
        e.prototype[Symbol.iterator] = function* () {
          for (let t = this.head; t; t = t.next) yield t.value;
        };
      })),
    um
  );
}
var sM = Mt;
Mt.Node = Bs;
Mt.create = Mt;
function Mt(e) {
  var t = this;
  if (
    (t instanceof Mt || (t = new Mt()),
    (t.tail = null),
    (t.head = null),
    (t.length = 0),
    e && typeof e.forEach == "function")
  )
    e.forEach(function (i) {
      t.push(i);
    });
  else if (arguments.length > 0)
    for (var n = 0, r = arguments.length; n < r; n++) t.push(arguments[n]);
  return t;
}
Mt.prototype.removeNode = function (e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next,
    n = e.prev;
  return (
    t && (t.prev = n),
    n && (n.next = t),
    e === this.head && (this.head = t),
    e === this.tail && (this.tail = n),
    e.list.length--,
    (e.next = null),
    (e.prev = null),
    (e.list = null),
    t
  );
};
Mt.prototype.unshiftNode = function (e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    (e.list = this),
      (e.next = t),
      t && (t.prev = e),
      (this.head = e),
      this.tail || (this.tail = e),
      this.length++;
  }
};
Mt.prototype.pushNode = function (e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    (e.list = this),
      (e.prev = t),
      t && (t.next = e),
      (this.tail = e),
      this.head || (this.head = e),
      this.length++;
  }
};
Mt.prototype.push = function () {
  for (var e = 0, t = arguments.length; e < t; e++) cM(this, arguments[e]);
  return this.length;
};
Mt.prototype.unshift = function () {
  for (var e = 0, t = arguments.length; e < t; e++) lM(this, arguments[e]);
  return this.length;
};
Mt.prototype.pop = function () {
  if (this.tail) {
    var e = this.tail.value;
    return (
      (this.tail = this.tail.prev),
      this.tail ? (this.tail.next = null) : (this.head = null),
      this.length--,
      e
    );
  }
};
Mt.prototype.shift = function () {
  if (this.head) {
    var e = this.head.value;
    return (
      (this.head = this.head.next),
      this.head ? (this.head.prev = null) : (this.tail = null),
      this.length--,
      e
    );
  }
};
Mt.prototype.forEach = function (e, t) {
  t = t || this;
  for (var n = this.head, r = 0; n !== null; r++)
    e.call(t, n.value, r, this), (n = n.next);
};
Mt.prototype.forEachReverse = function (e, t) {
  t = t || this;
  for (var n = this.tail, r = this.length - 1; n !== null; r--)
    e.call(t, n.value, r, this), (n = n.prev);
};
Mt.prototype.get = function (e) {
  for (var t = 0, n = this.head; n !== null && t < e; t++) n = n.next;
  if (t === e && n !== null) return n.value;
};
Mt.prototype.getReverse = function (e) {
  for (var t = 0, n = this.tail; n !== null && t < e; t++) n = n.prev;
  if (t === e && n !== null) return n.value;
};
Mt.prototype.map = function (e, t) {
  t = t || this;
  for (var n = new Mt(), r = this.head; r !== null; )
    n.push(e.call(t, r.value, this)), (r = r.next);
  return n;
};
Mt.prototype.mapReverse = function (e, t) {
  t = t || this;
  for (var n = new Mt(), r = this.tail; r !== null; )
    n.push(e.call(t, r.value, this)), (r = r.prev);
  return n;
};
Mt.prototype.reduce = function (e, t) {
  var n,
    r = this.head;
  if (arguments.length > 1) n = t;
  else if (this.head) (r = this.head.next), (n = this.head.value);
  else throw new TypeError("Reduce of empty list with no initial value");
  for (var i = 0; r !== null; i++) (n = e(n, r.value, i)), (r = r.next);
  return n;
};
Mt.prototype.reduceReverse = function (e, t) {
  var n,
    r = this.tail;
  if (arguments.length > 1) n = t;
  else if (this.tail) (r = this.tail.prev), (n = this.tail.value);
  else throw new TypeError("Reduce of empty list with no initial value");
  for (var i = this.length - 1; r !== null; i--)
    (n = e(n, r.value, i)), (r = r.prev);
  return n;
};
Mt.prototype.toArray = function () {
  for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++)
    (e[t] = n.value), (n = n.next);
  return e;
};
Mt.prototype.toArrayReverse = function () {
  for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++)
    (e[t] = n.value), (n = n.prev);
  return e;
};
Mt.prototype.slice = function (e, t) {
  (t = t || this.length),
    t < 0 && (t += this.length),
    (e = e || 0),
    e < 0 && (e += this.length);
  var n = new Mt();
  if (t < e || t < 0) return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var r = 0, i = this.head; i !== null && r < e; r++) i = i.next;
  for (; i !== null && r < t; r++, i = i.next) n.push(i.value);
  return n;
};
Mt.prototype.sliceReverse = function (e, t) {
  (t = t || this.length),
    t < 0 && (t += this.length),
    (e = e || 0),
    e < 0 && (e += this.length);
  var n = new Mt();
  if (t < e || t < 0) return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var r = this.length, i = this.tail; i !== null && r > t; r--) i = i.prev;
  for (; i !== null && r > e; r--, i = i.prev) n.push(i.value);
  return n;
};
Mt.prototype.splice = function (e, t, ...n) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var r = 0, i = this.head; i !== null && r < e; r++) i = i.next;
  for (var a = [], r = 0; i && r < t; r++)
    a.push(i.value), (i = this.removeNode(i));
  i === null && (i = this.tail),
    i !== this.head && i !== this.tail && (i = i.prev);
  for (var r = 0; r < n.length; r++) i = oM(this, i, n[r]);
  return a;
};
Mt.prototype.reverse = function () {
  for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
    var r = n.prev;
    (n.prev = n.next), (n.next = r);
  }
  return (this.head = t), (this.tail = e), this;
};
function oM(e, t, n) {
  var r = t === e.head ? new Bs(n, null, t, e) : new Bs(n, t, t.next, e);
  return (
    r.next === null && (e.tail = r),
    r.prev === null && (e.head = r),
    e.length++,
    r
  );
}
function cM(e, t) {
  (e.tail = new Bs(t, e.tail, null, e)),
    e.head || (e.head = e.tail),
    e.length++;
}
function lM(e, t) {
  (e.head = new Bs(t, null, e.head, e)),
    e.tail || (e.tail = e.head),
    e.length++;
}
function Bs(e, t, n, r) {
  if (!(this instanceof Bs)) return new Bs(e, t, n, r);
  (this.list = r),
    (this.value = e),
    t ? ((t.next = this), (this.prev = t)) : (this.prev = null),
    n ? ((n.prev = this), (this.next = n)) : (this.next = null);
}
try {
  aM()(Mt);
} catch {}
const uM = sM,
  gs = Symbol("max"),
  ra = Symbol("length"),
  oo = Symbol("lengthCalculator"),
  hl = Symbol("allowStale"),
  Is = Symbol("maxAge"),
  Zi = Symbol("dispose"),
  xw = Symbol("noDisposeOnSet"),
  Gn = Symbol("lruList"),
  li = Symbol("cache"),
  jC = Symbol("updateAgeOnGet"),
  fm = () => 1;
let fM = class {
  constructor(t) {
    if (
      (typeof t == "number" && (t = { max: t }),
      t || (t = {}),
      t.max && (typeof t.max != "number" || t.max < 0))
    )
      throw new TypeError("max must be a non-negative number");
    this[gs] = t.max || 1 / 0;
    const n = t.length || fm;
    if (
      ((this[oo] = typeof n != "function" ? fm : n),
      (this[hl] = t.stale || !1),
      t.maxAge && typeof t.maxAge != "number")
    )
      throw new TypeError("maxAge must be a number");
    (this[Is] = t.maxAge || 0),
      (this[Zi] = t.dispose),
      (this[xw] = t.noDisposeOnSet || !1),
      (this[jC] = t.updateAgeOnGet || !1),
      this.reset();
  }
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    (this[gs] = t || 1 / 0), Lc(this);
  }
  get max() {
    return this[gs];
  }
  set allowStale(t) {
    this[hl] = !!t;
  }
  get allowStale() {
    return this[hl];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    (this[Is] = t), Lc(this);
  }
  get maxAge() {
    return this[Is];
  }
  set lengthCalculator(t) {
    typeof t != "function" && (t = fm),
      t !== this[oo] &&
        ((this[oo] = t),
        (this[ra] = 0),
        this[Gn].forEach((n) => {
          (n.length = this[oo](n.value, n.key)), (this[ra] += n.length);
        })),
      Lc(this);
  }
  get lengthCalculator() {
    return this[oo];
  }
  get length() {
    return this[ra];
  }
  get itemCount() {
    return this[Gn].length;
  }
  rforEach(t, n) {
    n = n || this;
    for (let r = this[Gn].tail; r !== null; ) {
      const i = r.prev;
      Aw(this, t, r, n), (r = i);
    }
  }
  forEach(t, n) {
    n = n || this;
    for (let r = this[Gn].head; r !== null; ) {
      const i = r.next;
      Aw(this, t, r, n), (r = i);
    }
  }
  keys() {
    return this[Gn].toArray().map((t) => t.key);
  }
  values() {
    return this[Gn].toArray().map((t) => t.value);
  }
  reset() {
    this[Zi] &&
      this[Gn] &&
      this[Gn].length &&
      this[Gn].forEach((t) => this[Zi](t.key, t.value)),
      (this[li] = new Map()),
      (this[Gn] = new uM()),
      (this[ra] = 0);
  }
  dump() {
    return this[Gn].map((t) =>
      vd(this, t) ? !1 : { k: t.key, v: t.value, e: t.now + (t.maxAge || 0) },
    )
      .toArray()
      .filter((t) => t);
  }
  dumpLru() {
    return this[Gn];
  }
  set(t, n, r) {
    if (((r = r || this[Is]), r && typeof r != "number"))
      throw new TypeError("maxAge must be a number");
    const i = r ? Date.now() : 0,
      a = this[oo](n, t);
    if (this[li].has(t)) {
      if (a > this[gs]) return Lo(this, this[li].get(t)), !1;
      const c = this[li].get(t).value;
      return (
        this[Zi] && (this[xw] || this[Zi](t, c.value)),
        (c.now = i),
        (c.maxAge = r),
        (c.value = n),
        (this[ra] += a - c.length),
        (c.length = a),
        this.get(t),
        Lc(this),
        !0
      );
    }
    const s = new dM(t, n, a, i, r);
    return s.length > this[gs]
      ? (this[Zi] && this[Zi](t, n), !1)
      : ((this[ra] += s.length),
        this[Gn].unshift(s),
        this[li].set(t, this[Gn].head),
        Lc(this),
        !0);
  }
  has(t) {
    if (!this[li].has(t)) return !1;
    const n = this[li].get(t).value;
    return !vd(this, n);
  }
  get(t) {
    return dm(this, t, !0);
  }
  peek(t) {
    return dm(this, t, !1);
  }
  pop() {
    const t = this[Gn].tail;
    return t ? (Lo(this, t), t.value) : null;
  }
  del(t) {
    Lo(this, this[li].get(t));
  }
  load(t) {
    this.reset();
    const n = Date.now();
    for (let r = t.length - 1; r >= 0; r--) {
      const i = t[r],
        a = i.e || 0;
      if (a === 0) this.set(i.k, i.v);
      else {
        const s = a - n;
        s > 0 && this.set(i.k, i.v, s);
      }
    }
  }
  prune() {
    this[li].forEach((t, n) => dm(this, n, !1));
  }
};
const dm = (e, t, n) => {
    const r = e[li].get(t);
    if (r) {
      const i = r.value;
      if (vd(e, i)) {
        if ((Lo(e, r), !e[hl])) return;
      } else n && (e[jC] && (r.value.now = Date.now()), e[Gn].unshiftNode(r));
      return i.value;
    }
  },
  vd = (e, t) => {
    if (!t || (!t.maxAge && !e[Is])) return !1;
    const n = Date.now() - t.now;
    return t.maxAge ? n > t.maxAge : e[Is] && n > e[Is];
  },
  Lc = (e) => {
    if (e[ra] > e[gs])
      for (let t = e[Gn].tail; e[ra] > e[gs] && t !== null; ) {
        const n = t.prev;
        Lo(e, t), (t = n);
      }
  },
  Lo = (e, t) => {
    if (t) {
      const n = t.value;
      e[Zi] && e[Zi](n.key, n.value),
        (e[ra] -= n.length),
        e[li].delete(n.key),
        e[Gn].removeNode(t);
    }
  };
let dM = class {
  constructor(t, n, r, i, a) {
    (this.key = t),
      (this.value = n),
      (this.length = r),
      (this.now = i),
      (this.maxAge = a || 0);
  }
};
const Aw = (e, t, n, r) => {
  let i = n.value;
  vd(e, i) && (Lo(e, n), e[hl] || (i = void 0)),
    i && t.call(r, i.value, i.key, e);
};
var pM = fM,
  pm,
  Sw;
function Ii() {
  if (Sw) return pm;
  Sw = 1;
  class e {
    constructor(q, J) {
      if (((J = r(J)), q instanceof e))
        return q.loose === !!J.loose &&
          q.includePrerelease === !!J.includePrerelease
          ? q
          : new e(q.raw, J);
      if (q instanceof i)
        return (this.raw = q.value), (this.set = [[q]]), this.format(), this;
      if (
        ((this.options = J),
        (this.loose = !!J.loose),
        (this.includePrerelease = !!J.includePrerelease),
        (this.raw = q.trim().split(/\s+/).join(" ")),
        (this.set = this.raw
          .split("||")
          .map((Z) => this.parseRange(Z.trim()))
          .filter((Z) => Z.length)),
        !this.set.length)
      )
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const Z = this.set[0];
        if (
          ((this.set = this.set.filter((z) => !h(z[0]))), this.set.length === 0)
        )
          this.set = [Z];
        else if (this.set.length > 1) {
          for (const z of this.set)
            if (z.length === 1 && m(z[0])) {
              this.set = [z];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return (
        (this.range = this.set
          .map((q) => q.join(" ").trim())
          .join("||")
          .trim()),
        this.range
      );
    }
    toString() {
      return this.range;
    }
    parseRange(q) {
      const Z =
          ((this.options.includePrerelease && d) | (this.options.loose && p)) +
          ":" +
          q,
        z = n.get(Z);
      if (z) return z;
      const U = this.options.loose,
        G = U ? o[c.HYPHENRANGELOOSE] : o[c.HYPHENRANGE];
      (q = q.replace(G, Q(this.options.includePrerelease))),
        a("hyphen replace", q),
        (q = q.replace(o[c.COMPARATORTRIM], l)),
        a("comparator trim", q),
        (q = q.replace(o[c.TILDETRIM], f)),
        a("tilde trim", q),
        (q = q.replace(o[c.CARETTRIM], u)),
        a("caret trim", q);
      let L = q
        .split(" ")
        .map((x) => v(x, this.options))
        .join(" ")
        .split(/\s+/)
        .map((x) => O(x, this.options));
      U &&
        (L = L.filter(
          (x) => (
            a("loose invalid filter", x, this.options),
            !!x.match(o[c.COMPARATORLOOSE])
          ),
        )),
        a("range list", L);
      const k = new Map(),
        W = L.map((x) => new i(x, this.options));
      for (const x of W) {
        if (h(x)) return [x];
        k.set(x.value, x);
      }
      k.size > 1 && k.has("") && k.delete("");
      const F = [...k.values()];
      return n.set(Z, F), F;
    }
    intersects(q, J) {
      if (!(q instanceof e)) throw new TypeError("a Range is required");
      return this.set.some(
        (Z) =>
          g(Z, J) &&
          q.set.some(
            (z) =>
              g(z, J) && Z.every((U) => z.every((G) => U.intersects(G, J))),
          ),
      );
    }
    test(q) {
      if (!q) return !1;
      if (typeof q == "string")
        try {
          q = new s(q, this.options);
        } catch {
          return !1;
        }
      for (let J = 0; J < this.set.length; J++)
        if (j(this.set[J], q, this.options)) return !0;
      return !1;
    }
  }
  pm = e;
  const t = pM,
    n = new t({ max: 1e3 }),
    r = zv,
    i = pp(),
    a = fp,
    s = Ir,
    {
      safeRe: o,
      t: c,
      comparatorTrimReplace: l,
      tildeTrimReplace: f,
      caretTrimReplace: u,
    } = iu,
    { FLAG_INCLUDE_PRERELEASE: d, FLAG_LOOSE: p } = up,
    h = (H) => H.value === "<0.0.0-0",
    m = (H) => H.value === "",
    g = (H, q) => {
      let J = !0;
      const Z = H.slice();
      let z = Z.pop();
      for (; J && Z.length; )
        (J = Z.every((U) => z.intersects(U, q))), (z = Z.pop());
      return J;
    },
    v = (H, q) => (
      a("comp", H, q),
      (H = R(H, q)),
      a("caret", H),
      (H = _(H, q)),
      a("tildes", H),
      (H = I(H, q)),
      a("xrange", H),
      (H = w(H, q)),
      a("stars", H),
      H
    ),
    y = (H) => !H || H.toLowerCase() === "x" || H === "*",
    _ = (H, q) =>
      H.trim()
        .split(/\s+/)
        .map((J) => E(J, q))
        .join(" "),
    E = (H, q) => {
      const J = q.loose ? o[c.TILDELOOSE] : o[c.TILDE];
      return H.replace(J, (Z, z, U, G, L) => {
        a("tilde", H, Z, z, U, G, L);
        let k;
        return (
          y(z)
            ? (k = "")
            : y(U)
            ? (k = `>=${z}.0.0 <${+z + 1}.0.0-0`)
            : y(G)
            ? (k = `>=${z}.${U}.0 <${z}.${+U + 1}.0-0`)
            : L
            ? (a("replaceTilde pr", L),
              (k = `>=${z}.${U}.${G}-${L} <${z}.${+U + 1}.0-0`))
            : (k = `>=${z}.${U}.${G} <${z}.${+U + 1}.0-0`),
          a("tilde return", k),
          k
        );
      });
    },
    R = (H, q) =>
      H.trim()
        .split(/\s+/)
        .map((J) => A(J, q))
        .join(" "),
    A = (H, q) => {
      a("caret", H, q);
      const J = q.loose ? o[c.CARETLOOSE] : o[c.CARET],
        Z = q.includePrerelease ? "-0" : "";
      return H.replace(J, (z, U, G, L, k) => {
        a("caret", H, z, U, G, L, k);
        let W;
        return (
          y(U)
            ? (W = "")
            : y(G)
            ? (W = `>=${U}.0.0${Z} <${+U + 1}.0.0-0`)
            : y(L)
            ? U === "0"
              ? (W = `>=${U}.${G}.0${Z} <${U}.${+G + 1}.0-0`)
              : (W = `>=${U}.${G}.0${Z} <${+U + 1}.0.0-0`)
            : k
            ? (a("replaceCaret pr", k),
              U === "0"
                ? G === "0"
                  ? (W = `>=${U}.${G}.${L}-${k} <${U}.${G}.${+L + 1}-0`)
                  : (W = `>=${U}.${G}.${L}-${k} <${U}.${+G + 1}.0-0`)
                : (W = `>=${U}.${G}.${L}-${k} <${+U + 1}.0.0-0`))
            : (a("no pr"),
              U === "0"
                ? G === "0"
                  ? (W = `>=${U}.${G}.${L}${Z} <${U}.${G}.${+L + 1}-0`)
                  : (W = `>=${U}.${G}.${L}${Z} <${U}.${+G + 1}.0-0`)
                : (W = `>=${U}.${G}.${L} <${+U + 1}.0.0-0`)),
          a("caret return", W),
          W
        );
      });
    },
    I = (H, q) => (
      a("replaceXRanges", H, q),
      H.split(/\s+/)
        .map((J) => S(J, q))
        .join(" ")
    ),
    S = (H, q) => {
      H = H.trim();
      const J = q.loose ? o[c.XRANGELOOSE] : o[c.XRANGE];
      return H.replace(J, (Z, z, U, G, L, k) => {
        a("xRange", H, Z, z, U, G, L, k);
        const W = y(U),
          F = W || y(G),
          x = F || y(L),
          T = x;
        return (
          z === "=" && T && (z = ""),
          (k = q.includePrerelease ? "-0" : ""),
          W
            ? z === ">" || z === "<"
              ? (Z = "<0.0.0-0")
              : (Z = "*")
            : z && T
            ? (F && (G = 0),
              (L = 0),
              z === ">"
                ? ((z = ">="),
                  F
                    ? ((U = +U + 1), (G = 0), (L = 0))
                    : ((G = +G + 1), (L = 0)))
                : z === "<=" && ((z = "<"), F ? (U = +U + 1) : (G = +G + 1)),
              z === "<" && (k = "-0"),
              (Z = `${z + U}.${G}.${L}${k}`))
            : F
            ? (Z = `>=${U}.0.0${k} <${+U + 1}.0.0-0`)
            : x && (Z = `>=${U}.${G}.0${k} <${U}.${+G + 1}.0-0`),
          a("xRange return", Z),
          Z
        );
      });
    },
    w = (H, q) => (a("replaceStars", H, q), H.trim().replace(o[c.STAR], "")),
    O = (H, q) => (
      a("replaceGTE0", H, q),
      H.trim().replace(o[q.includePrerelease ? c.GTE0PRE : c.GTE0], "")
    ),
    Q = (H) => (q, J, Z, z, U, G, L, k, W, F, x, T, V) => (
      y(Z)
        ? (J = "")
        : y(z)
        ? (J = `>=${Z}.0.0${H ? "-0" : ""}`)
        : y(U)
        ? (J = `>=${Z}.${z}.0${H ? "-0" : ""}`)
        : G
        ? (J = `>=${J}`)
        : (J = `>=${J}${H ? "-0" : ""}`),
      y(W)
        ? (k = "")
        : y(F)
        ? (k = `<${+W + 1}.0.0-0`)
        : y(x)
        ? (k = `<${W}.${+F + 1}.0-0`)
        : T
        ? (k = `<=${W}.${F}.${x}-${T}`)
        : H
        ? (k = `<${W}.${F}.${+x + 1}-0`)
        : (k = `<=${k}`),
      `${J} ${k}`.trim()
    ),
    j = (H, q, J) => {
      for (let Z = 0; Z < H.length; Z++) if (!H[Z].test(q)) return !1;
      if (q.prerelease.length && !J.includePrerelease) {
        for (let Z = 0; Z < H.length; Z++)
          if (
            (a(H[Z].semver),
            H[Z].semver !== i.ANY && H[Z].semver.prerelease.length > 0)
          ) {
            const z = H[Z].semver;
            if (
              z.major === q.major &&
              z.minor === q.minor &&
              z.patch === q.patch
            )
              return !0;
          }
        return !1;
      }
      return !0;
    };
  return pm;
}
var hm, Iw;
function pp() {
  if (Iw) return hm;
  Iw = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(f, u) {
      if (((u = n(u)), f instanceof t)) {
        if (f.loose === !!u.loose) return f;
        f = f.value;
      }
      (f = f.trim().split(/\s+/).join(" ")),
        s("comparator", f, u),
        (this.options = u),
        (this.loose = !!u.loose),
        this.parse(f),
        this.semver === e
          ? (this.value = "")
          : (this.value = this.operator + this.semver.version),
        s("comp", this);
    }
    parse(f) {
      const u = this.options.loose ? r[i.COMPARATORLOOSE] : r[i.COMPARATOR],
        d = f.match(u);
      if (!d) throw new TypeError(`Invalid comparator: ${f}`);
      (this.operator = d[1] !== void 0 ? d[1] : ""),
        this.operator === "=" && (this.operator = ""),
        d[2]
          ? (this.semver = new o(d[2], this.options.loose))
          : (this.semver = e);
    }
    toString() {
      return this.value;
    }
    test(f) {
      if (
        (s("Comparator.test", f, this.options.loose),
        this.semver === e || f === e)
      )
        return !0;
      if (typeof f == "string")
        try {
          f = new o(f, this.options);
        } catch {
          return !1;
        }
      return a(f, this.operator, this.semver, this.options);
    }
    intersects(f, u) {
      if (!(f instanceof t)) throw new TypeError("a Comparator is required");
      return this.operator === ""
        ? this.value === ""
          ? !0
          : new c(f.value, u).test(this.value)
        : f.operator === ""
        ? f.value === ""
          ? !0
          : new c(this.value, u).test(f.semver)
        : ((u = n(u)),
          (u.includePrerelease &&
            (this.value === "<0.0.0-0" || f.value === "<0.0.0-0")) ||
          (!u.includePrerelease &&
            (this.value.startsWith("<0.0.0") || f.value.startsWith("<0.0.0")))
            ? !1
            : !!(
                (this.operator.startsWith(">") && f.operator.startsWith(">")) ||
                (this.operator.startsWith("<") && f.operator.startsWith("<")) ||
                (this.semver.version === f.semver.version &&
                  this.operator.includes("=") &&
                  f.operator.includes("=")) ||
                (a(this.semver, "<", f.semver, u) &&
                  this.operator.startsWith(">") &&
                  f.operator.startsWith("<")) ||
                (a(this.semver, ">", f.semver, u) &&
                  this.operator.startsWith("<") &&
                  f.operator.startsWith(">"))
              ));
    }
  }
  hm = t;
  const n = zv,
    { safeRe: r, t: i } = iu,
    a = FC,
    s = fp,
    o = Ir,
    c = Ii();
  return hm;
}
const hM = Ii(),
  mM = (e, t, n) => {
    try {
      t = new hM(t, n);
    } catch {
      return !1;
    }
    return t.test(e);
  };
var hp = mM;
const gM = Ii(),
  vM = (e, t) =>
    new gM(e, t).set.map((n) =>
      n
        .map((r) => r.value)
        .join(" ")
        .trim()
        .split(" "),
    );
var yM = vM;
const bM = Ir,
  _M = Ii(),
  EM = (e, t, n) => {
    let r = null,
      i = null,
      a = null;
    try {
      a = new _M(t, n);
    } catch {
      return null;
    }
    return (
      e.forEach((s) => {
        a.test(s) &&
          (!r || i.compare(s) === -1) &&
          ((r = s), (i = new bM(r, n)));
      }),
      r
    );
  };
var wM = EM;
const xM = Ir,
  AM = Ii(),
  SM = (e, t, n) => {
    let r = null,
      i = null,
      a = null;
    try {
      a = new AM(t, n);
    } catch {
      return null;
    }
    return (
      e.forEach((s) => {
        a.test(s) &&
          (!r || i.compare(s) === 1) &&
          ((r = s), (i = new xM(r, n)));
      }),
      r
    );
  };
var IM = SM;
const mm = Ir,
  $M = Ii(),
  $w = dp,
  CM = (e, t) => {
    e = new $M(e, t);
    let n = new mm("0.0.0");
    if (e.test(n) || ((n = new mm("0.0.0-0")), e.test(n))) return n;
    n = null;
    for (let r = 0; r < e.set.length; ++r) {
      const i = e.set[r];
      let a = null;
      i.forEach((s) => {
        const o = new mm(s.semver.version);
        switch (s.operator) {
          case ">":
            o.prerelease.length === 0 ? o.patch++ : o.prerelease.push(0),
              (o.raw = o.format());
          case "":
          case ">=":
            (!a || $w(o, a)) && (a = o);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${s.operator}`);
        }
      }),
        a && (!n || $w(n, a)) && (n = a);
    }
    return n && e.test(n) ? n : null;
  };
var RM = CM;
const kM = Ii(),
  TM = (e, t) => {
    try {
      return new kM(e, t).range || "*";
    } catch {
      return null;
    }
  };
var NM = TM;
const OM = Ir,
  MC = pp(),
  { ANY: PM } = MC,
  DM = Ii(),
  LM = hp,
  Cw = dp,
  Rw = Vv,
  BM = Xv,
  UM = Yv,
  FM = (e, t, n, r) => {
    (e = new OM(e, r)), (t = new DM(t, r));
    let i, a, s, o, c;
    switch (n) {
      case ">":
        (i = Cw), (a = BM), (s = Rw), (o = ">"), (c = ">=");
        break;
      case "<":
        (i = Rw), (a = UM), (s = Cw), (o = "<"), (c = "<=");
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (LM(e, t, r)) return !1;
    for (let l = 0; l < t.set.length; ++l) {
      const f = t.set[l];
      let u = null,
        d = null;
      if (
        (f.forEach((p) => {
          p.semver === PM && (p = new MC(">=0.0.0")),
            (u = u || p),
            (d = d || p),
            i(p.semver, u.semver, r)
              ? (u = p)
              : s(p.semver, d.semver, r) && (d = p);
        }),
        u.operator === o ||
          u.operator === c ||
          ((!d.operator || d.operator === o) && a(e, d.semver)))
      )
        return !1;
      if (d.operator === c && s(e, d.semver)) return !1;
    }
    return !0;
  };
var Jv = FM;
const jM = Jv,
  MM = (e, t, n) => jM(e, t, ">", n);
var HM = MM;
const qM = Jv,
  GM = (e, t, n) => qM(e, t, "<", n);
var QM = GM;
const kw = Ii(),
  WM = (e, t, n) => (
    (e = new kw(e, n)), (t = new kw(t, n)), e.intersects(t, n)
  );
var zM = WM;
const KM = hp,
  VM = Si;
var YM = (e, t, n) => {
  const r = [];
  let i = null,
    a = null;
  const s = e.sort((f, u) => VM(f, u, n));
  for (const f of s)
    KM(f, t, n)
      ? ((a = f), i || (i = f))
      : (a && r.push([i, a]), (a = null), (i = null));
  i && r.push([i, null]);
  const o = [];
  for (const [f, u] of r)
    f === u
      ? o.push(f)
      : !u && f === s[0]
      ? o.push("*")
      : u
      ? f === s[0]
        ? o.push(`<=${u}`)
        : o.push(`${f} - ${u}`)
      : o.push(`>=${f}`);
  const c = o.join(" || "),
    l = typeof t.raw == "string" ? t.raw : String(t);
  return c.length < l.length ? c : t;
};
const Tw = Ii(),
  Zv = pp(),
  { ANY: gm } = Zv,
  Bc = hp,
  ey = Si,
  XM = (e, t, n = {}) => {
    if (e === t) return !0;
    (e = new Tw(e, n)), (t = new Tw(t, n));
    let r = !1;
    e: for (const i of e.set) {
      for (const a of t.set) {
        const s = ZM(i, a, n);
        if (((r = r || s !== null), s)) continue e;
      }
      if (r) return !1;
    }
    return !0;
  },
  JM = [new Zv(">=0.0.0-0")],
  Nw = [new Zv(">=0.0.0")],
  ZM = (e, t, n) => {
    if (e === t) return !0;
    if (e.length === 1 && e[0].semver === gm) {
      if (t.length === 1 && t[0].semver === gm) return !0;
      n.includePrerelease ? (e = JM) : (e = Nw);
    }
    if (t.length === 1 && t[0].semver === gm) {
      if (n.includePrerelease) return !0;
      t = Nw;
    }
    const r = new Set();
    let i, a;
    for (const p of e)
      p.operator === ">" || p.operator === ">="
        ? (i = Ow(i, p, n))
        : p.operator === "<" || p.operator === "<="
        ? (a = Pw(a, p, n))
        : r.add(p.semver);
    if (r.size > 1) return null;
    let s;
    if (i && a) {
      if (((s = ey(i.semver, a.semver, n)), s > 0)) return null;
      if (s === 0 && (i.operator !== ">=" || a.operator !== "<=")) return null;
    }
    for (const p of r) {
      if ((i && !Bc(p, String(i), n)) || (a && !Bc(p, String(a), n)))
        return null;
      for (const h of t) if (!Bc(p, String(h), n)) return !1;
      return !0;
    }
    let o,
      c,
      l,
      f,
      u =
        a && !n.includePrerelease && a.semver.prerelease.length ? a.semver : !1,
      d =
        i && !n.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
    u &&
      u.prerelease.length === 1 &&
      a.operator === "<" &&
      u.prerelease[0] === 0 &&
      (u = !1);
    for (const p of t) {
      if (
        ((f = f || p.operator === ">" || p.operator === ">="),
        (l = l || p.operator === "<" || p.operator === "<="),
        i)
      ) {
        if (
          (d &&
            p.semver.prerelease &&
            p.semver.prerelease.length &&
            p.semver.major === d.major &&
            p.semver.minor === d.minor &&
            p.semver.patch === d.patch &&
            (d = !1),
          p.operator === ">" || p.operator === ">=")
        ) {
          if (((o = Ow(i, p, n)), o === p && o !== i)) return !1;
        } else if (i.operator === ">=" && !Bc(i.semver, String(p), n))
          return !1;
      }
      if (a) {
        if (
          (u &&
            p.semver.prerelease &&
            p.semver.prerelease.length &&
            p.semver.major === u.major &&
            p.semver.minor === u.minor &&
            p.semver.patch === u.patch &&
            (u = !1),
          p.operator === "<" || p.operator === "<=")
        ) {
          if (((c = Pw(a, p, n)), c === p && c !== a)) return !1;
        } else if (a.operator === "<=" && !Bc(a.semver, String(p), n))
          return !1;
      }
      if (!p.operator && (a || i) && s !== 0) return !1;
    }
    return !((i && l && !a && s !== 0) || (a && f && !i && s !== 0) || d || u);
  },
  Ow = (e, t, n) => {
    if (!e) return t;
    const r = ey(e.semver, t.semver, n);
    return r > 0
      ? e
      : r < 0 || (t.operator === ">" && e.operator === ">=")
      ? t
      : e;
  },
  Pw = (e, t, n) => {
    if (!e) return t;
    const r = ey(e.semver, t.semver, n);
    return r < 0
      ? e
      : r > 0 || (t.operator === "<" && e.operator === "<=")
      ? t
      : e;
  };
var e7 = XM;
const vm = iu,
  Dw = up,
  t7 = Ir,
  Lw = LC,
  n7 = wc,
  r7 = nj,
  i7 = aj,
  a7 = oj,
  s7 = lj,
  o7 = dj,
  c7 = mj,
  l7 = yj,
  u7 = Ej,
  f7 = Si,
  d7 = Sj,
  p7 = Cj,
  h7 = Kv,
  m7 = Nj,
  g7 = Dj,
  v7 = dp,
  y7 = Vv,
  b7 = BC,
  _7 = UC,
  E7 = Yv,
  w7 = Xv,
  x7 = FC,
  A7 = iM,
  S7 = pp(),
  I7 = Ii(),
  $7 = hp,
  C7 = yM,
  R7 = wM,
  k7 = IM,
  T7 = RM,
  N7 = NM,
  O7 = Jv,
  P7 = HM,
  D7 = QM,
  L7 = zM,
  B7 = YM,
  U7 = e7;
var HC = {
    parse: n7,
    valid: r7,
    clean: i7,
    inc: a7,
    diff: s7,
    major: o7,
    minor: c7,
    patch: l7,
    prerelease: u7,
    compare: f7,
    rcompare: d7,
    compareLoose: p7,
    compareBuild: h7,
    sort: m7,
    rsort: g7,
    gt: v7,
    lt: y7,
    eq: b7,
    neq: _7,
    gte: E7,
    lte: w7,
    cmp: x7,
    coerce: A7,
    Comparator: S7,
    Range: I7,
    satisfies: $7,
    toComparators: C7,
    maxSatisfying: R7,
    minSatisfying: k7,
    minVersion: T7,
    validRange: N7,
    outside: O7,
    gtr: P7,
    ltr: D7,
    intersects: L7,
    simplifyRange: B7,
    subset: U7,
    SemVer: t7,
    re: vm.re,
    src: vm.src,
    tokens: vm.t,
    SEMVER_SPEC_VERSION: Dw.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: Dw.RELEASE_TYPES,
    compareIdentifiers: Lw.compareIdentifiers,
    rcompareIdentifiers: Lw.rcompareIdentifiers,
  },
  ec = {},
  yd = { exports: {} };
yd.exports;
(function (e, t) {
  var n = 200,
    r = "__lodash_hash_undefined__",
    i = 1,
    a = 2,
    s = 9007199254740991,
    o = "[object Arguments]",
    c = "[object Array]",
    l = "[object AsyncFunction]",
    f = "[object Boolean]",
    u = "[object Date]",
    d = "[object Error]",
    p = "[object Function]",
    h = "[object GeneratorFunction]",
    m = "[object Map]",
    g = "[object Number]",
    v = "[object Null]",
    y = "[object Object]",
    _ = "[object Promise]",
    E = "[object Proxy]",
    R = "[object RegExp]",
    A = "[object Set]",
    I = "[object String]",
    S = "[object Symbol]",
    w = "[object Undefined]",
    O = "[object WeakMap]",
    Q = "[object ArrayBuffer]",
    j = "[object DataView]",
    H = "[object Float32Array]",
    q = "[object Float64Array]",
    J = "[object Int8Array]",
    Z = "[object Int16Array]",
    z = "[object Int32Array]",
    U = "[object Uint8Array]",
    G = "[object Uint8ClampedArray]",
    L = "[object Uint16Array]",
    k = "[object Uint32Array]",
    W = /[\\^$.*+?()[\]{}|]/g,
    F = /^\[object .+?Constructor\]$/,
    x = /^(?:0|[1-9]\d*)$/,
    T = {};
  (T[H] = T[q] = T[J] = T[Z] = T[z] = T[U] = T[G] = T[L] = T[k] = !0),
    (T[o] =
      T[c] =
      T[Q] =
      T[f] =
      T[j] =
      T[u] =
      T[d] =
      T[p] =
      T[m] =
      T[g] =
      T[y] =
      T[R] =
      T[A] =
      T[I] =
      T[O] =
        !1);
  var V = typeof Tn == "object" && Tn && Tn.Object === Object && Tn,
    B = typeof self == "object" && self && self.Object === Object && self,
    N = V || B || Function("return this")(),
    ce = t && !t.nodeType && t,
    re = ce && !0 && e && !e.nodeType && e,
    ne = re && re.exports === ce,
    Y = ne && V.process,
    M = (function () {
      try {
        return Y && Y.binding && Y.binding("util");
      } catch {}
    })(),
    oe = M && M.isTypedArray;
  function Ee(ee, ue) {
    for (
      var $e = -1, Ge = ee == null ? 0 : ee.length, ln = 0, Et = [];
      ++$e < Ge;

    ) {
      var Sn = ee[$e];
      ue(Sn, $e, ee) && (Et[ln++] = Sn);
    }
    return Et;
  }
  function le(ee, ue) {
    for (var $e = -1, Ge = ue.length, ln = ee.length; ++$e < Ge; )
      ee[ln + $e] = ue[$e];
    return ee;
  }
  function te(ee, ue) {
    for (var $e = -1, Ge = ee == null ? 0 : ee.length; ++$e < Ge; )
      if (ue(ee[$e], $e, ee)) return !0;
    return !1;
  }
  function ie(ee, ue) {
    for (var $e = -1, Ge = Array(ee); ++$e < ee; ) Ge[$e] = ue($e);
    return Ge;
  }
  function X(ee) {
    return function (ue) {
      return ee(ue);
    };
  }
  function he(ee, ue) {
    return ee.has(ue);
  }
  function be(ee, ue) {
    return ee == null ? void 0 : ee[ue];
  }
  function ye(ee) {
    var ue = -1,
      $e = Array(ee.size);
    return (
      ee.forEach(function (Ge, ln) {
        $e[++ue] = [ln, Ge];
      }),
      $e
    );
  }
  function Qe(ee, ue) {
    return function ($e) {
      return ee(ue($e));
    };
  }
  function lt(ee) {
    var ue = -1,
      $e = Array(ee.size);
    return (
      ee.forEach(function (Ge) {
        $e[++ue] = Ge;
      }),
      $e
    );
  }
  var Lt = Array.prototype,
    We = Function.prototype,
    bt = Object.prototype,
    wt = N["__core-js_shared__"],
    ct = We.toString,
    ze = bt.hasOwnProperty,
    dt = (function () {
      var ee = /[^.]+$/.exec((wt && wt.keys && wt.keys.IE_PROTO) || "");
      return ee ? "Symbol(src)_1." + ee : "";
    })(),
    ht = bt.toString,
    an = RegExp(
      "^" +
        ct
          .call(ze)
          .replace(W, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?",
          ) +
        "$",
    ),
    $n = ne ? N.Buffer : void 0,
    Wt = N.Symbol,
    Jt = N.Uint8Array,
    Zt = bt.propertyIsEnumerable,
    jr = Lt.splice,
    Nn = Wt ? Wt.toStringTag : void 0,
    Vr = Object.getOwnPropertySymbols,
    Vi = $n ? $n.isBuffer : void 0,
    On = Qe(Object.keys, Object),
    ni = zt(N, "DataView"),
    An = zt(N, "Map"),
    Mr = zt(N, "Promise"),
    Hr = zt(N, "Set"),
    Yi = zt(N, "WeakMap"),
    qr = zt(Object, "create"),
    ns = rs(ni),
    kc = rs(An),
    Bn = rs(Mr),
    no = rs(Hr),
    P = rs(Yi),
    C = Wt ? Wt.prototype : void 0,
    $ = C ? C.valueOf : void 0;
  function b(ee) {
    var ue = -1,
      $e = ee == null ? 0 : ee.length;
    for (this.clear(); ++ue < $e; ) {
      var Ge = ee[ue];
      this.set(Ge[0], Ge[1]);
    }
  }
  function D() {
    (this.__data__ = qr ? qr(null) : {}), (this.size = 0);
  }
  function K(ee) {
    var ue = this.has(ee) && delete this.__data__[ee];
    return (this.size -= ue ? 1 : 0), ue;
  }
  function se(ee) {
    var ue = this.__data__;
    if (qr) {
      var $e = ue[ee];
      return $e === r ? void 0 : $e;
    }
    return ze.call(ue, ee) ? ue[ee] : void 0;
  }
  function pe(ee) {
    var ue = this.__data__;
    return qr ? ue[ee] !== void 0 : ze.call(ue, ee);
  }
  function we(ee, ue) {
    var $e = this.__data__;
    return (
      (this.size += this.has(ee) ? 0 : 1),
      ($e[ee] = qr && ue === void 0 ? r : ue),
      this
    );
  }
  (b.prototype.clear = D),
    (b.prototype.delete = K),
    (b.prototype.get = se),
    (b.prototype.has = pe),
    (b.prototype.set = we);
  function Re(ee) {
    var ue = -1,
      $e = ee == null ? 0 : ee.length;
    for (this.clear(); ++ue < $e; ) {
      var Ge = ee[ue];
      this.set(Ge[0], Ge[1]);
    }
  }
  function ke() {
    (this.__data__ = []), (this.size = 0);
  }
  function je(ee) {
    var ue = this.__data__,
      $e = Ce(ue, ee);
    if ($e < 0) return !1;
    var Ge = ue.length - 1;
    return $e == Ge ? ue.pop() : jr.call(ue, $e, 1), --this.size, !0;
  }
  function Te(ee) {
    var ue = this.__data__,
      $e = Ce(ue, ee);
    return $e < 0 ? void 0 : ue[$e][1];
  }
  function Me(ee) {
    return Ce(this.__data__, ee) > -1;
  }
  function Ne(ee, ue) {
    var $e = this.__data__,
      Ge = Ce($e, ee);
    return Ge < 0 ? (++this.size, $e.push([ee, ue])) : ($e[Ge][1] = ue), this;
  }
  (Re.prototype.clear = ke),
    (Re.prototype.delete = je),
    (Re.prototype.get = Te),
    (Re.prototype.has = Me),
    (Re.prototype.set = Ne);
  function Ue(ee) {
    var ue = -1,
      $e = ee == null ? 0 : ee.length;
    for (this.clear(); ++ue < $e; ) {
      var Ge = ee[ue];
      this.set(Ge[0], Ge[1]);
    }
  }
  function qe() {
    (this.size = 0),
      (this.__data__ = {
        hash: new b(),
        map: new (An || Re)(),
        string: new b(),
      });
  }
  function Fe(ee) {
    var ue = Pt(this, ee).delete(ee);
    return (this.size -= ue ? 1 : 0), ue;
  }
  function Je(ee) {
    return Pt(this, ee).get(ee);
  }
  function Ke(ee) {
    return Pt(this, ee).has(ee);
  }
  function Be(ee, ue) {
    var $e = Pt(this, ee),
      Ge = $e.size;
    return $e.set(ee, ue), (this.size += $e.size == Ge ? 0 : 1), this;
  }
  (Ue.prototype.clear = qe),
    (Ue.prototype.delete = Fe),
    (Ue.prototype.get = Je),
    (Ue.prototype.has = Ke),
    (Ue.prototype.set = Be);
  function He(ee) {
    var ue = -1,
      $e = ee == null ? 0 : ee.length;
    for (this.__data__ = new Ue(); ++ue < $e; ) this.add(ee[ue]);
  }
  function De(ee) {
    return this.__data__.set(ee, r), this;
  }
  function Le(ee) {
    return this.__data__.has(ee);
  }
  (He.prototype.add = He.prototype.push = De), (He.prototype.has = Le);
  function Pe(ee) {
    var ue = (this.__data__ = new Re(ee));
    this.size = ue.size;
  }
  function Oe() {
    (this.__data__ = new Re()), (this.size = 0);
  }
  function ge(ee) {
    var ue = this.__data__,
      $e = ue.delete(ee);
    return (this.size = ue.size), $e;
  }
  function ve(ee) {
    return this.__data__.get(ee);
  }
  function Ie(ee) {
    return this.__data__.has(ee);
  }
  function Se(ee, ue) {
    var $e = this.__data__;
    if ($e instanceof Re) {
      var Ge = $e.__data__;
      if (!An || Ge.length < n - 1)
        return Ge.push([ee, ue]), (this.size = ++$e.size), this;
      $e = this.__data__ = new Ue(Ge);
    }
    return $e.set(ee, ue), (this.size = $e.size), this;
  }
  (Pe.prototype.clear = Oe),
    (Pe.prototype.delete = ge),
    (Pe.prototype.get = ve),
    (Pe.prototype.has = Ie),
    (Pe.prototype.set = Se);
  function Ae(ee, ue) {
    var $e = Ru(ee),
      Ge = !$e && bT(ee),
      ln = !$e && !Ge && nh(ee),
      Et = !$e && !Ge && !ln && b1(ee),
      Sn = $e || Ge || ln || Et,
      Mn = Sn ? ie(ee.length, String) : [],
      Vn = Mn.length;
    for (var yn in ee)
      (ue || ze.call(ee, yn)) &&
        !(
          Sn &&
          (yn == "length" ||
            (ln && (yn == "offset" || yn == "parent")) ||
            (Et &&
              (yn == "buffer" || yn == "byteLength" || yn == "byteOffset")) ||
            Un(yn, Vn))
        ) &&
        Mn.push(yn);
    return Mn;
  }
  function Ce(ee, ue) {
    for (var $e = ee.length; $e--; ) if (m1(ee[$e][0], ue)) return $e;
    return -1;
  }
  function Ve(ee, ue, $e) {
    var Ge = ue(ee);
    return Ru(ee) ? Ge : le(Ge, $e(ee));
  }
  function it(ee) {
    return ee == null
      ? ee === void 0
        ? w
        : v
      : Nn && Nn in Object(ee)
      ? mn(ee)
      : yT(ee);
  }
  function mt(ee) {
    return Tc(ee) && it(ee) == o;
  }
  function at(ee, ue, $e, Ge, ln) {
    return ee === ue
      ? !0
      : ee == null || ue == null || (!Tc(ee) && !Tc(ue))
      ? ee !== ee && ue !== ue
      : ae(ee, ue, $e, Ge, at, ln);
  }
  function ae(ee, ue, $e, Ge, ln, Et) {
    var Sn = Ru(ee),
      Mn = Ru(ue),
      Vn = Sn ? c : en(ee),
      yn = Mn ? c : en(ue);
    (Vn = Vn == o ? y : Vn), (yn = yn == o ? y : yn);
    var Gr = Vn == y,
      ri = yn == y,
      sr = Vn == yn;
    if (sr && nh(ee)) {
      if (!nh(ue)) return !1;
      (Sn = !0), (Gr = !1);
    }
    if (sr && !Gr)
      return (
        Et || (Et = new Pe()),
        Sn || b1(ee)
          ? yt(ee, ue, $e, Ge, ln, Et)
          : Ct(ee, ue, Vn, $e, Ge, ln, Et)
      );
    if (!($e & i)) {
      var Yr = Gr && ze.call(ee, "__wrapped__"),
        Xr = ri && ze.call(ue, "__wrapped__");
      if (Yr || Xr) {
        var ya = Yr ? ee.value() : ee,
          Xi = Xr ? ue.value() : ue;
        return Et || (Et = new Pe()), ln(ya, Xi, $e, Ge, Et);
      }
    }
    return sr ? (Et || (Et = new Pe()), Rt(ee, ue, $e, Ge, ln, Et)) : !1;
  }
  function _t(ee) {
    if (!y1(ee) || jn(ee)) return !1;
    var ue = g1(ee) ? an : F;
    return ue.test(rs(ee));
  }
  function Nt(ee) {
    return Tc(ee) && v1(ee.length) && !!T[it(ee)];
  }
  function Ot(ee) {
    if (!vT(ee)) return On(ee);
    var ue = [];
    for (var $e in Object(ee))
      ze.call(ee, $e) && $e != "constructor" && ue.push($e);
    return ue;
  }
  function yt(ee, ue, $e, Ge, ln, Et) {
    var Sn = $e & i,
      Mn = ee.length,
      Vn = ue.length;
    if (Mn != Vn && !(Sn && Vn > Mn)) return !1;
    var yn = Et.get(ee);
    if (yn && Et.get(ue)) return yn == ue;
    var Gr = -1,
      ri = !0,
      sr = $e & a ? new He() : void 0;
    for (Et.set(ee, ue), Et.set(ue, ee); ++Gr < Mn; ) {
      var Yr = ee[Gr],
        Xr = ue[Gr];
      if (Ge)
        var ya = Sn ? Ge(Xr, Yr, Gr, ue, ee, Et) : Ge(Yr, Xr, Gr, ee, ue, Et);
      if (ya !== void 0) {
        if (ya) continue;
        ri = !1;
        break;
      }
      if (sr) {
        if (
          !te(ue, function (Xi, is) {
            if (!he(sr, is) && (Yr === Xi || ln(Yr, Xi, $e, Ge, Et)))
              return sr.push(is);
          })
        ) {
          ri = !1;
          break;
        }
      } else if (!(Yr === Xr || ln(Yr, Xr, $e, Ge, Et))) {
        ri = !1;
        break;
      }
    }
    return Et.delete(ee), Et.delete(ue), ri;
  }
  function Ct(ee, ue, $e, Ge, ln, Et, Sn) {
    switch ($e) {
      case j:
        if (ee.byteLength != ue.byteLength || ee.byteOffset != ue.byteOffset)
          return !1;
        (ee = ee.buffer), (ue = ue.buffer);
      case Q:
        return !(ee.byteLength != ue.byteLength || !Et(new Jt(ee), new Jt(ue)));
      case f:
      case u:
      case g:
        return m1(+ee, +ue);
      case d:
        return ee.name == ue.name && ee.message == ue.message;
      case R:
      case I:
        return ee == ue + "";
      case m:
        var Mn = ye;
      case A:
        var Vn = Ge & i;
        if ((Mn || (Mn = lt), ee.size != ue.size && !Vn)) return !1;
        var yn = Sn.get(ee);
        if (yn) return yn == ue;
        (Ge |= a), Sn.set(ee, ue);
        var Gr = yt(Mn(ee), Mn(ue), Ge, ln, Et, Sn);
        return Sn.delete(ee), Gr;
      case S:
        if ($) return $.call(ee) == $.call(ue);
    }
    return !1;
  }
  function Rt(ee, ue, $e, Ge, ln, Et) {
    var Sn = $e & i,
      Mn = hn(ee),
      Vn = Mn.length,
      yn = hn(ue),
      Gr = yn.length;
    if (Vn != Gr && !Sn) return !1;
    for (var ri = Vn; ri--; ) {
      var sr = Mn[ri];
      if (!(Sn ? sr in ue : ze.call(ue, sr))) return !1;
    }
    var Yr = Et.get(ee);
    if (Yr && Et.get(ue)) return Yr == ue;
    var Xr = !0;
    Et.set(ee, ue), Et.set(ue, ee);
    for (var ya = Sn; ++ri < Vn; ) {
      sr = Mn[ri];
      var Xi = ee[sr],
        is = ue[sr];
      if (Ge)
        var _1 = Sn ? Ge(is, Xi, sr, ue, ee, Et) : Ge(Xi, is, sr, ee, ue, Et);
      if (!(_1 === void 0 ? Xi === is || ln(Xi, is, $e, Ge, Et) : _1)) {
        Xr = !1;
        break;
      }
      ya || (ya = sr == "constructor");
    }
    if (Xr && !ya) {
      var ku = ee.constructor,
        Tu = ue.constructor;
      ku != Tu &&
        "constructor" in ee &&
        "constructor" in ue &&
        !(
          typeof ku == "function" &&
          ku instanceof ku &&
          typeof Tu == "function" &&
          Tu instanceof Tu
        ) &&
        (Xr = !1);
    }
    return Et.delete(ee), Et.delete(ue), Xr;
  }
  function hn(ee) {
    return Ve(ee, wT, gn);
  }
  function Pt(ee, ue) {
    var $e = ee.__data__;
    return Fn(ue) ? $e[typeof ue == "string" ? "string" : "hash"] : $e.map;
  }
  function zt(ee, ue) {
    var $e = be(ee, ue);
    return _t($e) ? $e : void 0;
  }
  function mn(ee) {
    var ue = ze.call(ee, Nn),
      $e = ee[Nn];
    try {
      ee[Nn] = void 0;
      var Ge = !0;
    } catch {}
    var ln = ht.call(ee);
    return Ge && (ue ? (ee[Nn] = $e) : delete ee[Nn]), ln;
  }
  var gn = Vr
      ? function (ee) {
          return ee == null
            ? []
            : ((ee = Object(ee)),
              Ee(Vr(ee), function (ue) {
                return Zt.call(ee, ue);
              }));
        }
      : xT,
    en = it;
  ((ni && en(new ni(new ArrayBuffer(1))) != j) ||
    (An && en(new An()) != m) ||
    (Mr && en(Mr.resolve()) != _) ||
    (Hr && en(new Hr()) != A) ||
    (Yi && en(new Yi()) != O)) &&
    (en = function (ee) {
      var ue = it(ee),
        $e = ue == y ? ee.constructor : void 0,
        Ge = $e ? rs($e) : "";
      if (Ge)
        switch (Ge) {
          case ns:
            return j;
          case kc:
            return m;
          case Bn:
            return _;
          case no:
            return A;
          case P:
            return O;
        }
      return ue;
    });
  function Un(ee, ue) {
    return (
      (ue = ue ?? s),
      !!ue &&
        (typeof ee == "number" || x.test(ee)) &&
        ee > -1 &&
        ee % 1 == 0 &&
        ee < ue
    );
  }
  function Fn(ee) {
    var ue = typeof ee;
    return ue == "string" || ue == "number" || ue == "symbol" || ue == "boolean"
      ? ee !== "__proto__"
      : ee === null;
  }
  function jn(ee) {
    return !!dt && dt in ee;
  }
  function vT(ee) {
    var ue = ee && ee.constructor,
      $e = (typeof ue == "function" && ue.prototype) || bt;
    return ee === $e;
  }
  function yT(ee) {
    return ht.call(ee);
  }
  function rs(ee) {
    if (ee != null) {
      try {
        return ct.call(ee);
      } catch {}
      try {
        return ee + "";
      } catch {}
    }
    return "";
  }
  function m1(ee, ue) {
    return ee === ue || (ee !== ee && ue !== ue);
  }
  var bT = mt(
      (function () {
        return arguments;
      })(),
    )
      ? mt
      : function (ee) {
          return Tc(ee) && ze.call(ee, "callee") && !Zt.call(ee, "callee");
        },
    Ru = Array.isArray;
  function _T(ee) {
    return ee != null && v1(ee.length) && !g1(ee);
  }
  var nh = Vi || AT;
  function ET(ee, ue) {
    return at(ee, ue);
  }
  function g1(ee) {
    if (!y1(ee)) return !1;
    var ue = it(ee);
    return ue == p || ue == h || ue == l || ue == E;
  }
  function v1(ee) {
    return typeof ee == "number" && ee > -1 && ee % 1 == 0 && ee <= s;
  }
  function y1(ee) {
    var ue = typeof ee;
    return ee != null && (ue == "object" || ue == "function");
  }
  function Tc(ee) {
    return ee != null && typeof ee == "object";
  }
  var b1 = oe ? X(oe) : Nt;
  function wT(ee) {
    return _T(ee) ? Ae(ee) : Ot(ee);
  }
  function xT() {
    return [];
  }
  function AT() {
    return !1;
  }
  e.exports = ET;
})(yd, yd.exports);
var F7 = yd.exports;
Object.defineProperty(ec, "__esModule", { value: !0 });
ec.createTempUpdateFile = ec.DownloadedUpdateHelper = void 0;
const j7 = pr,
  M7 = Xt,
  Bw = F7,
  ps = Za,
  ml = pt;
class H7 {
  constructor(t) {
    (this.cacheDir = t),
      (this._file = null),
      (this._packageFile = null),
      (this.versionInfo = null),
      (this.fileInfo = null),
      (this._downloadedFileInfo = null);
  }
  get downloadedFileInfo() {
    return this._downloadedFileInfo;
  }
  get file() {
    return this._file;
  }
  get packageFile() {
    return this._packageFile;
  }
  get cacheDirForPendingUpdate() {
    return ml.join(this.cacheDir, "pending");
  }
  async validateDownloadedPath(t, n, r, i) {
    if (this.versionInfo != null && this.file === t && this.fileInfo != null)
      return Bw(this.versionInfo, n) &&
        Bw(this.fileInfo.info, r.info) &&
        (await (0, ps.pathExists)(t))
        ? t
        : null;
    const a = await this.getValidCachedUpdateFile(r, i);
    return a === null
      ? null
      : (i.info(`Update has already been downloaded to ${t}).`),
        (this._file = a),
        a);
  }
  async setDownloadedFile(t, n, r, i, a, s) {
    (this._file = t),
      (this._packageFile = n),
      (this.versionInfo = r),
      (this.fileInfo = i),
      (this._downloadedFileInfo = {
        fileName: a,
        sha512: i.info.sha512,
        isAdminRightsRequired: i.info.isAdminRightsRequired === !0,
      }),
      s &&
        (await (0, ps.outputJson)(
          this.getUpdateInfoFile(),
          this._downloadedFileInfo,
        ));
  }
  async clear() {
    (this._file = null),
      (this._packageFile = null),
      (this.versionInfo = null),
      (this.fileInfo = null),
      await this.cleanCacheDirForPendingUpdate();
  }
  async cleanCacheDirForPendingUpdate() {
    try {
      await (0, ps.emptyDir)(this.cacheDirForPendingUpdate);
    } catch {}
  }
  async getValidCachedUpdateFile(t, n) {
    var r;
    const i = this.getUpdateInfoFile();
    if (!(await (0, ps.pathExists)(i))) return null;
    let s;
    try {
      s = await (0, ps.readJson)(i);
    } catch (f) {
      let u = "No cached update info available";
      return (
        f.code !== "ENOENT" &&
          (await this.cleanCacheDirForPendingUpdate(),
          (u += ` (error on read: ${f.message})`)),
        n.info(u),
        null
      );
    }
    if (
      !((r = (s == null ? void 0 : s.fileName) !== null) !== null &&
      r !== void 0
        ? r
        : !1)
    )
      return (
        n.warn(
          "Cached update info is corrupted: no fileName, directory for cached update will be cleaned",
        ),
        await this.cleanCacheDirForPendingUpdate(),
        null
      );
    if (t.info.sha512 !== s.sha512)
      return (
        n.info(
          `Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${s.sha512}, expected: ${t.info.sha512}. Directory for cached update will be cleaned`,
        ),
        await this.cleanCacheDirForPendingUpdate(),
        null
      );
    const c = ml.join(this.cacheDirForPendingUpdate, s.fileName);
    if (!(await (0, ps.pathExists)(c)))
      return n.info("Cached update file doesn't exist"), null;
    const l = await q7(c);
    return t.info.sha512 !== l
      ? (n.warn(
          `Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${l}, expected: ${t.info.sha512}`,
        ),
        await this.cleanCacheDirForPendingUpdate(),
        null)
      : ((this._downloadedFileInfo = s), c);
  }
  getUpdateInfoFile() {
    return ml.join(this.cacheDirForPendingUpdate, "update-info.json");
  }
}
ec.DownloadedUpdateHelper = H7;
function q7(e, t = "sha512", n = "base64", r) {
  return new Promise((i, a) => {
    const s = (0, j7.createHash)(t);
    s.on("error", a).setEncoding(n),
      (0, M7.createReadStream)(e, { ...r, highWaterMark: 1024 * 1024 })
        .on("error", a)
        .on("end", () => {
          s.end(), i(s.read());
        })
        .pipe(s, { end: !1 });
  });
}
async function G7(e, t, n) {
  let r = 0,
    i = ml.join(t, e);
  for (let a = 0; a < 3; a++)
    try {
      return await (0, ps.unlink)(i), i;
    } catch (s) {
      if (s.code === "ENOENT") return i;
      n.warn(`Error on remove temp update file: ${s}`),
        (i = ml.join(t, `${r++}-${e}`));
    }
  return i;
}
ec.createTempUpdateFile = G7;
var mp = {},
  gp = {};
Object.defineProperty(gp, "__esModule", { value: !0 });
gp.getAppCacheDir = void 0;
const ym = pt,
  Q7 = Fr;
function W7() {
  const e = (0, Q7.homedir)();
  let t;
  return (
    process.platform === "win32"
      ? (t = process.env.LOCALAPPDATA || ym.join(e, "AppData", "Local"))
      : process.platform === "darwin"
      ? (t = ym.join(e, "Library", "Caches"))
      : (t = process.env.XDG_CACHE_HOME || ym.join(e, ".cache")),
    t
  );
}
gp.getAppCacheDir = W7;
Object.defineProperty(mp, "__esModule", { value: !0 });
mp.ElectronAppAdapter = void 0;
const Uw = pt,
  z7 = gp;
class K7 {
  constructor(t = xe.app) {
    this.app = t;
  }
  whenReady() {
    return this.app.whenReady();
  }
  get version() {
    return this.app.getVersion();
  }
  get name() {
    return this.app.getName();
  }
  get isPackaged() {
    return this.app.isPackaged === !0;
  }
  get appUpdateConfigPath() {
    return this.isPackaged
      ? Uw.join(process.resourcesPath, "app-update.yml")
      : Uw.join(this.app.getAppPath(), "dev-app-update.yml");
  }
  get userDataPath() {
    return this.app.getPath("userData");
  }
  get baseCachePath() {
    return (0, z7.getAppCacheDir)();
  }
  quit() {
    this.app.quit();
  }
  relaunch() {
    this.app.relaunch();
  }
  onQuit(t) {
    this.app.once("quit", (n, r) => t(r));
  }
}
mp.ElectronAppAdapter = K7;
var qC = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.ElectronHttpExecutor = e.getNetSession = e.NET_SESSION_NAME = void 0);
  const t = Ln();
  e.NET_SESSION_NAME = "electron-updater";
  function n() {
    return xe.session.fromPartition(e.NET_SESSION_NAME, { cache: !1 });
  }
  e.getNetSession = n;
  class r extends t.HttpExecutor {
    constructor(a) {
      super(), (this.proxyLoginCallback = a), (this.cachedSession = null);
    }
    async download(a, s, o) {
      return await o.cancellationToken.createPromise((c, l, f) => {
        const u = { headers: o.headers || void 0, redirect: "manual" };
        (0, t.configureRequestUrl)(a, u),
          (0, t.configureRequestOptions)(u),
          this.doDownload(
            u,
            {
              destination: s,
              options: o,
              onCancel: f,
              callback: (d) => {
                d == null ? c(s) : l(d);
              },
              responseHandler: null,
            },
            0,
          );
      });
    }
    createRequest(a, s) {
      a.headers &&
        a.headers.Host &&
        ((a.host = a.headers.Host), delete a.headers.Host),
        this.cachedSession == null && (this.cachedSession = n());
      const o = xe.net.request({ ...a, session: this.cachedSession });
      return (
        o.on("response", s),
        this.proxyLoginCallback != null &&
          o.on("login", this.proxyLoginCallback),
        o
      );
    }
    addRedirectHandlers(a, s, o, c, l) {
      a.on("redirect", (f, u, d) => {
        a.abort(),
          c > this.maxRedirects
            ? o(this.createMaxRedirectError())
            : l(t.HttpExecutor.prepareRedirectUrlOptions(d, s));
      });
    }
  }
  e.ElectronHttpExecutor = r;
})(qC);
var au = {},
  fr = {},
  V7 = 1 / 0,
  Y7 = "[object Symbol]",
  GC = /[\\^$.*+?()[\]{}|]/g,
  X7 = RegExp(GC.source),
  J7 = typeof Tn == "object" && Tn && Tn.Object === Object && Tn,
  Z7 = typeof self == "object" && self && self.Object === Object && self,
  eH = J7 || Z7 || Function("return this")(),
  tH = Object.prototype,
  nH = tH.toString,
  Fw = eH.Symbol,
  jw = Fw ? Fw.prototype : void 0,
  Mw = jw ? jw.toString : void 0;
function rH(e) {
  if (typeof e == "string") return e;
  if (aH(e)) return Mw ? Mw.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -V7 ? "-0" : t;
}
function iH(e) {
  return !!e && typeof e == "object";
}
function aH(e) {
  return typeof e == "symbol" || (iH(e) && nH.call(e) == Y7);
}
function sH(e) {
  return e == null ? "" : rH(e);
}
function oH(e) {
  return (e = sH(e)), e && X7.test(e) ? e.replace(GC, "\\$&") : e;
}
var cH = oH;
Object.defineProperty(fr, "__esModule", { value: !0 });
fr.blockmapFiles =
  fr.getChannelFilename =
  fr.newUrlFromBase =
  fr.newBaseUrl =
    void 0;
const QC = Ya,
  lH = cH;
function uH(e) {
  const t = new QC.URL(e);
  return t.pathname.endsWith("/") || (t.pathname += "/"), t;
}
fr.newBaseUrl = uH;
function d0(e, t, n = !1) {
  const r = new QC.URL(e, t),
    i = t.search;
  return (
    i != null && i.length !== 0
      ? (r.search = i)
      : n && (r.search = `noCache=${Date.now().toString(32)}`),
    r
  );
}
fr.newUrlFromBase = d0;
function fH(e) {
  return `${e}.yml`;
}
fr.getChannelFilename = fH;
function dH(e, t, n) {
  const r = d0(`${e.pathname}.blockmap`, e);
  return [
    d0(`${e.pathname.replace(new RegExp(lH(n), "g"), t)}.blockmap`, e),
    r,
  ];
}
fr.blockmapFiles = dH;
var In = {};
Object.defineProperty(In, "__esModule", { value: !0 });
In.resolveFiles =
  In.getFileList =
  In.parseUpdateInfo =
  In.findFile =
  In.Provider =
    void 0;
const Ka = Ln(),
  pH = ar,
  Hw = fr;
class hH {
  constructor(t) {
    (this.runtimeOptions = t),
      (this.requestHeaders = null),
      (this.executor = t.executor);
  }
  get isUseMultipleRangeRequest() {
    return this.runtimeOptions.isUseMultipleRangeRequest !== !1;
  }
  getChannelFilePrefix() {
    if (this.runtimeOptions.platform === "linux") {
      const t = process.env.TEST_UPDATER_ARCH || process.arch;
      return "-linux" + (t === "x64" ? "" : `-${t}`);
    } else return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
  }
  getDefaultChannelName() {
    return this.getCustomChannelName("latest");
  }
  getCustomChannelName(t) {
    return `${t}${this.getChannelFilePrefix()}`;
  }
  get fileExtraDownloadHeaders() {
    return null;
  }
  setRequestHeaders(t) {
    this.requestHeaders = t;
  }
  httpRequest(t, n, r) {
    return this.executor.request(this.createRequestOptions(t, n), r);
  }
  createRequestOptions(t, n) {
    const r = {};
    return (
      this.requestHeaders == null
        ? n != null && (r.headers = n)
        : (r.headers =
            n == null ? this.requestHeaders : { ...this.requestHeaders, ...n }),
      (0, Ka.configureRequestUrl)(t, r),
      r
    );
  }
}
In.Provider = hH;
function mH(e, t, n) {
  if (e.length === 0)
    throw (0, Ka.newError)(
      "No files provided",
      "ERR_UPDATER_NO_FILES_PROVIDED",
    );
  const r = e.find((i) => i.url.pathname.toLowerCase().endsWith(`.${t}`));
  return (
    r ??
    (n == null
      ? e[0]
      : e.find(
          (i) => !n.some((a) => i.url.pathname.toLowerCase().endsWith(`.${a}`)),
        ))
  );
}
In.findFile = mH;
function gH(e, t, n) {
  if (e == null)
    throw (0, Ka.newError)(
      `Cannot parse update info from ${t} in the latest release artifacts (${n}): rawData: null`,
      "ERR_UPDATER_INVALID_UPDATE_INFO",
    );
  let r;
  try {
    r = (0, pH.load)(e);
  } catch (i) {
    throw (0, Ka.newError)(
      `Cannot parse update info from ${t} in the latest release artifacts (${n}): ${
        i.stack || i.message
      }, rawData: ${e}`,
      "ERR_UPDATER_INVALID_UPDATE_INFO",
    );
  }
  return r;
}
In.parseUpdateInfo = gH;
function WC(e) {
  const t = e.files;
  if (t != null && t.length > 0) return t;
  if (e.path != null) return [{ url: e.path, sha2: e.sha2, sha512: e.sha512 }];
  throw (0, Ka.newError)(
    `No files provided: ${(0, Ka.safeStringifyJson)(e)}`,
    "ERR_UPDATER_NO_FILES_PROVIDED",
  );
}
In.getFileList = WC;
function vH(e, t, n = (r) => r) {
  const i = WC(e).map((o) => {
      if (o.sha2 == null && o.sha512 == null)
        throw (0, Ka.newError)(
          `Update info doesn't contain nor sha256 neither sha512 checksum: ${(0,
          Ka.safeStringifyJson)(o)}`,
          "ERR_UPDATER_NO_CHECKSUM",
        );
      return { url: (0, Hw.newUrlFromBase)(n(o.url), t), info: o };
    }),
    a = e.packages,
    s = a == null ? null : a[process.arch] || a.ia32;
  return (
    s != null &&
      (i[0].packageInfo = {
        ...s,
        path: (0, Hw.newUrlFromBase)(n(s.path), t).href,
      }),
    i
  );
}
In.resolveFiles = vH;
Object.defineProperty(au, "__esModule", { value: !0 });
au.GenericProvider = void 0;
const qw = Ln(),
  bm = fr,
  _m = In;
class yH extends _m.Provider {
  constructor(t, n, r) {
    super(r),
      (this.configuration = t),
      (this.updater = n),
      (this.baseUrl = (0, bm.newBaseUrl)(this.configuration.url));
  }
  get channel() {
    const t = this.updater.channel || this.configuration.channel;
    return t == null
      ? this.getDefaultChannelName()
      : this.getCustomChannelName(t);
  }
  async getLatestVersion() {
    const t = (0, bm.getChannelFilename)(this.channel),
      n = (0, bm.newUrlFromBase)(
        t,
        this.baseUrl,
        this.updater.isAddNoCacheQuery,
      );
    for (let r = 0; ; r++)
      try {
        return (0, _m.parseUpdateInfo)(await this.httpRequest(n), t, n);
      } catch (i) {
        if (i instanceof qw.HttpError && i.statusCode === 404)
          throw (0, qw.newError)(
            `Cannot find channel "${t}" update info: ${i.stack || i.message}`,
            "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND",
          );
        if (i.code === "ECONNREFUSED" && r < 3) {
          await new Promise((a, s) => {
            try {
              setTimeout(a, 1e3 * r);
            } catch (o) {
              s(o);
            }
          });
          continue;
        }
        throw i;
      }
  }
  resolveFiles(t) {
    return (0, _m.resolveFiles)(t, this.baseUrl);
  }
}
au.GenericProvider = yH;
var tc = {},
  vp = {};
Object.defineProperty(vp, "__esModule", { value: !0 });
vp.BitbucketProvider = void 0;
const Gw = Ln(),
  Em = fr,
  wm = In;
class bH extends wm.Provider {
  constructor(t, n, r) {
    super({ ...r, isUseMultipleRangeRequest: !1 }),
      (this.configuration = t),
      (this.updater = n);
    const { owner: i, slug: a } = t;
    this.baseUrl = (0, Em.newBaseUrl)(
      `https://api.bitbucket.org/2.0/repositories/${i}/${a}/downloads`,
    );
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "latest";
  }
  async getLatestVersion() {
    const t = new Gw.CancellationToken(),
      n = (0, Em.getChannelFilename)(this.getCustomChannelName(this.channel)),
      r = (0, Em.newUrlFromBase)(
        n,
        this.baseUrl,
        this.updater.isAddNoCacheQuery,
      );
    try {
      const i = await this.httpRequest(r, void 0, t);
      return (0, wm.parseUpdateInfo)(i, n, r);
    } catch (i) {
      throw (0, Gw.newError)(
        `Unable to find latest version on ${this.toString()}, please ensure release exists: ${
          i.stack || i.message
        }`,
        "ERR_UPDATER_LATEST_VERSION_NOT_FOUND",
      );
    }
  }
  resolveFiles(t) {
    return (0, wm.resolveFiles)(t, this.baseUrl);
  }
  toString() {
    const { owner: t, slug: n } = this.configuration;
    return `Bitbucket (owner: ${t}, slug: ${n}, channel: ${this.channel})`;
  }
}
vp.BitbucketProvider = bH;
var ca = {};
Object.defineProperty(ca, "__esModule", { value: !0 });
ca.computeReleaseNotes = ca.GitHubProvider = ca.BaseGitHubProvider = void 0;
const ea = Ln(),
  gl = HC,
  _H = Ya,
  Co = fr,
  p0 = In,
  xm = /\/tag\/([^/]+)$/;
class zC extends p0.Provider {
  constructor(t, n, r) {
    super({ ...r, isUseMultipleRangeRequest: !1 }),
      (this.options = t),
      (this.baseUrl = (0, Co.newBaseUrl)((0, ea.githubUrl)(t, n)));
    const i = n === "github.com" ? "api.github.com" : n;
    this.baseApiUrl = (0, Co.newBaseUrl)((0, ea.githubUrl)(t, i));
  }
  computeGithubBasePath(t) {
    const n = this.options.host;
    return n && !["github.com", "api.github.com"].includes(n)
      ? `/api/v3${t}`
      : t;
  }
}
ca.BaseGitHubProvider = zC;
class EH extends zC {
  constructor(t, n, r) {
    super(t, "github.com", r), (this.options = t), (this.updater = n);
  }
  async getLatestVersion() {
    var t, n, r, i;
    const a = new ea.CancellationToken(),
      s = await this.httpRequest(
        (0, Co.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl),
        { accept: "application/xml, application/atom+xml, text/xml, */*" },
        a,
      ),
      o = (0, ea.parseXml)(s);
    let c = o.element("entry", !1, "No published versions on GitHub"),
      l = null;
    try {
      if (this.updater.allowPrerelease) {
        const m =
          ((t = this.updater) === null || t === void 0 ? void 0 : t.channel) ||
          ((n = gl.prerelease(this.updater.currentVersion)) === null ||
          n === void 0
            ? void 0
            : n[0]) ||
          null;
        if (m === null) l = xm.exec(c.element("link").attribute("href"))[1];
        else
          for (const g of o.getElements("entry")) {
            const v = xm.exec(g.element("link").attribute("href"));
            if (v === null) continue;
            const y = v[1],
              _ =
                ((r = gl.prerelease(y)) === null || r === void 0
                  ? void 0
                  : r[0]) || null,
              E = !m || ["alpha", "beta"].includes(m),
              R = _ !== null && !["alpha", "beta"].includes(String(_));
            if (E && !R && !(m === "beta" && _ === "alpha")) {
              l = y;
              break;
            }
            if (_ && _ === m) {
              l = y;
              break;
            }
          }
      } else {
        l = await this.getLatestTagName(a);
        for (const m of o.getElements("entry"))
          if (xm.exec(m.element("link").attribute("href"))[1] === l) {
            c = m;
            break;
          }
      }
    } catch (m) {
      throw (0, ea.newError)(
        `Cannot parse releases feed: ${m.stack || m.message},
XML:
${s}`,
        "ERR_UPDATER_INVALID_RELEASE_FEED",
      );
    }
    if (l == null)
      throw (0, ea.newError)(
        "No published versions on GitHub",
        "ERR_UPDATER_NO_PUBLISHED_VERSIONS",
      );
    let f,
      u = "",
      d = "";
    const p = async (m) => {
      (u = (0, Co.getChannelFilename)(m)),
        (d = (0, Co.newUrlFromBase)(
          this.getBaseDownloadPath(String(l), u),
          this.baseUrl,
        ));
      const g = this.createRequestOptions(d);
      try {
        return await this.executor.request(g, a);
      } catch (v) {
        throw v instanceof ea.HttpError && v.statusCode === 404
          ? (0, ea.newError)(
              `Cannot find ${u} in the latest release artifacts (${d}): ${
                v.stack || v.message
              }`,
              "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND",
            )
          : v;
      }
    };
    try {
      const m = this.updater.allowPrerelease
        ? this.getCustomChannelName(
            String(
              ((i = gl.prerelease(l)) === null || i === void 0
                ? void 0
                : i[0]) || "latest",
            ),
          )
        : this.getDefaultChannelName();
      f = await p(m);
    } catch (m) {
      if (this.updater.allowPrerelease)
        f = await p(this.getDefaultChannelName());
      else throw m;
    }
    const h = (0, p0.parseUpdateInfo)(f, u, d);
    return (
      h.releaseName == null && (h.releaseName = c.elementValueOrEmpty("title")),
      h.releaseNotes == null &&
        (h.releaseNotes = KC(
          this.updater.currentVersion,
          this.updater.fullChangelog,
          o,
          c,
        )),
      { tag: l, ...h }
    );
  }
  async getLatestTagName(t) {
    const n = this.options,
      r =
        n.host == null || n.host === "github.com"
          ? (0, Co.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl)
          : new _H.URL(
              `${this.computeGithubBasePath(
                `/repos/${n.owner}/${n.repo}/releases`,
              )}/latest`,
              this.baseApiUrl,
            );
    try {
      const i = await this.httpRequest(r, { Accept: "application/json" }, t);
      return i == null ? null : JSON.parse(i).tag_name;
    } catch (i) {
      throw (0, ea.newError)(
        `Unable to find latest version on GitHub (${r}), please ensure a production release exists: ${
          i.stack || i.message
        }`,
        "ERR_UPDATER_LATEST_VERSION_NOT_FOUND",
      );
    }
  }
  get basePath() {
    return `/${this.options.owner}/${this.options.repo}/releases`;
  }
  resolveFiles(t) {
    return (0, p0.resolveFiles)(t, this.baseUrl, (n) =>
      this.getBaseDownloadPath(t.tag, n.replace(/ /g, "-")),
    );
  }
  getBaseDownloadPath(t, n) {
    return `${this.basePath}/download/${t}/${n}`;
  }
}
ca.GitHubProvider = EH;
function Qw(e) {
  const t = e.elementValueOrEmpty("content");
  return t === "No content." ? "" : t;
}
function KC(e, t, n, r) {
  if (!t) return Qw(r);
  const i = [];
  for (const a of n.getElements("entry")) {
    const s = /\/tag\/v?([^/]+)$/.exec(a.element("link").attribute("href"))[1];
    gl.lt(e, s) && i.push({ version: s, note: Qw(a) });
  }
  return i.sort((a, s) => gl.rcompare(a.version, s.version));
}
ca.computeReleaseNotes = KC;
var yp = {};
Object.defineProperty(yp, "__esModule", { value: !0 });
yp.KeygenProvider = void 0;
const Ww = Ln(),
  Am = fr,
  Sm = In;
class wH extends Sm.Provider {
  constructor(t, n, r) {
    super({ ...r, isUseMultipleRangeRequest: !1 }),
      (this.configuration = t),
      (this.updater = n),
      (this.baseUrl = (0, Am.newBaseUrl)(
        `https://api.keygen.sh/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`,
      ));
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "stable";
  }
  async getLatestVersion() {
    const t = new Ww.CancellationToken(),
      n = (0, Am.getChannelFilename)(this.getCustomChannelName(this.channel)),
      r = (0, Am.newUrlFromBase)(
        n,
        this.baseUrl,
        this.updater.isAddNoCacheQuery,
      );
    try {
      const i = await this.httpRequest(
        r,
        { Accept: "application/vnd.api+json", "Keygen-Version": "1.1" },
        t,
      );
      return (0, Sm.parseUpdateInfo)(i, n, r);
    } catch (i) {
      throw (0, Ww.newError)(
        `Unable to find latest version on ${this.toString()}, please ensure release exists: ${
          i.stack || i.message
        }`,
        "ERR_UPDATER_LATEST_VERSION_NOT_FOUND",
      );
    }
  }
  resolveFiles(t) {
    return (0, Sm.resolveFiles)(t, this.baseUrl);
  }
  toString() {
    const { account: t, product: n, platform: r } = this.configuration;
    return `Keygen (account: ${t}, product: ${n}, platform: ${r}, channel: ${this.channel})`;
  }
}
yp.KeygenProvider = wH;
var bp = {};
Object.defineProperty(bp, "__esModule", { value: !0 });
bp.PrivateGitHubProvider = void 0;
const co = Ln(),
  xH = ar,
  AH = pt,
  zw = Ya,
  Kw = fr,
  SH = ca,
  IH = In;
class $H extends SH.BaseGitHubProvider {
  constructor(t, n, r, i) {
    super(t, "api.github.com", i), (this.updater = n), (this.token = r);
  }
  createRequestOptions(t, n) {
    const r = super.createRequestOptions(t, n);
    return (r.redirect = "manual"), r;
  }
  async getLatestVersion() {
    const t = new co.CancellationToken(),
      n = (0, Kw.getChannelFilename)(this.getDefaultChannelName()),
      r = await this.getLatestVersionInfo(t),
      i = r.assets.find((o) => o.name === n);
    if (i == null)
      throw (0, co.newError)(
        `Cannot find ${n} in the release ${r.html_url || r.name}`,
        "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND",
      );
    const a = new zw.URL(i.url);
    let s;
    try {
      s = (0, xH.load)(
        await this.httpRequest(
          a,
          this.configureHeaders("application/octet-stream"),
          t,
        ),
      );
    } catch (o) {
      throw o instanceof co.HttpError && o.statusCode === 404
        ? (0, co.newError)(
            `Cannot find ${n} in the latest release artifacts (${a}): ${
              o.stack || o.message
            }`,
            "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND",
          )
        : o;
    }
    return (s.assets = r.assets), s;
  }
  get fileExtraDownloadHeaders() {
    return this.configureHeaders("application/octet-stream");
  }
  configureHeaders(t) {
    return { accept: t, authorization: `token ${this.token}` };
  }
  async getLatestVersionInfo(t) {
    const n = this.updater.allowPrerelease;
    let r = this.basePath;
    n || (r = `${r}/latest`);
    const i = (0, Kw.newUrlFromBase)(r, this.baseUrl);
    try {
      const a = JSON.parse(
        await this.httpRequest(
          i,
          this.configureHeaders("application/vnd.github.v3+json"),
          t,
        ),
      );
      return n ? a.find((s) => s.prerelease) || a[0] : a;
    } catch (a) {
      throw (0, co.newError)(
        `Unable to find latest version on GitHub (${i}), please ensure a production release exists: ${
          a.stack || a.message
        }`,
        "ERR_UPDATER_LATEST_VERSION_NOT_FOUND",
      );
    }
  }
  get basePath() {
    return this.computeGithubBasePath(
      `/repos/${this.options.owner}/${this.options.repo}/releases`,
    );
  }
  resolveFiles(t) {
    return (0, IH.getFileList)(t).map((n) => {
      const r = AH.posix.basename(n.url).replace(/ /g, "-"),
        i = t.assets.find((a) => a != null && a.name === r);
      if (i == null)
        throw (0, co.newError)(
          `Cannot find asset "${r}" in: ${JSON.stringify(t.assets, null, 2)}`,
          "ERR_UPDATER_ASSET_NOT_FOUND",
        );
      return { url: new zw.URL(i.url), info: n };
    });
  }
}
bp.PrivateGitHubProvider = $H;
Object.defineProperty(tc, "__esModule", { value: !0 });
tc.createClient = tc.isUrlProbablySupportMultiRangeRequests = void 0;
const ff = Ln(),
  CH = vp,
  Vw = au,
  RH = ca,
  kH = yp,
  TH = bp;
function VC(e) {
  return !e.includes("s3.amazonaws.com");
}
tc.isUrlProbablySupportMultiRangeRequests = VC;
function NH(e, t, n) {
  if (typeof e == "string")
    throw (0, ff.newError)(
      "Please pass PublishConfiguration object",
      "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION",
    );
  const r = e.provider;
  switch (r) {
    case "github": {
      const i = e,
        a =
          (i.private
            ? process.env.GH_TOKEN || process.env.GITHUB_TOKEN
            : null) || i.token;
      return a == null
        ? new RH.GitHubProvider(i, t, n)
        : new TH.PrivateGitHubProvider(i, t, a, n);
    }
    case "bitbucket":
      return new CH.BitbucketProvider(e, t, n);
    case "keygen":
      return new kH.KeygenProvider(e, t, n);
    case "s3":
    case "spaces":
      return new Vw.GenericProvider(
        {
          provider: "generic",
          url: (0, ff.getS3LikeProviderBaseUrl)(e),
          channel: e.channel || null,
        },
        t,
        { ...n, isUseMultipleRangeRequest: !1 },
      );
    case "generic": {
      const i = e;
      return new Vw.GenericProvider(i, t, {
        ...n,
        isUseMultipleRangeRequest:
          i.useMultipleRangeRequest !== !1 && VC(i.url),
      });
    }
    case "custom": {
      const i = e,
        a = i.updateProvider;
      if (!a)
        throw (0, ff.newError)(
          "Custom provider not specified",
          "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION",
        );
      return new a(i, t, n);
    }
    default:
      throw (0, ff.newError)(
        `Unsupported provider: ${r}`,
        "ERR_UPDATER_UNSUPPORTED_PROVIDER",
      );
  }
}
tc.createClient = NH;
var Yw;
function ty() {
  if (Yw) return cs;
  (Yw = 1),
    Object.defineProperty(cs, "__esModule", { value: !0 }),
    (cs.NoOpLogger = cs.AppUpdater = void 0);
  const e = Ln(),
    t = pr,
    n = Hi,
    r = Za,
    i = ar,
    a = lp,
    s = pt,
    o = HC,
    c = ec,
    l = mp,
    f = qC,
    u = au,
    d = xc(),
    p = tc;
  let h = class YC extends n.EventEmitter {
    constructor(y, _) {
      super(),
        (this.autoDownload = !0),
        (this.autoInstallOnAppQuit = !0),
        (this.autoRunAppAfterInstall = !0),
        (this.allowPrerelease = !1),
        (this.fullChangelog = !1),
        (this.allowDowngrade = !1),
        (this.disableWebInstaller = !1),
        (this.forceDevUpdateConfig = !1),
        (this._channel = null),
        (this.downloadedUpdateHelper = null),
        (this.requestHeaders = null),
        (this._logger = console),
        (this.signals = new d.UpdaterSignal(this)),
        (this._appUpdateConfigPath = null),
        (this.clientPromise = null),
        (this.stagingUserIdPromise = new a.Lazy(() =>
          this.getOrCreateStagingUserId(),
        )),
        (this.configOnDisk = new a.Lazy(() => this.loadUpdateConfig())),
        (this.checkForUpdatesPromise = null),
        (this.updateInfoAndProvider = null),
        (this._testOnlyOptions = null),
        this.on("error", (A) => {
          this._logger.error(`Error: ${A.stack || A.message}`);
        }),
        _ == null
          ? ((this.app = new l.ElectronAppAdapter()),
            (this.httpExecutor = new f.ElectronHttpExecutor((A, I) =>
              this.emit("login", A, I),
            )))
          : ((this.app = _), (this.httpExecutor = null));
      const E = this.app.version,
        R = (0, o.parse)(E);
      if (R == null)
        throw (0, e.newError)(
          `App version is not a valid semver version: "${E}"`,
          "ERR_UPDATER_INVALID_VERSION",
        );
      (this.currentVersion = R),
        (this.allowPrerelease = m(R)),
        y != null &&
          (this.setFeedURL(y),
          typeof y != "string" &&
            y.requestHeaders &&
            (this.requestHeaders = y.requestHeaders));
    }
    get channel() {
      return this._channel;
    }
    set channel(y) {
      if (this._channel != null) {
        if (typeof y != "string")
          throw (0, e.newError)(
            `Channel must be a string, but got: ${y}`,
            "ERR_UPDATER_INVALID_CHANNEL",
          );
        if (y.length === 0)
          throw (0, e.newError)(
            "Channel must be not an empty string",
            "ERR_UPDATER_INVALID_CHANNEL",
          );
      }
      (this._channel = y), (this.allowDowngrade = !0);
    }
    addAuthHeader(y) {
      this.requestHeaders = Object.assign({}, this.requestHeaders, {
        authorization: y,
      });
    }
    get netSession() {
      return (0, f.getNetSession)();
    }
    get logger() {
      return this._logger;
    }
    set logger(y) {
      this._logger = y ?? new g();
    }
    set updateConfigPath(y) {
      (this.clientPromise = null),
        (this._appUpdateConfigPath = y),
        (this.configOnDisk = new a.Lazy(() => this.loadUpdateConfig()));
    }
    getFeedURL() {
      return "Deprecated. Do not use it.";
    }
    setFeedURL(y) {
      const _ = this.createProviderRuntimeOptions();
      let E;
      typeof y == "string"
        ? (E = new u.GenericProvider({ provider: "generic", url: y }, this, {
            ..._,
            isUseMultipleRangeRequest: (0,
            p.isUrlProbablySupportMultiRangeRequests)(y),
          }))
        : (E = (0, p.createClient)(y, this, _)),
        (this.clientPromise = Promise.resolve(E));
    }
    checkForUpdates() {
      if (!this.isUpdaterActive()) return Promise.resolve(null);
      let y = this.checkForUpdatesPromise;
      if (y != null)
        return (
          this._logger.info("Checking for update (already in progress)"), y
        );
      const _ = () => (this.checkForUpdatesPromise = null);
      return (
        this._logger.info("Checking for update"),
        (y = this.doCheckForUpdates()
          .then((E) => (_(), E))
          .catch((E) => {
            throw (
              (_(),
              this.emit(
                "error",
                E,
                `Cannot check for updates: ${(E.stack || E).toString()}`,
              ),
              E)
            );
          })),
        (this.checkForUpdatesPromise = y),
        y
      );
    }
    isUpdaterActive() {
      return this.app.isPackaged || this.forceDevUpdateConfig
        ? !0
        : (this._logger.info(
            "Skip checkForUpdates because application is not packed and dev update config is not forced",
          ),
          !1);
    }
    checkForUpdatesAndNotify(y) {
      return this.checkForUpdates().then((_) =>
        _ != null && _.downloadPromise
          ? (_.downloadPromise.then(() => {
              const E = YC.formatDownloadNotification(
                _.updateInfo.version,
                this.app.name,
                y,
              );
              new xe.Notification(E).show();
            }),
            _)
          : (this._logger.debug != null &&
              this._logger.debug(
                "checkForUpdatesAndNotify called, downloadPromise is null",
              ),
            _),
      );
    }
    static formatDownloadNotification(y, _, E) {
      return (
        E == null &&
          (E = {
            title: "A new update is ready to install",
            body: "{appName} version {version} has been downloaded and will be automatically installed on exit",
          }),
        (E = {
          title: E.title.replace("{appName}", _).replace("{version}", y),
          body: E.body.replace("{appName}", _).replace("{version}", y),
        }),
        E
      );
    }
    async isStagingMatch(y) {
      const _ = y.stagingPercentage;
      let E = _;
      if (E == null) return !0;
      if (((E = parseInt(E, 10)), isNaN(E)))
        return this._logger.warn(`Staging percentage is NaN: ${_}`), !0;
      E = E / 100;
      const R = await this.stagingUserIdPromise.value,
        I = e.UUID.parse(R).readUInt32BE(12) / 4294967295;
      return (
        this._logger.info(
          `Staging percentage: ${E}, percentage: ${I}, user id: ${R}`,
        ),
        I < E
      );
    }
    computeFinalHeaders(y) {
      return (
        this.requestHeaders != null && Object.assign(y, this.requestHeaders), y
      );
    }
    async isUpdateAvailable(y) {
      const _ = (0, o.parse)(y.version);
      if (_ == null)
        throw (0, e.newError)(
          `This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${y.version}"`,
          "ERR_UPDATER_INVALID_VERSION",
        );
      const E = this.currentVersion;
      if ((0, o.eq)(_, E) || !(await this.isStagingMatch(y))) return !1;
      const A = (0, o.gt)(_, E),
        I = (0, o.lt)(_, E);
      return A ? !0 : this.allowDowngrade && I;
    }
    async getUpdateInfoAndProvider() {
      await this.app.whenReady(),
        this.clientPromise == null &&
          (this.clientPromise = this.configOnDisk.value.then((E) =>
            (0, p.createClient)(E, this, this.createProviderRuntimeOptions()),
          ));
      const y = await this.clientPromise,
        _ = await this.stagingUserIdPromise.value;
      return (
        y.setRequestHeaders(
          this.computeFinalHeaders({ "x-user-staging-id": _ }),
        ),
        { info: await y.getLatestVersion(), provider: y }
      );
    }
    createProviderRuntimeOptions() {
      return {
        isUseMultipleRangeRequest: !0,
        platform:
          this._testOnlyOptions == null
            ? process.platform
            : this._testOnlyOptions.platform,
        executor: this.httpExecutor,
      };
    }
    async doCheckForUpdates() {
      this.emit("checking-for-update");
      const y = await this.getUpdateInfoAndProvider(),
        _ = y.info;
      if (!(await this.isUpdateAvailable(_)))
        return (
          this._logger.info(
            `Update for version ${
              this.currentVersion
            } is not available (latest version: ${_.version}, downgrade is ${
              this.allowDowngrade ? "allowed" : "disallowed"
            }).`,
          ),
          this.emit("update-not-available", _),
          { versionInfo: _, updateInfo: _ }
        );
      (this.updateInfoAndProvider = y), this.onUpdateAvailable(_);
      const E = new e.CancellationToken();
      return {
        versionInfo: _,
        updateInfo: _,
        cancellationToken: E,
        downloadPromise: this.autoDownload ? this.downloadUpdate(E) : null,
      };
    }
    onUpdateAvailable(y) {
      this._logger.info(
        `Found version ${y.version} (url: ${(0, e.asArray)(y.files)
          .map((_) => _.url)
          .join(", ")})`,
      ),
        this.emit("update-available", y);
    }
    downloadUpdate(y = new e.CancellationToken()) {
      const _ = this.updateInfoAndProvider;
      if (_ == null) {
        const R = new Error("Please check update first");
        return this.dispatchError(R), Promise.reject(R);
      }
      this._logger.info(
        `Downloading update from ${(0, e.asArray)(_.info.files)
          .map((R) => R.url)
          .join(", ")}`,
      );
      const E = (R) => {
        if (!(R instanceof e.CancellationError))
          try {
            this.dispatchError(R);
          } catch (A) {
            this._logger.warn(`Cannot dispatch error event: ${A.stack || A}`);
          }
        return R;
      };
      try {
        return this.doDownloadUpdate({
          updateInfoAndProvider: _,
          requestHeaders: this.computeRequestHeaders(_.provider),
          cancellationToken: y,
          disableWebInstaller: this.disableWebInstaller,
        }).catch((R) => {
          throw E(R);
        });
      } catch (R) {
        return Promise.reject(E(R));
      }
    }
    dispatchError(y) {
      this.emit("error", y, (y.stack || y).toString());
    }
    dispatchUpdateDownloaded(y) {
      this.emit(d.UPDATE_DOWNLOADED, y);
    }
    async loadUpdateConfig() {
      return (
        this._appUpdateConfigPath == null &&
          (this._appUpdateConfigPath = this.app.appUpdateConfigPath),
        (0, i.load)(await (0, r.readFile)(this._appUpdateConfigPath, "utf-8"))
      );
    }
    computeRequestHeaders(y) {
      const _ = y.fileExtraDownloadHeaders;
      if (_ != null) {
        const E = this.requestHeaders;
        return E == null ? _ : { ..._, ...E };
      }
      return this.computeFinalHeaders({ accept: "*/*" });
    }
    async getOrCreateStagingUserId() {
      const y = s.join(this.app.userDataPath, ".updaterId");
      try {
        const E = await (0, r.readFile)(y, "utf-8");
        if (e.UUID.check(E)) return E;
        this._logger.warn(
          `Staging user id file exists, but content was invalid: ${E}`,
        );
      } catch (E) {
        E.code !== "ENOENT" &&
          this._logger.warn(
            `Couldn't read staging user ID, creating a blank one: ${E}`,
          );
      }
      const _ = e.UUID.v5((0, t.randomBytes)(4096), e.UUID.OID);
      this._logger.info(`Generated new staging user ID: ${_}`);
      try {
        await (0, r.outputFile)(y, _);
      } catch (E) {
        this._logger.warn(`Couldn't write out staging user ID: ${E}`);
      }
      return _;
    }
    get isAddNoCacheQuery() {
      const y = this.requestHeaders;
      if (y == null) return !0;
      for (const _ of Object.keys(y)) {
        const E = _.toLowerCase();
        if (E === "authorization" || E === "private-token") return !1;
      }
      return !0;
    }
    async getOrCreateDownloadHelper() {
      let y = this.downloadedUpdateHelper;
      if (y == null) {
        const _ = (await this.configOnDisk.value).updaterCacheDirName,
          E = this._logger;
        _ == null &&
          E.error(
            "updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?",
          );
        const R = s.join(this.app.baseCachePath, _ || this.app.name);
        E.debug != null && E.debug(`updater cache dir: ${R}`),
          (y = new c.DownloadedUpdateHelper(R)),
          (this.downloadedUpdateHelper = y);
      }
      return y;
    }
    async executeDownload(y) {
      const _ = y.fileInfo,
        E = {
          headers: y.downloadUpdateOptions.requestHeaders,
          cancellationToken: y.downloadUpdateOptions.cancellationToken,
          sha2: _.info.sha2,
          sha512: _.info.sha512,
        };
      this.listenerCount(d.DOWNLOAD_PROGRESS) > 0 &&
        (E.onProgress = (G) => this.emit(d.DOWNLOAD_PROGRESS, G));
      const R = y.downloadUpdateOptions.updateInfoAndProvider.info,
        A = R.version,
        I = _.packageInfo;
      function S() {
        const G = decodeURIComponent(y.fileInfo.url.pathname);
        return G.endsWith(`.${y.fileExtension}`)
          ? s.basename(G)
          : y.fileInfo.info.url;
      }
      const w = await this.getOrCreateDownloadHelper(),
        O = w.cacheDirForPendingUpdate;
      await (0, r.mkdir)(O, { recursive: !0 });
      const Q = S();
      let j = s.join(O, Q);
      const H =
          I == null
            ? null
            : s.join(O, `package-${A}${s.extname(I.path) || ".7z"}`),
        q = async (G) => (
          await w.setDownloadedFile(j, H, R, _, Q, G),
          await y.done({ ...R, downloadedFile: j }),
          H == null ? [j] : [j, H]
        ),
        J = this._logger,
        Z = await w.validateDownloadedPath(j, R, _, J);
      if (Z != null) return (j = Z), await q(!1);
      const z = async () => (
          await w.clear().catch(() => {}),
          await (0, r.unlink)(j).catch(() => {})
        ),
        U = await (0, c.createTempUpdateFile)(`temp-${Q}`, O, J);
      try {
        await y.task(U, E, H, z), await (0, r.rename)(U, j);
      } catch (G) {
        throw (
          (await z(),
          G instanceof e.CancellationError &&
            (J.info("cancelled"), this.emit("update-cancelled", R)),
          G)
        );
      }
      return (
        J.info(`New version ${A} has been downloaded to ${j}`), await q(!0)
      );
    }
  };
  cs.AppUpdater = h;
  function m(v) {
    const y = (0, o.prerelease)(v);
    return y != null && y.length > 0;
  }
  class g {
    info(y) {}
    warn(y) {}
    error(y) {}
  }
  return (cs.NoOpLogger = g), cs;
}
var Uc = {},
  Fc = {},
  Xw;
function _p() {
  if (Xw) return Fc;
  (Xw = 1),
    Object.defineProperty(Fc, "__esModule", { value: !0 }),
    (Fc.BaseUpdater = void 0);
  const e = Ql,
    t = ty();
  let n = class extends t.AppUpdater {
    constructor(i, a) {
      super(i, a),
        (this.quitAndInstallCalled = !1),
        (this.quitHandlerAdded = !1);
    }
    quitAndInstall(i = !1, a = !1) {
      this._logger.info("Install on explicit quitAndInstall"),
        this.install(i, i ? a : this.autoRunAppAfterInstall)
          ? setImmediate(() => {
              xe.autoUpdater.emit("before-quit-for-update"), this.app.quit();
            })
          : (this.quitAndInstallCalled = !1);
    }
    executeDownload(i) {
      return super.executeDownload({
        ...i,
        done: (a) => (
          this.dispatchUpdateDownloaded(a),
          this.addQuitHandler(),
          Promise.resolve()
        ),
      });
    }
    install(i = !1, a = !1) {
      if (this.quitAndInstallCalled)
        return (
          this._logger.warn(
            "install call ignored: quitAndInstallCalled is set to true",
          ),
          !1
        );
      const s = this.downloadedUpdateHelper,
        o = s == null ? null : s.file,
        c = s == null ? null : s.downloadedFileInfo;
      if (o == null || c == null)
        return (
          this.dispatchError(
            new Error("No valid update available, can't quit and install"),
          ),
          !1
        );
      this.quitAndInstallCalled = !0;
      try {
        return (
          this._logger.info(`Install: isSilent: ${i}, isForceRunAfter: ${a}`),
          this.doInstall({
            installerPath: o,
            isSilent: i,
            isForceRunAfter: a,
            isAdminRightsRequired: c.isAdminRightsRequired,
          })
        );
      } catch (l) {
        return this.dispatchError(l), !1;
      }
    }
    addQuitHandler() {
      this.quitHandlerAdded ||
        !this.autoInstallOnAppQuit ||
        ((this.quitHandlerAdded = !0),
        this.app.onQuit((i) => {
          if (this.quitAndInstallCalled) {
            this._logger.info(
              "Update installer has already been triggered. Quitting application.",
            );
            return;
          }
          if (!this.autoInstallOnAppQuit) {
            this._logger.info(
              "Update will not be installed on quit because autoInstallOnAppQuit is set to false.",
            );
            return;
          }
          if (i !== 0) {
            this._logger.info(
              `Update will be not installed on quit because application is quitting with exit code ${i}`,
            );
            return;
          }
          this._logger.info("Auto install update on quit"),
            this.install(!0, !1);
        }));
    }
    wrapSudo() {
      const { name: i } = this.app,
        a = `"${i} would like to update"`,
        s = this.spawnSyncLog(
          "which gksudo || which kdesudo || which pkexec || which beesu",
        ),
        o = [s];
      return (
        /kdesudo/i.test(s)
          ? (o.push("--comment", a), o.push("-c"))
          : /gksudo/i.test(s)
          ? o.push("--message", a)
          : /pkexec/i.test(s) && o.push("--disable-internal-agent"),
        o.join(" ")
      );
    }
    spawnSyncLog(i, a = [], s = {}) {
      return (
        this._logger.info(`Executing: ${i} with args: ${a}`),
        (0, e.spawnSync)(i, a, {
          env: { ...process.env, ...s },
          encoding: "utf-8",
          shell: !0,
        }).stdout.trim()
      );
    }
    async spawnLog(i, a = [], s = void 0, o = "ignore") {
      return (
        this._logger.info(`Executing: ${i} with args: ${a}`),
        new Promise((c, l) => {
          try {
            const f = { stdio: o, env: s, detached: !0 },
              u = (0, e.spawn)(i, a, f);
            u.on("error", (d) => {
              l(d);
            }),
              u.unref(),
              u.pid !== void 0 && c(!0);
          } catch (f) {
            l(f);
          }
        })
      );
    }
  };
  return (Fc.BaseUpdater = n), Fc;
}
var su = {},
  ou = {},
  Us = {},
  Ep = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.computeOperations = e.OperationKind = void 0);
  var t;
  (function (o) {
    (o[(o.COPY = 0)] = "COPY"), (o[(o.DOWNLOAD = 1)] = "DOWNLOAD");
  })((t = e.OperationKind || (e.OperationKind = {})));
  function n(o, c, l) {
    const f = s(o.files),
      u = s(c.files);
    let d = null;
    const p = c.files[0],
      h = [],
      m = p.name,
      g = f.get(m);
    if (g == null) throw new Error(`no file ${m} in old blockmap`);
    const v = u.get(m);
    let y = 0;
    const { checksumToOffset: _, checksumToOldSize: E } = a(
      f.get(m),
      g.offset,
      l,
    );
    let R = p.offset;
    for (let A = 0; A < v.checksums.length; R += v.sizes[A], A++) {
      const I = v.sizes[A],
        S = v.checksums[A];
      let w = _.get(S);
      w != null &&
        E.get(S) !== I &&
        (l.warn(
          `Checksum ("${S}") matches, but size differs (old: ${E.get(
            S,
          )}, new: ${I})`,
        ),
        (w = void 0)),
        w === void 0
          ? (y++,
            d != null && d.kind === t.DOWNLOAD && d.end === R
              ? (d.end += I)
              : ((d = { kind: t.DOWNLOAD, start: R, end: R + I }),
                i(d, h, S, A)))
          : d != null && d.kind === t.COPY && d.end === w
          ? (d.end += I)
          : ((d = { kind: t.COPY, start: w, end: w + I }), i(d, h, S, A));
    }
    return (
      y > 0 &&
        l.info(
          `File${
            p.name === "file" ? "" : " " + p.name
          } has ${y} changed blocks`,
        ),
      h
    );
  }
  e.computeOperations = n;
  const r =
    process.env.DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES === "true";
  function i(o, c, l, f) {
    if (r && c.length !== 0) {
      const u = c[c.length - 1];
      if (u.kind === o.kind && o.start < u.end && o.start > u.start) {
        const d = [u.start, u.end, o.start, o.end].reduce((p, h) =>
          p < h ? p : h,
        );
        throw new Error(`operation (block index: ${f}, checksum: ${l}, kind: ${
          t[o.kind]
        }) overlaps previous operation (checksum: ${l}):
abs: ${u.start} until ${u.end} and ${o.start} until ${o.end}
rel: ${u.start - d} until ${u.end - d} and ${o.start - d} until ${o.end - d}`);
      }
    }
    c.push(o);
  }
  function a(o, c, l) {
    const f = new Map(),
      u = new Map();
    let d = c;
    for (let p = 0; p < o.checksums.length; p++) {
      const h = o.checksums[p],
        m = o.sizes[p],
        g = u.get(h);
      if (g === void 0) f.set(h, d), u.set(h, m);
      else if (l.debug != null) {
        const v = g === m ? "(same size)" : `(size: ${g}, this size: ${m})`;
        l.debug(
          `${h} duplicated in blockmap ${v}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`,
        );
      }
      d += m;
    }
    return { checksumToOffset: f, checksumToOldSize: u };
  }
  function s(o) {
    const c = new Map();
    for (const l of o) c.set(l.name, l);
    return c;
  }
})(Ep);
Object.defineProperty(Us, "__esModule", { value: !0 });
Us.DataSplitter = Us.copyData = void 0;
const df = Ln(),
  OH = Xt,
  PH = Kr,
  DH = Ep,
  Jw = Buffer.from(`\r
\r
`);
var Ca;
(function (e) {
  (e[(e.INIT = 0)] = "INIT"),
    (e[(e.HEADER = 1)] = "HEADER"),
    (e[(e.BODY = 2)] = "BODY");
})(Ca || (Ca = {}));
function XC(e, t, n, r, i) {
  const a = (0, OH.createReadStream)("", {
    fd: n,
    autoClose: !1,
    start: e.start,
    end: e.end - 1,
  });
  a.on("error", r), a.once("end", i), a.pipe(t, { end: !1 });
}
Us.copyData = XC;
class LH extends PH.Writable {
  constructor(t, n, r, i, a, s) {
    super(),
      (this.out = t),
      (this.options = n),
      (this.partIndexToTaskIndex = r),
      (this.partIndexToLength = a),
      (this.finishHandler = s),
      (this.partIndex = -1),
      (this.headerListBuffer = null),
      (this.readState = Ca.INIT),
      (this.ignoreByteCount = 0),
      (this.remainingPartDataCount = 0),
      (this.actualPartLength = 0),
      (this.boundaryLength = i.length + 4),
      (this.ignoreByteCount = this.boundaryLength - 2);
  }
  get isFinished() {
    return this.partIndex === this.partIndexToLength.length;
  }
  _write(t, n, r) {
    if (this.isFinished) {
      console.error(`Trailing ignored data: ${t.length} bytes`);
      return;
    }
    this.handleData(t).then(r).catch(r);
  }
  async handleData(t) {
    let n = 0;
    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0)
      throw (0, df.newError)(
        "Internal error",
        "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH",
      );
    if (this.ignoreByteCount > 0) {
      const r = Math.min(this.ignoreByteCount, t.length);
      (this.ignoreByteCount -= r), (n = r);
    } else if (this.remainingPartDataCount > 0) {
      const r = Math.min(this.remainingPartDataCount, t.length);
      (this.remainingPartDataCount -= r),
        await this.processPartData(t, 0, r),
        (n = r);
    }
    if (n !== t.length) {
      if (this.readState === Ca.HEADER) {
        const r = this.searchHeaderListEnd(t, n);
        if (r === -1) return;
        (n = r), (this.readState = Ca.BODY), (this.headerListBuffer = null);
      }
      for (;;) {
        if (this.readState === Ca.BODY) this.readState = Ca.INIT;
        else {
          this.partIndex++;
          let s = this.partIndexToTaskIndex.get(this.partIndex);
          if (s == null)
            if (this.isFinished) s = this.options.end;
            else
              throw (0, df.newError)(
                "taskIndex is null",
                "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL",
              );
          const o =
            this.partIndex === 0
              ? this.options.start
              : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
          if (o < s) await this.copyExistingData(o, s);
          else if (o > s)
            throw (0, df.newError)(
              "prevTaskIndex must be < taskIndex",
              "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED",
            );
          if (this.isFinished) {
            this.onPartEnd(), this.finishHandler();
            return;
          }
          if (((n = this.searchHeaderListEnd(t, n)), n === -1)) {
            this.readState = Ca.HEADER;
            return;
          }
        }
        const r = this.partIndexToLength[this.partIndex],
          i = n + r,
          a = Math.min(i, t.length);
        if (
          (await this.processPartStarted(t, n, a),
          (this.remainingPartDataCount = r - (a - n)),
          this.remainingPartDataCount > 0)
        )
          return;
        if (((n = i + this.boundaryLength), n >= t.length)) {
          this.ignoreByteCount = this.boundaryLength - (t.length - i);
          return;
        }
      }
    }
  }
  copyExistingData(t, n) {
    return new Promise((r, i) => {
      const a = () => {
        if (t === n) {
          r();
          return;
        }
        const s = this.options.tasks[t];
        if (s.kind !== DH.OperationKind.COPY) {
          i(new Error("Task kind must be COPY"));
          return;
        }
        XC(s, this.out, this.options.oldFileFd, i, () => {
          t++, a();
        });
      };
      a();
    });
  }
  searchHeaderListEnd(t, n) {
    const r = t.indexOf(Jw, n);
    if (r !== -1) return r + Jw.length;
    const i = n === 0 ? t : t.slice(n);
    return (
      this.headerListBuffer == null
        ? (this.headerListBuffer = i)
        : (this.headerListBuffer = Buffer.concat([this.headerListBuffer, i])),
      -1
    );
  }
  onPartEnd() {
    const t = this.partIndexToLength[this.partIndex - 1];
    if (this.actualPartLength !== t)
      throw (0, df.newError)(
        `Expected length: ${t} differs from actual: ${this.actualPartLength}`,
        "ERR_DATA_SPLITTER_LENGTH_MISMATCH",
      );
    this.actualPartLength = 0;
  }
  processPartStarted(t, n, r) {
    return (
      this.partIndex !== 0 && this.onPartEnd(), this.processPartData(t, n, r)
    );
  }
  processPartData(t, n, r) {
    this.actualPartLength += r - n;
    const i = this.out;
    return i.write(n === 0 && t.length === r ? t : t.slice(n, r))
      ? Promise.resolve()
      : new Promise((a, s) => {
          i.on("error", s),
            i.once("drain", () => {
              i.removeListener("error", s), a();
            });
        });
  }
}
Us.DataSplitter = LH;
var nc = {};
Object.defineProperty(nc, "__esModule", { value: !0 });
nc.checkIsRangesSupported = nc.executeTasksUsingMultipleRangeRequests = void 0;
const h0 = Ln(),
  Zw = Us,
  ex = Ep;
function BH(e, t, n, r, i) {
  const a = (s) => {
    if (s >= t.length) {
      e.fileMetadataBuffer != null && n.write(e.fileMetadataBuffer), n.end();
      return;
    }
    const o = s + 1e3;
    UH(
      e,
      { tasks: t, start: s, end: Math.min(t.length, o), oldFileFd: r },
      n,
      () => a(o),
      i,
    );
  };
  return a;
}
nc.executeTasksUsingMultipleRangeRequests = BH;
function UH(e, t, n, r, i) {
  let a = "bytes=",
    s = 0;
  const o = new Map(),
    c = [];
  for (let u = t.start; u < t.end; u++) {
    const d = t.tasks[u];
    d.kind === ex.OperationKind.DOWNLOAD &&
      ((a += `${d.start}-${d.end - 1}, `),
      o.set(s, u),
      s++,
      c.push(d.end - d.start));
  }
  if (s <= 1) {
    const u = (d) => {
      if (d >= t.end) {
        r();
        return;
      }
      const p = t.tasks[d++];
      if (p.kind === ex.OperationKind.COPY)
        (0, Zw.copyData)(p, n, t.oldFileFd, i, () => u(d));
      else {
        const h = e.createRequestOptions();
        h.headers.Range = `bytes=${p.start}-${p.end - 1}`;
        const m = e.httpExecutor.createRequest(h, (g) => {
          m0(g, i) && (g.pipe(n, { end: !1 }), g.once("end", () => u(d)));
        });
        e.httpExecutor.addErrorAndTimeoutHandlers(m, i), m.end();
      }
    };
    u(t.start);
    return;
  }
  const l = e.createRequestOptions();
  l.headers.Range = a.substring(0, a.length - 2);
  const f = e.httpExecutor.createRequest(l, (u) => {
    if (!m0(u, i)) return;
    const d = (0, h0.safeGetHeader)(u, "content-type"),
      p = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(d);
    if (p == null) {
      i(
        new Error(
          `Content-Type "multipart/byteranges" is expected, but got "${d}"`,
        ),
      );
      return;
    }
    const h = new Zw.DataSplitter(n, t, o, p[1] || p[2], c, r);
    h.on("error", i),
      u.pipe(h),
      u.on("end", () => {
        setTimeout(() => {
          f.abort(), i(new Error("Response ends without calling any handlers"));
        }, 1e4);
      });
  });
  e.httpExecutor.addErrorAndTimeoutHandlers(f, i), f.end();
}
function m0(e, t) {
  if (e.statusCode >= 400) return t((0, h0.createHttpError)(e)), !1;
  if (e.statusCode !== 206) {
    const n = (0, h0.safeGetHeader)(e, "accept-ranges");
    if (n == null || n === "none")
      return (
        t(
          new Error(
            `Server doesn't support Accept-Ranges (response code ${e.statusCode})`,
          ),
        ),
        !1
      );
  }
  return !0;
}
nc.checkIsRangesSupported = m0;
var wp = {};
Object.defineProperty(wp, "__esModule", { value: !0 });
wp.ProgressDifferentialDownloadCallbackTransform = void 0;
const FH = Kr;
var Ro;
(function (e) {
  (e[(e.COPY = 0)] = "COPY"), (e[(e.DOWNLOAD = 1)] = "DOWNLOAD");
})(Ro || (Ro = {}));
class jH extends FH.Transform {
  constructor(t, n, r) {
    super(),
      (this.progressDifferentialDownloadInfo = t),
      (this.cancellationToken = n),
      (this.onProgress = r),
      (this.start = Date.now()),
      (this.transferred = 0),
      (this.delta = 0),
      (this.expectedBytes = 0),
      (this.index = 0),
      (this.operationType = Ro.COPY),
      (this.nextUpdate = this.start + 1e3);
  }
  _transform(t, n, r) {
    if (this.cancellationToken.cancelled) {
      r(new Error("cancelled"), null);
      return;
    }
    if (this.operationType == Ro.COPY) {
      r(null, t);
      return;
    }
    (this.transferred += t.length), (this.delta += t.length);
    const i = Date.now();
    i >= this.nextUpdate &&
      this.transferred !== this.expectedBytes &&
      this.transferred !== this.progressDifferentialDownloadInfo.grandTotal &&
      ((this.nextUpdate = i + 1e3),
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent:
          (this.transferred /
            this.progressDifferentialDownloadInfo.grandTotal) *
          100,
        bytesPerSecond: Math.round(this.transferred / ((i - this.start) / 1e3)),
      }),
      (this.delta = 0)),
      r(null, t);
  }
  beginFileCopy() {
    this.operationType = Ro.COPY;
  }
  beginRangeDownload() {
    (this.operationType = Ro.DOWNLOAD),
      (this.expectedBytes +=
        this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++]);
  }
  endRangeDownload() {
    this.transferred !== this.progressDifferentialDownloadInfo.grandTotal &&
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent:
          (this.transferred /
            this.progressDifferentialDownloadInfo.grandTotal) *
          100,
        bytesPerSecond: Math.round(
          this.transferred / ((Date.now() - this.start) / 1e3),
        ),
      });
  }
  _flush(t) {
    if (this.cancellationToken.cancelled) {
      t(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: 100,
      bytesPerSecond: Math.round(
        this.transferred / ((Date.now() - this.start) / 1e3),
      ),
    }),
      (this.delta = 0),
      (this.transferred = 0),
      t(null);
  }
}
wp.ProgressDifferentialDownloadCallbackTransform = jH;
Object.defineProperty(ou, "__esModule", { value: !0 });
ou.DifferentialDownloader = void 0;
const jc = Ln(),
  Im = Za,
  MH = Xt,
  HH = Us,
  qH = Ya,
  pf = Ep,
  tx = nc,
  GH = wp;
class QH {
  constructor(t, n, r) {
    (this.blockAwareFileInfo = t),
      (this.httpExecutor = n),
      (this.options = r),
      (this.fileMetadataBuffer = null),
      (this.logger = r.logger);
  }
  createRequestOptions() {
    const t = { headers: { ...this.options.requestHeaders, accept: "*/*" } };
    return (
      (0, jc.configureRequestUrl)(this.options.newUrl, t),
      (0, jc.configureRequestOptions)(t),
      t
    );
  }
  doDownload(t, n) {
    if (t.version !== n.version)
      throw new Error(
        `version is different (${t.version} - ${n.version}), full download is required`,
      );
    const r = this.logger,
      i = (0, pf.computeOperations)(t, n, r);
    r.debug != null && r.debug(JSON.stringify(i, null, 2));
    let a = 0,
      s = 0;
    for (const c of i) {
      const l = c.end - c.start;
      c.kind === pf.OperationKind.DOWNLOAD ? (a += l) : (s += l);
    }
    const o = this.blockAwareFileInfo.size;
    if (
      a +
        s +
        (this.fileMetadataBuffer == null
          ? 0
          : this.fileMetadataBuffer.length) !==
      o
    )
      throw new Error(
        `Internal error, size mismatch: downloadSize: ${a}, copySize: ${s}, newSize: ${o}`,
      );
    return (
      r.info(
        `Full: ${nx(o)}, To download: ${nx(a)} (${Math.round(a / (o / 100))}%)`,
      ),
      this.downloadFile(i)
    );
  }
  downloadFile(t) {
    const n = [],
      r = () =>
        Promise.all(
          n.map((i) =>
            (0, Im.close)(i.descriptor).catch((a) => {
              this.logger.error(`cannot close file "${i.path}": ${a}`);
            }),
          ),
        );
    return this.doDownloadFile(t, n)
      .then(r)
      .catch((i) =>
        r()
          .catch((a) => {
            try {
              this.logger.error(`cannot close files: ${a}`);
            } catch (s) {
              try {
                console.error(s);
              } catch {}
            }
            throw i;
          })
          .then(() => {
            throw i;
          }),
      );
  }
  async doDownloadFile(t, n) {
    const r = await (0, Im.open)(this.options.oldFile, "r");
    n.push({ descriptor: r, path: this.options.oldFile });
    const i = await (0, Im.open)(this.options.newFile, "w");
    n.push({ descriptor: i, path: this.options.newFile });
    const a = (0, MH.createWriteStream)(this.options.newFile, { fd: i });
    await new Promise((s, o) => {
      const c = [];
      let l;
      if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
        const v = [];
        let y = 0;
        for (const E of t)
          E.kind === pf.OperationKind.DOWNLOAD &&
            (v.push(E.end - E.start), (y += E.end - E.start));
        const _ = { expectedByteCounts: v, grandTotal: y };
        (l = new GH.ProgressDifferentialDownloadCallbackTransform(
          _,
          this.options.cancellationToken,
          this.options.onProgress,
        )),
          c.push(l);
      }
      const f = new jc.DigestTransform(this.blockAwareFileInfo.sha512);
      (f.isValidateOnEnd = !1),
        c.push(f),
        a.on("finish", () => {
          a.close(() => {
            n.splice(1, 1);
            try {
              f.validate();
            } catch (v) {
              o(v);
              return;
            }
            s(void 0);
          });
        }),
        c.push(a);
      let u = null;
      for (const v of c)
        v.on("error", o), u == null ? (u = v) : (u = u.pipe(v));
      const d = c[0];
      let p;
      if (this.options.isUseMultipleRangeRequest) {
        (p = (0, tx.executeTasksUsingMultipleRangeRequests)(this, t, d, r, o)),
          p(0);
        return;
      }
      let h = 0,
        m = null;
      this.logger.info(`Differential download: ${this.options.newUrl}`);
      const g = this.createRequestOptions();
      (g.redirect = "manual"),
        (p = (v) => {
          var y, _;
          if (v >= t.length) {
            this.fileMetadataBuffer != null && d.write(this.fileMetadataBuffer),
              d.end();
            return;
          }
          const E = t[v++];
          if (E.kind === pf.OperationKind.COPY) {
            l && l.beginFileCopy(), (0, HH.copyData)(E, d, r, o, () => p(v));
            return;
          }
          const R = `bytes=${E.start}-${E.end - 1}`;
          (g.headers.range = R),
            (_ =
              (y = this.logger) === null || y === void 0 ? void 0 : y.debug) ===
              null ||
              _ === void 0 ||
              _.call(y, `download range: ${R}`),
            l && l.beginRangeDownload();
          const A = this.httpExecutor.createRequest(g, (I) => {
            I.on("error", o),
              I.on("abort", () => {
                o(new Error("response has been aborted by the server"));
              }),
              I.statusCode >= 400 && o((0, jc.createHttpError)(I)),
              I.pipe(d, { end: !1 }),
              I.once("end", () => {
                l && l.endRangeDownload(),
                  ++h === 100 ? ((h = 0), setTimeout(() => p(v), 1e3)) : p(v);
              });
          });
          A.on("redirect", (I, S, w) => {
            this.logger.info(`Redirect to ${WH(w)}`),
              (m = w),
              (0, jc.configureRequestUrl)(new qH.URL(m), g),
              A.followRedirect();
          }),
            this.httpExecutor.addErrorAndTimeoutHandlers(A, o),
            A.end();
        }),
        p(0);
    });
  }
  async readRemoteBytes(t, n) {
    const r = Buffer.allocUnsafe(n + 1 - t),
      i = this.createRequestOptions();
    i.headers.range = `bytes=${t}-${n}`;
    let a = 0;
    if (
      (await this.request(i, (s) => {
        s.copy(r, a), (a += s.length);
      }),
      a !== r.length)
    )
      throw new Error(
        `Received data length ${a} is not equal to expected ${r.length}`,
      );
    return r;
  }
  request(t, n) {
    return new Promise((r, i) => {
      const a = this.httpExecutor.createRequest(t, (s) => {
        (0, tx.checkIsRangesSupported)(s, i) &&
          (s.on("data", n), s.on("end", () => r()));
      });
      this.httpExecutor.addErrorAndTimeoutHandlers(a, i), a.end();
    });
  }
}
ou.DifferentialDownloader = QH;
function nx(e, t = " KB") {
  return new Intl.NumberFormat("en").format((e / 1024).toFixed(2)) + t;
}
function WH(e) {
  const t = e.indexOf("?");
  return t < 0 ? e : e.substring(0, t);
}
Object.defineProperty(su, "__esModule", { value: !0 });
su.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
const lo = Za,
  zH = ou,
  KH = mc;
class VH extends zH.DifferentialDownloader {
  async download() {
    const t = this.blockAwareFileInfo,
      n = t.size,
      r = n - (t.blockMapSize + 4);
    this.fileMetadataBuffer = await this.readRemoteBytes(r, n - 1);
    const i = JC(
      this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4),
    );
    await this.doDownload(await YH(this.options.oldFile), i);
  }
}
su.FileWithEmbeddedBlockMapDifferentialDownloader = VH;
function JC(e) {
  return JSON.parse((0, KH.inflateRawSync)(e).toString());
}
async function YH(e) {
  const t = await (0, lo.open)(e, "r");
  try {
    const n = (await (0, lo.fstat)(t)).size,
      r = Buffer.allocUnsafe(4);
    await (0, lo.read)(t, r, 0, r.length, n - r.length);
    const i = Buffer.allocUnsafe(r.readUInt32BE(0));
    return (
      await (0, lo.read)(t, i, 0, i.length, n - r.length - i.length),
      await (0, lo.close)(t),
      JC(i)
    );
  } catch (n) {
    throw (await (0, lo.close)(t), n);
  }
}
var rx;
function ix() {
  if (rx) return Uc;
  (rx = 1),
    Object.defineProperty(Uc, "__esModule", { value: !0 }),
    (Uc.AppImageUpdater = void 0);
  const e = Ln(),
    t = Ql,
    n = Za,
    r = Xt,
    i = pt,
    a = _p(),
    s = su,
    o = xc(),
    c = In;
  let l = class extends a.BaseUpdater {
    constructor(u, d) {
      super(u, d);
    }
    isUpdaterActive() {
      return process.env.APPIMAGE == null
        ? (process.env.SNAP == null
            ? this._logger.warn(
                "APPIMAGE env is not defined, current application is not an AppImage",
              )
            : this._logger.info("SNAP env is defined, updater is disabled"),
          !1)
        : super.isUpdaterActive();
    }
    doDownloadUpdate(u) {
      const d = u.updateInfoAndProvider.provider,
        p = (0, c.findFile)(
          d.resolveFiles(u.updateInfoAndProvider.info),
          "AppImage",
          ["rpm", "deb"],
        );
      return this.executeDownload({
        fileExtension: "AppImage",
        fileInfo: p,
        downloadUpdateOptions: u,
        task: async (h, m) => {
          const g = process.env.APPIMAGE;
          if (g == null)
            throw (0, e.newError)(
              "APPIMAGE env is not defined",
              "ERR_UPDATER_OLD_FILE_NOT_FOUND",
            );
          let v = !1;
          try {
            const y = {
              newUrl: p.url,
              oldFile: g,
              logger: this._logger,
              newFile: h,
              isUseMultipleRangeRequest: d.isUseMultipleRangeRequest,
              requestHeaders: u.requestHeaders,
              cancellationToken: u.cancellationToken,
            };
            this.listenerCount(o.DOWNLOAD_PROGRESS) > 0 &&
              (y.onProgress = (_) => this.emit(o.DOWNLOAD_PROGRESS, _)),
              await new s.FileWithEmbeddedBlockMapDifferentialDownloader(
                p.info,
                this.httpExecutor,
                y,
              ).download();
          } catch (y) {
            this._logger.error(
              `Cannot download differentially, fallback to full download: ${
                y.stack || y
              }`,
            ),
              (v = process.platform === "linux");
          }
          v && (await this.httpExecutor.download(p.url, h, m)),
            await (0, n.chmod)(h, 493);
        },
      });
    }
    doInstall(u) {
      const d = process.env.APPIMAGE;
      if (d == null)
        throw (0, e.newError)(
          "APPIMAGE env is not defined",
          "ERR_UPDATER_OLD_FILE_NOT_FOUND",
        );
      (0, r.unlinkSync)(d);
      let p;
      const h = i.basename(d);
      i.basename(u.installerPath) === h || !/\d+\.\d+\.\d+/.test(h)
        ? (p = d)
        : (p = i.join(i.dirname(d), i.basename(u.installerPath))),
        (0, t.execFileSync)("mv", ["-f", u.installerPath, p]),
        p !== d && this.emit("appimage-filename-updated", p);
      const m = { ...process.env, APPIMAGE_SILENT_INSTALL: "true" };
      return (
        u.isForceRunAfter
          ? this.spawnLog(p, [], m)
          : ((m.APPIMAGE_EXIT_AFTER_INSTALL = "true"),
            (0, t.execFileSync)(p, [], { env: m })),
        !0
      );
    }
  };
  return (Uc.AppImageUpdater = l), Uc;
}
var Mc = {},
  ax;
function sx() {
  if (ax) return Mc;
  (ax = 1),
    Object.defineProperty(Mc, "__esModule", { value: !0 }),
    (Mc.DebUpdater = void 0);
  const e = _p(),
    t = xc(),
    n = In;
  let r = class extends e.BaseUpdater {
    constructor(a, s) {
      super(a, s);
    }
    doDownloadUpdate(a) {
      const s = a.updateInfoAndProvider.provider,
        o = (0, n.findFile)(
          s.resolveFiles(a.updateInfoAndProvider.info),
          "deb",
          ["AppImage", "rpm"],
        );
      return this.executeDownload({
        fileExtension: "deb",
        fileInfo: o,
        downloadUpdateOptions: a,
        task: async (c, l) => {
          this.listenerCount(t.DOWNLOAD_PROGRESS) > 0 &&
            (l.onProgress = (f) => this.emit(t.DOWNLOAD_PROGRESS, f)),
            await this.httpExecutor.download(o.url, c, l);
        },
      });
    }
    doInstall(a) {
      const s = this.wrapSudo(),
        o = /pkexec/i.test(s) ? "" : '"',
        c = [
          "dpkg",
          "-i",
          a.installerPath,
          "||",
          "apt-get",
          "install",
          "-f",
          "-y",
        ];
      return (
        this.spawnSyncLog(s, [`${o}/bin/bash`, "-c", `'${c.join(" ")}'${o}`]),
        a.isForceRunAfter && this.app.relaunch(),
        !0
      );
    }
  };
  return (Mc.DebUpdater = r), Mc;
}
var Hc = {},
  ox;
function cx() {
  if (ox) return Hc;
  (ox = 1),
    Object.defineProperty(Hc, "__esModule", { value: !0 }),
    (Hc.RpmUpdater = void 0);
  const e = _p(),
    t = xc(),
    n = In;
  let r = class extends e.BaseUpdater {
    constructor(a, s) {
      super(a, s);
    }
    doDownloadUpdate(a) {
      const s = a.updateInfoAndProvider.provider,
        o = (0, n.findFile)(
          s.resolveFiles(a.updateInfoAndProvider.info),
          "rpm",
          ["AppImage", "deb"],
        );
      return this.executeDownload({
        fileExtension: "rpm",
        fileInfo: o,
        downloadUpdateOptions: a,
        task: async (c, l) => {
          this.listenerCount(t.DOWNLOAD_PROGRESS) > 0 &&
            (l.onProgress = (f) => this.emit(t.DOWNLOAD_PROGRESS, f)),
            await this.httpExecutor.download(o.url, c, l);
        },
      });
    }
    doInstall(a) {
      const s = a.installerPath,
        o = this.wrapSudo(),
        c = /pkexec/i.test(o) ? "" : '"',
        l = this.spawnSyncLog("which zypper");
      let f;
      if (l)
        f = [
          l,
          "remove",
          "-y",
          `'${this.app.name}'`,
          ";",
          l,
          "clean",
          "--all",
          ";",
          l,
          "--no-refresh",
          "install",
          "--allow-unsigned-rpm",
          "-y",
          "-f",
          s,
        ];
      else {
        const u = this.spawnSyncLog("which dnf || which yum");
        f = [
          u,
          "-y",
          "remove",
          `'${this.app.name}'`,
          ";",
          u,
          "-y",
          "install",
          s,
        ];
      }
      return (
        this.spawnSyncLog(o, [`${c}/bin/bash`, "-c", `'${f.join(" ")}'${c}`]),
        a.isForceRunAfter && this.app.relaunch(),
        !0
      );
    }
  };
  return (Hc.RpmUpdater = r), Hc;
}
var qc = {},
  lx;
function ux() {
  if (lx) return qc;
  (lx = 1),
    Object.defineProperty(qc, "__esModule", { value: !0 }),
    (qc.MacUpdater = void 0);
  const e = Ln(),
    t = Za,
    n = Xt,
    r = Ws,
    i = ty(),
    a = In,
    s = Ql,
    o = pr;
  let c = class extends i.AppUpdater {
    constructor(f, u) {
      super(f, u),
        (this.nativeUpdater = xe.autoUpdater),
        (this.squirrelDownloadedUpdate = !1),
        this.nativeUpdater.on("error", (d) => {
          this._logger.warn(d), this.emit("error", d);
        }),
        this.nativeUpdater.on("update-downloaded", () => {
          this.squirrelDownloadedUpdate = !0;
        });
    }
    debug(f) {
      this._logger.debug != null && this._logger.debug(f);
    }
    async doDownloadUpdate(f) {
      let u = f.updateInfoAndProvider.provider.resolveFiles(
        f.updateInfoAndProvider.info,
      );
      const d = this._logger,
        p = "sysctl.proc_translated";
      let h = !1;
      try {
        this.debug("Checking for macOS Rosetta environment"),
          (h = (0, s.execFileSync)("sysctl", [p], {
            encoding: "utf8",
          }).includes(`${p}: 1`)),
          d.info(`Checked for macOS Rosetta environment (isRosetta=${h})`);
      } catch (y) {
        d.warn(
          `sysctl shell command to check for macOS Rosetta environment failed: ${y}`,
        );
      }
      let m = !1;
      try {
        this.debug("Checking for arm64 in uname");
        const _ = (0, s.execFileSync)("uname", ["-a"], {
          encoding: "utf8",
        }).includes("ARM");
        d.info(`Checked 'uname -a': arm64=${_}`), (m = m || _);
      } catch (y) {
        d.warn(`uname shell command to check for arm64 failed: ${y}`);
      }
      m = m || process.arch === "arm64" || h;
      const g = (y) => {
        var _;
        return (
          y.url.pathname.includes("arm64") ||
          ((_ = y.info.url) === null || _ === void 0
            ? void 0
            : _.includes("arm64"))
        );
      };
      m && u.some(g)
        ? (u = u.filter((y) => m === g(y)))
        : (u = u.filter((y) => !g(y)));
      const v = (0, a.findFile)(u, "zip", ["pkg", "dmg"]);
      if (v == null)
        throw (0, e.newError)(
          `ZIP file not provided: ${(0, e.safeStringifyJson)(u)}`,
          "ERR_UPDATER_ZIP_FILE_NOT_FOUND",
        );
      return this.executeDownload({
        fileExtension: "zip",
        fileInfo: v,
        downloadUpdateOptions: f,
        task: (y, _) => this.httpExecutor.download(v.url, y, _),
        done: (y) => this.updateDownloaded(v, y),
      });
    }
    async updateDownloaded(f, u) {
      var d, p;
      const h = u.downloadedFile,
        m =
          (d = f.info.size) !== null && d !== void 0
            ? d
            : (await (0, t.stat)(h)).size,
        g = this._logger,
        v = `fileToProxy=${f.url.href}`;
      this.debug(`Creating proxy server for native Squirrel.Mac (${v})`),
        (p = this.server) === null || p === void 0 || p.close(),
        (this.server = (0, r.createServer)()),
        this.debug(`Proxy server for native Squirrel.Mac is created (${v})`),
        this.server.on("close", () => {
          g.info(`Proxy server for native Squirrel.Mac is closed (${v})`);
        });
      const y = (_) => {
        const E = _.address();
        return typeof E == "string"
          ? E
          : `http://127.0.0.1:${E == null ? void 0 : E.port}`;
      };
      return await new Promise((_, E) => {
        const R = (0, o.randomBytes)(64)
            .toString("base64")
            .replace(/\//g, "_")
            .replace(/\+/g, "-"),
          A = Buffer.from(`autoupdater:${R}`, "ascii"),
          I = `/${(0, o.randomBytes)(64).toString("hex")}.zip`;
        this.server.on("request", (S, w) => {
          const O = S.url;
          if ((g.info(`${O} requested`), O === "/")) {
            if (
              !S.headers.authorization ||
              S.headers.authorization.indexOf("Basic ") === -1
            ) {
              (w.statusCode = 401),
                (w.statusMessage = "Invalid Authentication Credentials"),
                w.end(),
                g.warn("No authenthication info");
              return;
            }
            const H = S.headers.authorization.split(" ")[1],
              q = Buffer.from(H, "base64").toString("ascii"),
              [J, Z] = q.split(":");
            if (J !== "autoupdater" || Z !== R) {
              (w.statusCode = 401),
                (w.statusMessage = "Invalid Authentication Credentials"),
                w.end(),
                g.warn("Invalid authenthication credentials");
              return;
            }
            const z = Buffer.from(`{ "url": "${y(this.server)}${I}" }`);
            w.writeHead(200, {
              "Content-Type": "application/json",
              "Content-Length": z.length,
            }),
              w.end(z);
            return;
          }
          if (!O.startsWith(I)) {
            g.warn(`${O} requested, but not supported`),
              w.writeHead(404),
              w.end();
            return;
          }
          g.info(`${I} requested by Squirrel.Mac, pipe ${h}`);
          let Q = !1;
          w.on("finish", () => {
            Q || (this.nativeUpdater.removeListener("error", E), _([]));
          });
          const j = (0, n.createReadStream)(h);
          j.on("error", (H) => {
            try {
              w.end();
            } catch (q) {
              g.warn(`cannot end response: ${q}`);
            }
            (Q = !0),
              this.nativeUpdater.removeListener("error", E),
              E(new Error(`Cannot pipe "${h}": ${H}`));
          }),
            w.writeHead(200, {
              "Content-Type": "application/zip",
              "Content-Length": m,
            }),
            j.pipe(w);
        }),
          this.debug(
            `Proxy server for native Squirrel.Mac is starting to listen (${v})`,
          ),
          this.server.listen(0, "127.0.0.1", () => {
            this.debug(
              `Proxy server for native Squirrel.Mac is listening (address=${y(
                this.server,
              )}, ${v})`,
            ),
              this.nativeUpdater.setFeedURL({
                url: y(this.server),
                headers: {
                  "Cache-Control": "no-cache",
                  Authorization: `Basic ${A.toString("base64")}`,
                },
              }),
              this.dispatchUpdateDownloaded(u),
              this.autoInstallOnAppQuit
                ? (this.nativeUpdater.once("error", E),
                  this.nativeUpdater.checkForUpdates())
                : _([]);
          });
      });
    }
    quitAndInstall() {
      var f;
      this.squirrelDownloadedUpdate
        ? (this.nativeUpdater.quitAndInstall(),
          (f = this.server) === null || f === void 0 || f.close())
        : (this.nativeUpdater.on("update-downloaded", () => {
            var u;
            this.nativeUpdater.quitAndInstall(),
              (u = this.server) === null || u === void 0 || u.close();
          }),
          this.autoInstallOnAppQuit || this.nativeUpdater.checkForUpdates());
    }
  };
  return (qc.MacUpdater = c), qc;
}
var Gc = {},
  xp = {};
Object.defineProperty(xp, "__esModule", { value: !0 });
xp.GenericDifferentialDownloader = void 0;
const XH = ou;
class JH extends XH.DifferentialDownloader {
  download(t, n) {
    return this.doDownload(t, n);
  }
}
xp.GenericDifferentialDownloader = JH;
var Ap = {};
Object.defineProperty(Ap, "__esModule", { value: !0 });
Ap.verifySignature = void 0;
const fx = Ln(),
  ZC = Ql,
  ZH = Fr;
function eq(e, t, n) {
  return new Promise((r, i) => {
    const a = t.replace(/'/g, "''");
    (0, ZC.execFile)(
      "chcp 65001 >NUL & powershell.exe",
      [
        "-NoProfile",
        "-NonInteractive",
        "-InputFormat",
        "None",
        "-Command",
        `"Get-AuthenticodeSignature -LiteralPath '${a}' | ConvertTo-Json -Compress"`,
      ],
      { shell: !0, timeout: 20 * 1e3 },
      (s, o, c) => {
        try {
          if (s != null || c) {
            dx(n, s, c, i), r(null);
            return;
          }
          const l = tq(o);
          if (l.Status === 0) {
            const u = (0, fx.parseDn)(l.SignerCertificate.Subject);
            let d = !1;
            for (const p of e) {
              const h = (0, fx.parseDn)(p);
              if (
                (h.size
                  ? (d = Array.from(h.keys()).every(
                      (g) => h.get(g) === u.get(g),
                    ))
                  : p === u.get("CN") &&
                    (n.warn(
                      `Signature validated using only CN ${p}. Please add your full Distinguished Name (DN) to publisherNames configuration`,
                    ),
                    (d = !0)),
                d)
              ) {
                r(null);
                return;
              }
            }
          }
          const f =
            `publisherNames: ${e.join(" | ")}, raw info: ` +
            JSON.stringify(l, (u, d) => (u === "RawData" ? void 0 : d), 2);
          n.warn(
            `Sign verification failed, installer signed with incorrect certificate: ${f}`,
          ),
            r(f);
        } catch (l) {
          dx(n, l, null, i), r(null);
          return;
        }
      },
    );
  });
}
Ap.verifySignature = eq;
function tq(e) {
  const t = JSON.parse(e);
  delete t.PrivateKey, delete t.IsOSBinary, delete t.SignatureType;
  const n = t.SignerCertificate;
  return (
    n != null &&
      (delete n.Archived,
      delete n.Extensions,
      delete n.Handle,
      delete n.HasPrivateKey,
      delete n.SubjectName),
    delete t.Path,
    t
  );
}
function dx(e, t, n, r) {
  if (nq()) {
    e.warn(
      `Cannot execute Get-AuthenticodeSignature: ${
        t || n
      }. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`,
    );
    return;
  }
  try {
    (0, ZC.execFileSync)(
      "powershell.exe",
      ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"],
      { timeout: 10 * 1e3 },
    );
  } catch (i) {
    e.warn(
      `Cannot execute ConvertTo-Json: ${i.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`,
    );
    return;
  }
  t != null && r(t),
    n &&
      r(
        new Error(
          `Cannot execute Get-AuthenticodeSignature, stderr: ${n}. Failing signature validation due to unknown stderr.`,
        ),
      );
}
function nq() {
  const e = ZH.release();
  return e.startsWith("6.") && !e.startsWith("6.3");
}
var px;
function hx() {
  if (px) return Gc;
  (px = 1),
    Object.defineProperty(Gc, "__esModule", { value: !0 }),
    (Gc.NsisUpdater = void 0);
  const e = Ln(),
    t = pt,
    n = _p(),
    r = su,
    i = xp,
    a = xc(),
    s = fr,
    o = In,
    c = Za,
    l = Ap,
    f = Ya,
    u = mc;
  let d = class extends n.BaseUpdater {
    constructor(h, m) {
      super(h, m),
        (this._verifyUpdateCodeSignature = (g, v) =>
          (0, l.verifySignature)(g, v, this._logger));
    }
    get verifyUpdateCodeSignature() {
      return this._verifyUpdateCodeSignature;
    }
    set verifyUpdateCodeSignature(h) {
      h && (this._verifyUpdateCodeSignature = h);
    }
    doDownloadUpdate(h) {
      const m = h.updateInfoAndProvider.provider,
        g = (0, o.findFile)(
          m.resolveFiles(h.updateInfoAndProvider.info),
          "exe",
        );
      return this.executeDownload({
        fileExtension: "exe",
        downloadUpdateOptions: h,
        fileInfo: g,
        task: async (v, y, _, E) => {
          const R = g.packageInfo,
            A = R != null && _ != null;
          if (A && h.disableWebInstaller)
            throw (0, e.newError)(
              `Unable to download new version ${h.updateInfoAndProvider.info.version}. Web Installers are disabled`,
              "ERR_UPDATER_WEB_INSTALLER_DISABLED",
            );
          !A &&
            !h.disableWebInstaller &&
            this._logger.warn(
              "disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version.",
            ),
            (A || (await this.differentialDownloadInstaller(g, h, v, m))) &&
              (await this.httpExecutor.download(g.url, v, y));
          const I = await this.verifySignature(v);
          if (I != null)
            throw (
              (await E(),
              (0, e.newError)(
                `New version ${h.updateInfoAndProvider.info.version} is not signed by the application owner: ${I}`,
                "ERR_UPDATER_INVALID_SIGNATURE",
              ))
            );
          if (A && (await this.differentialDownloadWebPackage(h, R, _, m)))
            try {
              await this.httpExecutor.download(new f.URL(R.path), _, {
                headers: h.requestHeaders,
                cancellationToken: h.cancellationToken,
                sha512: R.sha512,
              });
            } catch (S) {
              try {
                await (0, c.unlink)(_);
              } catch {}
              throw S;
            }
        },
      });
    }
    async verifySignature(h) {
      let m;
      try {
        if (((m = (await this.configOnDisk.value).publisherName), m == null))
          return null;
      } catch (g) {
        if (g.code === "ENOENT") return null;
        throw g;
      }
      return await this._verifyUpdateCodeSignature(
        Array.isArray(m) ? m : [m],
        h,
      );
    }
    doInstall(h) {
      const m = ["--updated"];
      h.isSilent && m.push("/S"),
        h.isForceRunAfter && m.push("--force-run"),
        this.installDirectory && m.push(`/D=${this.installDirectory}`);
      const g =
        this.downloadedUpdateHelper == null
          ? null
          : this.downloadedUpdateHelper.packageFile;
      g != null && m.push(`--package-file=${g}`);
      const v = () => {
        this.spawnLog(
          t.join(process.resourcesPath, "elevate.exe"),
          [h.installerPath].concat(m),
        ).catch((y) => this.dispatchError(y));
      };
      return h.isAdminRightsRequired
        ? (this._logger.info(
            "isAdminRightsRequired is set to true, run installer using elevate.exe",
          ),
          v(),
          !0)
        : (this.spawnLog(h.installerPath, m).catch((y) => {
            const _ = y.code;
            this._logger.info(
              `Cannot run installer: error code: ${_}, error message: "${y.message}", will be executed again using elevate if EACCES"`,
            ),
              _ === "UNKNOWN" || _ === "EACCES" ? v() : this.dispatchError(y);
          }),
          !0);
    }
    async differentialDownloadInstaller(h, m, g, v) {
      try {
        if (
          this._testOnlyOptions != null &&
          !this._testOnlyOptions.isUseDifferentialDownload
        )
          return !0;
        const y = (0, s.blockmapFiles)(
          h.url,
          this.app.version,
          m.updateInfoAndProvider.info.version,
        );
        this._logger.info(`Download block maps (old: "${y[0]}", new: ${y[1]})`);
        const _ = async (A) => {
            const I = await this.httpExecutor.downloadToBuffer(A, {
              headers: m.requestHeaders,
              cancellationToken: m.cancellationToken,
            });
            if (I == null || I.length === 0)
              throw new Error(`Blockmap "${A.href}" is empty`);
            try {
              return JSON.parse((0, u.gunzipSync)(I).toString());
            } catch (S) {
              throw new Error(`Cannot parse blockmap "${A.href}", error: ${S}`);
            }
          },
          E = {
            newUrl: h.url,
            oldFile: t.join(
              this.downloadedUpdateHelper.cacheDir,
              e.CURRENT_APP_INSTALLER_FILE_NAME,
            ),
            logger: this._logger,
            newFile: g,
            isUseMultipleRangeRequest: v.isUseMultipleRangeRequest,
            requestHeaders: m.requestHeaders,
            cancellationToken: m.cancellationToken,
          };
        this.listenerCount(a.DOWNLOAD_PROGRESS) > 0 &&
          (E.onProgress = (A) => this.emit(a.DOWNLOAD_PROGRESS, A));
        const R = await Promise.all(y.map((A) => _(A)));
        return (
          await new i.GenericDifferentialDownloader(
            h.info,
            this.httpExecutor,
            E,
          ).download(R[0], R[1]),
          !1
        );
      } catch (y) {
        if (
          (this._logger.error(
            `Cannot download differentially, fallback to full download: ${
              y.stack || y
            }`,
          ),
          this._testOnlyOptions != null)
        )
          throw y;
        return !0;
      }
    }
    async differentialDownloadWebPackage(h, m, g, v) {
      if (m.blockMapSize == null) return !0;
      try {
        const y = {
          newUrl: new f.URL(m.path),
          oldFile: t.join(
            this.downloadedUpdateHelper.cacheDir,
            e.CURRENT_APP_PACKAGE_FILE_NAME,
          ),
          logger: this._logger,
          newFile: g,
          requestHeaders: this.requestHeaders,
          isUseMultipleRangeRequest: v.isUseMultipleRangeRequest,
          cancellationToken: h.cancellationToken,
        };
        this.listenerCount(a.DOWNLOAD_PROGRESS) > 0 &&
          (y.onProgress = (_) => this.emit(a.DOWNLOAD_PROGRESS, _)),
          await new r.FileWithEmbeddedBlockMapDifferentialDownloader(
            m,
            this.httpExecutor,
            y,
          ).download();
      } catch (y) {
        return (
          this._logger.error(
            `Cannot download differentially, fallback to full download: ${
              y.stack || y
            }`,
          ),
          process.platform === "win32"
        );
      }
      return !1;
    }
  };
  return (Gc.NsisUpdater = d), Gc;
}
var mx;
function xc() {
  return (
    mx ||
      ((mx = 1),
      (function (e) {
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.UpdaterSignal =
            e.UPDATE_DOWNLOADED =
            e.DOWNLOAD_PROGRESS =
            e.NsisUpdater =
            e.MacUpdater =
            e.RpmUpdater =
            e.DebUpdater =
            e.AppImageUpdater =
            e.Provider =
            e.CancellationToken =
            e.NoOpLogger =
            e.AppUpdater =
              void 0);
        const t = Ln();
        Object.defineProperty(e, "CancellationToken", {
          enumerable: !0,
          get: function () {
            return t.CancellationToken;
          },
        });
        const n = Za,
          r = pt;
        var i = ty();
        Object.defineProperty(e, "AppUpdater", {
          enumerable: !0,
          get: function () {
            return i.AppUpdater;
          },
        }),
          Object.defineProperty(e, "NoOpLogger", {
            enumerable: !0,
            get: function () {
              return i.NoOpLogger;
            },
          });
        var a = In;
        Object.defineProperty(e, "Provider", {
          enumerable: !0,
          get: function () {
            return a.Provider;
          },
        });
        var s = ix();
        Object.defineProperty(e, "AppImageUpdater", {
          enumerable: !0,
          get: function () {
            return s.AppImageUpdater;
          },
        });
        var o = sx();
        Object.defineProperty(e, "DebUpdater", {
          enumerable: !0,
          get: function () {
            return o.DebUpdater;
          },
        });
        var c = cx();
        Object.defineProperty(e, "RpmUpdater", {
          enumerable: !0,
          get: function () {
            return c.RpmUpdater;
          },
        });
        var l = ux();
        Object.defineProperty(e, "MacUpdater", {
          enumerable: !0,
          get: function () {
            return l.MacUpdater;
          },
        });
        var f = hx();
        Object.defineProperty(e, "NsisUpdater", {
          enumerable: !0,
          get: function () {
            return f.NsisUpdater;
          },
        });
        let u;
        function d() {
          if (process.platform === "win32") u = new (hx().NsisUpdater)();
          else if (process.platform === "darwin") u = new (ux().MacUpdater)();
          else {
            u = new (ix().AppImageUpdater)();
            try {
              const m = r.join(process.resourcesPath, "package-type");
              if (!(0, n.existsSync)(m)) return u;
              console.info(
                "Checking for beta autoupdate feature for deb/rpm distributions",
              );
              const g = (0, n.readFileSync)(m).toString().trim();
              switch ((console.info("Found package-type:", g), g)) {
                case "deb":
                  u = new (sx().DebUpdater)();
                  break;
                case "rpm":
                  u = new (cx().RpmUpdater)();
                  break;
                default:
                  break;
              }
            } catch (m) {
              console.warn(
                "Unable to detect 'package-type' for autoUpdater (beta rpm/deb support). If you'd like to expand support, please consider contributing to electron-builder",
                m.message,
              );
            }
          }
          return u;
        }
        Object.defineProperty(e, "autoUpdater", {
          enumerable: !0,
          get: () => u || d(),
        }),
          (e.DOWNLOAD_PROGRESS = "download-progress"),
          (e.UPDATE_DOWNLOADED = "update-downloaded");
        class p {
          constructor(g) {
            this.emitter = g;
          }
          login(g) {
            h(this.emitter, "login", g);
          }
          progress(g) {
            h(this.emitter, e.DOWNLOAD_PROGRESS, g);
          }
          updateDownloaded(g) {
            h(this.emitter, e.UPDATE_DOWNLOADED, g);
          }
          updateCancelled(g) {
            h(this.emitter, "update-cancelled", g);
          }
        }
        e.UpdaterSignal = p;
        function h(m, g, v) {
          m.on(g, v);
        }
      })(Yh)),
    Yh
  );
}
var vs = xc(),
  g0 = { exports: {} },
  rq = (e) => {
    const t = typeof e;
    return e !== null && (t === "object" || t === "function");
  };
const ls = rq,
  iq = new Set(["__proto__", "prototype", "constructor"]),
  aq = (e) => !e.some((t) => iq.has(t));
function hf(e) {
  const t = e.split("."),
    n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r];
    for (; i[i.length - 1] === "\\" && t[r + 1] !== void 0; )
      (i = i.slice(0, -1) + "."), (i += t[++r]);
    n.push(i);
  }
  return aq(n) ? n : [];
}
var sq = {
    get(e, t, n) {
      if (!ls(e) || typeof t != "string") return n === void 0 ? e : n;
      const r = hf(t);
      if (r.length !== 0) {
        for (let i = 0; i < r.length; i++)
          if (((e = e[r[i]]), e == null)) {
            if (i !== r.length - 1) return n;
            break;
          }
        return e === void 0 ? n : e;
      }
    },
    set(e, t, n) {
      if (!ls(e) || typeof t != "string") return e;
      const r = e,
        i = hf(t);
      for (let a = 0; a < i.length; a++) {
        const s = i[a];
        ls(e[s]) || (e[s] = {}), a === i.length - 1 && (e[s] = n), (e = e[s]);
      }
      return r;
    },
    delete(e, t) {
      if (!ls(e) || typeof t != "string") return !1;
      const n = hf(t);
      for (let r = 0; r < n.length; r++) {
        const i = n[r];
        if (r === n.length - 1) return delete e[i], !0;
        if (((e = e[i]), !ls(e))) return !1;
      }
    },
    has(e, t) {
      if (!ls(e) || typeof t != "string") return !1;
      const n = hf(t);
      if (n.length === 0) return !1;
      for (let r = 0; r < n.length; r++)
        if (ls(e)) {
          if (!(n[r] in e)) return !1;
          e = e[n[r]];
        } else return !1;
      return !0;
    },
  },
  ny = { exports: {} },
  ry = { exports: {} },
  iy = { exports: {} },
  ay = { exports: {} };
const e4 = Xt;
ay.exports = (e) =>
  new Promise((t) => {
    e4.access(e, (n) => {
      t(!n);
    });
  });
ay.exports.sync = (e) => {
  try {
    return e4.accessSync(e), !0;
  } catch {
    return !1;
  }
};
var oq = ay.exports,
  sy = { exports: {} },
  oy = { exports: {} };
const t4 = (e, ...t) =>
  new Promise((n) => {
    n(e(...t));
  });
oy.exports = t4;
oy.exports.default = t4;
var cq = oy.exports;
const lq = cq,
  n4 = (e) => {
    if (!((Number.isInteger(e) || e === 1 / 0) && e > 0))
      return Promise.reject(
        new TypeError("Expected `concurrency` to be a number from 1 and up"),
      );
    const t = [];
    let n = 0;
    const r = () => {
        n--, t.length > 0 && t.shift()();
      },
      i = (o, c, ...l) => {
        n++;
        const f = lq(o, ...l);
        c(f), f.then(r, r);
      },
      a = (o, c, ...l) => {
        n < e ? i(o, c, ...l) : t.push(i.bind(null, o, c, ...l));
      },
      s = (o, ...c) => new Promise((l) => a(o, l, ...c));
    return (
      Object.defineProperties(s, {
        activeCount: { get: () => n },
        pendingCount: { get: () => t.length },
        clearQueue: {
          value: () => {
            t.length = 0;
          },
        },
      }),
      s
    );
  };
sy.exports = n4;
sy.exports.default = n4;
var uq = sy.exports;
const gx = uq;
class r4 extends Error {
  constructor(t) {
    super(), (this.value = t);
  }
}
const fq = (e, t) => Promise.resolve(e).then(t),
  dq = (e) =>
    Promise.all(e).then((t) => t[1] === !0 && Promise.reject(new r4(t[0])));
var pq = (e, t, n) => {
  n = Object.assign({ concurrency: 1 / 0, preserveOrder: !0 }, n);
  const r = gx(n.concurrency),
    i = [...e].map((s) => [s, r(fq, s, t)]),
    a = gx(n.preserveOrder ? 1 : 1 / 0);
  return Promise.all(i.map((s) => a(dq, s)))
    .then(() => {})
    .catch((s) => (s instanceof r4 ? s.value : Promise.reject(s)));
};
const i4 = pt,
  a4 = oq,
  hq = pq;
iy.exports = (e, t) => (
  (t = Object.assign({ cwd: process.cwd() }, t)),
  hq(e, (n) => a4(i4.resolve(t.cwd, n)), t)
);
iy.exports.sync = (e, t) => {
  t = Object.assign({ cwd: process.cwd() }, t);
  for (const n of e) if (a4.sync(i4.resolve(t.cwd, n))) return n;
};
var mq = iy.exports;
const Ba = pt,
  s4 = mq;
ry.exports = (e, t = {}) => {
  const n = Ba.resolve(t.cwd || ""),
    { root: r } = Ba.parse(n),
    i = [].concat(e);
  return new Promise((a) => {
    (function s(o) {
      s4(i, { cwd: o }).then((c) => {
        c ? a(Ba.join(o, c)) : o === r ? a(null) : s(Ba.dirname(o));
      });
    })(n);
  });
};
ry.exports.sync = (e, t = {}) => {
  let n = Ba.resolve(t.cwd || "");
  const { root: r } = Ba.parse(n),
    i = [].concat(e);
  for (;;) {
    const a = s4.sync(i, { cwd: n });
    if (a) return Ba.join(n, a);
    if (n === r) return null;
    n = Ba.dirname(n);
  }
};
var gq = ry.exports;
const o4 = gq;
ny.exports = async ({ cwd: e } = {}) => o4("package.json", { cwd: e });
ny.exports.sync = ({ cwd: e } = {}) => o4.sync("package.json", { cwd: e });
var vq = ny.exports,
  cy = { exports: {} };
const wn = pt,
  c4 = Fr,
  Na = c4.homedir(),
  ly = c4.tmpdir(),
  { env: ko } = process,
  yq = (e) => {
    const t = wn.join(Na, "Library");
    return {
      data: wn.join(t, "Application Support", e),
      config: wn.join(t, "Preferences", e),
      cache: wn.join(t, "Caches", e),
      log: wn.join(t, "Logs", e),
      temp: wn.join(ly, e),
    };
  },
  bq = (e) => {
    const t = ko.APPDATA || wn.join(Na, "AppData", "Roaming"),
      n = ko.LOCALAPPDATA || wn.join(Na, "AppData", "Local");
    return {
      data: wn.join(n, e, "Data"),
      config: wn.join(t, e, "Config"),
      cache: wn.join(n, e, "Cache"),
      log: wn.join(n, e, "Log"),
      temp: wn.join(ly, e),
    };
  },
  _q = (e) => {
    const t = wn.basename(Na);
    return {
      data: wn.join(ko.XDG_DATA_HOME || wn.join(Na, ".local", "share"), e),
      config: wn.join(ko.XDG_CONFIG_HOME || wn.join(Na, ".config"), e),
      cache: wn.join(ko.XDG_CACHE_HOME || wn.join(Na, ".cache"), e),
      log: wn.join(ko.XDG_STATE_HOME || wn.join(Na, ".local", "state"), e),
      temp: wn.join(ly, t, e),
    };
  },
  l4 = (e, t) => {
    if (typeof e != "string")
      throw new TypeError(`Expected string, got ${typeof e}`);
    return (
      (t = Object.assign({ suffix: "nodejs" }, t)),
      t.suffix && (e += `-${t.suffix}`),
      process.platform === "darwin"
        ? yq(e)
        : process.platform === "win32"
        ? bq(e)
        : _q(e)
    );
  };
cy.exports = l4;
cy.exports.default = l4;
var Eq = cy.exports,
  Ui = {},
  Gt = {};
Object.defineProperty(Gt, "__esModule", { value: !0 });
Gt.NOOP =
  Gt.LIMIT_FILES_DESCRIPTORS =
  Gt.LIMIT_BASENAME_LENGTH =
  Gt.IS_USER_ROOT =
  Gt.IS_POSIX =
  Gt.DEFAULT_TIMEOUT_SYNC =
  Gt.DEFAULT_TIMEOUT_ASYNC =
  Gt.DEFAULT_WRITE_OPTIONS =
  Gt.DEFAULT_READ_OPTIONS =
  Gt.DEFAULT_FOLDER_MODE =
  Gt.DEFAULT_FILE_MODE =
  Gt.DEFAULT_ENCODING =
    void 0;
const wq = "utf8";
Gt.DEFAULT_ENCODING = wq;
const xq = 438;
Gt.DEFAULT_FILE_MODE = xq;
const Aq = 511;
Gt.DEFAULT_FOLDER_MODE = Aq;
const Sq = {};
Gt.DEFAULT_READ_OPTIONS = Sq;
const Iq = {};
Gt.DEFAULT_WRITE_OPTIONS = Iq;
const $q = 5e3;
Gt.DEFAULT_TIMEOUT_ASYNC = $q;
const Cq = 100;
Gt.DEFAULT_TIMEOUT_SYNC = Cq;
const Rq = !!process.getuid;
Gt.IS_POSIX = Rq;
const kq = process.getuid ? !process.getuid() : !1;
Gt.IS_USER_ROOT = kq;
const Tq = 128;
Gt.LIMIT_BASENAME_LENGTH = Tq;
const Nq = 1e4;
Gt.LIMIT_FILES_DESCRIPTORS = Nq;
const Oq = () => {};
Gt.NOOP = Oq;
var Sp = {},
  rc = {};
Object.defineProperty(rc, "__esModule", { value: !0 });
rc.attemptifySync = rc.attemptifyAsync = void 0;
const u4 = Gt,
  Pq = (e, t = u4.NOOP) =>
    function () {
      return e.apply(void 0, arguments).catch(t);
    };
rc.attemptifyAsync = Pq;
const Dq = (e, t = u4.NOOP) =>
  function () {
    try {
      return e.apply(void 0, arguments);
    } catch (n) {
      return t(n);
    }
  };
rc.attemptifySync = Dq;
var uy = {};
Object.defineProperty(uy, "__esModule", { value: !0 });
const Lq = Gt,
  f4 = {
    isChangeErrorOk: (e) => {
      const { code: t } = e;
      return (
        t === "ENOSYS" ||
        (!Lq.IS_USER_ROOT && (t === "EINVAL" || t === "EPERM"))
      );
    },
    isRetriableError: (e) => {
      const { code: t } = e;
      return (
        t === "EMFILE" ||
        t === "ENFILE" ||
        t === "EAGAIN" ||
        t === "EBUSY" ||
        t === "EACCESS" ||
        t === "EACCS" ||
        t === "EPERM"
      );
    },
    onChangeError: (e) => {
      if (!f4.isChangeErrorOk(e)) throw e;
    },
  };
uy.default = f4;
var ic = {},
  fy = {};
Object.defineProperty(fy, "__esModule", { value: !0 });
const Bq = Gt,
  on = {
    interval: 25,
    intervalId: void 0,
    limit: Bq.LIMIT_FILES_DESCRIPTORS,
    queueActive: new Set(),
    queueWaiting: new Set(),
    init: () => {
      on.intervalId || (on.intervalId = setInterval(on.tick, on.interval));
    },
    reset: () => {
      on.intervalId && (clearInterval(on.intervalId), delete on.intervalId);
    },
    add: (e) => {
      on.queueWaiting.add(e),
        on.queueActive.size < on.limit / 2 ? on.tick() : on.init();
    },
    remove: (e) => {
      on.queueWaiting.delete(e), on.queueActive.delete(e);
    },
    schedule: () =>
      new Promise((e) => {
        const t = () => on.remove(n),
          n = () => e(t);
        on.add(n);
      }),
    tick: () => {
      if (!(on.queueActive.size >= on.limit)) {
        if (!on.queueWaiting.size) return on.reset();
        for (const e of on.queueWaiting) {
          if (on.queueActive.size >= on.limit) break;
          on.queueWaiting.delete(e), on.queueActive.add(e), e();
        }
      }
    },
  };
fy.default = on;
Object.defineProperty(ic, "__esModule", { value: !0 });
ic.retryifySync = ic.retryifyAsync = void 0;
const Uq = fy,
  Fq = (e, t) =>
    function (n) {
      return function r() {
        return Uq.default.schedule().then((i) =>
          e.apply(void 0, arguments).then(
            (a) => (i(), a),
            (a) => {
              if ((i(), Date.now() >= n)) throw a;
              if (t(a)) {
                const s = Math.round(100 + 400 * Math.random());
                return new Promise((c) => setTimeout(c, s)).then(() =>
                  r.apply(void 0, arguments),
                );
              }
              throw a;
            },
          ),
        );
      };
    };
ic.retryifyAsync = Fq;
const jq = (e, t) =>
  function (n) {
    return function r() {
      try {
        return e.apply(void 0, arguments);
      } catch (i) {
        if (Date.now() > n) throw i;
        if (t(i)) return r.apply(void 0, arguments);
        throw i;
      }
    };
  };
ic.retryifySync = jq;
Object.defineProperty(Sp, "__esModule", { value: !0 });
const Kt = Xt,
  gr = wr,
  vr = rc,
  Hn = uy,
  Rr = ic,
  Mq = {
    chmodAttempt: vr.attemptifyAsync(
      gr.promisify(Kt.chmod),
      Hn.default.onChangeError,
    ),
    chownAttempt: vr.attemptifyAsync(
      gr.promisify(Kt.chown),
      Hn.default.onChangeError,
    ),
    closeAttempt: vr.attemptifyAsync(gr.promisify(Kt.close)),
    fsyncAttempt: vr.attemptifyAsync(gr.promisify(Kt.fsync)),
    mkdirAttempt: vr.attemptifyAsync(gr.promisify(Kt.mkdir)),
    realpathAttempt: vr.attemptifyAsync(gr.promisify(Kt.realpath)),
    statAttempt: vr.attemptifyAsync(gr.promisify(Kt.stat)),
    unlinkAttempt: vr.attemptifyAsync(gr.promisify(Kt.unlink)),
    closeRetry: Rr.retryifyAsync(
      gr.promisify(Kt.close),
      Hn.default.isRetriableError,
    ),
    fsyncRetry: Rr.retryifyAsync(
      gr.promisify(Kt.fsync),
      Hn.default.isRetriableError,
    ),
    openRetry: Rr.retryifyAsync(
      gr.promisify(Kt.open),
      Hn.default.isRetriableError,
    ),
    readFileRetry: Rr.retryifyAsync(
      gr.promisify(Kt.readFile),
      Hn.default.isRetriableError,
    ),
    renameRetry: Rr.retryifyAsync(
      gr.promisify(Kt.rename),
      Hn.default.isRetriableError,
    ),
    statRetry: Rr.retryifyAsync(
      gr.promisify(Kt.stat),
      Hn.default.isRetriableError,
    ),
    writeRetry: Rr.retryifyAsync(
      gr.promisify(Kt.write),
      Hn.default.isRetriableError,
    ),
    chmodSyncAttempt: vr.attemptifySync(Kt.chmodSync, Hn.default.onChangeError),
    chownSyncAttempt: vr.attemptifySync(Kt.chownSync, Hn.default.onChangeError),
    closeSyncAttempt: vr.attemptifySync(Kt.closeSync),
    mkdirSyncAttempt: vr.attemptifySync(Kt.mkdirSync),
    realpathSyncAttempt: vr.attemptifySync(Kt.realpathSync),
    statSyncAttempt: vr.attemptifySync(Kt.statSync),
    unlinkSyncAttempt: vr.attemptifySync(Kt.unlinkSync),
    closeSyncRetry: Rr.retryifySync(Kt.closeSync, Hn.default.isRetriableError),
    fsyncSyncRetry: Rr.retryifySync(Kt.fsyncSync, Hn.default.isRetriableError),
    openSyncRetry: Rr.retryifySync(Kt.openSync, Hn.default.isRetriableError),
    readFileSyncRetry: Rr.retryifySync(
      Kt.readFileSync,
      Hn.default.isRetriableError,
    ),
    renameSyncRetry: Rr.retryifySync(
      Kt.renameSync,
      Hn.default.isRetriableError,
    ),
    statSyncRetry: Rr.retryifySync(Kt.statSync, Hn.default.isRetriableError),
    writeSyncRetry: Rr.retryifySync(Kt.writeSync, Hn.default.isRetriableError),
  };
Sp.default = Mq;
var dy = {};
Object.defineProperty(dy, "__esModule", { value: !0 });
const Hq = {
  isFunction: (e) => typeof e == "function",
  isString: (e) => typeof e == "string",
  isUndefined: (e) => typeof e > "u",
};
dy.default = Hq;
var py = {};
Object.defineProperty(py, "__esModule", { value: !0 });
const mf = {},
  v0 = {
    next: (e) => {
      const t = mf[e];
      if (!t) return;
      t.shift();
      const n = t[0];
      n ? n(() => v0.next(e)) : delete mf[e];
    },
    schedule: (e) =>
      new Promise((t) => {
        let n = mf[e];
        n || (n = mf[e] = []),
          n.push(t),
          !(n.length > 1) && t(() => v0.next(e));
      }),
  };
py.default = v0;
var hy = {};
Object.defineProperty(hy, "__esModule", { value: !0 });
const qq = pt,
  vx = Gt,
  yx = Sp,
  Qr = {
    store: {},
    create: (e) => {
      const t = `000000${Math.floor(Math.random() * 16777215).toString(
          16,
        )}`.slice(-6),
        n = Date.now().toString().slice(-10),
        r = "tmp-",
        i = `.${r}${n}${t}`;
      return `${e}${i}`;
    },
    get: (e, t, n = !0) => {
      const r = Qr.truncate(t(e));
      return r in Qr.store
        ? Qr.get(e, t, n)
        : ((Qr.store[r] = n), [r, () => delete Qr.store[r]]);
    },
    purge: (e) => {
      Qr.store[e] && (delete Qr.store[e], yx.default.unlinkAttempt(e));
    },
    purgeSync: (e) => {
      Qr.store[e] && (delete Qr.store[e], yx.default.unlinkSyncAttempt(e));
    },
    purgeSyncAll: () => {
      for (const e in Qr.store) Qr.purgeSync(e);
    },
    truncate: (e) => {
      const t = qq.basename(e);
      if (t.length <= vx.LIMIT_BASENAME_LENGTH) return e;
      const n = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(
        t,
      );
      if (!n) return e;
      const r = t.length - vx.LIMIT_BASENAME_LENGTH;
      return `${e.slice(0, -t.length)}${n[1]}${n[2].slice(0, -r)}${n[3]}`;
    },
  };
process.on("exit", Qr.purgeSyncAll);
hy.default = Qr;
Object.defineProperty(Ui, "__esModule", { value: !0 });
Ui.writeFileSync = Ui.writeFile = Ui.readFileSync = Ui.readFile = void 0;
const d4 = pt,
  tr = Gt,
  qt = Sp,
  Wr = dy,
  Gq = py,
  Ua = hy;
function p4(e, t = tr.DEFAULT_READ_OPTIONS) {
  var n;
  if (Wr.default.isString(t)) return p4(e, { encoding: t });
  const r =
    Date.now() +
    ((n = t.timeout) !== null && n !== void 0 ? n : tr.DEFAULT_TIMEOUT_ASYNC);
  return qt.default.readFileRetry(r)(e, t);
}
Ui.readFile = p4;
function h4(e, t = tr.DEFAULT_READ_OPTIONS) {
  var n;
  if (Wr.default.isString(t)) return h4(e, { encoding: t });
  const r =
    Date.now() +
    ((n = t.timeout) !== null && n !== void 0 ? n : tr.DEFAULT_TIMEOUT_SYNC);
  return qt.default.readFileSyncRetry(r)(e, t);
}
Ui.readFileSync = h4;
const m4 = (e, t, n, r) => {
  if (Wr.default.isFunction(n)) return m4(e, t, tr.DEFAULT_WRITE_OPTIONS, n);
  const i = g4(e, t, n);
  return r && i.then(r, r), i;
};
Ui.writeFile = m4;
const g4 = async (e, t, n = tr.DEFAULT_WRITE_OPTIONS) => {
    var r;
    if (Wr.default.isString(n)) return g4(e, t, { encoding: n });
    const i =
      Date.now() +
      ((r = n.timeout) !== null && r !== void 0 ? r : tr.DEFAULT_TIMEOUT_ASYNC);
    let a = null,
      s = null,
      o = null,
      c = null,
      l = null;
    try {
      n.schedule && (a = await n.schedule(e)),
        (s = await Gq.default.schedule(e)),
        (e = (await qt.default.realpathAttempt(e)) || e),
        ([c, o] = Ua.default.get(
          e,
          n.tmpCreate || Ua.default.create,
          n.tmpPurge !== !1,
        ));
      const f = tr.IS_POSIX && Wr.default.isUndefined(n.chown),
        u = Wr.default.isUndefined(n.mode);
      if (f || u) {
        const p = await qt.default.statAttempt(e);
        p &&
          ((n = { ...n }),
          f && (n.chown = { uid: p.uid, gid: p.gid }),
          u && (n.mode = p.mode));
      }
      const d = d4.dirname(e);
      await qt.default.mkdirAttempt(d, {
        mode: tr.DEFAULT_FOLDER_MODE,
        recursive: !0,
      }),
        (l = await qt.default.openRetry(i)(
          c,
          "w",
          n.mode || tr.DEFAULT_FILE_MODE,
        )),
        n.tmpCreated && n.tmpCreated(c),
        Wr.default.isString(t)
          ? await qt.default.writeRetry(i)(
              l,
              t,
              0,
              n.encoding || tr.DEFAULT_ENCODING,
            )
          : Wr.default.isUndefined(t) ||
            (await qt.default.writeRetry(i)(l, t, 0, t.length, 0)),
        n.fsync !== !1 &&
          (n.fsyncWait !== !1
            ? await qt.default.fsyncRetry(i)(l)
            : qt.default.fsyncAttempt(l)),
        await qt.default.closeRetry(i)(l),
        (l = null),
        n.chown && (await qt.default.chownAttempt(c, n.chown.uid, n.chown.gid)),
        n.mode && (await qt.default.chmodAttempt(c, n.mode));
      try {
        await qt.default.renameRetry(i)(c, e);
      } catch (p) {
        if (p.code !== "ENAMETOOLONG") throw p;
        await qt.default.renameRetry(i)(c, Ua.default.truncate(e));
      }
      o(), (c = null);
    } finally {
      l && (await qt.default.closeAttempt(l)),
        c && Ua.default.purge(c),
        a && a(),
        s && s();
    }
  },
  v4 = (e, t, n = tr.DEFAULT_WRITE_OPTIONS) => {
    var r;
    if (Wr.default.isString(n)) return v4(e, t, { encoding: n });
    const i =
      Date.now() +
      ((r = n.timeout) !== null && r !== void 0 ? r : tr.DEFAULT_TIMEOUT_SYNC);
    let a = null,
      s = null,
      o = null;
    try {
      (e = qt.default.realpathSyncAttempt(e) || e),
        ([s, a] = Ua.default.get(
          e,
          n.tmpCreate || Ua.default.create,
          n.tmpPurge !== !1,
        ));
      const c = tr.IS_POSIX && Wr.default.isUndefined(n.chown),
        l = Wr.default.isUndefined(n.mode);
      if (c || l) {
        const u = qt.default.statSyncAttempt(e);
        u &&
          ((n = { ...n }),
          c && (n.chown = { uid: u.uid, gid: u.gid }),
          l && (n.mode = u.mode));
      }
      const f = d4.dirname(e);
      qt.default.mkdirSyncAttempt(f, {
        mode: tr.DEFAULT_FOLDER_MODE,
        recursive: !0,
      }),
        (o = qt.default.openSyncRetry(i)(
          s,
          "w",
          n.mode || tr.DEFAULT_FILE_MODE,
        )),
        n.tmpCreated && n.tmpCreated(s),
        Wr.default.isString(t)
          ? qt.default.writeSyncRetry(i)(
              o,
              t,
              0,
              n.encoding || tr.DEFAULT_ENCODING,
            )
          : Wr.default.isUndefined(t) ||
            qt.default.writeSyncRetry(i)(o, t, 0, t.length, 0),
        n.fsync !== !1 &&
          (n.fsyncWait !== !1
            ? qt.default.fsyncSyncRetry(i)(o)
            : qt.default.fsyncAttempt(o)),
        qt.default.closeSyncRetry(i)(o),
        (o = null),
        n.chown && qt.default.chownSyncAttempt(s, n.chown.uid, n.chown.gid),
        n.mode && qt.default.chmodSyncAttempt(s, n.mode);
      try {
        qt.default.renameSyncRetry(i)(s, e);
      } catch (u) {
        if (u.code !== "ENAMETOOLONG") throw u;
        qt.default.renameSyncRetry(i)(s, Ua.default.truncate(e));
      }
      a(), (s = null);
    } finally {
      o && qt.default.closeSyncAttempt(o), s && Ua.default.purge(s);
    }
  };
Ui.writeFileSync = v4;
var y0 = { exports: {} },
  y4 = {},
  yi = {},
  ac = {},
  cu = {},
  $t = {},
  Ml = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.regexpCode =
      e.getEsmExportName =
      e.getProperty =
      e.safeStringify =
      e.stringify =
      e.strConcat =
      e.addCodeArg =
      e.str =
      e._ =
      e.nil =
      e._Code =
      e.Name =
      e.IDENTIFIER =
      e._CodeOrName =
        void 0);
  class t {}
  (e._CodeOrName = t), (e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i);
  class n extends t {
    constructor(y) {
      if ((super(), !e.IDENTIFIER.test(y)))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = y;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = n;
  class r extends t {
    constructor(y) {
      super(), (this._items = typeof y == "string" ? [y] : y);
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1) return !1;
      const y = this._items[0];
      return y === "" || y === '""';
    }
    get str() {
      var y;
      return (y = this._str) !== null && y !== void 0
        ? y
        : (this._str = this._items.reduce((_, E) => `${_}${E}`, ""));
    }
    get names() {
      var y;
      return (y = this._names) !== null && y !== void 0
        ? y
        : (this._names = this._items.reduce(
            (_, E) => (E instanceof n && (_[E.str] = (_[E.str] || 0) + 1), _),
            {},
          ));
    }
  }
  (e._Code = r), (e.nil = new r(""));
  function i(v, ...y) {
    const _ = [v[0]];
    let E = 0;
    for (; E < y.length; ) o(_, y[E]), _.push(v[++E]);
    return new r(_);
  }
  e._ = i;
  const a = new r("+");
  function s(v, ...y) {
    const _ = [p(v[0])];
    let E = 0;
    for (; E < y.length; ) _.push(a), o(_, y[E]), _.push(a, p(v[++E]));
    return c(_), new r(_);
  }
  e.str = s;
  function o(v, y) {
    y instanceof r
      ? v.push(...y._items)
      : y instanceof n
      ? v.push(y)
      : v.push(u(y));
  }
  e.addCodeArg = o;
  function c(v) {
    let y = 1;
    for (; y < v.length - 1; ) {
      if (v[y] === a) {
        const _ = l(v[y - 1], v[y + 1]);
        if (_ !== void 0) {
          v.splice(y - 1, 3, _);
          continue;
        }
        v[y++] = "+";
      }
      y++;
    }
  }
  function l(v, y) {
    if (y === '""') return v;
    if (v === '""') return y;
    if (typeof v == "string")
      return y instanceof n || v[v.length - 1] !== '"'
        ? void 0
        : typeof y != "string"
        ? `${v.slice(0, -1)}${y}"`
        : y[0] === '"'
        ? v.slice(0, -1) + y.slice(1)
        : void 0;
    if (typeof y == "string" && y[0] === '"' && !(v instanceof n))
      return `"${v}${y.slice(1)}`;
  }
  function f(v, y) {
    return y.emptyStr() ? v : v.emptyStr() ? y : s`${v}${y}`;
  }
  e.strConcat = f;
  function u(v) {
    return typeof v == "number" || typeof v == "boolean" || v === null
      ? v
      : p(Array.isArray(v) ? v.join(",") : v);
  }
  function d(v) {
    return new r(p(v));
  }
  e.stringify = d;
  function p(v) {
    return JSON.stringify(v)
      .replace(/\u2028/g, "\\u2028")
      .replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = p;
  function h(v) {
    return typeof v == "string" && e.IDENTIFIER.test(v)
      ? new r(`.${v}`)
      : i`[${v}]`;
  }
  e.getProperty = h;
  function m(v) {
    if (typeof v == "string" && e.IDENTIFIER.test(v)) return new r(`${v}`);
    throw new Error(
      `CodeGen: invalid export name: ${v}, use explicit $id name mapping`,
    );
  }
  e.getEsmExportName = m;
  function g(v) {
    return new r(v.toString());
  }
  e.regexpCode = g;
})(Ml);
var b0 = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.ValueScope =
      e.ValueScopeName =
      e.Scope =
      e.varKinds =
      e.UsedValueState =
        void 0);
  const t = Ml;
  class n extends Error {
    constructor(l) {
      super(`CodeGen: "code" for ${l} not defined`), (this.value = l.value);
    }
  }
  var r;
  (function (c) {
    (c[(c.Started = 0)] = "Started"), (c[(c.Completed = 1)] = "Completed");
  })((r = e.UsedValueState || (e.UsedValueState = {}))),
    (e.varKinds = {
      const: new t.Name("const"),
      let: new t.Name("let"),
      var: new t.Name("var"),
    });
  class i {
    constructor({ prefixes: l, parent: f } = {}) {
      (this._names = {}), (this._prefixes = l), (this._parent = f);
    }
    toName(l) {
      return l instanceof t.Name ? l : this.name(l);
    }
    name(l) {
      return new t.Name(this._newName(l));
    }
    _newName(l) {
      const f = this._names[l] || this._nameGroup(l);
      return `${l}${f.index++}`;
    }
    _nameGroup(l) {
      var f, u;
      if (
        (!(
          (u =
            (f = this._parent) === null || f === void 0
              ? void 0
              : f._prefixes) === null || u === void 0
        ) &&
          u.has(l)) ||
        (this._prefixes && !this._prefixes.has(l))
      )
        throw new Error(`CodeGen: prefix "${l}" is not allowed in this scope`);
      return (this._names[l] = { prefix: l, index: 0 });
    }
  }
  e.Scope = i;
  class a extends t.Name {
    constructor(l, f) {
      super(f), (this.prefix = l);
    }
    setValue(l, { property: f, itemIndex: u }) {
      (this.value = l), (this.scopePath = (0, t._)`.${new t.Name(f)}[${u}]`);
    }
  }
  e.ValueScopeName = a;
  const s = (0, t._)`\n`;
  class o extends i {
    constructor(l) {
      super(l),
        (this._values = {}),
        (this._scope = l.scope),
        (this.opts = { ...l, _n: l.lines ? s : t.nil });
    }
    get() {
      return this._scope;
    }
    name(l) {
      return new a(l, this._newName(l));
    }
    value(l, f) {
      var u;
      if (f.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const d = this.toName(l),
        { prefix: p } = d,
        h = (u = f.key) !== null && u !== void 0 ? u : f.ref;
      let m = this._values[p];
      if (m) {
        const y = m.get(h);
        if (y) return y;
      } else m = this._values[p] = new Map();
      m.set(h, d);
      const g = this._scope[p] || (this._scope[p] = []),
        v = g.length;
      return (g[v] = f.ref), d.setValue(f, { property: p, itemIndex: v }), d;
    }
    getValue(l, f) {
      const u = this._values[l];
      if (u) return u.get(f);
    }
    scopeRefs(l, f = this._values) {
      return this._reduceValues(f, (u) => {
        if (u.scopePath === void 0)
          throw new Error(`CodeGen: name "${u}" has no value`);
        return (0, t._)`${l}${u.scopePath}`;
      });
    }
    scopeCode(l = this._values, f, u) {
      return this._reduceValues(
        l,
        (d) => {
          if (d.value === void 0)
            throw new Error(`CodeGen: name "${d}" has no value`);
          return d.value.code;
        },
        f,
        u,
      );
    }
    _reduceValues(l, f, u = {}, d) {
      let p = t.nil;
      for (const h in l) {
        const m = l[h];
        if (!m) continue;
        const g = (u[h] = u[h] || new Map());
        m.forEach((v) => {
          if (g.has(v)) return;
          g.set(v, r.Started);
          let y = f(v);
          if (y) {
            const _ = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            p = (0, t._)`${p}${_} ${v} = ${y};${this.opts._n}`;
          } else if ((y = d == null ? void 0 : d(v)))
            p = (0, t._)`${p}${y}${this.opts._n}`;
          else throw new n(v);
          g.set(v, r.Completed);
        });
      }
      return p;
    }
  }
  e.ValueScope = o;
})(b0);
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.or =
      e.and =
      e.not =
      e.CodeGen =
      e.operators =
      e.varKinds =
      e.ValueScopeName =
      e.ValueScope =
      e.Scope =
      e.Name =
      e.regexpCode =
      e.stringify =
      e.getProperty =
      e.nil =
      e.strConcat =
      e.str =
      e._ =
        void 0);
  const t = Ml,
    n = b0;
  var r = Ml;
  Object.defineProperty(e, "_", {
    enumerable: !0,
    get: function () {
      return r._;
    },
  }),
    Object.defineProperty(e, "str", {
      enumerable: !0,
      get: function () {
        return r.str;
      },
    }),
    Object.defineProperty(e, "strConcat", {
      enumerable: !0,
      get: function () {
        return r.strConcat;
      },
    }),
    Object.defineProperty(e, "nil", {
      enumerable: !0,
      get: function () {
        return r.nil;
      },
    }),
    Object.defineProperty(e, "getProperty", {
      enumerable: !0,
      get: function () {
        return r.getProperty;
      },
    }),
    Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function () {
        return r.stringify;
      },
    }),
    Object.defineProperty(e, "regexpCode", {
      enumerable: !0,
      get: function () {
        return r.regexpCode;
      },
    }),
    Object.defineProperty(e, "Name", {
      enumerable: !0,
      get: function () {
        return r.Name;
      },
    });
  var i = b0;
  Object.defineProperty(e, "Scope", {
    enumerable: !0,
    get: function () {
      return i.Scope;
    },
  }),
    Object.defineProperty(e, "ValueScope", {
      enumerable: !0,
      get: function () {
        return i.ValueScope;
      },
    }),
    Object.defineProperty(e, "ValueScopeName", {
      enumerable: !0,
      get: function () {
        return i.ValueScopeName;
      },
    }),
    Object.defineProperty(e, "varKinds", {
      enumerable: !0,
      get: function () {
        return i.varKinds;
      },
    }),
    (e.operators = {
      GT: new t._Code(">"),
      GTE: new t._Code(">="),
      LT: new t._Code("<"),
      LTE: new t._Code("<="),
      EQ: new t._Code("==="),
      NEQ: new t._Code("!=="),
      NOT: new t._Code("!"),
      OR: new t._Code("||"),
      AND: new t._Code("&&"),
      ADD: new t._Code("+"),
    });
  class a {
    optimizeNodes() {
      return this;
    }
    optimizeNames(x, T) {
      return this;
    }
  }
  class s extends a {
    constructor(x, T, V) {
      super(), (this.varKind = x), (this.name = T), (this.rhs = V);
    }
    render({ es5: x, _n: T }) {
      const V = x ? n.varKinds.var : this.varKind,
        B = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${V} ${this.name}${B};` + T;
    }
    optimizeNames(x, T) {
      if (x[this.name.str])
        return this.rhs && (this.rhs = q(this.rhs, x, T)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class o extends a {
    constructor(x, T, V) {
      super(), (this.lhs = x), (this.rhs = T), (this.sideEffects = V);
    }
    render({ _n: x }) {
      return `${this.lhs} = ${this.rhs};` + x;
    }
    optimizeNames(x, T) {
      if (
        !(this.lhs instanceof t.Name && !x[this.lhs.str] && !this.sideEffects)
      )
        return (this.rhs = q(this.rhs, x, T)), this;
    }
    get names() {
      const x = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return H(x, this.rhs);
    }
  }
  class c extends o {
    constructor(x, T, V, B) {
      super(x, V, B), (this.op = T);
    }
    render({ _n: x }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + x;
    }
  }
  class l extends a {
    constructor(x) {
      super(), (this.label = x), (this.names = {});
    }
    render({ _n: x }) {
      return `${this.label}:` + x;
    }
  }
  class f extends a {
    constructor(x) {
      super(), (this.label = x), (this.names = {});
    }
    render({ _n: x }) {
      return `break${this.label ? ` ${this.label}` : ""};` + x;
    }
  }
  class u extends a {
    constructor(x) {
      super(), (this.error = x);
    }
    render({ _n: x }) {
      return `throw ${this.error};` + x;
    }
    get names() {
      return this.error.names;
    }
  }
  class d extends a {
    constructor(x) {
      super(), (this.code = x);
    }
    render({ _n: x }) {
      return `${this.code};` + x;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(x, T) {
      return (this.code = q(this.code, x, T)), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class p extends a {
    constructor(x = []) {
      super(), (this.nodes = x);
    }
    render(x) {
      return this.nodes.reduce((T, V) => T + V.render(x), "");
    }
    optimizeNodes() {
      const { nodes: x } = this;
      let T = x.length;
      for (; T--; ) {
        const V = x[T].optimizeNodes();
        Array.isArray(V)
          ? x.splice(T, 1, ...V)
          : V
          ? (x[T] = V)
          : x.splice(T, 1);
      }
      return x.length > 0 ? this : void 0;
    }
    optimizeNames(x, T) {
      const { nodes: V } = this;
      let B = V.length;
      for (; B--; ) {
        const N = V[B];
        N.optimizeNames(x, T) || (J(x, N.names), V.splice(B, 1));
      }
      return V.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((x, T) => j(x, T.names), {});
    }
  }
  class h extends p {
    render(x) {
      return "{" + x._n + super.render(x) + "}" + x._n;
    }
  }
  class m extends p {}
  class g extends h {}
  g.kind = "else";
  class v extends h {
    constructor(x, T) {
      super(T), (this.condition = x);
    }
    render(x) {
      let T = `if(${this.condition})` + super.render(x);
      return this.else && (T += "else " + this.else.render(x)), T;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const x = this.condition;
      if (x === !0) return this.nodes;
      let T = this.else;
      if (T) {
        const V = T.optimizeNodes();
        T = this.else = Array.isArray(V) ? new g(V) : V;
      }
      if (T)
        return x === !1
          ? T instanceof v
            ? T
            : T.nodes
          : this.nodes.length
          ? this
          : new v(Z(x), T instanceof v ? [T] : T.nodes);
      if (!(x === !1 || !this.nodes.length)) return this;
    }
    optimizeNames(x, T) {
      var V;
      if (
        ((this.else =
          (V = this.else) === null || V === void 0
            ? void 0
            : V.optimizeNames(x, T)),
        !!(super.optimizeNames(x, T) || this.else))
      )
        return (this.condition = q(this.condition, x, T)), this;
    }
    get names() {
      const x = super.names;
      return H(x, this.condition), this.else && j(x, this.else.names), x;
    }
  }
  v.kind = "if";
  class y extends h {}
  y.kind = "for";
  class _ extends y {
    constructor(x) {
      super(), (this.iteration = x);
    }
    render(x) {
      return `for(${this.iteration})` + super.render(x);
    }
    optimizeNames(x, T) {
      if (super.optimizeNames(x, T))
        return (this.iteration = q(this.iteration, x, T)), this;
    }
    get names() {
      return j(super.names, this.iteration.names);
    }
  }
  class E extends y {
    constructor(x, T, V, B) {
      super(),
        (this.varKind = x),
        (this.name = T),
        (this.from = V),
        (this.to = B);
    }
    render(x) {
      const T = x.es5 ? n.varKinds.var : this.varKind,
        { name: V, from: B, to: N } = this;
      return `for(${T} ${V}=${B}; ${V}<${N}; ${V}++)` + super.render(x);
    }
    get names() {
      const x = H(super.names, this.from);
      return H(x, this.to);
    }
  }
  class R extends y {
    constructor(x, T, V, B) {
      super(),
        (this.loop = x),
        (this.varKind = T),
        (this.name = V),
        (this.iterable = B);
    }
    render(x) {
      return (
        `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
        super.render(x)
      );
    }
    optimizeNames(x, T) {
      if (super.optimizeNames(x, T))
        return (this.iterable = q(this.iterable, x, T)), this;
    }
    get names() {
      return j(super.names, this.iterable.names);
    }
  }
  class A extends h {
    constructor(x, T, V) {
      super(), (this.name = x), (this.args = T), (this.async = V);
    }
    render(x) {
      return (
        `${this.async ? "async " : ""}function ${this.name}(${this.args})` +
        super.render(x)
      );
    }
  }
  A.kind = "func";
  class I extends p {
    render(x) {
      return "return " + super.render(x);
    }
  }
  I.kind = "return";
  class S extends h {
    render(x) {
      let T = "try" + super.render(x);
      return (
        this.catch && (T += this.catch.render(x)),
        this.finally && (T += this.finally.render(x)),
        T
      );
    }
    optimizeNodes() {
      var x, T;
      return (
        super.optimizeNodes(),
        (x = this.catch) === null || x === void 0 || x.optimizeNodes(),
        (T = this.finally) === null || T === void 0 || T.optimizeNodes(),
        this
      );
    }
    optimizeNames(x, T) {
      var V, B;
      return (
        super.optimizeNames(x, T),
        (V = this.catch) === null || V === void 0 || V.optimizeNames(x, T),
        (B = this.finally) === null || B === void 0 || B.optimizeNames(x, T),
        this
      );
    }
    get names() {
      const x = super.names;
      return (
        this.catch && j(x, this.catch.names),
        this.finally && j(x, this.finally.names),
        x
      );
    }
  }
  class w extends h {
    constructor(x) {
      super(), (this.error = x);
    }
    render(x) {
      return `catch(${this.error})` + super.render(x);
    }
  }
  w.kind = "catch";
  class O extends h {
    render(x) {
      return "finally" + super.render(x);
    }
  }
  O.kind = "finally";
  class Q {
    constructor(x, T = {}) {
      (this._values = {}),
        (this._blockStarts = []),
        (this._constants = {}),
        (this.opts = {
          ...T,
          _n: T.lines
            ? `
`
            : "",
        }),
        (this._extScope = x),
        (this._scope = new n.Scope({ parent: x })),
        (this._nodes = [new m()]);
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(x) {
      return this._scope.name(x);
    }
    scopeName(x) {
      return this._extScope.name(x);
    }
    scopeValue(x, T) {
      const V = this._extScope.value(x, T);
      return (
        (this._values[V.prefix] || (this._values[V.prefix] = new Set())).add(V),
        V
      );
    }
    getScopeValue(x, T) {
      return this._extScope.getValue(x, T);
    }
    scopeRefs(x) {
      return this._extScope.scopeRefs(x, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(x, T, V, B) {
      const N = this._scope.toName(T);
      return (
        V !== void 0 && B && (this._constants[N.str] = V),
        this._leafNode(new s(x, N, V)),
        N
      );
    }
    const(x, T, V) {
      return this._def(n.varKinds.const, x, T, V);
    }
    let(x, T, V) {
      return this._def(n.varKinds.let, x, T, V);
    }
    var(x, T, V) {
      return this._def(n.varKinds.var, x, T, V);
    }
    assign(x, T, V) {
      return this._leafNode(new o(x, T, V));
    }
    add(x, T) {
      return this._leafNode(new c(x, e.operators.ADD, T));
    }
    code(x) {
      return (
        typeof x == "function" ? x() : x !== t.nil && this._leafNode(new d(x)),
        this
      );
    }
    object(...x) {
      const T = ["{"];
      for (const [V, B] of x)
        T.length > 1 && T.push(","),
          T.push(V),
          (V !== B || this.opts.es5) && (T.push(":"), (0, t.addCodeArg)(T, B));
      return T.push("}"), new t._Code(T);
    }
    if(x, T, V) {
      if ((this._blockNode(new v(x)), T && V))
        this.code(T).else().code(V).endIf();
      else if (T) this.code(T).endIf();
      else if (V) throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    elseIf(x) {
      return this._elseNode(new v(x));
    }
    else() {
      return this._elseNode(new g());
    }
    endIf() {
      return this._endBlockNode(v, g);
    }
    _for(x, T) {
      return this._blockNode(x), T && this.code(T).endFor(), this;
    }
    for(x, T) {
      return this._for(new _(x), T);
    }
    forRange(x, T, V, B, N = this.opts.es5 ? n.varKinds.var : n.varKinds.let) {
      const ce = this._scope.toName(x);
      return this._for(new E(N, ce, T, V), () => B(ce));
    }
    forOf(x, T, V, B = n.varKinds.const) {
      const N = this._scope.toName(x);
      if (this.opts.es5) {
        const ce = T instanceof t.Name ? T : this.var("_arr", T);
        return this.forRange("_i", 0, (0, t._)`${ce}.length`, (re) => {
          this.var(N, (0, t._)`${ce}[${re}]`), V(N);
        });
      }
      return this._for(new R("of", B, N, T), () => V(N));
    }
    forIn(x, T, V, B = this.opts.es5 ? n.varKinds.var : n.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(x, (0, t._)`Object.keys(${T})`, V);
      const N = this._scope.toName(x);
      return this._for(new R("in", B, N, T), () => V(N));
    }
    endFor() {
      return this._endBlockNode(y);
    }
    label(x) {
      return this._leafNode(new l(x));
    }
    break(x) {
      return this._leafNode(new f(x));
    }
    return(x) {
      const T = new I();
      if ((this._blockNode(T), this.code(x), T.nodes.length !== 1))
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(I);
    }
    try(x, T, V) {
      if (!T && !V)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const B = new S();
      if ((this._blockNode(B), this.code(x), T)) {
        const N = this.name("e");
        (this._currNode = B.catch = new w(N)), T(N);
      }
      return (
        V && ((this._currNode = B.finally = new O()), this.code(V)),
        this._endBlockNode(w, O)
      );
    }
    throw(x) {
      return this._leafNode(new u(x));
    }
    block(x, T) {
      return (
        this._blockStarts.push(this._nodes.length),
        x && this.code(x).endBlock(T),
        this
      );
    }
    endBlock(x) {
      const T = this._blockStarts.pop();
      if (T === void 0) throw new Error("CodeGen: not in self-balancing block");
      const V = this._nodes.length - T;
      if (V < 0 || (x !== void 0 && V !== x))
        throw new Error(
          `CodeGen: wrong number of nodes: ${V} vs ${x} expected`,
        );
      return (this._nodes.length = T), this;
    }
    func(x, T = t.nil, V, B) {
      return this._blockNode(new A(x, T, V)), B && this.code(B).endFunc(), this;
    }
    endFunc() {
      return this._endBlockNode(A);
    }
    optimize(x = 1) {
      for (; x-- > 0; )
        this._root.optimizeNodes(),
          this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(x) {
      return this._currNode.nodes.push(x), this;
    }
    _blockNode(x) {
      this._currNode.nodes.push(x), this._nodes.push(x);
    }
    _endBlockNode(x, T) {
      const V = this._currNode;
      if (V instanceof x || (T && V instanceof T))
        return this._nodes.pop(), this;
      throw new Error(
        `CodeGen: not in block "${T ? `${x.kind}/${T.kind}` : x.kind}"`,
      );
    }
    _elseNode(x) {
      const T = this._currNode;
      if (!(T instanceof v)) throw new Error('CodeGen: "else" without "if"');
      return (this._currNode = T.else = x), this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const x = this._nodes;
      return x[x.length - 1];
    }
    set _currNode(x) {
      const T = this._nodes;
      T[T.length - 1] = x;
    }
  }
  e.CodeGen = Q;
  function j(F, x) {
    for (const T in x) F[T] = (F[T] || 0) + (x[T] || 0);
    return F;
  }
  function H(F, x) {
    return x instanceof t._CodeOrName ? j(F, x.names) : F;
  }
  function q(F, x, T) {
    if (F instanceof t.Name) return V(F);
    if (!B(F)) return F;
    return new t._Code(
      F._items.reduce(
        (N, ce) => (
          ce instanceof t.Name && (ce = V(ce)),
          ce instanceof t._Code ? N.push(...ce._items) : N.push(ce),
          N
        ),
        [],
      ),
    );
    function V(N) {
      const ce = T[N.str];
      return ce === void 0 || x[N.str] !== 1 ? N : (delete x[N.str], ce);
    }
    function B(N) {
      return (
        N instanceof t._Code &&
        N._items.some(
          (ce) =>
            ce instanceof t.Name && x[ce.str] === 1 && T[ce.str] !== void 0,
        )
      );
    }
  }
  function J(F, x) {
    for (const T in x) F[T] = (F[T] || 0) - (x[T] || 0);
  }
  function Z(F) {
    return typeof F == "boolean" || typeof F == "number" || F === null
      ? !F
      : (0, t._)`!${W(F)}`;
  }
  e.not = Z;
  const z = k(e.operators.AND);
  function U(...F) {
    return F.reduce(z);
  }
  e.and = U;
  const G = k(e.operators.OR);
  function L(...F) {
    return F.reduce(G);
  }
  e.or = L;
  function k(F) {
    return (x, T) =>
      x === t.nil ? T : T === t.nil ? x : (0, t._)`${W(x)} ${F} ${W(T)}`;
  }
  function W(F) {
    return F instanceof t.Name ? F : (0, t._)`(${F})`;
  }
})($t);
var Ut = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.checkStrictMode =
      e.getErrorPath =
      e.Type =
      e.useFunc =
      e.setEvaluated =
      e.evaluatedPropsToName =
      e.mergeEvaluated =
      e.eachItem =
      e.unescapeJsonPointer =
      e.escapeJsonPointer =
      e.escapeFragment =
      e.unescapeFragment =
      e.schemaRefOrVal =
      e.schemaHasRulesButRef =
      e.schemaHasRules =
      e.checkUnknownRules =
      e.alwaysValidSchema =
      e.toHash =
        void 0);
  const t = $t,
    n = Ml;
  function r(A) {
    const I = {};
    for (const S of A) I[S] = !0;
    return I;
  }
  e.toHash = r;
  function i(A, I) {
    return typeof I == "boolean"
      ? I
      : Object.keys(I).length === 0
      ? !0
      : (a(A, I), !s(I, A.self.RULES.all));
  }
  e.alwaysValidSchema = i;
  function a(A, I = A.schema) {
    const { opts: S, self: w } = A;
    if (!S.strictSchema || typeof I == "boolean") return;
    const O = w.RULES.keywords;
    for (const Q in I) O[Q] || R(A, `unknown keyword: "${Q}"`);
  }
  e.checkUnknownRules = a;
  function s(A, I) {
    if (typeof A == "boolean") return !A;
    for (const S in A) if (I[S]) return !0;
    return !1;
  }
  e.schemaHasRules = s;
  function o(A, I) {
    if (typeof A == "boolean") return !A;
    for (const S in A) if (S !== "$ref" && I.all[S]) return !0;
    return !1;
  }
  e.schemaHasRulesButRef = o;
  function c({ topSchemaRef: A, schemaPath: I }, S, w, O) {
    if (!O) {
      if (typeof S == "number" || typeof S == "boolean") return S;
      if (typeof S == "string") return (0, t._)`${S}`;
    }
    return (0, t._)`${A}${I}${(0, t.getProperty)(w)}`;
  }
  e.schemaRefOrVal = c;
  function l(A) {
    return d(decodeURIComponent(A));
  }
  e.unescapeFragment = l;
  function f(A) {
    return encodeURIComponent(u(A));
  }
  e.escapeFragment = f;
  function u(A) {
    return typeof A == "number"
      ? `${A}`
      : A.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  e.escapeJsonPointer = u;
  function d(A) {
    return A.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  e.unescapeJsonPointer = d;
  function p(A, I) {
    if (Array.isArray(A)) for (const S of A) I(S);
    else I(A);
  }
  e.eachItem = p;
  function h({
    mergeNames: A,
    mergeToName: I,
    mergeValues: S,
    resultToName: w,
  }) {
    return (O, Q, j, H) => {
      const q =
        j === void 0
          ? Q
          : j instanceof t.Name
          ? (Q instanceof t.Name ? A(O, Q, j) : I(O, Q, j), j)
          : Q instanceof t.Name
          ? (I(O, j, Q), Q)
          : S(Q, j);
      return H === t.Name && !(q instanceof t.Name) ? w(O, q) : q;
    };
  }
  e.mergeEvaluated = {
    props: h({
      mergeNames: (A, I, S) =>
        A.if((0, t._)`${S} !== true && ${I} !== undefined`, () => {
          A.if(
            (0, t._)`${I} === true`,
            () => A.assign(S, !0),
            () =>
              A.assign(S, (0, t._)`${S} || {}`).code(
                (0, t._)`Object.assign(${S}, ${I})`,
              ),
          );
        }),
      mergeToName: (A, I, S) =>
        A.if((0, t._)`${S} !== true`, () => {
          I === !0
            ? A.assign(S, !0)
            : (A.assign(S, (0, t._)`${S} || {}`), g(A, S, I));
        }),
      mergeValues: (A, I) => (A === !0 ? !0 : { ...A, ...I }),
      resultToName: m,
    }),
    items: h({
      mergeNames: (A, I, S) =>
        A.if((0, t._)`${S} !== true && ${I} !== undefined`, () =>
          A.assign(
            S,
            (0, t._)`${I} === true ? true : ${S} > ${I} ? ${S} : ${I}`,
          ),
        ),
      mergeToName: (A, I, S) =>
        A.if((0, t._)`${S} !== true`, () =>
          A.assign(S, I === !0 ? !0 : (0, t._)`${S} > ${I} ? ${S} : ${I}`),
        ),
      mergeValues: (A, I) => (A === !0 ? !0 : Math.max(A, I)),
      resultToName: (A, I) => A.var("items", I),
    }),
  };
  function m(A, I) {
    if (I === !0) return A.var("props", !0);
    const S = A.var("props", (0, t._)`{}`);
    return I !== void 0 && g(A, S, I), S;
  }
  e.evaluatedPropsToName = m;
  function g(A, I, S) {
    Object.keys(S).forEach((w) =>
      A.assign((0, t._)`${I}${(0, t.getProperty)(w)}`, !0),
    );
  }
  e.setEvaluated = g;
  const v = {};
  function y(A, I) {
    return A.scopeValue("func", {
      ref: I,
      code: v[I.code] || (v[I.code] = new n._Code(I.code)),
    });
  }
  e.useFunc = y;
  var _;
  (function (A) {
    (A[(A.Num = 0)] = "Num"), (A[(A.Str = 1)] = "Str");
  })((_ = e.Type || (e.Type = {})));
  function E(A, I, S) {
    if (A instanceof t.Name) {
      const w = I === _.Num;
      return S
        ? w
          ? (0, t._)`"[" + ${A} + "]"`
          : (0, t._)`"['" + ${A} + "']"`
        : w
        ? (0, t._)`"/" + ${A}`
        : (0, t._)`"/" + ${A}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return S ? (0, t.getProperty)(A).toString() : "/" + u(A);
  }
  e.getErrorPath = E;
  function R(A, I, S = A.opts.strictSchema) {
    if (S) {
      if (((I = `strict mode: ${I}`), S === !0)) throw new Error(I);
      A.self.logger.warn(I);
    }
  }
  e.checkStrictMode = R;
})(Ut);
var Wi = {};
Object.defineProperty(Wi, "__esModule", { value: !0 });
const or = $t,
  Qq = {
    data: new or.Name("data"),
    valCxt: new or.Name("valCxt"),
    instancePath: new or.Name("instancePath"),
    parentData: new or.Name("parentData"),
    parentDataProperty: new or.Name("parentDataProperty"),
    rootData: new or.Name("rootData"),
    dynamicAnchors: new or.Name("dynamicAnchors"),
    vErrors: new or.Name("vErrors"),
    errors: new or.Name("errors"),
    this: new or.Name("this"),
    self: new or.Name("self"),
    scope: new or.Name("scope"),
    json: new or.Name("json"),
    jsonPos: new or.Name("jsonPos"),
    jsonLen: new or.Name("jsonLen"),
    jsonPart: new or.Name("jsonPart"),
  };
Wi.default = Qq;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.extendErrors =
      e.resetErrorsCount =
      e.reportExtraError =
      e.reportError =
      e.keyword$DataError =
      e.keywordError =
        void 0);
  const t = $t,
    n = Ut,
    r = Wi;
  (e.keywordError = {
    message: ({ keyword: g }) =>
      (0, t.str)`must pass "${g}" keyword validation`,
  }),
    (e.keyword$DataError = {
      message: ({ keyword: g, schemaType: v }) =>
        v
          ? (0, t.str)`"${g}" keyword must be ${v} ($data)`
          : (0, t.str)`"${g}" keyword is invalid ($data)`,
    });
  function i(g, v = e.keywordError, y, _) {
    const { it: E } = g,
      { gen: R, compositeRule: A, allErrors: I } = E,
      S = u(g, v, y);
    _ ?? (A || I) ? c(R, S) : l(E, (0, t._)`[${S}]`);
  }
  e.reportError = i;
  function a(g, v = e.keywordError, y) {
    const { it: _ } = g,
      { gen: E, compositeRule: R, allErrors: A } = _,
      I = u(g, v, y);
    c(E, I), R || A || l(_, r.default.vErrors);
  }
  e.reportExtraError = a;
  function s(g, v) {
    g.assign(r.default.errors, v),
      g.if((0, t._)`${r.default.vErrors} !== null`, () =>
        g.if(
          v,
          () => g.assign((0, t._)`${r.default.vErrors}.length`, v),
          () => g.assign(r.default.vErrors, null),
        ),
      );
  }
  e.resetErrorsCount = s;
  function o({
    gen: g,
    keyword: v,
    schemaValue: y,
    data: _,
    errsCount: E,
    it: R,
  }) {
    if (E === void 0) throw new Error("ajv implementation error");
    const A = g.name("err");
    g.forRange("i", E, r.default.errors, (I) => {
      g.const(A, (0, t._)`${r.default.vErrors}[${I}]`),
        g.if((0, t._)`${A}.instancePath === undefined`, () =>
          g.assign(
            (0, t._)`${A}.instancePath`,
            (0, t.strConcat)(r.default.instancePath, R.errorPath),
          ),
        ),
        g.assign(
          (0, t._)`${A}.schemaPath`,
          (0, t.str)`${R.errSchemaPath}/${v}`,
        ),
        R.opts.verbose &&
          (g.assign((0, t._)`${A}.schema`, y),
          g.assign((0, t._)`${A}.data`, _));
    });
  }
  e.extendErrors = o;
  function c(g, v) {
    const y = g.const("err", v);
    g.if(
      (0, t._)`${r.default.vErrors} === null`,
      () => g.assign(r.default.vErrors, (0, t._)`[${y}]`),
      (0, t._)`${r.default.vErrors}.push(${y})`,
    ),
      g.code((0, t._)`${r.default.errors}++`);
  }
  function l(g, v) {
    const { gen: y, validateName: _, schemaEnv: E } = g;
    E.$async
      ? y.throw((0, t._)`new ${g.ValidationError}(${v})`)
      : (y.assign((0, t._)`${_}.errors`, v), y.return(!1));
  }
  const f = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema"),
  };
  function u(g, v, y) {
    const { createErrors: _ } = g.it;
    return _ === !1 ? (0, t._)`{}` : d(g, v, y);
  }
  function d(g, v, y = {}) {
    const { gen: _, it: E } = g,
      R = [p(E, y), h(g, y)];
    return m(g, v, R), _.object(...R);
  }
  function p({ errorPath: g }, { instancePath: v }) {
    const y = v ? (0, t.str)`${g}${(0, n.getErrorPath)(v, n.Type.Str)}` : g;
    return [
      r.default.instancePath,
      (0, t.strConcat)(r.default.instancePath, y),
    ];
  }
  function h(
    { keyword: g, it: { errSchemaPath: v } },
    { schemaPath: y, parentSchema: _ },
  ) {
    let E = _ ? v : (0, t.str)`${v}/${g}`;
    return (
      y && (E = (0, t.str)`${E}${(0, n.getErrorPath)(y, n.Type.Str)}`),
      [f.schemaPath, E]
    );
  }
  function m(g, { params: v, message: y }, _) {
    const { keyword: E, data: R, schemaValue: A, it: I } = g,
      { opts: S, propertyName: w, topSchemaRef: O, schemaPath: Q } = I;
    _.push(
      [f.keyword, E],
      [f.params, typeof v == "function" ? v(g) : v || (0, t._)`{}`],
    ),
      S.messages && _.push([f.message, typeof y == "function" ? y(g) : y]),
      S.verbose &&
        _.push(
          [f.schema, A],
          [f.parentSchema, (0, t._)`${O}${Q}`],
          [r.default.data, R],
        ),
      w && _.push([f.propertyName, w]);
  }
})(cu);
Object.defineProperty(ac, "__esModule", { value: !0 });
ac.boolOrEmptySchema = ac.topBoolOrEmptySchema = void 0;
const Wq = cu,
  zq = $t,
  Kq = Wi,
  Vq = { message: "boolean schema is false" };
function Yq(e) {
  const { gen: t, schema: n, validateName: r } = e;
  n === !1
    ? b4(e, !1)
    : typeof n == "object" && n.$async === !0
    ? t.return(Kq.default.data)
    : (t.assign((0, zq._)`${r}.errors`, null), t.return(!0));
}
ac.topBoolOrEmptySchema = Yq;
function Xq(e, t) {
  const { gen: n, schema: r } = e;
  r === !1 ? (n.var(t, !1), b4(e)) : n.var(t, !0);
}
ac.boolOrEmptySchema = Xq;
function b4(e, t) {
  const { gen: n, data: r } = e,
    i = {
      gen: n,
      keyword: "false schema",
      data: r,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: e,
    };
  (0, Wq.reportError)(i, Vq, void 0, t);
}
var lu = {},
  Fs = {};
Object.defineProperty(Fs, "__esModule", { value: !0 });
Fs.getRules = Fs.isJSONType = void 0;
const Jq = [
    "string",
    "number",
    "integer",
    "boolean",
    "null",
    "object",
    "array",
  ],
  Zq = new Set(Jq);
function eG(e) {
  return typeof e == "string" && Zq.has(e);
}
Fs.isJSONType = eG;
function tG() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] },
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {},
  };
}
Fs.getRules = tG;
var la = {};
Object.defineProperty(la, "__esModule", { value: !0 });
la.shouldUseRule = la.shouldUseGroup = la.schemaHasRulesForType = void 0;
function nG({ schema: e, self: t }, n) {
  const r = t.RULES.types[n];
  return r && r !== !0 && _4(e, r);
}
la.schemaHasRulesForType = nG;
function _4(e, t) {
  return t.rules.some((n) => E4(e, n));
}
la.shouldUseGroup = _4;
function E4(e, t) {
  var n;
  return (
    e[t.keyword] !== void 0 ||
    ((n = t.definition.implements) === null || n === void 0
      ? void 0
      : n.some((r) => e[r] !== void 0))
  );
}
la.shouldUseRule = E4;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.reportTypeError =
      e.checkDataTypes =
      e.checkDataType =
      e.coerceAndCheckDataType =
      e.getJSONTypes =
      e.getSchemaTypes =
      e.DataType =
        void 0);
  const t = Fs,
    n = la,
    r = cu,
    i = $t,
    a = Ut;
  var s;
  (function (_) {
    (_[(_.Correct = 0)] = "Correct"), (_[(_.Wrong = 1)] = "Wrong");
  })((s = e.DataType || (e.DataType = {})));
  function o(_) {
    const E = c(_.type);
    if (E.includes("null")) {
      if (_.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!E.length && _.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      _.nullable === !0 && E.push("null");
    }
    return E;
  }
  e.getSchemaTypes = o;
  function c(_) {
    const E = Array.isArray(_) ? _ : _ ? [_] : [];
    if (E.every(t.isJSONType)) return E;
    throw new Error("type must be JSONType or JSONType[]: " + E.join(","));
  }
  e.getJSONTypes = c;
  function l(_, E) {
    const { gen: R, data: A, opts: I } = _,
      S = u(E, I.coerceTypes),
      w =
        E.length > 0 &&
        !(
          S.length === 0 &&
          E.length === 1 &&
          (0, n.schemaHasRulesForType)(_, E[0])
        );
    if (w) {
      const O = m(E, A, I.strictNumbers, s.Wrong);
      R.if(O, () => {
        S.length ? d(_, E, S) : v(_);
      });
    }
    return w;
  }
  e.coerceAndCheckDataType = l;
  const f = new Set(["string", "number", "integer", "boolean", "null"]);
  function u(_, E) {
    return E
      ? _.filter((R) => f.has(R) || (E === "array" && R === "array"))
      : [];
  }
  function d(_, E, R) {
    const { gen: A, data: I, opts: S } = _,
      w = A.let("dataType", (0, i._)`typeof ${I}`),
      O = A.let("coerced", (0, i._)`undefined`);
    S.coerceTypes === "array" &&
      A.if(
        (0, i._)`${w} == 'object' && Array.isArray(${I}) && ${I}.length == 1`,
        () =>
          A.assign(I, (0, i._)`${I}[0]`)
            .assign(w, (0, i._)`typeof ${I}`)
            .if(m(E, I, S.strictNumbers), () => A.assign(O, I)),
      ),
      A.if((0, i._)`${O} !== undefined`);
    for (const j of R)
      (f.has(j) || (j === "array" && S.coerceTypes === "array")) && Q(j);
    A.else(),
      v(_),
      A.endIf(),
      A.if((0, i._)`${O} !== undefined`, () => {
        A.assign(I, O), p(_, O);
      });
    function Q(j) {
      switch (j) {
        case "string":
          A.elseIf((0, i._)`${w} == "number" || ${w} == "boolean"`)
            .assign(O, (0, i._)`"" + ${I}`)
            .elseIf((0, i._)`${I} === null`)
            .assign(O, (0, i._)`""`);
          return;
        case "number":
          A.elseIf(
            (0, i._)`${w} == "boolean" || ${I} === null
              || (${w} == "string" && ${I} && ${I} == +${I})`,
          ).assign(O, (0, i._)`+${I}`);
          return;
        case "integer":
          A.elseIf(
            (0, i._)`${w} === "boolean" || ${I} === null
              || (${w} === "string" && ${I} && ${I} == +${I} && !(${I} % 1))`,
          ).assign(O, (0, i._)`+${I}`);
          return;
        case "boolean":
          A.elseIf((0, i._)`${I} === "false" || ${I} === 0 || ${I} === null`)
            .assign(O, !1)
            .elseIf((0, i._)`${I} === "true" || ${I} === 1`)
            .assign(O, !0);
          return;
        case "null":
          A.elseIf((0, i._)`${I} === "" || ${I} === 0 || ${I} === false`),
            A.assign(O, null);
          return;
        case "array":
          A.elseIf(
            (0, i._)`${w} === "string" || ${w} === "number"
              || ${w} === "boolean" || ${I} === null`,
          ).assign(O, (0, i._)`[${I}]`);
      }
    }
  }
  function p({ gen: _, parentData: E, parentDataProperty: R }, A) {
    _.if((0, i._)`${E} !== undefined`, () => _.assign((0, i._)`${E}[${R}]`, A));
  }
  function h(_, E, R, A = s.Correct) {
    const I = A === s.Correct ? i.operators.EQ : i.operators.NEQ;
    let S;
    switch (_) {
      case "null":
        return (0, i._)`${E} ${I} null`;
      case "array":
        S = (0, i._)`Array.isArray(${E})`;
        break;
      case "object":
        S = (0, i._)`${E} && typeof ${E} == "object" && !Array.isArray(${E})`;
        break;
      case "integer":
        S = w((0, i._)`!(${E} % 1) && !isNaN(${E})`);
        break;
      case "number":
        S = w();
        break;
      default:
        return (0, i._)`typeof ${E} ${I} ${_}`;
    }
    return A === s.Correct ? S : (0, i.not)(S);
    function w(O = i.nil) {
      return (0, i.and)(
        (0, i._)`typeof ${E} == "number"`,
        O,
        R ? (0, i._)`isFinite(${E})` : i.nil,
      );
    }
  }
  e.checkDataType = h;
  function m(_, E, R, A) {
    if (_.length === 1) return h(_[0], E, R, A);
    let I;
    const S = (0, a.toHash)(_);
    if (S.array && S.object) {
      const w = (0, i._)`typeof ${E} != "object"`;
      (I = S.null ? w : (0, i._)`!${E} || ${w}`),
        delete S.null,
        delete S.array,
        delete S.object;
    } else I = i.nil;
    S.number && delete S.integer;
    for (const w in S) I = (0, i.and)(I, h(w, E, R, A));
    return I;
  }
  e.checkDataTypes = m;
  const g = {
    message: ({ schema: _ }) => `must be ${_}`,
    params: ({ schema: _, schemaValue: E }) =>
      typeof _ == "string" ? (0, i._)`{type: ${_}}` : (0, i._)`{type: ${E}}`,
  };
  function v(_) {
    const E = y(_);
    (0, r.reportError)(E, g);
  }
  e.reportTypeError = v;
  function y(_) {
    const { gen: E, data: R, schema: A } = _,
      I = (0, a.schemaRefOrVal)(_, A, "type");
    return {
      gen: E,
      keyword: "type",
      data: R,
      schema: A.type,
      schemaCode: I,
      schemaValue: I,
      parentSchema: A,
      params: {},
      it: _,
    };
  }
})(lu);
var Ip = {};
Object.defineProperty(Ip, "__esModule", { value: !0 });
Ip.assignDefaults = void 0;
const uo = $t,
  rG = Ut;
function iG(e, t) {
  const { properties: n, items: r } = e.schema;
  if (t === "object" && n) for (const i in n) bx(e, i, n[i].default);
  else
    t === "array" &&
      Array.isArray(r) &&
      r.forEach((i, a) => bx(e, a, i.default));
}
Ip.assignDefaults = iG;
function bx(e, t, n) {
  const { gen: r, compositeRule: i, data: a, opts: s } = e;
  if (n === void 0) return;
  const o = (0, uo._)`${a}${(0, uo.getProperty)(t)}`;
  if (i) {
    (0, rG.checkStrictMode)(e, `default is ignored for: ${o}`);
    return;
  }
  let c = (0, uo._)`${o} === undefined`;
  s.useDefaults === "empty" &&
    (c = (0, uo._)`${c} || ${o} === null || ${o} === ""`),
    r.if(c, (0, uo._)`${o} = ${(0, uo.stringify)(n)}`);
}
var Fi = {},
  St = {};
Object.defineProperty(St, "__esModule", { value: !0 });
St.validateUnion =
  St.validateArray =
  St.usePattern =
  St.callValidateCode =
  St.schemaProperties =
  St.allSchemaProperties =
  St.noPropertyInData =
  St.propertyInData =
  St.isOwnProperty =
  St.hasPropFunc =
  St.reportMissingProp =
  St.checkMissingProp =
  St.checkReportMissingProp =
    void 0;
const dn = $t,
  my = Ut,
  _a = Wi,
  aG = Ut;
function sG(e, t) {
  const { gen: n, data: r, it: i } = e;
  n.if(vy(n, r, t, i.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, dn._)`${t}` }, !0), e.error();
  });
}
St.checkReportMissingProp = sG;
function oG({ gen: e, data: t, it: { opts: n } }, r, i) {
  return (0, dn.or)(
    ...r.map((a) =>
      (0, dn.and)(vy(e, t, a, n.ownProperties), (0, dn._)`${i} = ${a}`),
    ),
  );
}
St.checkMissingProp = oG;
function cG(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
St.reportMissingProp = cG;
function w4(e) {
  return e.scopeValue("func", {
    ref: Object.prototype.hasOwnProperty,
    code: (0, dn._)`Object.prototype.hasOwnProperty`,
  });
}
St.hasPropFunc = w4;
function gy(e, t, n) {
  return (0, dn._)`${w4(e)}.call(${t}, ${n})`;
}
St.isOwnProperty = gy;
function lG(e, t, n, r) {
  const i = (0, dn._)`${t}${(0, dn.getProperty)(n)} !== undefined`;
  return r ? (0, dn._)`${i} && ${gy(e, t, n)}` : i;
}
St.propertyInData = lG;
function vy(e, t, n, r) {
  const i = (0, dn._)`${t}${(0, dn.getProperty)(n)} === undefined`;
  return r ? (0, dn.or)(i, (0, dn.not)(gy(e, t, n))) : i;
}
St.noPropertyInData = vy;
function x4(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
St.allSchemaProperties = x4;
function uG(e, t) {
  return x4(t).filter((n) => !(0, my.alwaysValidSchema)(e, t[n]));
}
St.schemaProperties = uG;
function fG(
  {
    schemaCode: e,
    data: t,
    it: { gen: n, topSchemaRef: r, schemaPath: i, errorPath: a },
    it: s,
  },
  o,
  c,
  l,
) {
  const f = l ? (0, dn._)`${e}, ${t}, ${r}${i}` : t,
    u = [
      [_a.default.instancePath, (0, dn.strConcat)(_a.default.instancePath, a)],
      [_a.default.parentData, s.parentData],
      [_a.default.parentDataProperty, s.parentDataProperty],
      [_a.default.rootData, _a.default.rootData],
    ];
  s.opts.dynamicRef &&
    u.push([_a.default.dynamicAnchors, _a.default.dynamicAnchors]);
  const d = (0, dn._)`${f}, ${n.object(...u)}`;
  return c !== dn.nil
    ? (0, dn._)`${o}.call(${c}, ${d})`
    : (0, dn._)`${o}(${d})`;
}
St.callValidateCode = fG;
const dG = (0, dn._)`new RegExp`;
function pG({ gen: e, it: { opts: t } }, n) {
  const r = t.unicodeRegExp ? "u" : "",
    { regExp: i } = t.code,
    a = i(n, r);
  return e.scopeValue("pattern", {
    key: a.toString(),
    ref: a,
    code: (0, dn._)`${
      i.code === "new RegExp" ? dG : (0, aG.useFunc)(e, i)
    }(${n}, ${r})`,
  });
}
St.usePattern = pG;
function hG(e) {
  const { gen: t, data: n, keyword: r, it: i } = e,
    a = t.name("valid");
  if (i.allErrors) {
    const o = t.let("valid", !0);
    return s(() => t.assign(o, !1)), o;
  }
  return t.var(a, !0), s(() => t.break()), a;
  function s(o) {
    const c = t.const("len", (0, dn._)`${n}.length`);
    t.forRange("i", 0, c, (l) => {
      e.subschema({ keyword: r, dataProp: l, dataPropType: my.Type.Num }, a),
        t.if((0, dn.not)(a), o);
    });
  }
}
St.validateArray = hG;
function mG(e) {
  const { gen: t, schema: n, keyword: r, it: i } = e;
  if (!Array.isArray(n)) throw new Error("ajv implementation error");
  if (n.some((c) => (0, my.alwaysValidSchema)(i, c)) && !i.opts.unevaluated)
    return;
  const s = t.let("valid", !1),
    o = t.name("_valid");
  t.block(() =>
    n.forEach((c, l) => {
      const f = e.subschema(
        { keyword: r, schemaProp: l, compositeRule: !0 },
        o,
      );
      t.assign(s, (0, dn._)`${s} || ${o}`),
        e.mergeValidEvaluated(f, o) || t.if((0, dn.not)(s));
    }),
  ),
    e.result(
      s,
      () => e.reset(),
      () => e.error(!0),
    );
}
St.validateUnion = mG;
Object.defineProperty(Fi, "__esModule", { value: !0 });
Fi.validateKeywordUsage =
  Fi.validSchemaType =
  Fi.funcKeywordCode =
  Fi.macroKeywordCode =
    void 0;
const br = $t,
  ys = Wi,
  gG = St,
  vG = cu;
function yG(e, t) {
  const { gen: n, keyword: r, schema: i, parentSchema: a, it: s } = e,
    o = t.macro.call(s.self, i, a, s),
    c = A4(n, r, o);
  s.opts.validateSchema !== !1 && s.self.validateSchema(o, !0);
  const l = n.name("valid");
  e.subschema(
    {
      schema: o,
      schemaPath: br.nil,
      errSchemaPath: `${s.errSchemaPath}/${r}`,
      topSchemaRef: c,
      compositeRule: !0,
    },
    l,
  ),
    e.pass(l, () => e.error(!0));
}
Fi.macroKeywordCode = yG;
function bG(e, t) {
  var n;
  const { gen: r, keyword: i, schema: a, parentSchema: s, $data: o, it: c } = e;
  EG(c, t);
  const l = !o && t.compile ? t.compile.call(c.self, a, s, c) : t.validate,
    f = A4(r, i, l),
    u = r.let("valid");
  e.block$data(u, d), e.ok((n = t.valid) !== null && n !== void 0 ? n : u);
  function d() {
    if (t.errors === !1) m(), t.modifying && _x(e), g(() => e.error());
    else {
      const v = t.async ? p() : h();
      t.modifying && _x(e), g(() => _G(e, v));
    }
  }
  function p() {
    const v = r.let("ruleErrs", null);
    return (
      r.try(
        () => m((0, br._)`await `),
        (y) =>
          r.assign(u, !1).if(
            (0, br._)`${y} instanceof ${c.ValidationError}`,
            () => r.assign(v, (0, br._)`${y}.errors`),
            () => r.throw(y),
          ),
      ),
      v
    );
  }
  function h() {
    const v = (0, br._)`${f}.errors`;
    return r.assign(v, null), m(br.nil), v;
  }
  function m(v = t.async ? (0, br._)`await ` : br.nil) {
    const y = c.opts.passContext ? ys.default.this : ys.default.self,
      _ = !(("compile" in t && !o) || t.schema === !1);
    r.assign(
      u,
      (0, br._)`${v}${(0, gG.callValidateCode)(e, f, y, _)}`,
      t.modifying,
    );
  }
  function g(v) {
    var y;
    r.if((0, br.not)((y = t.valid) !== null && y !== void 0 ? y : u), v);
  }
}
Fi.funcKeywordCode = bG;
function _x(e) {
  const { gen: t, data: n, it: r } = e;
  t.if(r.parentData, () =>
    t.assign(n, (0, br._)`${r.parentData}[${r.parentDataProperty}]`),
  );
}
function _G(e, t) {
  const { gen: n } = e;
  n.if(
    (0, br._)`Array.isArray(${t})`,
    () => {
      n
        .assign(
          ys.default.vErrors,
          (0,
          br._)`${ys.default.vErrors} === null ? ${t} : ${ys.default.vErrors}.concat(${t})`,
        )
        .assign(ys.default.errors, (0, br._)`${ys.default.vErrors}.length`),
        (0, vG.extendErrors)(e);
    },
    () => e.error(),
  );
}
function EG({ schemaEnv: e }, t) {
  if (t.async && !e.$async) throw new Error("async keyword in sync schema");
}
function A4(e, t, n) {
  if (n === void 0) throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue(
    "keyword",
    typeof n == "function"
      ? { ref: n }
      : { ref: n, code: (0, br.stringify)(n) },
  );
}
function wG(e, t, n = !1) {
  return (
    !t.length ||
    t.some((r) =>
      r === "array"
        ? Array.isArray(e)
        : r === "object"
        ? e && typeof e == "object" && !Array.isArray(e)
        : typeof e == r || (n && typeof e > "u"),
    )
  );
}
Fi.validSchemaType = wG;
function xG({ schema: e, opts: t, self: n, errSchemaPath: r }, i, a) {
  if (Array.isArray(i.keyword) ? !i.keyword.includes(a) : i.keyword !== a)
    throw new Error("ajv implementation error");
  const s = i.dependencies;
  if (s != null && s.some((o) => !Object.prototype.hasOwnProperty.call(e, o)))
    throw new Error(
      `parent schema must have dependencies of ${a}: ${s.join(",")}`,
    );
  if (i.validateSchema && !i.validateSchema(e[a])) {
    const c =
      `keyword "${a}" value is invalid at path "${r}": ` +
      n.errorsText(i.validateSchema.errors);
    if (t.validateSchema === "log") n.logger.error(c);
    else throw new Error(c);
  }
}
Fi.validateKeywordUsage = xG;
var Ga = {};
Object.defineProperty(Ga, "__esModule", { value: !0 });
Ga.extendSubschemaMode = Ga.extendSubschemaData = Ga.getSubschema = void 0;
const Di = $t,
  S4 = Ut;
function AG(
  e,
  {
    keyword: t,
    schemaProp: n,
    schema: r,
    schemaPath: i,
    errSchemaPath: a,
    topSchemaRef: s,
  },
) {
  if (t !== void 0 && r !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const o = e.schema[t];
    return n === void 0
      ? {
          schema: o,
          schemaPath: (0, Di._)`${e.schemaPath}${(0, Di.getProperty)(t)}`,
          errSchemaPath: `${e.errSchemaPath}/${t}`,
        }
      : {
          schema: o[n],
          schemaPath: (0, Di._)`${e.schemaPath}${(0, Di.getProperty)(t)}${(0,
          Di.getProperty)(n)}`,
          errSchemaPath: `${e.errSchemaPath}/${t}/${(0, S4.escapeFragment)(n)}`,
        };
  }
  if (r !== void 0) {
    if (i === void 0 || a === void 0 || s === void 0)
      throw new Error(
        '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"',
      );
    return { schema: r, schemaPath: i, topSchemaRef: s, errSchemaPath: a };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
Ga.getSubschema = AG;
function SG(
  e,
  t,
  { dataProp: n, dataPropType: r, data: i, dataTypes: a, propertyName: s },
) {
  if (i !== void 0 && n !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: o } = t;
  if (n !== void 0) {
    const { errorPath: l, dataPathArr: f, opts: u } = t,
      d = o.let("data", (0, Di._)`${t.data}${(0, Di.getProperty)(n)}`, !0);
    c(d),
      (e.errorPath = (0, Di.str)`${l}${(0, S4.getErrorPath)(
        n,
        r,
        u.jsPropertySyntax,
      )}`),
      (e.parentDataProperty = (0, Di._)`${n}`),
      (e.dataPathArr = [...f, e.parentDataProperty]);
  }
  if (i !== void 0) {
    const l = i instanceof Di.Name ? i : o.let("data", i, !0);
    c(l), s !== void 0 && (e.propertyName = s);
  }
  a && (e.dataTypes = a);
  function c(l) {
    (e.data = l),
      (e.dataLevel = t.dataLevel + 1),
      (e.dataTypes = []),
      (t.definedProperties = new Set()),
      (e.parentData = t.data),
      (e.dataNames = [...t.dataNames, l]);
  }
}
Ga.extendSubschemaData = SG;
function IG(
  e,
  {
    jtdDiscriminator: t,
    jtdMetadata: n,
    compositeRule: r,
    createErrors: i,
    allErrors: a,
  },
) {
  r !== void 0 && (e.compositeRule = r),
    i !== void 0 && (e.createErrors = i),
    a !== void 0 && (e.allErrors = a),
    (e.jtdDiscriminator = t),
    (e.jtdMetadata = n);
}
Ga.extendSubschemaMode = IG;
var nr = {},
  $p = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, i, a;
      if (Array.isArray(t)) {
        if (((r = t.length), r != n.length)) return !1;
        for (i = r; i-- !== 0; ) if (!e(t[i], n[i])) return !1;
        return !0;
      }
      if (t.constructor === RegExp)
        return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf)
        return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString)
        return t.toString() === n.toString();
      if (((a = Object.keys(t)), (r = a.length), r !== Object.keys(n).length))
        return !1;
      for (i = r; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(n, a[i])) return !1;
      for (i = r; i-- !== 0; ) {
        var s = a[i];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  },
  I4 = { exports: {} },
  Fa = (I4.exports = function (e, t, n) {
    typeof t == "function" && ((n = t), (t = {})), (n = t.cb || n);
    var r = typeof n == "function" ? n : n.pre || function () {},
      i = n.post || function () {};
    Mf(t, r, i, e, "", e);
  });
Fa.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0,
};
Fa.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 };
Fa.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0,
};
Fa.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0,
};
function Mf(e, t, n, r, i, a, s, o, c, l) {
  if (r && typeof r == "object" && !Array.isArray(r)) {
    t(r, i, a, s, o, c, l);
    for (var f in r) {
      var u = r[f];
      if (Array.isArray(u)) {
        if (f in Fa.arrayKeywords)
          for (var d = 0; d < u.length; d++)
            Mf(e, t, n, u[d], i + "/" + f + "/" + d, a, i, f, r, d);
      } else if (f in Fa.propsKeywords) {
        if (u && typeof u == "object")
          for (var p in u)
            Mf(e, t, n, u[p], i + "/" + f + "/" + $G(p), a, i, f, r, p);
      } else
        (f in Fa.keywords || (e.allKeys && !(f in Fa.skipKeywords))) &&
          Mf(e, t, n, u, i + "/" + f, a, i, f, r);
    }
    n(r, i, a, s, o, c, l);
  }
}
function $G(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var CG = I4.exports;
Object.defineProperty(nr, "__esModule", { value: !0 });
nr.getSchemaRefs =
  nr.resolveUrl =
  nr.normalizeId =
  nr._getFullPath =
  nr.getFullPath =
  nr.inlineRef =
    void 0;
const RG = Ut,
  kG = $p,
  TG = CG,
  NG = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
  ]);
function OG(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !_0(e) : t ? $4(e) <= t : !1;
}
nr.inlineRef = OG;
const PG = new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor",
]);
function _0(e) {
  for (const t in e) {
    if (PG.has(t)) return !0;
    const n = e[t];
    if ((Array.isArray(n) && n.some(_0)) || (typeof n == "object" && _0(n)))
      return !0;
  }
  return !1;
}
function $4(e) {
  let t = 0;
  for (const n in e) {
    if (n === "$ref") return 1 / 0;
    if (
      (t++,
      !NG.has(n) &&
        (typeof e[n] == "object" && (0, RG.eachItem)(e[n], (r) => (t += $4(r))),
        t === 1 / 0))
    )
      return 1 / 0;
  }
  return t;
}
function C4(e, t = "", n) {
  n !== !1 && (t = Bo(t));
  const r = e.parse(t);
  return R4(e, r);
}
nr.getFullPath = C4;
function R4(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
nr._getFullPath = R4;
const DG = /#\/?$/;
function Bo(e) {
  return e ? e.replace(DG, "") : "";
}
nr.normalizeId = Bo;
function LG(e, t, n) {
  return (n = Bo(n)), e.resolve(t, n);
}
nr.resolveUrl = LG;
const BG = /^[a-z_][-a-z0-9._]*$/i;
function UG(e, t) {
  if (typeof e == "boolean") return {};
  const { schemaId: n, uriResolver: r } = this.opts,
    i = Bo(e[n] || t),
    a = { "": i },
    s = C4(r, i, !1),
    o = {},
    c = new Set();
  return (
    TG(e, { allKeys: !0 }, (u, d, p, h) => {
      if (h === void 0) return;
      const m = s + d;
      let g = a[h];
      typeof u[n] == "string" && (g = v.call(this, u[n])),
        y.call(this, u.$anchor),
        y.call(this, u.$dynamicAnchor),
        (a[d] = g);
      function v(_) {
        const E = this.opts.uriResolver.resolve;
        if (((_ = Bo(g ? E(g, _) : _)), c.has(_))) throw f(_);
        c.add(_);
        let R = this.refs[_];
        return (
          typeof R == "string" && (R = this.refs[R]),
          typeof R == "object"
            ? l(u, R.schema, _)
            : _ !== Bo(m) &&
              (_[0] === "#" ? (l(u, o[_], _), (o[_] = u)) : (this.refs[_] = m)),
          _
        );
      }
      function y(_) {
        if (typeof _ == "string") {
          if (!BG.test(_)) throw new Error(`invalid anchor "${_}"`);
          v.call(this, `#${_}`);
        }
      }
    }),
    o
  );
  function l(u, d, p) {
    if (d !== void 0 && !kG(u, d)) throw f(p);
  }
  function f(u) {
    return new Error(`reference "${u}" resolves to more than one schema`);
  }
}
nr.getSchemaRefs = UG;
Object.defineProperty(yi, "__esModule", { value: !0 });
yi.getData = yi.KeywordCxt = yi.validateFunctionCode = void 0;
const k4 = ac,
  Ex = lu,
  yy = la,
  bd = lu,
  FG = Ip,
  vl = Fi,
  $m = Ga,
  Ye = $t,
  gt = Wi,
  jG = nr,
  ua = Ut,
  Qc = cu;
function MG(e) {
  if (O4(e) && (P4(e), N4(e))) {
    GG(e);
    return;
  }
  T4(e, () => (0, k4.topBoolOrEmptySchema)(e));
}
yi.validateFunctionCode = MG;
function T4({ gen: e, validateName: t, schema: n, schemaEnv: r, opts: i }, a) {
  i.code.es5
    ? e.func(
        t,
        (0, Ye._)`${gt.default.data}, ${gt.default.valCxt}`,
        r.$async,
        () => {
          e.code((0, Ye._)`"use strict"; ${wx(n, i)}`), qG(e, i), e.code(a);
        },
      )
    : e.func(t, (0, Ye._)`${gt.default.data}, ${HG(i)}`, r.$async, () =>
        e.code(wx(n, i)).code(a),
      );
}
function HG(e) {
  return (0, Ye._)`{${gt.default.instancePath}="", ${gt.default.parentData}, ${
    gt.default.parentDataProperty
  }, ${gt.default.rootData}=${gt.default.data}${
    e.dynamicRef ? (0, Ye._)`, ${gt.default.dynamicAnchors}={}` : Ye.nil
  }}={}`;
}
function qG(e, t) {
  e.if(
    gt.default.valCxt,
    () => {
      e.var(
        gt.default.instancePath,
        (0, Ye._)`${gt.default.valCxt}.${gt.default.instancePath}`,
      ),
        e.var(
          gt.default.parentData,
          (0, Ye._)`${gt.default.valCxt}.${gt.default.parentData}`,
        ),
        e.var(
          gt.default.parentDataProperty,
          (0, Ye._)`${gt.default.valCxt}.${gt.default.parentDataProperty}`,
        ),
        e.var(
          gt.default.rootData,
          (0, Ye._)`${gt.default.valCxt}.${gt.default.rootData}`,
        ),
        t.dynamicRef &&
          e.var(
            gt.default.dynamicAnchors,
            (0, Ye._)`${gt.default.valCxt}.${gt.default.dynamicAnchors}`,
          );
    },
    () => {
      e.var(gt.default.instancePath, (0, Ye._)`""`),
        e.var(gt.default.parentData, (0, Ye._)`undefined`),
        e.var(gt.default.parentDataProperty, (0, Ye._)`undefined`),
        e.var(gt.default.rootData, gt.default.data),
        t.dynamicRef && e.var(gt.default.dynamicAnchors, (0, Ye._)`{}`);
    },
  );
}
function GG(e) {
  const { schema: t, opts: n, gen: r } = e;
  T4(e, () => {
    n.$comment && t.$comment && L4(e),
      VG(e),
      r.let(gt.default.vErrors, null),
      r.let(gt.default.errors, 0),
      n.unevaluated && QG(e),
      D4(e),
      JG(e);
  });
}
function QG(e) {
  const { gen: t, validateName: n } = e;
  (e.evaluated = t.const("evaluated", (0, Ye._)`${n}.evaluated`)),
    t.if((0, Ye._)`${e.evaluated}.dynamicProps`, () =>
      t.assign((0, Ye._)`${e.evaluated}.props`, (0, Ye._)`undefined`),
    ),
    t.if((0, Ye._)`${e.evaluated}.dynamicItems`, () =>
      t.assign((0, Ye._)`${e.evaluated}.items`, (0, Ye._)`undefined`),
    );
}
function wx(e, t) {
  const n = typeof e == "object" && e[t.schemaId];
  return n && (t.code.source || t.code.process)
    ? (0, Ye._)`/*# sourceURL=${n} */`
    : Ye.nil;
}
function WG(e, t) {
  if (O4(e) && (P4(e), N4(e))) {
    zG(e, t);
    return;
  }
  (0, k4.boolOrEmptySchema)(e, t);
}
function N4({ schema: e, self: t }) {
  if (typeof e == "boolean") return !e;
  for (const n in e) if (t.RULES.all[n]) return !0;
  return !1;
}
function O4(e) {
  return typeof e.schema != "boolean";
}
function zG(e, t) {
  const { schema: n, gen: r, opts: i } = e;
  i.$comment && n.$comment && L4(e), YG(e), XG(e);
  const a = r.const("_errs", gt.default.errors);
  D4(e, a), r.var(t, (0, Ye._)`${a} === ${gt.default.errors}`);
}
function P4(e) {
  (0, ua.checkUnknownRules)(e), KG(e);
}
function D4(e, t) {
  if (e.opts.jtd) return xx(e, [], !1, t);
  const n = (0, Ex.getSchemaTypes)(e.schema),
    r = (0, Ex.coerceAndCheckDataType)(e, n);
  xx(e, n, !r, t);
}
function KG(e) {
  const { schema: t, errSchemaPath: n, opts: r, self: i } = e;
  t.$ref &&
    r.ignoreKeywordsWithRef &&
    (0, ua.schemaHasRulesButRef)(t, i.RULES) &&
    i.logger.warn(`$ref: keywords ignored in schema at path "${n}"`);
}
function VG(e) {
  const { schema: t, opts: n } = e;
  t.default !== void 0 &&
    n.useDefaults &&
    n.strictSchema &&
    (0, ua.checkStrictMode)(e, "default is ignored in the schema root");
}
function YG(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, jG.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function XG(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function L4({ gen: e, schemaEnv: t, schema: n, errSchemaPath: r, opts: i }) {
  const a = n.$comment;
  if (i.$comment === !0) e.code((0, Ye._)`${gt.default.self}.logger.log(${a})`);
  else if (typeof i.$comment == "function") {
    const s = (0, Ye.str)`${r}/$comment`,
      o = e.scopeValue("root", { ref: t.root });
    e.code(
      (0, Ye._)`${gt.default.self}.opts.$comment(${a}, ${s}, ${o}.schema)`,
    );
  }
}
function JG(e) {
  const {
    gen: t,
    schemaEnv: n,
    validateName: r,
    ValidationError: i,
    opts: a,
  } = e;
  n.$async
    ? t.if(
        (0, Ye._)`${gt.default.errors} === 0`,
        () => t.return(gt.default.data),
        () => t.throw((0, Ye._)`new ${i}(${gt.default.vErrors})`),
      )
    : (t.assign((0, Ye._)`${r}.errors`, gt.default.vErrors),
      a.unevaluated && ZG(e),
      t.return((0, Ye._)`${gt.default.errors} === 0`));
}
function ZG({ gen: e, evaluated: t, props: n, items: r }) {
  n instanceof Ye.Name && e.assign((0, Ye._)`${t}.props`, n),
    r instanceof Ye.Name && e.assign((0, Ye._)`${t}.items`, r);
}
function xx(e, t, n, r) {
  const { gen: i, schema: a, data: s, allErrors: o, opts: c, self: l } = e,
    { RULES: f } = l;
  if (
    a.$ref &&
    (c.ignoreKeywordsWithRef || !(0, ua.schemaHasRulesButRef)(a, f))
  ) {
    i.block(() => F4(e, "$ref", f.all.$ref.definition));
    return;
  }
  c.jtd || eQ(e, t),
    i.block(() => {
      for (const d of f.rules) u(d);
      u(f.post);
    });
  function u(d) {
    (0, yy.shouldUseGroup)(a, d) &&
      (d.type
        ? (i.if((0, bd.checkDataType)(d.type, s, c.strictNumbers)),
          Ax(e, d),
          t.length === 1 &&
            t[0] === d.type &&
            n &&
            (i.else(), (0, bd.reportTypeError)(e)),
          i.endIf())
        : Ax(e, d),
      o || i.if((0, Ye._)`${gt.default.errors} === ${r || 0}`));
  }
}
function Ax(e, t) {
  const {
    gen: n,
    schema: r,
    opts: { useDefaults: i },
  } = e;
  i && (0, FG.assignDefaults)(e, t.type),
    n.block(() => {
      for (const a of t.rules)
        (0, yy.shouldUseRule)(r, a) && F4(e, a.keyword, a.definition, t.type);
    });
}
function eQ(e, t) {
  e.schemaEnv.meta ||
    !e.opts.strictTypes ||
    (tQ(e, t), e.opts.allowUnionTypes || nQ(e, t), rQ(e, e.dataTypes));
}
function tQ(e, t) {
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((n) => {
      B4(e.dataTypes, n) ||
        by(e, `type "${n}" not allowed by context "${e.dataTypes.join(",")}"`);
    }),
      aQ(e, t);
  }
}
function nQ(e, t) {
  t.length > 1 &&
    !(t.length === 2 && t.includes("null")) &&
    by(e, "use allowUnionTypes to allow union type keyword");
}
function rQ(e, t) {
  const n = e.self.RULES.all;
  for (const r in n) {
    const i = n[r];
    if (typeof i == "object" && (0, yy.shouldUseRule)(e.schema, i)) {
      const { type: a } = i.definition;
      a.length &&
        !a.some((s) => iQ(t, s)) &&
        by(e, `missing type "${a.join(",")}" for keyword "${r}"`);
    }
  }
}
function iQ(e, t) {
  return e.includes(t) || (t === "number" && e.includes("integer"));
}
function B4(e, t) {
  return e.includes(t) || (t === "integer" && e.includes("number"));
}
function aQ(e, t) {
  const n = [];
  for (const r of e.dataTypes)
    B4(t, r)
      ? n.push(r)
      : t.includes("integer") && r === "number" && n.push("integer");
  e.dataTypes = n;
}
function by(e, t) {
  const n = e.schemaEnv.baseId + e.errSchemaPath;
  (t += ` at "${n}" (strictTypes)`),
    (0, ua.checkStrictMode)(e, t, e.opts.strictTypes);
}
let U4 = class {
  constructor(t, n, r) {
    if (
      ((0, vl.validateKeywordUsage)(t, n, r),
      (this.gen = t.gen),
      (this.allErrors = t.allErrors),
      (this.keyword = r),
      (this.data = t.data),
      (this.schema = t.schema[r]),
      (this.$data =
        n.$data && t.opts.$data && this.schema && this.schema.$data),
      (this.schemaValue = (0, ua.schemaRefOrVal)(
        t,
        this.schema,
        r,
        this.$data,
      )),
      (this.schemaType = n.schemaType),
      (this.parentSchema = t.schema),
      (this.params = {}),
      (this.it = t),
      (this.def = n),
      this.$data)
    )
      this.schemaCode = t.gen.const("vSchema", j4(this.$data, t));
    else if (
      ((this.schemaCode = this.schemaValue),
      !(0, vl.validSchemaType)(this.schema, n.schemaType, n.allowUndefined))
    )
      throw new Error(`${r} value must be ${JSON.stringify(n.schemaType)}`);
    ("code" in n ? n.trackErrors : n.errors !== !1) &&
      (this.errsCount = t.gen.const("_errs", gt.default.errors));
  }
  result(t, n, r) {
    this.failResult((0, Ye.not)(t), n, r);
  }
  failResult(t, n, r) {
    this.gen.if(t),
      r ? r() : this.error(),
      n
        ? (this.gen.else(), n(), this.allErrors && this.gen.endIf())
        : this.allErrors
        ? this.gen.endIf()
        : this.gen.else();
  }
  pass(t, n) {
    this.failResult((0, Ye.not)(t), void 0, n);
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(t),
      this.error(),
      this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data) return this.fail(t);
    const { schemaCode: n } = this;
    this.fail(
      (0, Ye._)`${n} !== undefined && (${(0, Ye.or)(this.invalid$data(), t)})`,
    );
  }
  error(t, n, r) {
    if (n) {
      this.setParams(n), this._error(t, r), this.setParams({});
      return;
    }
    this._error(t, r);
  }
  _error(t, n) {
    (t ? Qc.reportExtraError : Qc.reportError)(this, this.def.error, n);
  }
  $dataError() {
    (0, Qc.reportError)(this, this.def.$dataError || Qc.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, Qc.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, n) {
    n ? Object.assign(this.params, t) : (this.params = t);
  }
  block$data(t, n, r = Ye.nil) {
    this.gen.block(() => {
      this.check$data(t, r), n();
    });
  }
  check$data(t = Ye.nil, n = Ye.nil) {
    if (!this.$data) return;
    const { gen: r, schemaCode: i, schemaType: a, def: s } = this;
    r.if((0, Ye.or)((0, Ye._)`${i} === undefined`, n)),
      t !== Ye.nil && r.assign(t, !0),
      (a.length || s.validateSchema) &&
        (r.elseIf(this.invalid$data()),
        this.$dataError(),
        t !== Ye.nil && r.assign(t, !1)),
      r.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: n, schemaType: r, def: i, it: a } = this;
    return (0, Ye.or)(s(), o());
    function s() {
      if (r.length) {
        if (!(n instanceof Ye.Name))
          throw new Error("ajv implementation error");
        const c = Array.isArray(r) ? r : [r];
        return (0, Ye._)`${(0, bd.checkDataTypes)(
          c,
          n,
          a.opts.strictNumbers,
          bd.DataType.Wrong,
        )}`;
      }
      return Ye.nil;
    }
    function o() {
      if (i.validateSchema) {
        const c = t.scopeValue("validate$data", { ref: i.validateSchema });
        return (0, Ye._)`!${c}(${n})`;
      }
      return Ye.nil;
    }
  }
  subschema(t, n) {
    const r = (0, $m.getSubschema)(this.it, t);
    (0, $m.extendSubschemaData)(r, this.it, t),
      (0, $m.extendSubschemaMode)(r, t);
    const i = { ...this.it, ...r, items: void 0, props: void 0 };
    return WG(i, n), i;
  }
  mergeEvaluated(t, n) {
    const { it: r, gen: i } = this;
    r.opts.unevaluated &&
      (r.props !== !0 &&
        t.props !== void 0 &&
        (r.props = ua.mergeEvaluated.props(i, t.props, r.props, n)),
      r.items !== !0 &&
        t.items !== void 0 &&
        (r.items = ua.mergeEvaluated.items(i, t.items, r.items, n)));
  }
  mergeValidEvaluated(t, n) {
    const { it: r, gen: i } = this;
    if (r.opts.unevaluated && (r.props !== !0 || r.items !== !0))
      return i.if(n, () => this.mergeEvaluated(t, Ye.Name)), !0;
  }
};
yi.KeywordCxt = U4;
function F4(e, t, n, r) {
  const i = new U4(e, n, t);
  "code" in n
    ? n.code(i, r)
    : i.$data && n.validate
    ? (0, vl.funcKeywordCode)(i, n)
    : "macro" in n
    ? (0, vl.macroKeywordCode)(i, n)
    : (n.compile || n.validate) && (0, vl.funcKeywordCode)(i, n);
}
const sQ = /^\/(?:[^~]|~0|~1)*$/,
  oQ = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function j4(e, { dataLevel: t, dataNames: n, dataPathArr: r }) {
  let i, a;
  if (e === "") return gt.default.rootData;
  if (e[0] === "/") {
    if (!sQ.test(e)) throw new Error(`Invalid JSON-pointer: ${e}`);
    (i = e), (a = gt.default.rootData);
  } else {
    const l = oQ.exec(e);
    if (!l) throw new Error(`Invalid JSON-pointer: ${e}`);
    const f = +l[1];
    if (((i = l[2]), i === "#")) {
      if (f >= t) throw new Error(c("property/index", f));
      return r[t - f];
    }
    if (f > t) throw new Error(c("data", f));
    if (((a = n[t - f]), !i)) return a;
  }
  let s = a;
  const o = i.split("/");
  for (const l of o)
    l &&
      ((a = (0, Ye._)`${a}${(0, Ye.getProperty)(
        (0, ua.unescapeJsonPointer)(l),
      )}`),
      (s = (0, Ye._)`${s} && ${a}`));
  return s;
  function c(l, f) {
    return `Cannot access ${l} ${f} levels up, current level is ${t}`;
  }
}
yi.getData = j4;
var uu = {};
Object.defineProperty(uu, "__esModule", { value: !0 });
let cQ = class extends Error {
  constructor(t) {
    super("validation failed"),
      (this.errors = t),
      (this.ajv = this.validation = !0);
  }
};
uu.default = cQ;
var fu = {};
Object.defineProperty(fu, "__esModule", { value: !0 });
const Cm = nr;
let lQ = class extends Error {
  constructor(t, n, r, i) {
    super(i || `can't resolve reference ${r} from id ${n}`),
      (this.missingRef = (0, Cm.resolveUrl)(t, n, r)),
      (this.missingSchema = (0, Cm.normalizeId)(
        (0, Cm.getFullPath)(t, this.missingRef),
      ));
  }
};
fu.default = lQ;
var Dr = {};
Object.defineProperty(Dr, "__esModule", { value: !0 });
Dr.resolveSchema =
  Dr.getCompilingSchema =
  Dr.resolveRef =
  Dr.compileSchema =
  Dr.SchemaEnv =
    void 0;
const ii = $t,
  uQ = uu,
  us = Wi,
  hi = nr,
  Sx = Ut,
  fQ = yi;
let Cp = class {
  constructor(t) {
    var n;
    (this.refs = {}), (this.dynamicAnchors = {});
    let r;
    typeof t.schema == "object" && (r = t.schema),
      (this.schema = t.schema),
      (this.schemaId = t.schemaId),
      (this.root = t.root || this),
      (this.baseId =
        (n = t.baseId) !== null && n !== void 0
          ? n
          : (0, hi.normalizeId)(r == null ? void 0 : r[t.schemaId || "$id"])),
      (this.schemaPath = t.schemaPath),
      (this.localRefs = t.localRefs),
      (this.meta = t.meta),
      (this.$async = r == null ? void 0 : r.$async),
      (this.refs = {});
  }
};
Dr.SchemaEnv = Cp;
function _y(e) {
  const t = M4.call(this, e);
  if (t) return t;
  const n = (0, hi.getFullPath)(this.opts.uriResolver, e.root.baseId),
    { es5: r, lines: i } = this.opts.code,
    { ownProperties: a } = this.opts,
    s = new ii.CodeGen(this.scope, { es5: r, lines: i, ownProperties: a });
  let o;
  e.$async &&
    (o = s.scopeValue("Error", {
      ref: uQ.default,
      code: (0, ii._)`require("ajv/dist/runtime/validation_error").default`,
    }));
  const c = s.scopeName("validate");
  e.validateName = c;
  const l = {
    gen: s,
    allErrors: this.opts.allErrors,
    data: us.default.data,
    parentData: us.default.parentData,
    parentDataProperty: us.default.parentDataProperty,
    dataNames: [us.default.data],
    dataPathArr: [ii.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: new Set(),
    topSchemaRef: s.scopeValue(
      "schema",
      this.opts.code.source === !0
        ? { ref: e.schema, code: (0, ii.stringify)(e.schema) }
        : { ref: e.schema },
    ),
    validateName: c,
    ValidationError: o,
    schema: e.schema,
    schemaEnv: e,
    rootId: n,
    baseId: e.baseId || n,
    schemaPath: ii.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, ii._)`""`,
    opts: this.opts,
    self: this,
  };
  let f;
  try {
    this._compilations.add(e),
      (0, fQ.validateFunctionCode)(l),
      s.optimize(this.opts.code.optimize);
    const u = s.toString();
    (f = `${s.scopeRefs(us.default.scope)}return ${u}`),
      this.opts.code.process && (f = this.opts.code.process(f, e));
    const p = new Function(`${us.default.self}`, `${us.default.scope}`, f)(
      this,
      this.scope.get(),
    );
    if (
      (this.scope.value(c, { ref: p }),
      (p.errors = null),
      (p.schema = e.schema),
      (p.schemaEnv = e),
      e.$async && (p.$async = !0),
      this.opts.code.source === !0 &&
        (p.source = {
          validateName: c,
          validateCode: u,
          scopeValues: s._values,
        }),
      this.opts.unevaluated)
    ) {
      const { props: h, items: m } = l;
      (p.evaluated = {
        props: h instanceof ii.Name ? void 0 : h,
        items: m instanceof ii.Name ? void 0 : m,
        dynamicProps: h instanceof ii.Name,
        dynamicItems: m instanceof ii.Name,
      }),
        p.source && (p.source.evaluated = (0, ii.stringify)(p.evaluated));
    }
    return (e.validate = p), e;
  } catch (u) {
    throw (
      (delete e.validate,
      delete e.validateName,
      f && this.logger.error("Error compiling schema, function code:", f),
      u)
    );
  } finally {
    this._compilations.delete(e);
  }
}
Dr.compileSchema = _y;
function dQ(e, t, n) {
  var r;
  n = (0, hi.resolveUrl)(this.opts.uriResolver, t, n);
  const i = e.refs[n];
  if (i) return i;
  let a = mQ.call(this, e, n);
  if (a === void 0) {
    const s = (r = e.localRefs) === null || r === void 0 ? void 0 : r[n],
      { schemaId: o } = this.opts;
    s && (a = new Cp({ schema: s, schemaId: o, root: e, baseId: t }));
  }
  if (a !== void 0) return (e.refs[n] = pQ.call(this, a));
}
Dr.resolveRef = dQ;
function pQ(e) {
  return (0, hi.inlineRef)(e.schema, this.opts.inlineRefs)
    ? e.schema
    : e.validate
    ? e
    : _y.call(this, e);
}
function M4(e) {
  for (const t of this._compilations) if (hQ(t, e)) return t;
}
Dr.getCompilingSchema = M4;
function hQ(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function mQ(e, t) {
  let n;
  for (; typeof (n = this.refs[t]) == "string"; ) t = n;
  return n || this.schemas[t] || Rp.call(this, e, t);
}
function Rp(e, t) {
  const n = this.opts.uriResolver.parse(t),
    r = (0, hi._getFullPath)(this.opts.uriResolver, n);
  let i = (0, hi.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && r === i) return Rm.call(this, n, e);
  const a = (0, hi.normalizeId)(r),
    s = this.refs[a] || this.schemas[a];
  if (typeof s == "string") {
    const o = Rp.call(this, e, s);
    return typeof (o == null ? void 0 : o.schema) != "object"
      ? void 0
      : Rm.call(this, n, o);
  }
  if (typeof (s == null ? void 0 : s.schema) == "object") {
    if ((s.validate || _y.call(this, s), a === (0, hi.normalizeId)(t))) {
      const { schema: o } = s,
        { schemaId: c } = this.opts,
        l = o[c];
      return (
        l && (i = (0, hi.resolveUrl)(this.opts.uriResolver, i, l)),
        new Cp({ schema: o, schemaId: c, root: e, baseId: i })
      );
    }
    return Rm.call(this, n, s);
  }
}
Dr.resolveSchema = Rp;
const gQ = new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions",
]);
function Rm(e, { baseId: t, schema: n, root: r }) {
  var i;
  if (((i = e.fragment) === null || i === void 0 ? void 0 : i[0]) !== "/")
    return;
  for (const o of e.fragment.slice(1).split("/")) {
    if (typeof n == "boolean") return;
    const c = n[(0, Sx.unescapeFragment)(o)];
    if (c === void 0) return;
    n = c;
    const l = typeof n == "object" && n[this.opts.schemaId];
    !gQ.has(o) && l && (t = (0, hi.resolveUrl)(this.opts.uriResolver, t, l));
  }
  let a;
  if (
    typeof n != "boolean" &&
    n.$ref &&
    !(0, Sx.schemaHasRulesButRef)(n, this.RULES)
  ) {
    const o = (0, hi.resolveUrl)(this.opts.uriResolver, t, n.$ref);
    a = Rp.call(this, r, o);
  }
  const { schemaId: s } = this.opts;
  if (
    ((a = a || new Cp({ schema: n, schemaId: s, root: r, baseId: t })),
    a.schema !== a.root.schema)
  )
    return a;
}
const vQ =
    "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
  yQ = "Meta-schema for $data reference (JSON AnySchema extension proposal)",
  bQ = "object",
  _Q = ["$data"],
  EQ = {
    $data: {
      type: "string",
      anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }],
    },
  },
  wQ = !1,
  xQ = {
    $id: vQ,
    description: yQ,
    type: bQ,
    required: _Q,
    properties: EQ,
    additionalProperties: wQ,
  };
var Ey = {},
  E0 = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function (
  e,
  t,
) {
  (function (n, r) {
    r(t);
  })(Tn, function (n) {
    function r() {
      for (var C = arguments.length, $ = Array(C), b = 0; b < C; b++)
        $[b] = arguments[b];
      if ($.length > 1) {
        $[0] = $[0].slice(0, -1);
        for (var D = $.length - 1, K = 1; K < D; ++K) $[K] = $[K].slice(1, -1);
        return ($[D] = $[D].slice(1)), $.join("");
      } else return $[0];
    }
    function i(C) {
      return "(?:" + C + ")";
    }
    function a(C) {
      return C === void 0
        ? "undefined"
        : C === null
        ? "null"
        : Object.prototype.toString
            .call(C)
            .split(" ")
            .pop()
            .split("]")
            .shift()
            .toLowerCase();
    }
    function s(C) {
      return C.toUpperCase();
    }
    function o(C) {
      return C != null
        ? C instanceof Array
          ? C
          : typeof C.length != "number" || C.split || C.setInterval || C.call
          ? [C]
          : Array.prototype.slice.call(C)
        : [];
    }
    function c(C, $) {
      var b = C;
      if ($) for (var D in $) b[D] = $[D];
      return b;
    }
    function l(C) {
      var $ = "[A-Za-z]",
        b = "[0-9]",
        D = r(b, "[A-Fa-f]"),
        K = i(
          i("%[EFef]" + D + "%" + D + D + "%" + D + D) +
            "|" +
            i("%[89A-Fa-f]" + D + "%" + D + D) +
            "|" +
            i("%" + D + D),
        ),
        se = "[\\:\\/\\?\\#\\[\\]\\@]",
        pe = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        we = r(se, pe),
        Re = C
          ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]"
          : "[]",
        ke = C ? "[\\uE000-\\uF8FF]" : "[]",
        je = r($, b, "[\\-\\.\\_\\~]", Re);
      i($ + r($, b, "[\\+\\-\\.]") + "*"),
        i(i(K + "|" + r(je, pe, "[\\:]")) + "*");
      var Te = i(
          i("25[0-5]") +
            "|" +
            i("2[0-4]" + b) +
            "|" +
            i("1" + b + b) +
            "|" +
            i("0?[1-9]" + b) +
            "|0?0?" +
            b,
        ),
        Me = i(Te + "\\." + Te + "\\." + Te + "\\." + Te),
        Ne = i(D + "{1,4}"),
        Ue = i(i(Ne + "\\:" + Ne) + "|" + Me),
        qe = i(i(Ne + "\\:") + "{6}" + Ue),
        Fe = i("\\:\\:" + i(Ne + "\\:") + "{5}" + Ue),
        Je = i(i(Ne) + "?\\:\\:" + i(Ne + "\\:") + "{4}" + Ue),
        Ke = i(
          i(i(Ne + "\\:") + "{0,1}" + Ne) +
            "?\\:\\:" +
            i(Ne + "\\:") +
            "{3}" +
            Ue,
        ),
        Be = i(
          i(i(Ne + "\\:") + "{0,2}" + Ne) +
            "?\\:\\:" +
            i(Ne + "\\:") +
            "{2}" +
            Ue,
        ),
        He = i(i(i(Ne + "\\:") + "{0,3}" + Ne) + "?\\:\\:" + Ne + "\\:" + Ue),
        De = i(i(i(Ne + "\\:") + "{0,4}" + Ne) + "?\\:\\:" + Ue),
        Le = i(i(i(Ne + "\\:") + "{0,5}" + Ne) + "?\\:\\:" + Ne),
        Pe = i(i(i(Ne + "\\:") + "{0,6}" + Ne) + "?\\:\\:"),
        Oe = i([qe, Fe, Je, Ke, Be, He, De, Le, Pe].join("|")),
        ge = i(i(je + "|" + K) + "+");
      i("[vV]" + D + "+\\." + r(je, pe, "[\\:]") + "+"),
        i(i(K + "|" + r(je, pe)) + "*");
      var ve = i(K + "|" + r(je, pe, "[\\:\\@]"));
      return (
        i(i(K + "|" + r(je, pe, "[\\@]")) + "+"),
        i(i(ve + "|" + r("[\\/\\?]", ke)) + "*"),
        {
          NOT_SCHEME: new RegExp(r("[^]", $, b, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(r("[^\\%\\:]", je, pe), "g"),
          NOT_HOST: new RegExp(r("[^\\%\\[\\]\\:]", je, pe), "g"),
          NOT_PATH: new RegExp(r("[^\\%\\/\\:\\@]", je, pe), "g"),
          NOT_PATH_NOSCHEME: new RegExp(r("[^\\%\\/\\@]", je, pe), "g"),
          NOT_QUERY: new RegExp(r("[^\\%]", je, pe, "[\\:\\@\\/\\?]", ke), "g"),
          NOT_FRAGMENT: new RegExp(r("[^\\%]", je, pe, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(r("[^]", je, pe), "g"),
          UNRESERVED: new RegExp(je, "g"),
          OTHER_CHARS: new RegExp(r("[^\\%]", je, we), "g"),
          PCT_ENCODED: new RegExp(K, "g"),
          IPV4ADDRESS: new RegExp("^(" + Me + ")$"),
          IPV6ADDRESS: new RegExp(
            "^\\[?(" +
              Oe +
              ")" +
              i(i("\\%25|\\%(?!" + D + "{2})") + "(" + ge + ")") +
              "?\\]?$",
          ),
        }
      );
    }
    var f = l(!1),
      u = l(!0),
      d = (function () {
        function C($, b) {
          var D = [],
            K = !0,
            se = !1,
            pe = void 0;
          try {
            for (
              var we = $[Symbol.iterator](), Re;
              !(K = (Re = we.next()).done) &&
              (D.push(Re.value), !(b && D.length === b));
              K = !0
            );
          } catch (ke) {
            (se = !0), (pe = ke);
          } finally {
            try {
              !K && we.return && we.return();
            } finally {
              if (se) throw pe;
            }
          }
          return D;
        }
        return function ($, b) {
          if (Array.isArray($)) return $;
          if (Symbol.iterator in Object($)) return C($, b);
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance",
          );
        };
      })(),
      p = function (C) {
        if (Array.isArray(C)) {
          for (var $ = 0, b = Array(C.length); $ < C.length; $++) b[$] = C[$];
          return b;
        } else return Array.from(C);
      },
      h = 2147483647,
      m = 36,
      g = 1,
      v = 26,
      y = 38,
      _ = 700,
      E = 72,
      R = 128,
      A = "-",
      I = /^xn--/,
      S = /[^\0-\x7E]/,
      w = /[\x2E\u3002\uFF0E\uFF61]/g,
      O = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input",
      },
      Q = m - g,
      j = Math.floor,
      H = String.fromCharCode;
    function q(C) {
      throw new RangeError(O[C]);
    }
    function J(C, $) {
      for (var b = [], D = C.length; D--; ) b[D] = $(C[D]);
      return b;
    }
    function Z(C, $) {
      var b = C.split("@"),
        D = "";
      b.length > 1 && ((D = b[0] + "@"), (C = b[1])), (C = C.replace(w, "."));
      var K = C.split("."),
        se = J(K, $).join(".");
      return D + se;
    }
    function z(C) {
      for (var $ = [], b = 0, D = C.length; b < D; ) {
        var K = C.charCodeAt(b++);
        if (K >= 55296 && K <= 56319 && b < D) {
          var se = C.charCodeAt(b++);
          (se & 64512) == 56320
            ? $.push(((K & 1023) << 10) + (se & 1023) + 65536)
            : ($.push(K), b--);
        } else $.push(K);
      }
      return $;
    }
    var U = function ($) {
        return String.fromCodePoint.apply(String, p($));
      },
      G = function ($) {
        return $ - 48 < 10
          ? $ - 22
          : $ - 65 < 26
          ? $ - 65
          : $ - 97 < 26
          ? $ - 97
          : m;
      },
      L = function ($, b) {
        return $ + 22 + 75 * ($ < 26) - ((b != 0) << 5);
      },
      k = function ($, b, D) {
        var K = 0;
        for ($ = D ? j($ / _) : $ >> 1, $ += j($ / b); $ > (Q * v) >> 1; K += m)
          $ = j($ / Q);
        return j(K + ((Q + 1) * $) / ($ + y));
      },
      W = function ($) {
        var b = [],
          D = $.length,
          K = 0,
          se = R,
          pe = E,
          we = $.lastIndexOf(A);
        we < 0 && (we = 0);
        for (var Re = 0; Re < we; ++Re)
          $.charCodeAt(Re) >= 128 && q("not-basic"), b.push($.charCodeAt(Re));
        for (var ke = we > 0 ? we + 1 : 0; ke < D; ) {
          for (var je = K, Te = 1, Me = m; ; Me += m) {
            ke >= D && q("invalid-input");
            var Ne = G($.charCodeAt(ke++));
            (Ne >= m || Ne > j((h - K) / Te)) && q("overflow"), (K += Ne * Te);
            var Ue = Me <= pe ? g : Me >= pe + v ? v : Me - pe;
            if (Ne < Ue) break;
            var qe = m - Ue;
            Te > j(h / qe) && q("overflow"), (Te *= qe);
          }
          var Fe = b.length + 1;
          (pe = k(K - je, Fe, je == 0)),
            j(K / Fe) > h - se && q("overflow"),
            (se += j(K / Fe)),
            (K %= Fe),
            b.splice(K++, 0, se);
        }
        return String.fromCodePoint.apply(String, b);
      },
      F = function ($) {
        var b = [];
        $ = z($);
        var D = $.length,
          K = R,
          se = 0,
          pe = E,
          we = !0,
          Re = !1,
          ke = void 0;
        try {
          for (
            var je = $[Symbol.iterator](), Te;
            !(we = (Te = je.next()).done);
            we = !0
          ) {
            var Me = Te.value;
            Me < 128 && b.push(H(Me));
          }
        } catch (at) {
          (Re = !0), (ke = at);
        } finally {
          try {
            !we && je.return && je.return();
          } finally {
            if (Re) throw ke;
          }
        }
        var Ne = b.length,
          Ue = Ne;
        for (Ne && b.push(A); Ue < D; ) {
          var qe = h,
            Fe = !0,
            Je = !1,
            Ke = void 0;
          try {
            for (
              var Be = $[Symbol.iterator](), He;
              !(Fe = (He = Be.next()).done);
              Fe = !0
            ) {
              var De = He.value;
              De >= K && De < qe && (qe = De);
            }
          } catch (at) {
            (Je = !0), (Ke = at);
          } finally {
            try {
              !Fe && Be.return && Be.return();
            } finally {
              if (Je) throw Ke;
            }
          }
          var Le = Ue + 1;
          qe - K > j((h - se) / Le) && q("overflow"),
            (se += (qe - K) * Le),
            (K = qe);
          var Pe = !0,
            Oe = !1,
            ge = void 0;
          try {
            for (
              var ve = $[Symbol.iterator](), Ie;
              !(Pe = (Ie = ve.next()).done);
              Pe = !0
            ) {
              var Se = Ie.value;
              if ((Se < K && ++se > h && q("overflow"), Se == K)) {
                for (var Ae = se, Ce = m; ; Ce += m) {
                  var Ve = Ce <= pe ? g : Ce >= pe + v ? v : Ce - pe;
                  if (Ae < Ve) break;
                  var it = Ae - Ve,
                    mt = m - Ve;
                  b.push(H(L(Ve + (it % mt), 0))), (Ae = j(it / mt));
                }
                b.push(H(L(Ae, 0))), (pe = k(se, Le, Ue == Ne)), (se = 0), ++Ue;
              }
            }
          } catch (at) {
            (Oe = !0), (ge = at);
          } finally {
            try {
              !Pe && ve.return && ve.return();
            } finally {
              if (Oe) throw ge;
            }
          }
          ++se, ++K;
        }
        return b.join("");
      },
      x = function ($) {
        return Z($, function (b) {
          return I.test(b) ? W(b.slice(4).toLowerCase()) : b;
        });
      },
      T = function ($) {
        return Z($, function (b) {
          return S.test(b) ? "xn--" + F(b) : b;
        });
      },
      V = {
        version: "2.1.0",
        ucs2: { decode: z, encode: U },
        decode: W,
        encode: F,
        toASCII: T,
        toUnicode: x,
      },
      B = {};
    function N(C) {
      var $ = C.charCodeAt(0),
        b = void 0;
      return (
        $ < 16
          ? (b = "%0" + $.toString(16).toUpperCase())
          : $ < 128
          ? (b = "%" + $.toString(16).toUpperCase())
          : $ < 2048
          ? (b =
              "%" +
              (($ >> 6) | 192).toString(16).toUpperCase() +
              "%" +
              (($ & 63) | 128).toString(16).toUpperCase())
          : (b =
              "%" +
              (($ >> 12) | 224).toString(16).toUpperCase() +
              "%" +
              ((($ >> 6) & 63) | 128).toString(16).toUpperCase() +
              "%" +
              (($ & 63) | 128).toString(16).toUpperCase()),
        b
      );
    }
    function ce(C) {
      for (var $ = "", b = 0, D = C.length; b < D; ) {
        var K = parseInt(C.substr(b + 1, 2), 16);
        if (K < 128) ($ += String.fromCharCode(K)), (b += 3);
        else if (K >= 194 && K < 224) {
          if (D - b >= 6) {
            var se = parseInt(C.substr(b + 4, 2), 16);
            $ += String.fromCharCode(((K & 31) << 6) | (se & 63));
          } else $ += C.substr(b, 6);
          b += 6;
        } else if (K >= 224) {
          if (D - b >= 9) {
            var pe = parseInt(C.substr(b + 4, 2), 16),
              we = parseInt(C.substr(b + 7, 2), 16);
            $ += String.fromCharCode(
              ((K & 15) << 12) | ((pe & 63) << 6) | (we & 63),
            );
          } else $ += C.substr(b, 9);
          b += 9;
        } else ($ += C.substr(b, 3)), (b += 3);
      }
      return $;
    }
    function re(C, $) {
      function b(D) {
        var K = ce(D);
        return K.match($.UNRESERVED) ? K : D;
      }
      return (
        C.scheme &&
          (C.scheme = String(C.scheme)
            .replace($.PCT_ENCODED, b)
            .toLowerCase()
            .replace($.NOT_SCHEME, "")),
        C.userinfo !== void 0 &&
          (C.userinfo = String(C.userinfo)
            .replace($.PCT_ENCODED, b)
            .replace($.NOT_USERINFO, N)
            .replace($.PCT_ENCODED, s)),
        C.host !== void 0 &&
          (C.host = String(C.host)
            .replace($.PCT_ENCODED, b)
            .toLowerCase()
            .replace($.NOT_HOST, N)
            .replace($.PCT_ENCODED, s)),
        C.path !== void 0 &&
          (C.path = String(C.path)
            .replace($.PCT_ENCODED, b)
            .replace(C.scheme ? $.NOT_PATH : $.NOT_PATH_NOSCHEME, N)
            .replace($.PCT_ENCODED, s)),
        C.query !== void 0 &&
          (C.query = String(C.query)
            .replace($.PCT_ENCODED, b)
            .replace($.NOT_QUERY, N)
            .replace($.PCT_ENCODED, s)),
        C.fragment !== void 0 &&
          (C.fragment = String(C.fragment)
            .replace($.PCT_ENCODED, b)
            .replace($.NOT_FRAGMENT, N)
            .replace($.PCT_ENCODED, s)),
        C
      );
    }
    function ne(C) {
      return C.replace(/^0*(.*)/, "$1") || "0";
    }
    function Y(C, $) {
      var b = C.match($.IPV4ADDRESS) || [],
        D = d(b, 2),
        K = D[1];
      return K ? K.split(".").map(ne).join(".") : C;
    }
    function M(C, $) {
      var b = C.match($.IPV6ADDRESS) || [],
        D = d(b, 3),
        K = D[1],
        se = D[2];
      if (K) {
        for (
          var pe = K.toLowerCase().split("::").reverse(),
            we = d(pe, 2),
            Re = we[0],
            ke = we[1],
            je = ke ? ke.split(":").map(ne) : [],
            Te = Re.split(":").map(ne),
            Me = $.IPV4ADDRESS.test(Te[Te.length - 1]),
            Ne = Me ? 7 : 8,
            Ue = Te.length - Ne,
            qe = Array(Ne),
            Fe = 0;
          Fe < Ne;
          ++Fe
        )
          qe[Fe] = je[Fe] || Te[Ue + Fe] || "";
        Me && (qe[Ne - 1] = Y(qe[Ne - 1], $));
        var Je = qe.reduce(function (Le, Pe, Oe) {
            if (!Pe || Pe === "0") {
              var ge = Le[Le.length - 1];
              ge && ge.index + ge.length === Oe
                ? ge.length++
                : Le.push({ index: Oe, length: 1 });
            }
            return Le;
          }, []),
          Ke = Je.sort(function (Le, Pe) {
            return Pe.length - Le.length;
          })[0],
          Be = void 0;
        if (Ke && Ke.length > 1) {
          var He = qe.slice(0, Ke.index),
            De = qe.slice(Ke.index + Ke.length);
          Be = He.join(":") + "::" + De.join(":");
        } else Be = qe.join(":");
        return se && (Be += "%" + se), Be;
      } else return C;
    }
    var oe =
        /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,
      Ee = "".match(/(){0}/)[1] === void 0;
    function le(C) {
      var $ =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        b = {},
        D = $.iri !== !1 ? u : f;
      $.reference === "suffix" &&
        (C = ($.scheme ? $.scheme + ":" : "") + "//" + C);
      var K = C.match(oe);
      if (K) {
        Ee
          ? ((b.scheme = K[1]),
            (b.userinfo = K[3]),
            (b.host = K[4]),
            (b.port = parseInt(K[5], 10)),
            (b.path = K[6] || ""),
            (b.query = K[7]),
            (b.fragment = K[8]),
            isNaN(b.port) && (b.port = K[5]))
          : ((b.scheme = K[1] || void 0),
            (b.userinfo = C.indexOf("@") !== -1 ? K[3] : void 0),
            (b.host = C.indexOf("//") !== -1 ? K[4] : void 0),
            (b.port = parseInt(K[5], 10)),
            (b.path = K[6] || ""),
            (b.query = C.indexOf("?") !== -1 ? K[7] : void 0),
            (b.fragment = C.indexOf("#") !== -1 ? K[8] : void 0),
            isNaN(b.port) &&
              (b.port = C.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/)
                ? K[4]
                : void 0)),
          b.host && (b.host = M(Y(b.host, D), D)),
          b.scheme === void 0 &&
          b.userinfo === void 0 &&
          b.host === void 0 &&
          b.port === void 0 &&
          !b.path &&
          b.query === void 0
            ? (b.reference = "same-document")
            : b.scheme === void 0
            ? (b.reference = "relative")
            : b.fragment === void 0
            ? (b.reference = "absolute")
            : (b.reference = "uri"),
          $.reference &&
            $.reference !== "suffix" &&
            $.reference !== b.reference &&
            (b.error =
              b.error || "URI is not a " + $.reference + " reference.");
        var se = B[($.scheme || b.scheme || "").toLowerCase()];
        if (!$.unicodeSupport && (!se || !se.unicodeSupport)) {
          if (b.host && ($.domainHost || (se && se.domainHost)))
            try {
              b.host = V.toASCII(
                b.host.replace(D.PCT_ENCODED, ce).toLowerCase(),
              );
            } catch (pe) {
              b.error =
                b.error ||
                "Host's domain name can not be converted to ASCII via punycode: " +
                  pe;
            }
          re(b, f);
        } else re(b, D);
        se && se.parse && se.parse(b, $);
      } else b.error = b.error || "URI can not be parsed.";
      return b;
    }
    function te(C, $) {
      var b = $.iri !== !1 ? u : f,
        D = [];
      return (
        C.userinfo !== void 0 && (D.push(C.userinfo), D.push("@")),
        C.host !== void 0 &&
          D.push(
            M(Y(String(C.host), b), b).replace(
              b.IPV6ADDRESS,
              function (K, se, pe) {
                return "[" + se + (pe ? "%25" + pe : "") + "]";
              },
            ),
          ),
        (typeof C.port == "number" || typeof C.port == "string") &&
          (D.push(":"), D.push(String(C.port))),
        D.length ? D.join("") : void 0
      );
    }
    var ie = /^\.\.?\//,
      X = /^\/\.(\/|$)/,
      he = /^\/\.\.(\/|$)/,
      be = /^\/?(?:.|\n)*?(?=\/|$)/;
    function ye(C) {
      for (var $ = []; C.length; )
        if (C.match(ie)) C = C.replace(ie, "");
        else if (C.match(X)) C = C.replace(X, "/");
        else if (C.match(he)) (C = C.replace(he, "/")), $.pop();
        else if (C === "." || C === "..") C = "";
        else {
          var b = C.match(be);
          if (b) {
            var D = b[0];
            (C = C.slice(D.length)), $.push(D);
          } else throw new Error("Unexpected dot segment condition");
        }
      return $.join("");
    }
    function Qe(C) {
      var $ =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        b = $.iri ? u : f,
        D = [],
        K = B[($.scheme || C.scheme || "").toLowerCase()];
      if (
        (K && K.serialize && K.serialize(C, $),
        C.host && !b.IPV6ADDRESS.test(C.host))
      ) {
        if ($.domainHost || (K && K.domainHost))
          try {
            C.host = $.iri
              ? V.toUnicode(C.host)
              : V.toASCII(C.host.replace(b.PCT_ENCODED, ce).toLowerCase());
          } catch (we) {
            C.error =
              C.error ||
              "Host's domain name can not be converted to " +
                ($.iri ? "Unicode" : "ASCII") +
                " via punycode: " +
                we;
          }
      }
      re(C, b),
        $.reference !== "suffix" && C.scheme && (D.push(C.scheme), D.push(":"));
      var se = te(C, $);
      if (
        (se !== void 0 &&
          ($.reference !== "suffix" && D.push("//"),
          D.push(se),
          C.path && C.path.charAt(0) !== "/" && D.push("/")),
        C.path !== void 0)
      ) {
        var pe = C.path;
        !$.absolutePath && (!K || !K.absolutePath) && (pe = ye(pe)),
          se === void 0 && (pe = pe.replace(/^\/\//, "/%2F")),
          D.push(pe);
      }
      return (
        C.query !== void 0 && (D.push("?"), D.push(C.query)),
        C.fragment !== void 0 && (D.push("#"), D.push(C.fragment)),
        D.join("")
      );
    }
    function lt(C, $) {
      var b =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        D = arguments[3],
        K = {};
      return (
        D || ((C = le(Qe(C, b), b)), ($ = le(Qe($, b), b))),
        (b = b || {}),
        !b.tolerant && $.scheme
          ? ((K.scheme = $.scheme),
            (K.userinfo = $.userinfo),
            (K.host = $.host),
            (K.port = $.port),
            (K.path = ye($.path || "")),
            (K.query = $.query))
          : ($.userinfo !== void 0 || $.host !== void 0 || $.port !== void 0
              ? ((K.userinfo = $.userinfo),
                (K.host = $.host),
                (K.port = $.port),
                (K.path = ye($.path || "")),
                (K.query = $.query))
              : ($.path
                  ? ($.path.charAt(0) === "/"
                      ? (K.path = ye($.path))
                      : ((C.userinfo !== void 0 ||
                          C.host !== void 0 ||
                          C.port !== void 0) &&
                        !C.path
                          ? (K.path = "/" + $.path)
                          : C.path
                          ? (K.path =
                              C.path.slice(0, C.path.lastIndexOf("/") + 1) +
                              $.path)
                          : (K.path = $.path),
                        (K.path = ye(K.path))),
                    (K.query = $.query))
                  : ((K.path = C.path),
                    $.query !== void 0
                      ? (K.query = $.query)
                      : (K.query = C.query)),
                (K.userinfo = C.userinfo),
                (K.host = C.host),
                (K.port = C.port)),
            (K.scheme = C.scheme)),
        (K.fragment = $.fragment),
        K
      );
    }
    function Lt(C, $, b) {
      var D = c({ scheme: "null" }, b);
      return Qe(lt(le(C, D), le($, D), D, !0), D);
    }
    function We(C, $) {
      return (
        typeof C == "string"
          ? (C = Qe(le(C, $), $))
          : a(C) === "object" && (C = le(Qe(C, $), $)),
        C
      );
    }
    function bt(C, $, b) {
      return (
        typeof C == "string"
          ? (C = Qe(le(C, b), b))
          : a(C) === "object" && (C = Qe(C, b)),
        typeof $ == "string"
          ? ($ = Qe(le($, b), b))
          : a($) === "object" && ($ = Qe($, b)),
        C === $
      );
    }
    function wt(C, $) {
      return C && C.toString().replace(!$ || !$.iri ? f.ESCAPE : u.ESCAPE, N);
    }
    function ct(C, $) {
      return (
        C &&
        C.toString().replace(!$ || !$.iri ? f.PCT_ENCODED : u.PCT_ENCODED, ce)
      );
    }
    var ze = {
        scheme: "http",
        domainHost: !0,
        parse: function ($, b) {
          return (
            $.host || ($.error = $.error || "HTTP URIs must have a host."), $
          );
        },
        serialize: function ($, b) {
          var D = String($.scheme).toLowerCase() === "https";
          return (
            ($.port === (D ? 443 : 80) || $.port === "") && ($.port = void 0),
            $.path || ($.path = "/"),
            $
          );
        },
      },
      dt = {
        scheme: "https",
        domainHost: ze.domainHost,
        parse: ze.parse,
        serialize: ze.serialize,
      };
    function ht(C) {
      return typeof C.secure == "boolean"
        ? C.secure
        : String(C.scheme).toLowerCase() === "wss";
    }
    var an = {
        scheme: "ws",
        domainHost: !0,
        parse: function ($, b) {
          var D = $;
          return (
            (D.secure = ht(D)),
            (D.resourceName = (D.path || "/") + (D.query ? "?" + D.query : "")),
            (D.path = void 0),
            (D.query = void 0),
            D
          );
        },
        serialize: function ($, b) {
          if (
            (($.port === (ht($) ? 443 : 80) || $.port === "") &&
              ($.port = void 0),
            typeof $.secure == "boolean" &&
              (($.scheme = $.secure ? "wss" : "ws"), ($.secure = void 0)),
            $.resourceName)
          ) {
            var D = $.resourceName.split("?"),
              K = d(D, 2),
              se = K[0],
              pe = K[1];
            ($.path = se && se !== "/" ? se : void 0),
              ($.query = pe),
              ($.resourceName = void 0);
          }
          return ($.fragment = void 0), $;
        },
      },
      $n = {
        scheme: "wss",
        domainHost: an.domainHost,
        parse: an.parse,
        serialize: an.serialize,
      },
      Wt = {},
      Jt =
        "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]",
      Zt = "[0-9A-Fa-f]",
      jr = i(
        i("%[EFef]" + Zt + "%" + Zt + Zt + "%" + Zt + Zt) +
          "|" +
          i("%[89A-Fa-f]" + Zt + "%" + Zt + Zt) +
          "|" +
          i("%" + Zt + Zt),
      ),
      Nn = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]",
      Vr = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]",
      Vi = r(Vr, '[\\"\\\\]'),
      On = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]",
      ni = new RegExp(Jt, "g"),
      An = new RegExp(jr, "g"),
      Mr = new RegExp(r("[^]", Nn, "[\\.]", '[\\"]', Vi), "g"),
      Hr = new RegExp(r("[^]", Jt, On), "g"),
      Yi = Hr;
    function qr(C) {
      var $ = ce(C);
      return $.match(ni) ? $ : C;
    }
    var ns = {
        scheme: "mailto",
        parse: function ($, b) {
          var D = $,
            K = (D.to = D.path ? D.path.split(",") : []);
          if (((D.path = void 0), D.query)) {
            for (
              var se = !1,
                pe = {},
                we = D.query.split("&"),
                Re = 0,
                ke = we.length;
              Re < ke;
              ++Re
            ) {
              var je = we[Re].split("=");
              switch (je[0]) {
                case "to":
                  for (
                    var Te = je[1].split(","), Me = 0, Ne = Te.length;
                    Me < Ne;
                    ++Me
                  )
                    K.push(Te[Me]);
                  break;
                case "subject":
                  D.subject = ct(je[1], b);
                  break;
                case "body":
                  D.body = ct(je[1], b);
                  break;
                default:
                  (se = !0), (pe[ct(je[0], b)] = ct(je[1], b));
                  break;
              }
            }
            se && (D.headers = pe);
          }
          D.query = void 0;
          for (var Ue = 0, qe = K.length; Ue < qe; ++Ue) {
            var Fe = K[Ue].split("@");
            if (((Fe[0] = ct(Fe[0])), b.unicodeSupport))
              Fe[1] = ct(Fe[1], b).toLowerCase();
            else
              try {
                Fe[1] = V.toASCII(ct(Fe[1], b).toLowerCase());
              } catch (Je) {
                D.error =
                  D.error ||
                  "Email address's domain name can not be converted to ASCII via punycode: " +
                    Je;
              }
            K[Ue] = Fe.join("@");
          }
          return D;
        },
        serialize: function ($, b) {
          var D = $,
            K = o($.to);
          if (K) {
            for (var se = 0, pe = K.length; se < pe; ++se) {
              var we = String(K[se]),
                Re = we.lastIndexOf("@"),
                ke = we
                  .slice(0, Re)
                  .replace(An, qr)
                  .replace(An, s)
                  .replace(Mr, N),
                je = we.slice(Re + 1);
              try {
                je = b.iri
                  ? V.toUnicode(je)
                  : V.toASCII(ct(je, b).toLowerCase());
              } catch (Ue) {
                D.error =
                  D.error ||
                  "Email address's domain name can not be converted to " +
                    (b.iri ? "Unicode" : "ASCII") +
                    " via punycode: " +
                    Ue;
              }
              K[se] = ke + "@" + je;
            }
            D.path = K.join(",");
          }
          var Te = ($.headers = $.headers || {});
          $.subject && (Te.subject = $.subject), $.body && (Te.body = $.body);
          var Me = [];
          for (var Ne in Te)
            Te[Ne] !== Wt[Ne] &&
              Me.push(
                Ne.replace(An, qr).replace(An, s).replace(Hr, N) +
                  "=" +
                  Te[Ne].replace(An, qr).replace(An, s).replace(Yi, N),
              );
          return Me.length && (D.query = Me.join("&")), D;
        },
      },
      kc = /^([^\:]+)\:(.*)/,
      Bn = {
        scheme: "urn",
        parse: function ($, b) {
          var D = $.path && $.path.match(kc),
            K = $;
          if (D) {
            var se = b.scheme || K.scheme || "urn",
              pe = D[1].toLowerCase(),
              we = D[2],
              Re = se + ":" + (b.nid || pe),
              ke = B[Re];
            (K.nid = pe),
              (K.nss = we),
              (K.path = void 0),
              ke && (K = ke.parse(K, b));
          } else K.error = K.error || "URN can not be parsed.";
          return K;
        },
        serialize: function ($, b) {
          var D = b.scheme || $.scheme || "urn",
            K = $.nid,
            se = D + ":" + (b.nid || K),
            pe = B[se];
          pe && ($ = pe.serialize($, b));
          var we = $,
            Re = $.nss;
          return (we.path = (K || b.nid) + ":" + Re), we;
        },
      },
      no = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/,
      P = {
        scheme: "urn:uuid",
        parse: function ($, b) {
          var D = $;
          return (
            (D.uuid = D.nss),
            (D.nss = void 0),
            !b.tolerant &&
              (!D.uuid || !D.uuid.match(no)) &&
              (D.error = D.error || "UUID is not valid."),
            D
          );
        },
        serialize: function ($, b) {
          var D = $;
          return (D.nss = ($.uuid || "").toLowerCase()), D;
        },
      };
    (B[ze.scheme] = ze),
      (B[dt.scheme] = dt),
      (B[an.scheme] = an),
      (B[$n.scheme] = $n),
      (B[ns.scheme] = ns),
      (B[Bn.scheme] = Bn),
      (B[P.scheme] = P),
      (n.SCHEMES = B),
      (n.pctEncChar = N),
      (n.pctDecChars = ce),
      (n.parse = le),
      (n.removeDotSegments = ye),
      (n.serialize = Qe),
      (n.resolveComponents = lt),
      (n.resolve = Lt),
      (n.normalize = We),
      (n.equal = bt),
      (n.escapeComponent = wt),
      (n.unescapeComponent = ct),
      Object.defineProperty(n, "__esModule", { value: !0 });
  });
})(E0, E0.exports);
var H4 = E0.exports;
Object.defineProperty(Ey, "__esModule", { value: !0 });
const q4 = H4;
q4.code = 'require("ajv/dist/runtime/uri").default';
Ey.default = q4;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.CodeGen =
      e.Name =
      e.nil =
      e.stringify =
      e.str =
      e._ =
      e.KeywordCxt =
        void 0);
  var t = yi;
  Object.defineProperty(e, "KeywordCxt", {
    enumerable: !0,
    get: function () {
      return t.KeywordCxt;
    },
  });
  var n = $t;
  Object.defineProperty(e, "_", {
    enumerable: !0,
    get: function () {
      return n._;
    },
  }),
    Object.defineProperty(e, "str", {
      enumerable: !0,
      get: function () {
        return n.str;
      },
    }),
    Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function () {
        return n.stringify;
      },
    }),
    Object.defineProperty(e, "nil", {
      enumerable: !0,
      get: function () {
        return n.nil;
      },
    }),
    Object.defineProperty(e, "Name", {
      enumerable: !0,
      get: function () {
        return n.Name;
      },
    }),
    Object.defineProperty(e, "CodeGen", {
      enumerable: !0,
      get: function () {
        return n.CodeGen;
      },
    });
  const r = uu,
    i = fu,
    a = Fs,
    s = Dr,
    o = $t,
    c = nr,
    l = lu,
    f = Ut,
    u = xQ,
    d = Ey,
    p = (L, k) => new RegExp(L, k);
  p.code = "new RegExp";
  const h = ["removeAdditional", "useDefaults", "coerceTypes"],
    m = new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error",
    ]),
    g = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs:
        "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode:
        "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats:
        "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now.",
    },
    v = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode:
        '"minLength"/"maxLength" account for unicode characters by default.',
    },
    y = 200;
  function _(L) {
    var k,
      W,
      F,
      x,
      T,
      V,
      B,
      N,
      ce,
      re,
      ne,
      Y,
      M,
      oe,
      Ee,
      le,
      te,
      ie,
      X,
      he,
      be,
      ye,
      Qe,
      lt,
      Lt;
    const We = L.strict,
      bt = (k = L.code) === null || k === void 0 ? void 0 : k.optimize,
      wt = bt === !0 || bt === void 0 ? 1 : bt || 0,
      ct =
        (F = (W = L.code) === null || W === void 0 ? void 0 : W.regExp) !==
          null && F !== void 0
          ? F
          : p,
      ze = (x = L.uriResolver) !== null && x !== void 0 ? x : d.default;
    return {
      strictSchema:
        (V = (T = L.strictSchema) !== null && T !== void 0 ? T : We) !== null &&
        V !== void 0
          ? V
          : !0,
      strictNumbers:
        (N = (B = L.strictNumbers) !== null && B !== void 0 ? B : We) !==
          null && N !== void 0
          ? N
          : !0,
      strictTypes:
        (re = (ce = L.strictTypes) !== null && ce !== void 0 ? ce : We) !==
          null && re !== void 0
          ? re
          : "log",
      strictTuples:
        (Y = (ne = L.strictTuples) !== null && ne !== void 0 ? ne : We) !==
          null && Y !== void 0
          ? Y
          : "log",
      strictRequired:
        (oe = (M = L.strictRequired) !== null && M !== void 0 ? M : We) !==
          null && oe !== void 0
          ? oe
          : !1,
      code: L.code
        ? { ...L.code, optimize: wt, regExp: ct }
        : { optimize: wt, regExp: ct },
      loopRequired: (Ee = L.loopRequired) !== null && Ee !== void 0 ? Ee : y,
      loopEnum: (le = L.loopEnum) !== null && le !== void 0 ? le : y,
      meta: (te = L.meta) !== null && te !== void 0 ? te : !0,
      messages: (ie = L.messages) !== null && ie !== void 0 ? ie : !0,
      inlineRefs: (X = L.inlineRefs) !== null && X !== void 0 ? X : !0,
      schemaId: (he = L.schemaId) !== null && he !== void 0 ? he : "$id",
      addUsedSchema: (be = L.addUsedSchema) !== null && be !== void 0 ? be : !0,
      validateSchema:
        (ye = L.validateSchema) !== null && ye !== void 0 ? ye : !0,
      validateFormats:
        (Qe = L.validateFormats) !== null && Qe !== void 0 ? Qe : !0,
      unicodeRegExp: (lt = L.unicodeRegExp) !== null && lt !== void 0 ? lt : !0,
      int32range: (Lt = L.int32range) !== null && Lt !== void 0 ? Lt : !0,
      uriResolver: ze,
    };
  }
  class E {
    constructor(k = {}) {
      (this.schemas = {}),
        (this.refs = {}),
        (this.formats = {}),
        (this._compilations = new Set()),
        (this._loading = {}),
        (this._cache = new Map()),
        (k = this.opts = { ...k, ..._(k) });
      const { es5: W, lines: F } = this.opts.code;
      (this.scope = new o.ValueScope({
        scope: {},
        prefixes: m,
        es5: W,
        lines: F,
      })),
        (this.logger = j(k.logger));
      const x = k.validateFormats;
      (k.validateFormats = !1),
        (this.RULES = (0, a.getRules)()),
        R.call(this, g, k, "NOT SUPPORTED"),
        R.call(this, v, k, "DEPRECATED", "warn"),
        (this._metaOpts = O.call(this)),
        k.formats && S.call(this),
        this._addVocabularies(),
        this._addDefaultMetaSchema(),
        k.keywords && w.call(this, k.keywords),
        typeof k.meta == "object" && this.addMetaSchema(k.meta),
        I.call(this),
        (k.validateFormats = x);
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: k, meta: W, schemaId: F } = this.opts;
      let x = u;
      F === "id" && ((x = { ...u }), (x.id = x.$id), delete x.$id),
        W && k && this.addMetaSchema(x, x[F], !1);
    }
    defaultMeta() {
      const { meta: k, schemaId: W } = this.opts;
      return (this.opts.defaultMeta =
        typeof k == "object" ? k[W] || k : void 0);
    }
    validate(k, W) {
      let F;
      if (typeof k == "string") {
        if (((F = this.getSchema(k)), !F))
          throw new Error(`no schema with key or ref "${k}"`);
      } else F = this.compile(k);
      const x = F(W);
      return "$async" in F || (this.errors = F.errors), x;
    }
    compile(k, W) {
      const F = this._addSchema(k, W);
      return F.validate || this._compileSchemaEnv(F);
    }
    compileAsync(k, W) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: F } = this.opts;
      return x.call(this, k, W);
      async function x(re, ne) {
        await T.call(this, re.$schema);
        const Y = this._addSchema(re, ne);
        return Y.validate || V.call(this, Y);
      }
      async function T(re) {
        re && !this.getSchema(re) && (await x.call(this, { $ref: re }, !0));
      }
      async function V(re) {
        try {
          return this._compileSchemaEnv(re);
        } catch (ne) {
          if (!(ne instanceof i.default)) throw ne;
          return (
            B.call(this, ne),
            await N.call(this, ne.missingSchema),
            V.call(this, re)
          );
        }
      }
      function B({ missingSchema: re, missingRef: ne }) {
        if (this.refs[re])
          throw new Error(
            `AnySchema ${re} is loaded but ${ne} cannot be resolved`,
          );
      }
      async function N(re) {
        const ne = await ce.call(this, re);
        this.refs[re] || (await T.call(this, ne.$schema)),
          this.refs[re] || this.addSchema(ne, re, W);
      }
      async function ce(re) {
        const ne = this._loading[re];
        if (ne) return ne;
        try {
          return await (this._loading[re] = F(re));
        } finally {
          delete this._loading[re];
        }
      }
    }
    addSchema(k, W, F, x = this.opts.validateSchema) {
      if (Array.isArray(k)) {
        for (const V of k) this.addSchema(V, void 0, F, x);
        return this;
      }
      let T;
      if (typeof k == "object") {
        const { schemaId: V } = this.opts;
        if (((T = k[V]), T !== void 0 && typeof T != "string"))
          throw new Error(`schema ${V} must be string`);
      }
      return (
        (W = (0, c.normalizeId)(W || T)),
        this._checkUnique(W),
        (this.schemas[W] = this._addSchema(k, F, W, x, !0)),
        this
      );
    }
    addMetaSchema(k, W, F = this.opts.validateSchema) {
      return this.addSchema(k, W, !0, F), this;
    }
    validateSchema(k, W) {
      if (typeof k == "boolean") return !0;
      let F;
      if (((F = k.$schema), F !== void 0 && typeof F != "string"))
        throw new Error("$schema must be a string");
      if (((F = F || this.opts.defaultMeta || this.defaultMeta()), !F))
        return (
          this.logger.warn("meta-schema not available"),
          (this.errors = null),
          !0
        );
      const x = this.validate(F, k);
      if (!x && W) {
        const T = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log") this.logger.error(T);
        else throw new Error(T);
      }
      return x;
    }
    getSchema(k) {
      let W;
      for (; typeof (W = A.call(this, k)) == "string"; ) k = W;
      if (W === void 0) {
        const { schemaId: F } = this.opts,
          x = new s.SchemaEnv({ schema: {}, schemaId: F });
        if (((W = s.resolveSchema.call(this, x, k)), !W)) return;
        this.refs[k] = W;
      }
      return W.validate || this._compileSchemaEnv(W);
    }
    removeSchema(k) {
      if (k instanceof RegExp)
        return (
          this._removeAllSchemas(this.schemas, k),
          this._removeAllSchemas(this.refs, k),
          this
        );
      switch (typeof k) {
        case "undefined":
          return (
            this._removeAllSchemas(this.schemas),
            this._removeAllSchemas(this.refs),
            this._cache.clear(),
            this
          );
        case "string": {
          const W = A.call(this, k);
          return (
            typeof W == "object" && this._cache.delete(W.schema),
            delete this.schemas[k],
            delete this.refs[k],
            this
          );
        }
        case "object": {
          const W = k;
          this._cache.delete(W);
          let F = k[this.opts.schemaId];
          return (
            F &&
              ((F = (0, c.normalizeId)(F)),
              delete this.schemas[F],
              delete this.refs[F]),
            this
          );
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(k) {
      for (const W of k) this.addKeyword(W);
      return this;
    }
    addKeyword(k, W) {
      let F;
      if (typeof k == "string")
        (F = k),
          typeof W == "object" &&
            (this.logger.warn(
              "these parameters are deprecated, see docs for addKeyword",
            ),
            (W.keyword = F));
      else if (typeof k == "object" && W === void 0) {
        if (((W = k), (F = W.keyword), Array.isArray(F) && !F.length))
          throw new Error(
            "addKeywords: keyword must be string or non-empty array",
          );
      } else throw new Error("invalid addKeywords parameters");
      if ((q.call(this, F, W), !W))
        return (0, f.eachItem)(F, (T) => J.call(this, T)), this;
      z.call(this, W);
      const x = {
        ...W,
        type: (0, l.getJSONTypes)(W.type),
        schemaType: (0, l.getJSONTypes)(W.schemaType),
      };
      return (
        (0, f.eachItem)(
          F,
          x.type.length === 0
            ? (T) => J.call(this, T, x)
            : (T) => x.type.forEach((V) => J.call(this, T, x, V)),
        ),
        this
      );
    }
    getKeyword(k) {
      const W = this.RULES.all[k];
      return typeof W == "object" ? W.definition : !!W;
    }
    removeKeyword(k) {
      const { RULES: W } = this;
      delete W.keywords[k], delete W.all[k];
      for (const F of W.rules) {
        const x = F.rules.findIndex((T) => T.keyword === k);
        x >= 0 && F.rules.splice(x, 1);
      }
      return this;
    }
    addFormat(k, W) {
      return (
        typeof W == "string" && (W = new RegExp(W)), (this.formats[k] = W), this
      );
    }
    errorsText(
      k = this.errors,
      { separator: W = ", ", dataVar: F = "data" } = {},
    ) {
      return !k || k.length === 0
        ? "No errors"
        : k
            .map((x) => `${F}${x.instancePath} ${x.message}`)
            .reduce((x, T) => x + W + T);
    }
    $dataMetaSchema(k, W) {
      const F = this.RULES.all;
      k = JSON.parse(JSON.stringify(k));
      for (const x of W) {
        const T = x.split("/").slice(1);
        let V = k;
        for (const B of T) V = V[B];
        for (const B in F) {
          const N = F[B];
          if (typeof N != "object") continue;
          const { $data: ce } = N.definition,
            re = V[B];
          ce && re && (V[B] = G(re));
        }
      }
      return k;
    }
    _removeAllSchemas(k, W) {
      for (const F in k) {
        const x = k[F];
        (!W || W.test(F)) &&
          (typeof x == "string"
            ? delete k[F]
            : x && !x.meta && (this._cache.delete(x.schema), delete k[F]));
      }
    }
    _addSchema(
      k,
      W,
      F,
      x = this.opts.validateSchema,
      T = this.opts.addUsedSchema,
    ) {
      let V;
      const { schemaId: B } = this.opts;
      if (typeof k == "object") V = k[B];
      else {
        if (this.opts.jtd) throw new Error("schema must be object");
        if (typeof k != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let N = this._cache.get(k);
      if (N !== void 0) return N;
      F = (0, c.normalizeId)(V || F);
      const ce = c.getSchemaRefs.call(this, k, F);
      return (
        (N = new s.SchemaEnv({
          schema: k,
          schemaId: B,
          meta: W,
          baseId: F,
          localRefs: ce,
        })),
        this._cache.set(N.schema, N),
        T &&
          !F.startsWith("#") &&
          (F && this._checkUnique(F), (this.refs[F] = N)),
        x && this.validateSchema(k, !0),
        N
      );
    }
    _checkUnique(k) {
      if (this.schemas[k] || this.refs[k])
        throw new Error(`schema with key or id "${k}" already exists`);
    }
    _compileSchemaEnv(k) {
      if (
        (k.meta ? this._compileMetaSchema(k) : s.compileSchema.call(this, k),
        !k.validate)
      )
        throw new Error("ajv implementation error");
      return k.validate;
    }
    _compileMetaSchema(k) {
      const W = this.opts;
      this.opts = this._metaOpts;
      try {
        s.compileSchema.call(this, k);
      } finally {
        this.opts = W;
      }
    }
  }
  (e.default = E),
    (E.ValidationError = r.default),
    (E.MissingRefError = i.default);
  function R(L, k, W, F = "error") {
    for (const x in L) {
      const T = x;
      T in k && this.logger[F](`${W}: option ${x}. ${L[T]}`);
    }
  }
  function A(L) {
    return (L = (0, c.normalizeId)(L)), this.schemas[L] || this.refs[L];
  }
  function I() {
    const L = this.opts.schemas;
    if (L)
      if (Array.isArray(L)) this.addSchema(L);
      else for (const k in L) this.addSchema(L[k], k);
  }
  function S() {
    for (const L in this.opts.formats) {
      const k = this.opts.formats[L];
      k && this.addFormat(L, k);
    }
  }
  function w(L) {
    if (Array.isArray(L)) {
      this.addVocabulary(L);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const k in L) {
      const W = L[k];
      W.keyword || (W.keyword = k), this.addKeyword(W);
    }
  }
  function O() {
    const L = { ...this.opts };
    for (const k of h) delete L[k];
    return L;
  }
  const Q = { log() {}, warn() {}, error() {} };
  function j(L) {
    if (L === !1) return Q;
    if (L === void 0) return console;
    if (L.log && L.warn && L.error) return L;
    throw new Error("logger must implement log, warn and error methods");
  }
  const H = /^[a-z_$][a-z0-9_$:-]*$/i;
  function q(L, k) {
    const { RULES: W } = this;
    if (
      ((0, f.eachItem)(L, (F) => {
        if (W.keywords[F]) throw new Error(`Keyword ${F} is already defined`);
        if (!H.test(F)) throw new Error(`Keyword ${F} has invalid name`);
      }),
      !!k && k.$data && !("code" in k || "validate" in k))
    )
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function J(L, k, W) {
    var F;
    const x = k == null ? void 0 : k.post;
    if (W && x) throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: T } = this;
    let V = x ? T.post : T.rules.find(({ type: N }) => N === W);
    if (
      (V || ((V = { type: W, rules: [] }), T.rules.push(V)),
      (T.keywords[L] = !0),
      !k)
    )
      return;
    const B = {
      keyword: L,
      definition: {
        ...k,
        type: (0, l.getJSONTypes)(k.type),
        schemaType: (0, l.getJSONTypes)(k.schemaType),
      },
    };
    k.before ? Z.call(this, V, B, k.before) : V.rules.push(B),
      (T.all[L] = B),
      (F = k.implements) === null ||
        F === void 0 ||
        F.forEach((N) => this.addKeyword(N));
  }
  function Z(L, k, W) {
    const F = L.rules.findIndex((x) => x.keyword === W);
    F >= 0
      ? L.rules.splice(F, 0, k)
      : (L.rules.push(k), this.logger.warn(`rule ${W} is not defined`));
  }
  function z(L) {
    let { metaSchema: k } = L;
    k !== void 0 &&
      (L.$data && this.opts.$data && (k = G(k)),
      (L.validateSchema = this.compile(k, !0)));
  }
  const U = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
  };
  function G(L) {
    return { anyOf: [L, U] };
  }
})(y4);
var wy = {},
  xy = {},
  Ay = {};
Object.defineProperty(Ay, "__esModule", { value: !0 });
const AQ = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  },
};
Ay.default = AQ;
var js = {};
Object.defineProperty(js, "__esModule", { value: !0 });
js.callRef = js.getValidate = void 0;
const SQ = fu,
  Ix = St,
  Nr = $t,
  fo = Wi,
  $x = Dr,
  gf = Ut,
  IQ = {
    keyword: "$ref",
    schemaType: "string",
    code(e) {
      const { gen: t, schema: n, it: r } = e,
        { baseId: i, schemaEnv: a, validateName: s, opts: o, self: c } = r,
        { root: l } = a;
      if ((n === "#" || n === "#/") && i === l.baseId) return u();
      const f = $x.resolveRef.call(c, l, i, n);
      if (f === void 0) throw new SQ.default(r.opts.uriResolver, i, n);
      if (f instanceof $x.SchemaEnv) return d(f);
      return p(f);
      function u() {
        if (a === l) return Hf(e, s, a, a.$async);
        const h = t.scopeValue("root", { ref: l });
        return Hf(e, (0, Nr._)`${h}.validate`, l, l.$async);
      }
      function d(h) {
        const m = G4(e, h);
        Hf(e, m, h, h.$async);
      }
      function p(h) {
        const m = t.scopeValue(
            "schema",
            o.code.source === !0
              ? { ref: h, code: (0, Nr.stringify)(h) }
              : { ref: h },
          ),
          g = t.name("valid"),
          v = e.subschema(
            {
              schema: h,
              dataTypes: [],
              schemaPath: Nr.nil,
              topSchemaRef: m,
              errSchemaPath: n,
            },
            g,
          );
        e.mergeEvaluated(v), e.ok(g);
      }
    },
  };
function G4(e, t) {
  const { gen: n } = e;
  return t.validate
    ? n.scopeValue("validate", { ref: t.validate })
    : (0, Nr._)`${n.scopeValue("wrapper", { ref: t })}.validate`;
}
js.getValidate = G4;
function Hf(e, t, n, r) {
  const { gen: i, it: a } = e,
    { allErrors: s, schemaEnv: o, opts: c } = a,
    l = c.passContext ? fo.default.this : Nr.nil;
  r ? f() : u();
  function f() {
    if (!o.$async) throw new Error("async schema referenced by sync schema");
    const h = i.let("valid");
    i.try(
      () => {
        i.code((0, Nr._)`await ${(0, Ix.callValidateCode)(e, t, l)}`),
          p(t),
          s || i.assign(h, !0);
      },
      (m) => {
        i.if((0, Nr._)`!(${m} instanceof ${a.ValidationError})`, () =>
          i.throw(m),
        ),
          d(m),
          s || i.assign(h, !1);
      },
    ),
      e.ok(h);
  }
  function u() {
    e.result(
      (0, Ix.callValidateCode)(e, t, l),
      () => p(t),
      () => d(t),
    );
  }
  function d(h) {
    const m = (0, Nr._)`${h}.errors`;
    i.assign(
      fo.default.vErrors,
      (0,
      Nr._)`${fo.default.vErrors} === null ? ${m} : ${fo.default.vErrors}.concat(${m})`,
    ),
      i.assign(fo.default.errors, (0, Nr._)`${fo.default.vErrors}.length`);
  }
  function p(h) {
    var m;
    if (!a.opts.unevaluated) return;
    const g =
      (m = n == null ? void 0 : n.validate) === null || m === void 0
        ? void 0
        : m.evaluated;
    if (a.props !== !0)
      if (g && !g.dynamicProps)
        g.props !== void 0 &&
          (a.props = gf.mergeEvaluated.props(i, g.props, a.props));
      else {
        const v = i.var("props", (0, Nr._)`${h}.evaluated.props`);
        a.props = gf.mergeEvaluated.props(i, v, a.props, Nr.Name);
      }
    if (a.items !== !0)
      if (g && !g.dynamicItems)
        g.items !== void 0 &&
          (a.items = gf.mergeEvaluated.items(i, g.items, a.items));
      else {
        const v = i.var("items", (0, Nr._)`${h}.evaluated.items`);
        a.items = gf.mergeEvaluated.items(i, v, a.items, Nr.Name);
      }
  }
}
js.callRef = Hf;
js.default = IQ;
Object.defineProperty(xy, "__esModule", { value: !0 });
const $Q = Ay,
  CQ = js,
  RQ = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    $Q.default,
    CQ.default,
  ];
xy.default = RQ;
var Sy = {},
  Iy = {};
Object.defineProperty(Iy, "__esModule", { value: !0 });
const _d = $t,
  Ea = _d.operators,
  Ed = {
    maximum: { okStr: "<=", ok: Ea.LTE, fail: Ea.GT },
    minimum: { okStr: ">=", ok: Ea.GTE, fail: Ea.LT },
    exclusiveMaximum: { okStr: "<", ok: Ea.LT, fail: Ea.GTE },
    exclusiveMinimum: { okStr: ">", ok: Ea.GT, fail: Ea.LTE },
  },
  kQ = {
    message: ({ keyword: e, schemaCode: t }) =>
      (0, _d.str)`must be ${Ed[e].okStr} ${t}`,
    params: ({ keyword: e, schemaCode: t }) =>
      (0, _d._)`{comparison: ${Ed[e].okStr}, limit: ${t}}`,
  },
  TQ = {
    keyword: Object.keys(Ed),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: kQ,
    code(e) {
      const { keyword: t, data: n, schemaCode: r } = e;
      e.fail$data((0, _d._)`${n} ${Ed[t].fail} ${r} || isNaN(${n})`);
    },
  };
Iy.default = TQ;
var $y = {};
Object.defineProperty($y, "__esModule", { value: !0 });
const yl = $t,
  NQ = {
    message: ({ schemaCode: e }) => (0, yl.str)`must be multiple of ${e}`,
    params: ({ schemaCode: e }) => (0, yl._)`{multipleOf: ${e}}`,
  },
  OQ = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: NQ,
    code(e) {
      const { gen: t, data: n, schemaCode: r, it: i } = e,
        a = i.opts.multipleOfPrecision,
        s = t.let("res"),
        o = a
          ? (0, yl._)`Math.abs(Math.round(${s}) - ${s}) > 1e-${a}`
          : (0, yl._)`${s} !== parseInt(${s})`;
      e.fail$data((0, yl._)`(${r} === 0 || (${s} = ${n}/${r}, ${o}))`);
    },
  };
$y.default = OQ;
var Cy = {},
  Ry = {};
Object.defineProperty(Ry, "__esModule", { value: !0 });
function Q4(e) {
  const t = e.length;
  let n = 0,
    r = 0,
    i;
  for (; r < t; )
    n++,
      (i = e.charCodeAt(r++)),
      i >= 55296 &&
        i <= 56319 &&
        r < t &&
        ((i = e.charCodeAt(r)), (i & 64512) === 56320 && r++);
  return n;
}
Ry.default = Q4;
Q4.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(Cy, "__esModule", { value: !0 });
const bs = $t,
  PQ = Ut,
  DQ = Ry,
  LQ = {
    message({ keyword: e, schemaCode: t }) {
      const n = e === "maxLength" ? "more" : "fewer";
      return (0, bs.str)`must NOT have ${n} than ${t} characters`;
    },
    params: ({ schemaCode: e }) => (0, bs._)`{limit: ${e}}`,
  },
  BQ = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: LQ,
    code(e) {
      const { keyword: t, data: n, schemaCode: r, it: i } = e,
        a = t === "maxLength" ? bs.operators.GT : bs.operators.LT,
        s =
          i.opts.unicode === !1
            ? (0, bs._)`${n}.length`
            : (0, bs._)`${(0, PQ.useFunc)(e.gen, DQ.default)}(${n})`;
      e.fail$data((0, bs._)`${s} ${a} ${r}`);
    },
  };
Cy.default = BQ;
var ky = {};
Object.defineProperty(ky, "__esModule", { value: !0 });
const UQ = St,
  wd = $t,
  FQ = {
    message: ({ schemaCode: e }) => (0, wd.str)`must match pattern "${e}"`,
    params: ({ schemaCode: e }) => (0, wd._)`{pattern: ${e}}`,
  },
  jQ = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: FQ,
    code(e) {
      const { data: t, $data: n, schema: r, schemaCode: i, it: a } = e,
        s = a.opts.unicodeRegExp ? "u" : "",
        o = n ? (0, wd._)`(new RegExp(${i}, ${s}))` : (0, UQ.usePattern)(e, r);
      e.fail$data((0, wd._)`!${o}.test(${t})`);
    },
  };
ky.default = jQ;
var Ty = {};
Object.defineProperty(Ty, "__esModule", { value: !0 });
const bl = $t,
  MQ = {
    message({ keyword: e, schemaCode: t }) {
      const n = e === "maxProperties" ? "more" : "fewer";
      return (0, bl.str)`must NOT have ${n} than ${t} properties`;
    },
    params: ({ schemaCode: e }) => (0, bl._)`{limit: ${e}}`,
  },
  HQ = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: MQ,
    code(e) {
      const { keyword: t, data: n, schemaCode: r } = e,
        i = t === "maxProperties" ? bl.operators.GT : bl.operators.LT;
      e.fail$data((0, bl._)`Object.keys(${n}).length ${i} ${r}`);
    },
  };
Ty.default = HQ;
var Ny = {};
Object.defineProperty(Ny, "__esModule", { value: !0 });
const Wc = St,
  _l = $t,
  qQ = Ut,
  GQ = {
    message: ({ params: { missingProperty: e } }) =>
      (0, _l.str)`must have required property '${e}'`,
    params: ({ params: { missingProperty: e } }) =>
      (0, _l._)`{missingProperty: ${e}}`,
  },
  QQ = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: GQ,
    code(e) {
      const { gen: t, schema: n, schemaCode: r, data: i, $data: a, it: s } = e,
        { opts: o } = s;
      if (!a && n.length === 0) return;
      const c = n.length >= o.loopRequired;
      if ((s.allErrors ? l() : f(), o.strictRequired)) {
        const p = e.parentSchema.properties,
          { definedProperties: h } = e.it;
        for (const m of n)
          if ((p == null ? void 0 : p[m]) === void 0 && !h.has(m)) {
            const g = s.schemaEnv.baseId + s.errSchemaPath,
              v = `required property "${m}" is not defined at "${g}" (strictRequired)`;
            (0, qQ.checkStrictMode)(s, v, s.opts.strictRequired);
          }
      }
      function l() {
        if (c || a) e.block$data(_l.nil, u);
        else for (const p of n) (0, Wc.checkReportMissingProp)(e, p);
      }
      function f() {
        const p = t.let("missing");
        if (c || a) {
          const h = t.let("valid", !0);
          e.block$data(h, () => d(p, h)), e.ok(h);
        } else
          t.if((0, Wc.checkMissingProp)(e, n, p)),
            (0, Wc.reportMissingProp)(e, p),
            t.else();
      }
      function u() {
        t.forOf("prop", r, (p) => {
          e.setParams({ missingProperty: p }),
            t.if((0, Wc.noPropertyInData)(t, i, p, o.ownProperties), () =>
              e.error(),
            );
        });
      }
      function d(p, h) {
        e.setParams({ missingProperty: p }),
          t.forOf(
            p,
            r,
            () => {
              t.assign(h, (0, Wc.propertyInData)(t, i, p, o.ownProperties)),
                t.if((0, _l.not)(h), () => {
                  e.error(), t.break();
                });
            },
            _l.nil,
          );
      }
    },
  };
Ny.default = QQ;
var Oy = {};
Object.defineProperty(Oy, "__esModule", { value: !0 });
const El = $t,
  WQ = {
    message({ keyword: e, schemaCode: t }) {
      const n = e === "maxItems" ? "more" : "fewer";
      return (0, El.str)`must NOT have ${n} than ${t} items`;
    },
    params: ({ schemaCode: e }) => (0, El._)`{limit: ${e}}`,
  },
  zQ = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: WQ,
    code(e) {
      const { keyword: t, data: n, schemaCode: r } = e,
        i = t === "maxItems" ? El.operators.GT : El.operators.LT;
      e.fail$data((0, El._)`${n}.length ${i} ${r}`);
    },
  };
Oy.default = zQ;
var Py = {},
  du = {};
Object.defineProperty(du, "__esModule", { value: !0 });
const W4 = $p;
W4.code = 'require("ajv/dist/runtime/equal").default';
du.default = W4;
Object.defineProperty(Py, "__esModule", { value: !0 });
const km = lu,
  Xn = $t,
  KQ = Ut,
  VQ = du,
  YQ = {
    message: ({ params: { i: e, j: t } }) =>
      (0,
      Xn.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
    params: ({ params: { i: e, j: t } }) => (0, Xn._)`{i: ${e}, j: ${t}}`,
  },
  XQ = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: YQ,
    code(e) {
      const {
        gen: t,
        data: n,
        $data: r,
        schema: i,
        parentSchema: a,
        schemaCode: s,
        it: o,
      } = e;
      if (!r && !i) return;
      const c = t.let("valid"),
        l = a.items ? (0, km.getSchemaTypes)(a.items) : [];
      e.block$data(c, f, (0, Xn._)`${s} === false`), e.ok(c);
      function f() {
        const h = t.let("i", (0, Xn._)`${n}.length`),
          m = t.let("j");
        e.setParams({ i: h, j: m }),
          t.assign(c, !0),
          t.if((0, Xn._)`${h} > 1`, () => (u() ? d : p)(h, m));
      }
      function u() {
        return l.length > 0 && !l.some((h) => h === "object" || h === "array");
      }
      function d(h, m) {
        const g = t.name("item"),
          v = (0, km.checkDataTypes)(
            l,
            g,
            o.opts.strictNumbers,
            km.DataType.Wrong,
          ),
          y = t.const("indices", (0, Xn._)`{}`);
        t.for((0, Xn._)`;${h}--;`, () => {
          t.let(g, (0, Xn._)`${n}[${h}]`),
            t.if(v, (0, Xn._)`continue`),
            l.length > 1 &&
              t.if((0, Xn._)`typeof ${g} == "string"`, (0, Xn._)`${g} += "_"`),
            t
              .if((0, Xn._)`typeof ${y}[${g}] == "number"`, () => {
                t.assign(m, (0, Xn._)`${y}[${g}]`),
                  e.error(),
                  t.assign(c, !1).break();
              })
              .code((0, Xn._)`${y}[${g}] = ${h}`);
        });
      }
      function p(h, m) {
        const g = (0, KQ.useFunc)(t, VQ.default),
          v = t.name("outer");
        t.label(v).for((0, Xn._)`;${h}--;`, () =>
          t.for((0, Xn._)`${m} = ${h}; ${m}--;`, () =>
            t.if((0, Xn._)`${g}(${n}[${h}], ${n}[${m}])`, () => {
              e.error(), t.assign(c, !1).break(v);
            }),
          ),
        );
      }
    },
  };
Py.default = XQ;
var Dy = {};
Object.defineProperty(Dy, "__esModule", { value: !0 });
const w0 = $t,
  JQ = Ut,
  ZQ = du,
  eW = {
    message: "must be equal to constant",
    params: ({ schemaCode: e }) => (0, w0._)`{allowedValue: ${e}}`,
  },
  tW = {
    keyword: "const",
    $data: !0,
    error: eW,
    code(e) {
      const { gen: t, data: n, $data: r, schemaCode: i, schema: a } = e;
      r || (a && typeof a == "object")
        ? e.fail$data((0, w0._)`!${(0, JQ.useFunc)(t, ZQ.default)}(${n}, ${i})`)
        : e.fail((0, w0._)`${a} !== ${n}`);
    },
  };
Dy.default = tW;
var Ly = {};
Object.defineProperty(Ly, "__esModule", { value: !0 });
const il = $t,
  nW = Ut,
  rW = du,
  iW = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode: e }) => (0, il._)`{allowedValues: ${e}}`,
  },
  aW = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: iW,
    code(e) {
      const { gen: t, data: n, $data: r, schema: i, schemaCode: a, it: s } = e;
      if (!r && i.length === 0)
        throw new Error("enum must have non-empty array");
      const o = i.length >= s.opts.loopEnum;
      let c;
      const l = () => c ?? (c = (0, nW.useFunc)(t, rW.default));
      let f;
      if (o || r) (f = t.let("valid")), e.block$data(f, u);
      else {
        if (!Array.isArray(i)) throw new Error("ajv implementation error");
        const p = t.const("vSchema", a);
        f = (0, il.or)(...i.map((h, m) => d(p, m)));
      }
      e.pass(f);
      function u() {
        t.assign(f, !1),
          t.forOf("v", a, (p) =>
            t.if((0, il._)`${l()}(${n}, ${p})`, () => t.assign(f, !0).break()),
          );
      }
      function d(p, h) {
        const m = i[h];
        return typeof m == "object" && m !== null
          ? (0, il._)`${l()}(${n}, ${p}[${h}])`
          : (0, il._)`${n} === ${m}`;
      }
    },
  };
Ly.default = aW;
Object.defineProperty(Sy, "__esModule", { value: !0 });
const sW = Iy,
  oW = $y,
  cW = Cy,
  lW = ky,
  uW = Ty,
  fW = Ny,
  dW = Oy,
  pW = Py,
  hW = Dy,
  mW = Ly,
  gW = [
    sW.default,
    oW.default,
    cW.default,
    lW.default,
    uW.default,
    fW.default,
    dW.default,
    pW.default,
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    hW.default,
    mW.default,
  ];
Sy.default = gW;
var By = {},
  Ac = {};
Object.defineProperty(Ac, "__esModule", { value: !0 });
Ac.validateAdditionalItems = void 0;
const _s = $t,
  x0 = Ut,
  vW = {
    message: ({ params: { len: e } }) =>
      (0, _s.str)`must NOT have more than ${e} items`,
    params: ({ params: { len: e } }) => (0, _s._)`{limit: ${e}}`,
  },
  yW = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: vW,
    code(e) {
      const { parentSchema: t, it: n } = e,
        { items: r } = t;
      if (!Array.isArray(r)) {
        (0, x0.checkStrictMode)(
          n,
          '"additionalItems" is ignored when "items" is not an array of schemas',
        );
        return;
      }
      z4(e, r);
    },
  };
function z4(e, t) {
  const { gen: n, schema: r, data: i, keyword: a, it: s } = e;
  s.items = !0;
  const o = n.const("len", (0, _s._)`${i}.length`);
  if (r === !1)
    e.setParams({ len: t.length }), e.pass((0, _s._)`${o} <= ${t.length}`);
  else if (typeof r == "object" && !(0, x0.alwaysValidSchema)(s, r)) {
    const l = n.var("valid", (0, _s._)`${o} <= ${t.length}`);
    n.if((0, _s.not)(l), () => c(l)), e.ok(l);
  }
  function c(l) {
    n.forRange("i", t.length, o, (f) => {
      e.subschema({ keyword: a, dataProp: f, dataPropType: x0.Type.Num }, l),
        s.allErrors || n.if((0, _s.not)(l), () => n.break());
    });
  }
}
Ac.validateAdditionalItems = z4;
Ac.default = yW;
var Uy = {},
  Sc = {};
Object.defineProperty(Sc, "__esModule", { value: !0 });
Sc.validateTuple = void 0;
const Cx = $t,
  qf = Ut,
  bW = St,
  _W = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(e) {
      const { schema: t, it: n } = e;
      if (Array.isArray(t)) return K4(e, "additionalItems", t);
      (n.items = !0),
        !(0, qf.alwaysValidSchema)(n, t) && e.ok((0, bW.validateArray)(e));
    },
  };
function K4(e, t, n = e.schema) {
  const { gen: r, parentSchema: i, data: a, keyword: s, it: o } = e;
  f(i),
    o.opts.unevaluated &&
      n.length &&
      o.items !== !0 &&
      (o.items = qf.mergeEvaluated.items(r, n.length, o.items));
  const c = r.name("valid"),
    l = r.const("len", (0, Cx._)`${a}.length`);
  n.forEach((u, d) => {
    (0, qf.alwaysValidSchema)(o, u) ||
      (r.if((0, Cx._)`${l} > ${d}`, () =>
        e.subschema({ keyword: s, schemaProp: d, dataProp: d }, c),
      ),
      e.ok(c));
  });
  function f(u) {
    const { opts: d, errSchemaPath: p } = o,
      h = n.length,
      m = h === u.minItems && (h === u.maxItems || u[t] === !1);
    if (d.strictTuples && !m) {
      const g = `"${s}" is ${h}-tuple, but minItems or maxItems/${t} are not specified or different at path "${p}"`;
      (0, qf.checkStrictMode)(o, g, d.strictTuples);
    }
  }
}
Sc.validateTuple = K4;
Sc.default = _W;
Object.defineProperty(Uy, "__esModule", { value: !0 });
const EW = Sc,
  wW = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (e) => (0, EW.validateTuple)(e, "items"),
  };
Uy.default = wW;
var Fy = {};
Object.defineProperty(Fy, "__esModule", { value: !0 });
const Rx = $t,
  xW = Ut,
  AW = St,
  SW = Ac,
  IW = {
    message: ({ params: { len: e } }) =>
      (0, Rx.str)`must NOT have more than ${e} items`,
    params: ({ params: { len: e } }) => (0, Rx._)`{limit: ${e}}`,
  },
  $W = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: IW,
    code(e) {
      const { schema: t, parentSchema: n, it: r } = e,
        { prefixItems: i } = n;
      (r.items = !0),
        !(0, xW.alwaysValidSchema)(r, t) &&
          (i
            ? (0, SW.validateAdditionalItems)(e, i)
            : e.ok((0, AW.validateArray)(e)));
    },
  };
Fy.default = $W;
var jy = {};
Object.defineProperty(jy, "__esModule", { value: !0 });
const Jr = $t,
  vf = Ut,
  CW = {
    message: ({ params: { min: e, max: t } }) =>
      t === void 0
        ? (0, Jr.str)`must contain at least ${e} valid item(s)`
        : (0,
          Jr.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
    params: ({ params: { min: e, max: t } }) =>
      t === void 0
        ? (0, Jr._)`{minContains: ${e}}`
        : (0, Jr._)`{minContains: ${e}, maxContains: ${t}}`,
  },
  RW = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: CW,
    code(e) {
      const { gen: t, schema: n, parentSchema: r, data: i, it: a } = e;
      let s, o;
      const { minContains: c, maxContains: l } = r;
      a.opts.next ? ((s = c === void 0 ? 1 : c), (o = l)) : (s = 1);
      const f = t.const("len", (0, Jr._)`${i}.length`);
      if ((e.setParams({ min: s, max: o }), o === void 0 && s === 0)) {
        (0, vf.checkStrictMode)(
          a,
          '"minContains" == 0 without "maxContains": "contains" keyword ignored',
        );
        return;
      }
      if (o !== void 0 && s > o) {
        (0, vf.checkStrictMode)(
          a,
          '"minContains" > "maxContains" is always invalid',
        ),
          e.fail();
        return;
      }
      if ((0, vf.alwaysValidSchema)(a, n)) {
        let m = (0, Jr._)`${f} >= ${s}`;
        o !== void 0 && (m = (0, Jr._)`${m} && ${f} <= ${o}`), e.pass(m);
        return;
      }
      a.items = !0;
      const u = t.name("valid");
      o === void 0 && s === 1
        ? p(u, () => t.if(u, () => t.break()))
        : s === 0
        ? (t.let(u, !0), o !== void 0 && t.if((0, Jr._)`${i}.length > 0`, d))
        : (t.let(u, !1), d()),
        e.result(u, () => e.reset());
      function d() {
        const m = t.name("_valid"),
          g = t.let("count", 0);
        p(m, () => t.if(m, () => h(g)));
      }
      function p(m, g) {
        t.forRange("i", 0, f, (v) => {
          e.subschema(
            {
              keyword: "contains",
              dataProp: v,
              dataPropType: vf.Type.Num,
              compositeRule: !0,
            },
            m,
          ),
            g();
        });
      }
      function h(m) {
        t.code((0, Jr._)`${m}++`),
          o === void 0
            ? t.if((0, Jr._)`${m} >= ${s}`, () => t.assign(u, !0).break())
            : (t.if((0, Jr._)`${m} > ${o}`, () => t.assign(u, !1).break()),
              s === 1
                ? t.assign(u, !0)
                : t.if((0, Jr._)`${m} >= ${s}`, () => t.assign(u, !0)));
      }
    },
  };
jy.default = RW;
var V4 = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0);
  const t = $t,
    n = Ut,
    r = St;
  e.error = {
    message: ({ params: { property: c, depsCount: l, deps: f } }) => {
      const u = l === 1 ? "property" : "properties";
      return (0, t.str)`must have ${u} ${f} when property ${c} is present`;
    },
    params: ({
      params: { property: c, depsCount: l, deps: f, missingProperty: u },
    }) => (0, t._)`{property: ${c},
    missingProperty: ${u},
    depsCount: ${l},
    deps: ${f}}`,
  };
  const i = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(c) {
      const [l, f] = a(c);
      s(c, l), o(c, f);
    },
  };
  function a({ schema: c }) {
    const l = {},
      f = {};
    for (const u in c) {
      if (u === "__proto__") continue;
      const d = Array.isArray(c[u]) ? l : f;
      d[u] = c[u];
    }
    return [l, f];
  }
  function s(c, l = c.schema) {
    const { gen: f, data: u, it: d } = c;
    if (Object.keys(l).length === 0) return;
    const p = f.let("missing");
    for (const h in l) {
      const m = l[h];
      if (m.length === 0) continue;
      const g = (0, r.propertyInData)(f, u, h, d.opts.ownProperties);
      c.setParams({ property: h, depsCount: m.length, deps: m.join(", ") }),
        d.allErrors
          ? f.if(g, () => {
              for (const v of m) (0, r.checkReportMissingProp)(c, v);
            })
          : (f.if((0, t._)`${g} && (${(0, r.checkMissingProp)(c, m, p)})`),
            (0, r.reportMissingProp)(c, p),
            f.else());
    }
  }
  e.validatePropertyDeps = s;
  function o(c, l = c.schema) {
    const { gen: f, data: u, keyword: d, it: p } = c,
      h = f.name("valid");
    for (const m in l)
      (0, n.alwaysValidSchema)(p, l[m]) ||
        (f.if(
          (0, r.propertyInData)(f, u, m, p.opts.ownProperties),
          () => {
            const g = c.subschema({ keyword: d, schemaProp: m }, h);
            c.mergeValidEvaluated(g, h);
          },
          () => f.var(h, !0),
        ),
        c.ok(h));
  }
  (e.validateSchemaDeps = o), (e.default = i);
})(V4);
var My = {};
Object.defineProperty(My, "__esModule", { value: !0 });
const Y4 = $t,
  kW = Ut,
  TW = {
    message: "property name must be valid",
    params: ({ params: e }) => (0, Y4._)`{propertyName: ${e.propertyName}}`,
  },
  NW = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: TW,
    code(e) {
      const { gen: t, schema: n, data: r, it: i } = e;
      if ((0, kW.alwaysValidSchema)(i, n)) return;
      const a = t.name("valid");
      t.forIn("key", r, (s) => {
        e.setParams({ propertyName: s }),
          e.subschema(
            {
              keyword: "propertyNames",
              data: s,
              dataTypes: ["string"],
              propertyName: s,
              compositeRule: !0,
            },
            a,
          ),
          t.if((0, Y4.not)(a), () => {
            e.error(!0), i.allErrors || t.break();
          });
      }),
        e.ok(a);
    },
  };
My.default = NW;
var kp = {};
Object.defineProperty(kp, "__esModule", { value: !0 });
const yf = St,
  oi = $t,
  OW = Wi,
  bf = Ut,
  PW = {
    message: "must NOT have additional properties",
    params: ({ params: e }) =>
      (0, oi._)`{additionalProperty: ${e.additionalProperty}}`,
  },
  DW = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: PW,
    code(e) {
      const {
        gen: t,
        schema: n,
        parentSchema: r,
        data: i,
        errsCount: a,
        it: s,
      } = e;
      if (!a) throw new Error("ajv implementation error");
      const { allErrors: o, opts: c } = s;
      if (
        ((s.props = !0),
        c.removeAdditional !== "all" && (0, bf.alwaysValidSchema)(s, n))
      )
        return;
      const l = (0, yf.allSchemaProperties)(r.properties),
        f = (0, yf.allSchemaProperties)(r.patternProperties);
      u(), e.ok((0, oi._)`${a} === ${OW.default.errors}`);
      function u() {
        t.forIn("key", i, (g) => {
          !l.length && !f.length ? h(g) : t.if(d(g), () => h(g));
        });
      }
      function d(g) {
        let v;
        if (l.length > 8) {
          const y = (0, bf.schemaRefOrVal)(s, r.properties, "properties");
          v = (0, yf.isOwnProperty)(t, y, g);
        } else
          l.length
            ? (v = (0, oi.or)(...l.map((y) => (0, oi._)`${g} === ${y}`)))
            : (v = oi.nil);
        return (
          f.length &&
            (v = (0, oi.or)(
              v,
              ...f.map(
                (y) => (0, oi._)`${(0, yf.usePattern)(e, y)}.test(${g})`,
              ),
            )),
          (0, oi.not)(v)
        );
      }
      function p(g) {
        t.code((0, oi._)`delete ${i}[${g}]`);
      }
      function h(g) {
        if (c.removeAdditional === "all" || (c.removeAdditional && n === !1)) {
          p(g);
          return;
        }
        if (n === !1) {
          e.setParams({ additionalProperty: g }), e.error(), o || t.break();
          return;
        }
        if (typeof n == "object" && !(0, bf.alwaysValidSchema)(s, n)) {
          const v = t.name("valid");
          c.removeAdditional === "failing"
            ? (m(g, v, !1),
              t.if((0, oi.not)(v), () => {
                e.reset(), p(g);
              }))
            : (m(g, v), o || t.if((0, oi.not)(v), () => t.break()));
        }
      }
      function m(g, v, y) {
        const _ = {
          keyword: "additionalProperties",
          dataProp: g,
          dataPropType: bf.Type.Str,
        };
        y === !1 &&
          Object.assign(_, {
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1,
          }),
          e.subschema(_, v);
      }
    },
  };
kp.default = DW;
var Hy = {};
Object.defineProperty(Hy, "__esModule", { value: !0 });
const LW = yi,
  kx = St,
  Tm = Ut,
  Tx = kp,
  BW = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(e) {
      const { gen: t, schema: n, parentSchema: r, data: i, it: a } = e;
      a.opts.removeAdditional === "all" &&
        r.additionalProperties === void 0 &&
        Tx.default.code(
          new LW.KeywordCxt(a, Tx.default, "additionalProperties"),
        );
      const s = (0, kx.allSchemaProperties)(n);
      for (const u of s) a.definedProperties.add(u);
      a.opts.unevaluated &&
        s.length &&
        a.props !== !0 &&
        (a.props = Tm.mergeEvaluated.props(t, (0, Tm.toHash)(s), a.props));
      const o = s.filter((u) => !(0, Tm.alwaysValidSchema)(a, n[u]));
      if (o.length === 0) return;
      const c = t.name("valid");
      for (const u of o)
        l(u)
          ? f(u)
          : (t.if((0, kx.propertyInData)(t, i, u, a.opts.ownProperties)),
            f(u),
            a.allErrors || t.else().var(c, !0),
            t.endIf()),
          e.it.definedProperties.add(u),
          e.ok(c);
      function l(u) {
        return (
          a.opts.useDefaults && !a.compositeRule && n[u].default !== void 0
        );
      }
      function f(u) {
        e.subschema({ keyword: "properties", schemaProp: u, dataProp: u }, c);
      }
    },
  };
Hy.default = BW;
var qy = {};
Object.defineProperty(qy, "__esModule", { value: !0 });
const Nx = St,
  _f = $t,
  Ox = Ut,
  Px = Ut,
  UW = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(e) {
      const { gen: t, schema: n, data: r, parentSchema: i, it: a } = e,
        { opts: s } = a,
        o = (0, Nx.allSchemaProperties)(n),
        c = o.filter((m) => (0, Ox.alwaysValidSchema)(a, n[m]));
      if (
        o.length === 0 ||
        (c.length === o.length && (!a.opts.unevaluated || a.props === !0))
      )
        return;
      const l = s.strictSchema && !s.allowMatchingProperties && i.properties,
        f = t.name("valid");
      a.props !== !0 &&
        !(a.props instanceof _f.Name) &&
        (a.props = (0, Px.evaluatedPropsToName)(t, a.props));
      const { props: u } = a;
      d();
      function d() {
        for (const m of o)
          l && p(m), a.allErrors ? h(m) : (t.var(f, !0), h(m), t.if(f));
      }
      function p(m) {
        for (const g in l)
          new RegExp(m).test(g) &&
            (0, Ox.checkStrictMode)(
              a,
              `property ${g} matches pattern ${m} (use allowMatchingProperties)`,
            );
      }
      function h(m) {
        t.forIn("key", r, (g) => {
          t.if((0, _f._)`${(0, Nx.usePattern)(e, m)}.test(${g})`, () => {
            const v = c.includes(m);
            v ||
              e.subschema(
                {
                  keyword: "patternProperties",
                  schemaProp: m,
                  dataProp: g,
                  dataPropType: Px.Type.Str,
                },
                f,
              ),
              a.opts.unevaluated && u !== !0
                ? t.assign((0, _f._)`${u}[${g}]`, !0)
                : !v && !a.allErrors && t.if((0, _f.not)(f), () => t.break());
          });
        });
      }
    },
  };
qy.default = UW;
var Gy = {};
Object.defineProperty(Gy, "__esModule", { value: !0 });
const FW = Ut,
  jW = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(e) {
      const { gen: t, schema: n, it: r } = e;
      if ((0, FW.alwaysValidSchema)(r, n)) {
        e.fail();
        return;
      }
      const i = t.name("valid");
      e.subschema(
        { keyword: "not", compositeRule: !0, createErrors: !1, allErrors: !1 },
        i,
      ),
        e.failResult(
          i,
          () => e.reset(),
          () => e.error(),
        );
    },
    error: { message: "must NOT be valid" },
  };
Gy.default = jW;
var Qy = {};
Object.defineProperty(Qy, "__esModule", { value: !0 });
const MW = St,
  HW = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: MW.validateUnion,
    error: { message: "must match a schema in anyOf" },
  };
Qy.default = HW;
var Wy = {};
Object.defineProperty(Wy, "__esModule", { value: !0 });
const Gf = $t,
  qW = Ut,
  GW = {
    message: "must match exactly one schema in oneOf",
    params: ({ params: e }) => (0, Gf._)`{passingSchemas: ${e.passing}}`,
  },
  QW = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: GW,
    code(e) {
      const { gen: t, schema: n, parentSchema: r, it: i } = e;
      if (!Array.isArray(n)) throw new Error("ajv implementation error");
      if (i.opts.discriminator && r.discriminator) return;
      const a = n,
        s = t.let("valid", !1),
        o = t.let("passing", null),
        c = t.name("_valid");
      e.setParams({ passing: o }),
        t.block(l),
        e.result(
          s,
          () => e.reset(),
          () => e.error(!0),
        );
      function l() {
        a.forEach((f, u) => {
          let d;
          (0, qW.alwaysValidSchema)(i, f)
            ? t.var(c, !0)
            : (d = e.subschema(
                { keyword: "oneOf", schemaProp: u, compositeRule: !0 },
                c,
              )),
            u > 0 &&
              t
                .if((0, Gf._)`${c} && ${s}`)
                .assign(s, !1)
                .assign(o, (0, Gf._)`[${o}, ${u}]`)
                .else(),
            t.if(c, () => {
              t.assign(s, !0),
                t.assign(o, u),
                d && e.mergeEvaluated(d, Gf.Name);
            });
        });
      }
    },
  };
Wy.default = QW;
var zy = {};
Object.defineProperty(zy, "__esModule", { value: !0 });
const WW = Ut,
  zW = {
    keyword: "allOf",
    schemaType: "array",
    code(e) {
      const { gen: t, schema: n, it: r } = e;
      if (!Array.isArray(n)) throw new Error("ajv implementation error");
      const i = t.name("valid");
      n.forEach((a, s) => {
        if ((0, WW.alwaysValidSchema)(r, a)) return;
        const o = e.subschema({ keyword: "allOf", schemaProp: s }, i);
        e.ok(i), e.mergeEvaluated(o);
      });
    },
  };
zy.default = zW;
var Ky = {};
Object.defineProperty(Ky, "__esModule", { value: !0 });
const xd = $t,
  X4 = Ut,
  KW = {
    message: ({ params: e }) => (0, xd.str)`must match "${e.ifClause}" schema`,
    params: ({ params: e }) => (0, xd._)`{failingKeyword: ${e.ifClause}}`,
  },
  VW = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: KW,
    code(e) {
      const { gen: t, parentSchema: n, it: r } = e;
      n.then === void 0 &&
        n.else === void 0 &&
        (0, X4.checkStrictMode)(r, '"if" without "then" and "else" is ignored');
      const i = Dx(r, "then"),
        a = Dx(r, "else");
      if (!i && !a) return;
      const s = t.let("valid", !0),
        o = t.name("_valid");
      if ((c(), e.reset(), i && a)) {
        const f = t.let("ifClause");
        e.setParams({ ifClause: f }), t.if(o, l("then", f), l("else", f));
      } else i ? t.if(o, l("then")) : t.if((0, xd.not)(o), l("else"));
      e.pass(s, () => e.error(!0));
      function c() {
        const f = e.subschema(
          { keyword: "if", compositeRule: !0, createErrors: !1, allErrors: !1 },
          o,
        );
        e.mergeEvaluated(f);
      }
      function l(f, u) {
        return () => {
          const d = e.subschema({ keyword: f }, o);
          t.assign(s, o),
            e.mergeValidEvaluated(d, s),
            u ? t.assign(u, (0, xd._)`${f}`) : e.setParams({ ifClause: f });
        };
      }
    },
  };
function Dx(e, t) {
  const n = e.schema[t];
  return n !== void 0 && !(0, X4.alwaysValidSchema)(e, n);
}
Ky.default = VW;
var Vy = {};
Object.defineProperty(Vy, "__esModule", { value: !0 });
const YW = Ut,
  XW = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: e, parentSchema: t, it: n }) {
      t.if === void 0 &&
        (0, YW.checkStrictMode)(n, `"${e}" without "if" is ignored`);
    },
  };
Vy.default = XW;
Object.defineProperty(By, "__esModule", { value: !0 });
const JW = Ac,
  ZW = Uy,
  ez = Sc,
  tz = Fy,
  nz = jy,
  rz = V4,
  iz = My,
  az = kp,
  sz = Hy,
  oz = qy,
  cz = Gy,
  lz = Qy,
  uz = Wy,
  fz = zy,
  dz = Ky,
  pz = Vy;
function hz(e = !1) {
  const t = [
    cz.default,
    lz.default,
    uz.default,
    fz.default,
    dz.default,
    pz.default,
    iz.default,
    az.default,
    rz.default,
    sz.default,
    oz.default,
  ];
  return (
    e ? t.push(ZW.default, tz.default) : t.push(JW.default, ez.default),
    t.push(nz.default),
    t
  );
}
By.default = hz;
var Yy = {},
  Xy = {};
Object.defineProperty(Xy, "__esModule", { value: !0 });
const Cn = $t,
  mz = {
    message: ({ schemaCode: e }) => (0, Cn.str)`must match format "${e}"`,
    params: ({ schemaCode: e }) => (0, Cn._)`{format: ${e}}`,
  },
  gz = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: mz,
    code(e, t) {
      const { gen: n, data: r, $data: i, schema: a, schemaCode: s, it: o } = e,
        { opts: c, errSchemaPath: l, schemaEnv: f, self: u } = o;
      if (!c.validateFormats) return;
      i ? d() : p();
      function d() {
        const h = n.scopeValue("formats", {
            ref: u.formats,
            code: c.code.formats,
          }),
          m = n.const("fDef", (0, Cn._)`${h}[${s}]`),
          g = n.let("fType"),
          v = n.let("format");
        n.if(
          (0, Cn._)`typeof ${m} == "object" && !(${m} instanceof RegExp)`,
          () =>
            n
              .assign(g, (0, Cn._)`${m}.type || "string"`)
              .assign(v, (0, Cn._)`${m}.validate`),
          () => n.assign(g, (0, Cn._)`"string"`).assign(v, m),
        ),
          e.fail$data((0, Cn.or)(y(), _()));
        function y() {
          return c.strictSchema === !1 ? Cn.nil : (0, Cn._)`${s} && !${v}`;
        }
        function _() {
          const E = f.$async
              ? (0, Cn._)`(${m}.async ? await ${v}(${r}) : ${v}(${r}))`
              : (0, Cn._)`${v}(${r})`,
            R = (0, Cn._)`(typeof ${v} == "function" ? ${E} : ${v}.test(${r}))`;
          return (0, Cn._)`${v} && ${v} !== true && ${g} === ${t} && !${R}`;
        }
      }
      function p() {
        const h = u.formats[a];
        if (!h) {
          y();
          return;
        }
        if (h === !0) return;
        const [m, g, v] = _(h);
        m === t && e.pass(E());
        function y() {
          if (c.strictSchema === !1) {
            u.logger.warn(R());
            return;
          }
          throw new Error(R());
          function R() {
            return `unknown format "${a}" ignored in schema at path "${l}"`;
          }
        }
        function _(R) {
          const A =
              R instanceof RegExp
                ? (0, Cn.regexpCode)(R)
                : c.code.formats
                ? (0, Cn._)`${c.code.formats}${(0, Cn.getProperty)(a)}`
                : void 0,
            I = n.scopeValue("formats", { key: a, ref: R, code: A });
          return typeof R == "object" && !(R instanceof RegExp)
            ? [R.type || "string", R.validate, (0, Cn._)`${I}.validate`]
            : ["string", R, I];
        }
        function E() {
          if (typeof h == "object" && !(h instanceof RegExp) && h.async) {
            if (!f.$async) throw new Error("async format in sync schema");
            return (0, Cn._)`await ${v}(${r})`;
          }
          return typeof g == "function"
            ? (0, Cn._)`${v}(${r})`
            : (0, Cn._)`${v}.test(${r})`;
        }
      }
    },
  };
Xy.default = gz;
Object.defineProperty(Yy, "__esModule", { value: !0 });
const vz = Xy,
  yz = [vz.default];
Yy.default = yz;
var sc = {};
Object.defineProperty(sc, "__esModule", { value: !0 });
sc.contentVocabulary = sc.metadataVocabulary = void 0;
sc.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples",
];
sc.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
Object.defineProperty(wy, "__esModule", { value: !0 });
const bz = xy,
  _z = Sy,
  Ez = By,
  wz = Yy,
  Lx = sc,
  xz = [
    bz.default,
    _z.default,
    (0, Ez.default)(),
    wz.default,
    Lx.metadataVocabulary,
    Lx.contentVocabulary,
  ];
wy.default = xz;
var Jy = {},
  J4 = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.DiscrError = void 0),
    (function (t) {
      (t.Tag = "tag"), (t.Mapping = "mapping");
    })(e.DiscrError || (e.DiscrError = {}));
})(J4);
Object.defineProperty(Jy, "__esModule", { value: !0 });
const Ao = $t,
  A0 = J4,
  Bx = Dr,
  Az = Ut,
  Sz = {
    message: ({ params: { discrError: e, tagName: t } }) =>
      e === A0.DiscrError.Tag
        ? `tag "${t}" must be string`
        : `value of tag "${t}" must be in oneOf`,
    params: ({ params: { discrError: e, tag: t, tagName: n } }) =>
      (0, Ao._)`{error: ${e}, tag: ${n}, tagValue: ${t}}`,
  },
  Iz = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: Sz,
    code(e) {
      const { gen: t, data: n, schema: r, parentSchema: i, it: a } = e,
        { oneOf: s } = i;
      if (!a.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const o = r.propertyName;
      if (typeof o != "string")
        throw new Error("discriminator: requires propertyName");
      if (r.mapping) throw new Error("discriminator: mapping is not supported");
      if (!s) throw new Error("discriminator: requires oneOf keyword");
      const c = t.let("valid", !1),
        l = t.const("tag", (0, Ao._)`${n}${(0, Ao.getProperty)(o)}`);
      t.if(
        (0, Ao._)`typeof ${l} == "string"`,
        () => f(),
        () =>
          e.error(!1, { discrError: A0.DiscrError.Tag, tag: l, tagName: o }),
      ),
        e.ok(c);
      function f() {
        const p = d();
        t.if(!1);
        for (const h in p)
          t.elseIf((0, Ao._)`${l} === ${h}`), t.assign(c, u(p[h]));
        t.else(),
          e.error(!1, {
            discrError: A0.DiscrError.Mapping,
            tag: l,
            tagName: o,
          }),
          t.endIf();
      }
      function u(p) {
        const h = t.name("valid"),
          m = e.subschema({ keyword: "oneOf", schemaProp: p }, h);
        return e.mergeEvaluated(m, Ao.Name), h;
      }
      function d() {
        var p;
        const h = {},
          m = v(i);
        let g = !0;
        for (let E = 0; E < s.length; E++) {
          let R = s[E];
          R != null &&
            R.$ref &&
            !(0, Az.schemaHasRulesButRef)(R, a.self.RULES) &&
            ((R = Bx.resolveRef.call(
              a.self,
              a.schemaEnv.root,
              a.baseId,
              R == null ? void 0 : R.$ref,
            )),
            R instanceof Bx.SchemaEnv && (R = R.schema));
          const A =
            (p = R == null ? void 0 : R.properties) === null || p === void 0
              ? void 0
              : p[o];
          if (typeof A != "object")
            throw new Error(
              `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${o}"`,
            );
          (g = g && (m || v(R))), y(A, E);
        }
        if (!g) throw new Error(`discriminator: "${o}" must be required`);
        return h;
        function v({ required: E }) {
          return Array.isArray(E) && E.includes(o);
        }
        function y(E, R) {
          if (E.const) _(E.const, R);
          else if (E.enum) for (const A of E.enum) _(A, R);
          else
            throw new Error(
              `discriminator: "properties/${o}" must have "const" or "enum"`,
            );
        }
        function _(E, R) {
          if (typeof E != "string" || E in h)
            throw new Error(
              `discriminator: "${o}" values must be unique strings`,
            );
          h[E] = R;
        }
      }
    },
  };
Jy.default = Iz;
const $z = "http://json-schema.org/draft-07/schema#",
  Cz = "http://json-schema.org/draft-07/schema#",
  Rz = "Core schema meta-schema",
  kz = {
    schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
    nonNegativeInteger: { type: "integer", minimum: 0 },
    nonNegativeIntegerDefault0: {
      allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
    },
    simpleTypes: {
      enum: [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string",
      ],
    },
    stringArray: {
      type: "array",
      items: { type: "string" },
      uniqueItems: !0,
      default: [],
    },
  },
  Tz = ["object", "boolean"],
  Nz = {
    $id: { type: "string", format: "uri-reference" },
    $schema: { type: "string", format: "uri" },
    $ref: { type: "string", format: "uri-reference" },
    $comment: { type: "string" },
    title: { type: "string" },
    description: { type: "string" },
    default: !0,
    readOnly: { type: "boolean", default: !1 },
    examples: { type: "array", items: !0 },
    multipleOf: { type: "number", exclusiveMinimum: 0 },
    maximum: { type: "number" },
    exclusiveMaximum: { type: "number" },
    minimum: { type: "number" },
    exclusiveMinimum: { type: "number" },
    maxLength: { $ref: "#/definitions/nonNegativeInteger" },
    minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
    pattern: { type: "string", format: "regex" },
    additionalItems: { $ref: "#" },
    items: {
      anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
      default: !0,
    },
    maxItems: { $ref: "#/definitions/nonNegativeInteger" },
    minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
    uniqueItems: { type: "boolean", default: !1 },
    contains: { $ref: "#" },
    maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
    minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
    required: { $ref: "#/definitions/stringArray" },
    additionalProperties: { $ref: "#" },
    definitions: {
      type: "object",
      additionalProperties: { $ref: "#" },
      default: {},
    },
    properties: {
      type: "object",
      additionalProperties: { $ref: "#" },
      default: {},
    },
    patternProperties: {
      type: "object",
      additionalProperties: { $ref: "#" },
      propertyNames: { format: "regex" },
      default: {},
    },
    dependencies: {
      type: "object",
      additionalProperties: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
      },
    },
    propertyNames: { $ref: "#" },
    const: !0,
    enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 },
    type: {
      anyOf: [
        { $ref: "#/definitions/simpleTypes" },
        {
          type: "array",
          items: { $ref: "#/definitions/simpleTypes" },
          minItems: 1,
          uniqueItems: !0,
        },
      ],
    },
    format: { type: "string" },
    contentMediaType: { type: "string" },
    contentEncoding: { type: "string" },
    if: { $ref: "#" },
    then: { $ref: "#" },
    else: { $ref: "#" },
    allOf: { $ref: "#/definitions/schemaArray" },
    anyOf: { $ref: "#/definitions/schemaArray" },
    oneOf: { $ref: "#/definitions/schemaArray" },
    not: { $ref: "#" },
  },
  Oz = {
    $schema: $z,
    $id: Cz,
    title: Rz,
    definitions: kz,
    type: Tz,
    properties: Nz,
    default: !0,
  };
(function (e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.MissingRefError =
      t.ValidationError =
      t.CodeGen =
      t.Name =
      t.nil =
      t.stringify =
      t.str =
      t._ =
      t.KeywordCxt =
        void 0);
  const n = y4,
    r = wy,
    i = Jy,
    a = Oz,
    s = ["/properties"],
    o = "http://json-schema.org/draft-07/schema";
  class c extends n.default {
    _addVocabularies() {
      super._addVocabularies(),
        r.default.forEach((h) => this.addVocabulary(h)),
        this.opts.discriminator && this.addKeyword(i.default);
    }
    _addDefaultMetaSchema() {
      if ((super._addDefaultMetaSchema(), !this.opts.meta)) return;
      const h = this.opts.$data ? this.$dataMetaSchema(a, s) : a;
      this.addMetaSchema(h, o, !1),
        (this.refs["http://json-schema.org/schema"] = o);
    }
    defaultMeta() {
      return (this.opts.defaultMeta =
        super.defaultMeta() || (this.getSchema(o) ? o : void 0));
    }
  }
  (e.exports = t = c),
    Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.default = c);
  var l = yi;
  Object.defineProperty(t, "KeywordCxt", {
    enumerable: !0,
    get: function () {
      return l.KeywordCxt;
    },
  });
  var f = $t;
  Object.defineProperty(t, "_", {
    enumerable: !0,
    get: function () {
      return f._;
    },
  }),
    Object.defineProperty(t, "str", {
      enumerable: !0,
      get: function () {
        return f.str;
      },
    }),
    Object.defineProperty(t, "stringify", {
      enumerable: !0,
      get: function () {
        return f.stringify;
      },
    }),
    Object.defineProperty(t, "nil", {
      enumerable: !0,
      get: function () {
        return f.nil;
      },
    }),
    Object.defineProperty(t, "Name", {
      enumerable: !0,
      get: function () {
        return f.Name;
      },
    }),
    Object.defineProperty(t, "CodeGen", {
      enumerable: !0,
      get: function () {
        return f.CodeGen;
      },
    });
  var u = uu;
  Object.defineProperty(t, "ValidationError", {
    enumerable: !0,
    get: function () {
      return u.default;
    },
  });
  var d = fu;
  Object.defineProperty(t, "MissingRefError", {
    enumerable: !0,
    get: function () {
      return d.default;
    },
  });
})(y0, y0.exports);
var Pz = y0.exports,
  S0 = { exports: {} },
  Z4 = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.formatNames = e.fastFormats = e.fullFormats = void 0);
  function t(w, O) {
    return { validate: w, compare: O };
  }
  (e.fullFormats = {
    date: t(a, s),
    time: t(c, l),
    "date-time": t(u, d),
    duration:
      /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: m,
    "uri-reference":
      /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template":
      /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email:
      /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname:
      /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: S,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment":
      /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte: v,
    int32: { type: "number", validate: E },
    int64: { type: "number", validate: R },
    float: { type: "number", validate: A },
    double: { type: "number", validate: A },
    password: !0,
    binary: !0,
  }),
    (e.fastFormats = {
      ...e.fullFormats,
      date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, s),
      time: t(
        /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
        l,
      ),
      "date-time": t(
        /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
        d,
      ),
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference":
        /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      email:
        /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    }),
    (e.formatNames = Object.keys(e.fullFormats));
  function n(w) {
    return w % 4 === 0 && (w % 100 !== 0 || w % 400 === 0);
  }
  const r = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
    i = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function a(w) {
    const O = r.exec(w);
    if (!O) return !1;
    const Q = +O[1],
      j = +O[2],
      H = +O[3];
    return j >= 1 && j <= 12 && H >= 1 && H <= (j === 2 && n(Q) ? 29 : i[j]);
  }
  function s(w, O) {
    if (w && O) return w > O ? 1 : w < O ? -1 : 0;
  }
  const o = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function c(w, O) {
    const Q = o.exec(w);
    if (!Q) return !1;
    const j = +Q[1],
      H = +Q[2],
      q = +Q[3],
      J = Q[5];
    return (
      ((j <= 23 && H <= 59 && q <= 59) || (j === 23 && H === 59 && q === 60)) &&
      (!O || J !== "")
    );
  }
  function l(w, O) {
    if (!(w && O)) return;
    const Q = o.exec(w),
      j = o.exec(O);
    if (Q && j)
      return (
        (w = Q[1] + Q[2] + Q[3] + (Q[4] || "")),
        (O = j[1] + j[2] + j[3] + (j[4] || "")),
        w > O ? 1 : w < O ? -1 : 0
      );
  }
  const f = /t|\s/i;
  function u(w) {
    const O = w.split(f);
    return O.length === 2 && a(O[0]) && c(O[1], !0);
  }
  function d(w, O) {
    if (!(w && O)) return;
    const [Q, j] = w.split(f),
      [H, q] = O.split(f),
      J = s(Q, H);
    if (J !== void 0) return J || l(j, q);
  }
  const p = /\/|:/,
    h =
      /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function m(w) {
    return p.test(w) && h.test(w);
  }
  const g =
    /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function v(w) {
    return (g.lastIndex = 0), g.test(w);
  }
  const y = -(2 ** 31),
    _ = 2 ** 31 - 1;
  function E(w) {
    return Number.isInteger(w) && w <= _ && w >= y;
  }
  function R(w) {
    return Number.isInteger(w);
  }
  function A() {
    return !0;
  }
  const I = /[^\\]\\Z/;
  function S(w) {
    if (I.test(w)) return !1;
    try {
      return new RegExp(w), !0;
    } catch {
      return !1;
    }
  }
})(Z4);
var eR = {},
  I0 = { exports: {} },
  tR = {},
  bi = {},
  oc = {},
  pu = {},
  xt = {},
  Hl = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.regexpCode =
      e.getEsmExportName =
      e.getProperty =
      e.safeStringify =
      e.stringify =
      e.strConcat =
      e.addCodeArg =
      e.str =
      e._ =
      e.nil =
      e._Code =
      e.Name =
      e.IDENTIFIER =
      e._CodeOrName =
        void 0);
  class t {}
  (e._CodeOrName = t), (e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i);
  class n extends t {
    constructor(y) {
      if ((super(), !e.IDENTIFIER.test(y)))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = y;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = n;
  class r extends t {
    constructor(y) {
      super(), (this._items = typeof y == "string" ? [y] : y);
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1) return !1;
      const y = this._items[0];
      return y === "" || y === '""';
    }
    get str() {
      var y;
      return (y = this._str) !== null && y !== void 0
        ? y
        : (this._str = this._items.reduce((_, E) => `${_}${E}`, ""));
    }
    get names() {
      var y;
      return (y = this._names) !== null && y !== void 0
        ? y
        : (this._names = this._items.reduce(
            (_, E) => (E instanceof n && (_[E.str] = (_[E.str] || 0) + 1), _),
            {},
          ));
    }
  }
  (e._Code = r), (e.nil = new r(""));
  function i(v, ...y) {
    const _ = [v[0]];
    let E = 0;
    for (; E < y.length; ) o(_, y[E]), _.push(v[++E]);
    return new r(_);
  }
  e._ = i;
  const a = new r("+");
  function s(v, ...y) {
    const _ = [p(v[0])];
    let E = 0;
    for (; E < y.length; ) _.push(a), o(_, y[E]), _.push(a, p(v[++E]));
    return c(_), new r(_);
  }
  e.str = s;
  function o(v, y) {
    y instanceof r
      ? v.push(...y._items)
      : y instanceof n
      ? v.push(y)
      : v.push(u(y));
  }
  e.addCodeArg = o;
  function c(v) {
    let y = 1;
    for (; y < v.length - 1; ) {
      if (v[y] === a) {
        const _ = l(v[y - 1], v[y + 1]);
        if (_ !== void 0) {
          v.splice(y - 1, 3, _);
          continue;
        }
        v[y++] = "+";
      }
      y++;
    }
  }
  function l(v, y) {
    if (y === '""') return v;
    if (v === '""') return y;
    if (typeof v == "string")
      return y instanceof n || v[v.length - 1] !== '"'
        ? void 0
        : typeof y != "string"
        ? `${v.slice(0, -1)}${y}"`
        : y[0] === '"'
        ? v.slice(0, -1) + y.slice(1)
        : void 0;
    if (typeof y == "string" && y[0] === '"' && !(v instanceof n))
      return `"${v}${y.slice(1)}`;
  }
  function f(v, y) {
    return y.emptyStr() ? v : v.emptyStr() ? y : s`${v}${y}`;
  }
  e.strConcat = f;
  function u(v) {
    return typeof v == "number" || typeof v == "boolean" || v === null
      ? v
      : p(Array.isArray(v) ? v.join(",") : v);
  }
  function d(v) {
    return new r(p(v));
  }
  e.stringify = d;
  function p(v) {
    return JSON.stringify(v)
      .replace(/\u2028/g, "\\u2028")
      .replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = p;
  function h(v) {
    return typeof v == "string" && e.IDENTIFIER.test(v)
      ? new r(`.${v}`)
      : i`[${v}]`;
  }
  e.getProperty = h;
  function m(v) {
    if (typeof v == "string" && e.IDENTIFIER.test(v)) return new r(`${v}`);
    throw new Error(
      `CodeGen: invalid export name: ${v}, use explicit $id name mapping`,
    );
  }
  e.getEsmExportName = m;
  function g(v) {
    return new r(v.toString());
  }
  e.regexpCode = g;
})(Hl);
var $0 = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.ValueScope =
      e.ValueScopeName =
      e.Scope =
      e.varKinds =
      e.UsedValueState =
        void 0);
  const t = Hl;
  class n extends Error {
    constructor(l) {
      super(`CodeGen: "code" for ${l} not defined`), (this.value = l.value);
    }
  }
  var r;
  (function (c) {
    (c[(c.Started = 0)] = "Started"), (c[(c.Completed = 1)] = "Completed");
  })((r = e.UsedValueState || (e.UsedValueState = {}))),
    (e.varKinds = {
      const: new t.Name("const"),
      let: new t.Name("let"),
      var: new t.Name("var"),
    });
  class i {
    constructor({ prefixes: l, parent: f } = {}) {
      (this._names = {}), (this._prefixes = l), (this._parent = f);
    }
    toName(l) {
      return l instanceof t.Name ? l : this.name(l);
    }
    name(l) {
      return new t.Name(this._newName(l));
    }
    _newName(l) {
      const f = this._names[l] || this._nameGroup(l);
      return `${l}${f.index++}`;
    }
    _nameGroup(l) {
      var f, u;
      if (
        (!(
          (u =
            (f = this._parent) === null || f === void 0
              ? void 0
              : f._prefixes) === null || u === void 0
        ) &&
          u.has(l)) ||
        (this._prefixes && !this._prefixes.has(l))
      )
        throw new Error(`CodeGen: prefix "${l}" is not allowed in this scope`);
      return (this._names[l] = { prefix: l, index: 0 });
    }
  }
  e.Scope = i;
  class a extends t.Name {
    constructor(l, f) {
      super(f), (this.prefix = l);
    }
    setValue(l, { property: f, itemIndex: u }) {
      (this.value = l), (this.scopePath = (0, t._)`.${new t.Name(f)}[${u}]`);
    }
  }
  e.ValueScopeName = a;
  const s = (0, t._)`\n`;
  class o extends i {
    constructor(l) {
      super(l),
        (this._values = {}),
        (this._scope = l.scope),
        (this.opts = { ...l, _n: l.lines ? s : t.nil });
    }
    get() {
      return this._scope;
    }
    name(l) {
      return new a(l, this._newName(l));
    }
    value(l, f) {
      var u;
      if (f.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const d = this.toName(l),
        { prefix: p } = d,
        h = (u = f.key) !== null && u !== void 0 ? u : f.ref;
      let m = this._values[p];
      if (m) {
        const y = m.get(h);
        if (y) return y;
      } else m = this._values[p] = new Map();
      m.set(h, d);
      const g = this._scope[p] || (this._scope[p] = []),
        v = g.length;
      return (g[v] = f.ref), d.setValue(f, { property: p, itemIndex: v }), d;
    }
    getValue(l, f) {
      const u = this._values[l];
      if (u) return u.get(f);
    }
    scopeRefs(l, f = this._values) {
      return this._reduceValues(f, (u) => {
        if (u.scopePath === void 0)
          throw new Error(`CodeGen: name "${u}" has no value`);
        return (0, t._)`${l}${u.scopePath}`;
      });
    }
    scopeCode(l = this._values, f, u) {
      return this._reduceValues(
        l,
        (d) => {
          if (d.value === void 0)
            throw new Error(`CodeGen: name "${d}" has no value`);
          return d.value.code;
        },
        f,
        u,
      );
    }
    _reduceValues(l, f, u = {}, d) {
      let p = t.nil;
      for (const h in l) {
        const m = l[h];
        if (!m) continue;
        const g = (u[h] = u[h] || new Map());
        m.forEach((v) => {
          if (g.has(v)) return;
          g.set(v, r.Started);
          let y = f(v);
          if (y) {
            const _ = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            p = (0, t._)`${p}${_} ${v} = ${y};${this.opts._n}`;
          } else if ((y = d == null ? void 0 : d(v)))
            p = (0, t._)`${p}${y}${this.opts._n}`;
          else throw new n(v);
          g.set(v, r.Completed);
        });
      }
      return p;
    }
  }
  e.ValueScope = o;
})($0);
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.or =
      e.and =
      e.not =
      e.CodeGen =
      e.operators =
      e.varKinds =
      e.ValueScopeName =
      e.ValueScope =
      e.Scope =
      e.Name =
      e.regexpCode =
      e.stringify =
      e.getProperty =
      e.nil =
      e.strConcat =
      e.str =
      e._ =
        void 0);
  const t = Hl,
    n = $0;
  var r = Hl;
  Object.defineProperty(e, "_", {
    enumerable: !0,
    get: function () {
      return r._;
    },
  }),
    Object.defineProperty(e, "str", {
      enumerable: !0,
      get: function () {
        return r.str;
      },
    }),
    Object.defineProperty(e, "strConcat", {
      enumerable: !0,
      get: function () {
        return r.strConcat;
      },
    }),
    Object.defineProperty(e, "nil", {
      enumerable: !0,
      get: function () {
        return r.nil;
      },
    }),
    Object.defineProperty(e, "getProperty", {
      enumerable: !0,
      get: function () {
        return r.getProperty;
      },
    }),
    Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function () {
        return r.stringify;
      },
    }),
    Object.defineProperty(e, "regexpCode", {
      enumerable: !0,
      get: function () {
        return r.regexpCode;
      },
    }),
    Object.defineProperty(e, "Name", {
      enumerable: !0,
      get: function () {
        return r.Name;
      },
    });
  var i = $0;
  Object.defineProperty(e, "Scope", {
    enumerable: !0,
    get: function () {
      return i.Scope;
    },
  }),
    Object.defineProperty(e, "ValueScope", {
      enumerable: !0,
      get: function () {
        return i.ValueScope;
      },
    }),
    Object.defineProperty(e, "ValueScopeName", {
      enumerable: !0,
      get: function () {
        return i.ValueScopeName;
      },
    }),
    Object.defineProperty(e, "varKinds", {
      enumerable: !0,
      get: function () {
        return i.varKinds;
      },
    }),
    (e.operators = {
      GT: new t._Code(">"),
      GTE: new t._Code(">="),
      LT: new t._Code("<"),
      LTE: new t._Code("<="),
      EQ: new t._Code("==="),
      NEQ: new t._Code("!=="),
      NOT: new t._Code("!"),
      OR: new t._Code("||"),
      AND: new t._Code("&&"),
      ADD: new t._Code("+"),
    });
  class a {
    optimizeNodes() {
      return this;
    }
    optimizeNames(x, T) {
      return this;
    }
  }
  class s extends a {
    constructor(x, T, V) {
      super(), (this.varKind = x), (this.name = T), (this.rhs = V);
    }
    render({ es5: x, _n: T }) {
      const V = x ? n.varKinds.var : this.varKind,
        B = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${V} ${this.name}${B};` + T;
    }
    optimizeNames(x, T) {
      if (x[this.name.str])
        return this.rhs && (this.rhs = q(this.rhs, x, T)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class o extends a {
    constructor(x, T, V) {
      super(), (this.lhs = x), (this.rhs = T), (this.sideEffects = V);
    }
    render({ _n: x }) {
      return `${this.lhs} = ${this.rhs};` + x;
    }
    optimizeNames(x, T) {
      if (
        !(this.lhs instanceof t.Name && !x[this.lhs.str] && !this.sideEffects)
      )
        return (this.rhs = q(this.rhs, x, T)), this;
    }
    get names() {
      const x = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return H(x, this.rhs);
    }
  }
  class c extends o {
    constructor(x, T, V, B) {
      super(x, V, B), (this.op = T);
    }
    render({ _n: x }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + x;
    }
  }
  class l extends a {
    constructor(x) {
      super(), (this.label = x), (this.names = {});
    }
    render({ _n: x }) {
      return `${this.label}:` + x;
    }
  }
  class f extends a {
    constructor(x) {
      super(), (this.label = x), (this.names = {});
    }
    render({ _n: x }) {
      return `break${this.label ? ` ${this.label}` : ""};` + x;
    }
  }
  class u extends a {
    constructor(x) {
      super(), (this.error = x);
    }
    render({ _n: x }) {
      return `throw ${this.error};` + x;
    }
    get names() {
      return this.error.names;
    }
  }
  class d extends a {
    constructor(x) {
      super(), (this.code = x);
    }
    render({ _n: x }) {
      return `${this.code};` + x;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(x, T) {
      return (this.code = q(this.code, x, T)), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class p extends a {
    constructor(x = []) {
      super(), (this.nodes = x);
    }
    render(x) {
      return this.nodes.reduce((T, V) => T + V.render(x), "");
    }
    optimizeNodes() {
      const { nodes: x } = this;
      let T = x.length;
      for (; T--; ) {
        const V = x[T].optimizeNodes();
        Array.isArray(V)
          ? x.splice(T, 1, ...V)
          : V
          ? (x[T] = V)
          : x.splice(T, 1);
      }
      return x.length > 0 ? this : void 0;
    }
    optimizeNames(x, T) {
      const { nodes: V } = this;
      let B = V.length;
      for (; B--; ) {
        const N = V[B];
        N.optimizeNames(x, T) || (J(x, N.names), V.splice(B, 1));
      }
      return V.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((x, T) => j(x, T.names), {});
    }
  }
  class h extends p {
    render(x) {
      return "{" + x._n + super.render(x) + "}" + x._n;
    }
  }
  class m extends p {}
  class g extends h {}
  g.kind = "else";
  class v extends h {
    constructor(x, T) {
      super(T), (this.condition = x);
    }
    render(x) {
      let T = `if(${this.condition})` + super.render(x);
      return this.else && (T += "else " + this.else.render(x)), T;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const x = this.condition;
      if (x === !0) return this.nodes;
      let T = this.else;
      if (T) {
        const V = T.optimizeNodes();
        T = this.else = Array.isArray(V) ? new g(V) : V;
      }
      if (T)
        return x === !1
          ? T instanceof v
            ? T
            : T.nodes
          : this.nodes.length
          ? this
          : new v(Z(x), T instanceof v ? [T] : T.nodes);
      if (!(x === !1 || !this.nodes.length)) return this;
    }
    optimizeNames(x, T) {
      var V;
      if (
        ((this.else =
          (V = this.else) === null || V === void 0
            ? void 0
            : V.optimizeNames(x, T)),
        !!(super.optimizeNames(x, T) || this.else))
      )
        return (this.condition = q(this.condition, x, T)), this;
    }
    get names() {
      const x = super.names;
      return H(x, this.condition), this.else && j(x, this.else.names), x;
    }
  }
  v.kind = "if";
  class y extends h {}
  y.kind = "for";
  class _ extends y {
    constructor(x) {
      super(), (this.iteration = x);
    }
    render(x) {
      return `for(${this.iteration})` + super.render(x);
    }
    optimizeNames(x, T) {
      if (super.optimizeNames(x, T))
        return (this.iteration = q(this.iteration, x, T)), this;
    }
    get names() {
      return j(super.names, this.iteration.names);
    }
  }
  class E extends y {
    constructor(x, T, V, B) {
      super(),
        (this.varKind = x),
        (this.name = T),
        (this.from = V),
        (this.to = B);
    }
    render(x) {
      const T = x.es5 ? n.varKinds.var : this.varKind,
        { name: V, from: B, to: N } = this;
      return `for(${T} ${V}=${B}; ${V}<${N}; ${V}++)` + super.render(x);
    }
    get names() {
      const x = H(super.names, this.from);
      return H(x, this.to);
    }
  }
  class R extends y {
    constructor(x, T, V, B) {
      super(),
        (this.loop = x),
        (this.varKind = T),
        (this.name = V),
        (this.iterable = B);
    }
    render(x) {
      return (
        `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
        super.render(x)
      );
    }
    optimizeNames(x, T) {
      if (super.optimizeNames(x, T))
        return (this.iterable = q(this.iterable, x, T)), this;
    }
    get names() {
      return j(super.names, this.iterable.names);
    }
  }
  class A extends h {
    constructor(x, T, V) {
      super(), (this.name = x), (this.args = T), (this.async = V);
    }
    render(x) {
      return (
        `${this.async ? "async " : ""}function ${this.name}(${this.args})` +
        super.render(x)
      );
    }
  }
  A.kind = "func";
  class I extends p {
    render(x) {
      return "return " + super.render(x);
    }
  }
  I.kind = "return";
  class S extends h {
    render(x) {
      let T = "try" + super.render(x);
      return (
        this.catch && (T += this.catch.render(x)),
        this.finally && (T += this.finally.render(x)),
        T
      );
    }
    optimizeNodes() {
      var x, T;
      return (
        super.optimizeNodes(),
        (x = this.catch) === null || x === void 0 || x.optimizeNodes(),
        (T = this.finally) === null || T === void 0 || T.optimizeNodes(),
        this
      );
    }
    optimizeNames(x, T) {
      var V, B;
      return (
        super.optimizeNames(x, T),
        (V = this.catch) === null || V === void 0 || V.optimizeNames(x, T),
        (B = this.finally) === null || B === void 0 || B.optimizeNames(x, T),
        this
      );
    }
    get names() {
      const x = super.names;
      return (
        this.catch && j(x, this.catch.names),
        this.finally && j(x, this.finally.names),
        x
      );
    }
  }
  class w extends h {
    constructor(x) {
      super(), (this.error = x);
    }
    render(x) {
      return `catch(${this.error})` + super.render(x);
    }
  }
  w.kind = "catch";
  class O extends h {
    render(x) {
      return "finally" + super.render(x);
    }
  }
  O.kind = "finally";
  class Q {
    constructor(x, T = {}) {
      (this._values = {}),
        (this._blockStarts = []),
        (this._constants = {}),
        (this.opts = {
          ...T,
          _n: T.lines
            ? `
`
            : "",
        }),
        (this._extScope = x),
        (this._scope = new n.Scope({ parent: x })),
        (this._nodes = [new m()]);
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(x) {
      return this._scope.name(x);
    }
    scopeName(x) {
      return this._extScope.name(x);
    }
    scopeValue(x, T) {
      const V = this._extScope.value(x, T);
      return (
        (this._values[V.prefix] || (this._values[V.prefix] = new Set())).add(V),
        V
      );
    }
    getScopeValue(x, T) {
      return this._extScope.getValue(x, T);
    }
    scopeRefs(x) {
      return this._extScope.scopeRefs(x, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(x, T, V, B) {
      const N = this._scope.toName(T);
      return (
        V !== void 0 && B && (this._constants[N.str] = V),
        this._leafNode(new s(x, N, V)),
        N
      );
    }
    const(x, T, V) {
      return this._def(n.varKinds.const, x, T, V);
    }
    let(x, T, V) {
      return this._def(n.varKinds.let, x, T, V);
    }
    var(x, T, V) {
      return this._def(n.varKinds.var, x, T, V);
    }
    assign(x, T, V) {
      return this._leafNode(new o(x, T, V));
    }
    add(x, T) {
      return this._leafNode(new c(x, e.operators.ADD, T));
    }
    code(x) {
      return (
        typeof x == "function" ? x() : x !== t.nil && this._leafNode(new d(x)),
        this
      );
    }
    object(...x) {
      const T = ["{"];
      for (const [V, B] of x)
        T.length > 1 && T.push(","),
          T.push(V),
          (V !== B || this.opts.es5) && (T.push(":"), (0, t.addCodeArg)(T, B));
      return T.push("}"), new t._Code(T);
    }
    if(x, T, V) {
      if ((this._blockNode(new v(x)), T && V))
        this.code(T).else().code(V).endIf();
      else if (T) this.code(T).endIf();
      else if (V) throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    elseIf(x) {
      return this._elseNode(new v(x));
    }
    else() {
      return this._elseNode(new g());
    }
    endIf() {
      return this._endBlockNode(v, g);
    }
    _for(x, T) {
      return this._blockNode(x), T && this.code(T).endFor(), this;
    }
    for(x, T) {
      return this._for(new _(x), T);
    }
    forRange(x, T, V, B, N = this.opts.es5 ? n.varKinds.var : n.varKinds.let) {
      const ce = this._scope.toName(x);
      return this._for(new E(N, ce, T, V), () => B(ce));
    }
    forOf(x, T, V, B = n.varKinds.const) {
      const N = this._scope.toName(x);
      if (this.opts.es5) {
        const ce = T instanceof t.Name ? T : this.var("_arr", T);
        return this.forRange("_i", 0, (0, t._)`${ce}.length`, (re) => {
          this.var(N, (0, t._)`${ce}[${re}]`), V(N);
        });
      }
      return this._for(new R("of", B, N, T), () => V(N));
    }
    forIn(x, T, V, B = this.opts.es5 ? n.varKinds.var : n.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(x, (0, t._)`Object.keys(${T})`, V);
      const N = this._scope.toName(x);
      return this._for(new R("in", B, N, T), () => V(N));
    }
    endFor() {
      return this._endBlockNode(y);
    }
    label(x) {
      return this._leafNode(new l(x));
    }
    break(x) {
      return this._leafNode(new f(x));
    }
    return(x) {
      const T = new I();
      if ((this._blockNode(T), this.code(x), T.nodes.length !== 1))
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(I);
    }
    try(x, T, V) {
      if (!T && !V)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const B = new S();
      if ((this._blockNode(B), this.code(x), T)) {
        const N = this.name("e");
        (this._currNode = B.catch = new w(N)), T(N);
      }
      return (
        V && ((this._currNode = B.finally = new O()), this.code(V)),
        this._endBlockNode(w, O)
      );
    }
    throw(x) {
      return this._leafNode(new u(x));
    }
    block(x, T) {
      return (
        this._blockStarts.push(this._nodes.length),
        x && this.code(x).endBlock(T),
        this
      );
    }
    endBlock(x) {
      const T = this._blockStarts.pop();
      if (T === void 0) throw new Error("CodeGen: not in self-balancing block");
      const V = this._nodes.length - T;
      if (V < 0 || (x !== void 0 && V !== x))
        throw new Error(
          `CodeGen: wrong number of nodes: ${V} vs ${x} expected`,
        );
      return (this._nodes.length = T), this;
    }
    func(x, T = t.nil, V, B) {
      return this._blockNode(new A(x, T, V)), B && this.code(B).endFunc(), this;
    }
    endFunc() {
      return this._endBlockNode(A);
    }
    optimize(x = 1) {
      for (; x-- > 0; )
        this._root.optimizeNodes(),
          this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(x) {
      return this._currNode.nodes.push(x), this;
    }
    _blockNode(x) {
      this._currNode.nodes.push(x), this._nodes.push(x);
    }
    _endBlockNode(x, T) {
      const V = this._currNode;
      if (V instanceof x || (T && V instanceof T))
        return this._nodes.pop(), this;
      throw new Error(
        `CodeGen: not in block "${T ? `${x.kind}/${T.kind}` : x.kind}"`,
      );
    }
    _elseNode(x) {
      const T = this._currNode;
      if (!(T instanceof v)) throw new Error('CodeGen: "else" without "if"');
      return (this._currNode = T.else = x), this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const x = this._nodes;
      return x[x.length - 1];
    }
    set _currNode(x) {
      const T = this._nodes;
      T[T.length - 1] = x;
    }
  }
  e.CodeGen = Q;
  function j(F, x) {
    for (const T in x) F[T] = (F[T] || 0) + (x[T] || 0);
    return F;
  }
  function H(F, x) {
    return x instanceof t._CodeOrName ? j(F, x.names) : F;
  }
  function q(F, x, T) {
    if (F instanceof t.Name) return V(F);
    if (!B(F)) return F;
    return new t._Code(
      F._items.reduce(
        (N, ce) => (
          ce instanceof t.Name && (ce = V(ce)),
          ce instanceof t._Code ? N.push(...ce._items) : N.push(ce),
          N
        ),
        [],
      ),
    );
    function V(N) {
      const ce = T[N.str];
      return ce === void 0 || x[N.str] !== 1 ? N : (delete x[N.str], ce);
    }
    function B(N) {
      return (
        N instanceof t._Code &&
        N._items.some(
          (ce) =>
            ce instanceof t.Name && x[ce.str] === 1 && T[ce.str] !== void 0,
        )
      );
    }
  }
  function J(F, x) {
    for (const T in x) F[T] = (F[T] || 0) - (x[T] || 0);
  }
  function Z(F) {
    return typeof F == "boolean" || typeof F == "number" || F === null
      ? !F
      : (0, t._)`!${W(F)}`;
  }
  e.not = Z;
  const z = k(e.operators.AND);
  function U(...F) {
    return F.reduce(z);
  }
  e.and = U;
  const G = k(e.operators.OR);
  function L(...F) {
    return F.reduce(G);
  }
  e.or = L;
  function k(F) {
    return (x, T) =>
      x === t.nil ? T : T === t.nil ? x : (0, t._)`${W(x)} ${F} ${W(T)}`;
  }
  function W(F) {
    return F instanceof t.Name ? F : (0, t._)`(${F})`;
  }
})(xt);
var Ft = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.checkStrictMode =
      e.getErrorPath =
      e.Type =
      e.useFunc =
      e.setEvaluated =
      e.evaluatedPropsToName =
      e.mergeEvaluated =
      e.eachItem =
      e.unescapeJsonPointer =
      e.escapeJsonPointer =
      e.escapeFragment =
      e.unescapeFragment =
      e.schemaRefOrVal =
      e.schemaHasRulesButRef =
      e.schemaHasRules =
      e.checkUnknownRules =
      e.alwaysValidSchema =
      e.toHash =
        void 0);
  const t = xt,
    n = Hl;
  function r(A) {
    const I = {};
    for (const S of A) I[S] = !0;
    return I;
  }
  e.toHash = r;
  function i(A, I) {
    return typeof I == "boolean"
      ? I
      : Object.keys(I).length === 0
      ? !0
      : (a(A, I), !s(I, A.self.RULES.all));
  }
  e.alwaysValidSchema = i;
  function a(A, I = A.schema) {
    const { opts: S, self: w } = A;
    if (!S.strictSchema || typeof I == "boolean") return;
    const O = w.RULES.keywords;
    for (const Q in I) O[Q] || R(A, `unknown keyword: "${Q}"`);
  }
  e.checkUnknownRules = a;
  function s(A, I) {
    if (typeof A == "boolean") return !A;
    for (const S in A) if (I[S]) return !0;
    return !1;
  }
  e.schemaHasRules = s;
  function o(A, I) {
    if (typeof A == "boolean") return !A;
    for (const S in A) if (S !== "$ref" && I.all[S]) return !0;
    return !1;
  }
  e.schemaHasRulesButRef = o;
  function c({ topSchemaRef: A, schemaPath: I }, S, w, O) {
    if (!O) {
      if (typeof S == "number" || typeof S == "boolean") return S;
      if (typeof S == "string") return (0, t._)`${S}`;
    }
    return (0, t._)`${A}${I}${(0, t.getProperty)(w)}`;
  }
  e.schemaRefOrVal = c;
  function l(A) {
    return d(decodeURIComponent(A));
  }
  e.unescapeFragment = l;
  function f(A) {
    return encodeURIComponent(u(A));
  }
  e.escapeFragment = f;
  function u(A) {
    return typeof A == "number"
      ? `${A}`
      : A.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  e.escapeJsonPointer = u;
  function d(A) {
    return A.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  e.unescapeJsonPointer = d;
  function p(A, I) {
    if (Array.isArray(A)) for (const S of A) I(S);
    else I(A);
  }
  e.eachItem = p;
  function h({
    mergeNames: A,
    mergeToName: I,
    mergeValues: S,
    resultToName: w,
  }) {
    return (O, Q, j, H) => {
      const q =
        j === void 0
          ? Q
          : j instanceof t.Name
          ? (Q instanceof t.Name ? A(O, Q, j) : I(O, Q, j), j)
          : Q instanceof t.Name
          ? (I(O, j, Q), Q)
          : S(Q, j);
      return H === t.Name && !(q instanceof t.Name) ? w(O, q) : q;
    };
  }
  e.mergeEvaluated = {
    props: h({
      mergeNames: (A, I, S) =>
        A.if((0, t._)`${S} !== true && ${I} !== undefined`, () => {
          A.if(
            (0, t._)`${I} === true`,
            () => A.assign(S, !0),
            () =>
              A.assign(S, (0, t._)`${S} || {}`).code(
                (0, t._)`Object.assign(${S}, ${I})`,
              ),
          );
        }),
      mergeToName: (A, I, S) =>
        A.if((0, t._)`${S} !== true`, () => {
          I === !0
            ? A.assign(S, !0)
            : (A.assign(S, (0, t._)`${S} || {}`), g(A, S, I));
        }),
      mergeValues: (A, I) => (A === !0 ? !0 : { ...A, ...I }),
      resultToName: m,
    }),
    items: h({
      mergeNames: (A, I, S) =>
        A.if((0, t._)`${S} !== true && ${I} !== undefined`, () =>
          A.assign(
            S,
            (0, t._)`${I} === true ? true : ${S} > ${I} ? ${S} : ${I}`,
          ),
        ),
      mergeToName: (A, I, S) =>
        A.if((0, t._)`${S} !== true`, () =>
          A.assign(S, I === !0 ? !0 : (0, t._)`${S} > ${I} ? ${S} : ${I}`),
        ),
      mergeValues: (A, I) => (A === !0 ? !0 : Math.max(A, I)),
      resultToName: (A, I) => A.var("items", I),
    }),
  };
  function m(A, I) {
    if (I === !0) return A.var("props", !0);
    const S = A.var("props", (0, t._)`{}`);
    return I !== void 0 && g(A, S, I), S;
  }
  e.evaluatedPropsToName = m;
  function g(A, I, S) {
    Object.keys(S).forEach((w) =>
      A.assign((0, t._)`${I}${(0, t.getProperty)(w)}`, !0),
    );
  }
  e.setEvaluated = g;
  const v = {};
  function y(A, I) {
    return A.scopeValue("func", {
      ref: I,
      code: v[I.code] || (v[I.code] = new n._Code(I.code)),
    });
  }
  e.useFunc = y;
  var _;
  (function (A) {
    (A[(A.Num = 0)] = "Num"), (A[(A.Str = 1)] = "Str");
  })((_ = e.Type || (e.Type = {})));
  function E(A, I, S) {
    if (A instanceof t.Name) {
      const w = I === _.Num;
      return S
        ? w
          ? (0, t._)`"[" + ${A} + "]"`
          : (0, t._)`"['" + ${A} + "']"`
        : w
        ? (0, t._)`"/" + ${A}`
        : (0, t._)`"/" + ${A}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return S ? (0, t.getProperty)(A).toString() : "/" + u(A);
  }
  e.getErrorPath = E;
  function R(A, I, S = A.opts.strictSchema) {
    if (S) {
      if (((I = `strict mode: ${I}`), S === !0)) throw new Error(I);
      A.self.logger.warn(I);
    }
  }
  e.checkStrictMode = R;
})(Ft);
var zi = {};
Object.defineProperty(zi, "__esModule", { value: !0 });
const cr = xt,
  Dz = {
    data: new cr.Name("data"),
    valCxt: new cr.Name("valCxt"),
    instancePath: new cr.Name("instancePath"),
    parentData: new cr.Name("parentData"),
    parentDataProperty: new cr.Name("parentDataProperty"),
    rootData: new cr.Name("rootData"),
    dynamicAnchors: new cr.Name("dynamicAnchors"),
    vErrors: new cr.Name("vErrors"),
    errors: new cr.Name("errors"),
    this: new cr.Name("this"),
    self: new cr.Name("self"),
    scope: new cr.Name("scope"),
    json: new cr.Name("json"),
    jsonPos: new cr.Name("jsonPos"),
    jsonLen: new cr.Name("jsonLen"),
    jsonPart: new cr.Name("jsonPart"),
  };
zi.default = Dz;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.extendErrors =
      e.resetErrorsCount =
      e.reportExtraError =
      e.reportError =
      e.keyword$DataError =
      e.keywordError =
        void 0);
  const t = xt,
    n = Ft,
    r = zi;
  (e.keywordError = {
    message: ({ keyword: g }) =>
      (0, t.str)`must pass "${g}" keyword validation`,
  }),
    (e.keyword$DataError = {
      message: ({ keyword: g, schemaType: v }) =>
        v
          ? (0, t.str)`"${g}" keyword must be ${v} ($data)`
          : (0, t.str)`"${g}" keyword is invalid ($data)`,
    });
  function i(g, v = e.keywordError, y, _) {
    const { it: E } = g,
      { gen: R, compositeRule: A, allErrors: I } = E,
      S = u(g, v, y);
    _ ?? (A || I) ? c(R, S) : l(E, (0, t._)`[${S}]`);
  }
  e.reportError = i;
  function a(g, v = e.keywordError, y) {
    const { it: _ } = g,
      { gen: E, compositeRule: R, allErrors: A } = _,
      I = u(g, v, y);
    c(E, I), R || A || l(_, r.default.vErrors);
  }
  e.reportExtraError = a;
  function s(g, v) {
    g.assign(r.default.errors, v),
      g.if((0, t._)`${r.default.vErrors} !== null`, () =>
        g.if(
          v,
          () => g.assign((0, t._)`${r.default.vErrors}.length`, v),
          () => g.assign(r.default.vErrors, null),
        ),
      );
  }
  e.resetErrorsCount = s;
  function o({
    gen: g,
    keyword: v,
    schemaValue: y,
    data: _,
    errsCount: E,
    it: R,
  }) {
    if (E === void 0) throw new Error("ajv implementation error");
    const A = g.name("err");
    g.forRange("i", E, r.default.errors, (I) => {
      g.const(A, (0, t._)`${r.default.vErrors}[${I}]`),
        g.if((0, t._)`${A}.instancePath === undefined`, () =>
          g.assign(
            (0, t._)`${A}.instancePath`,
            (0, t.strConcat)(r.default.instancePath, R.errorPath),
          ),
        ),
        g.assign(
          (0, t._)`${A}.schemaPath`,
          (0, t.str)`${R.errSchemaPath}/${v}`,
        ),
        R.opts.verbose &&
          (g.assign((0, t._)`${A}.schema`, y),
          g.assign((0, t._)`${A}.data`, _));
    });
  }
  e.extendErrors = o;
  function c(g, v) {
    const y = g.const("err", v);
    g.if(
      (0, t._)`${r.default.vErrors} === null`,
      () => g.assign(r.default.vErrors, (0, t._)`[${y}]`),
      (0, t._)`${r.default.vErrors}.push(${y})`,
    ),
      g.code((0, t._)`${r.default.errors}++`);
  }
  function l(g, v) {
    const { gen: y, validateName: _, schemaEnv: E } = g;
    E.$async
      ? y.throw((0, t._)`new ${g.ValidationError}(${v})`)
      : (y.assign((0, t._)`${_}.errors`, v), y.return(!1));
  }
  const f = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema"),
  };
  function u(g, v, y) {
    const { createErrors: _ } = g.it;
    return _ === !1 ? (0, t._)`{}` : d(g, v, y);
  }
  function d(g, v, y = {}) {
    const { gen: _, it: E } = g,
      R = [p(E, y), h(g, y)];
    return m(g, v, R), _.object(...R);
  }
  function p({ errorPath: g }, { instancePath: v }) {
    const y = v ? (0, t.str)`${g}${(0, n.getErrorPath)(v, n.Type.Str)}` : g;
    return [
      r.default.instancePath,
      (0, t.strConcat)(r.default.instancePath, y),
    ];
  }
  function h(
    { keyword: g, it: { errSchemaPath: v } },
    { schemaPath: y, parentSchema: _ },
  ) {
    let E = _ ? v : (0, t.str)`${v}/${g}`;
    return (
      y && (E = (0, t.str)`${E}${(0, n.getErrorPath)(y, n.Type.Str)}`),
      [f.schemaPath, E]
    );
  }
  function m(g, { params: v, message: y }, _) {
    const { keyword: E, data: R, schemaValue: A, it: I } = g,
      { opts: S, propertyName: w, topSchemaRef: O, schemaPath: Q } = I;
    _.push(
      [f.keyword, E],
      [f.params, typeof v == "function" ? v(g) : v || (0, t._)`{}`],
    ),
      S.messages && _.push([f.message, typeof y == "function" ? y(g) : y]),
      S.verbose &&
        _.push(
          [f.schema, A],
          [f.parentSchema, (0, t._)`${O}${Q}`],
          [r.default.data, R],
        ),
      w && _.push([f.propertyName, w]);
  }
})(pu);
Object.defineProperty(oc, "__esModule", { value: !0 });
oc.boolOrEmptySchema = oc.topBoolOrEmptySchema = void 0;
const Lz = pu,
  Bz = xt,
  Uz = zi,
  Fz = { message: "boolean schema is false" };
function jz(e) {
  const { gen: t, schema: n, validateName: r } = e;
  n === !1
    ? nR(e, !1)
    : typeof n == "object" && n.$async === !0
    ? t.return(Uz.default.data)
    : (t.assign((0, Bz._)`${r}.errors`, null), t.return(!0));
}
oc.topBoolOrEmptySchema = jz;
function Mz(e, t) {
  const { gen: n, schema: r } = e;
  r === !1 ? (n.var(t, !1), nR(e)) : n.var(t, !0);
}
oc.boolOrEmptySchema = Mz;
function nR(e, t) {
  const { gen: n, data: r } = e,
    i = {
      gen: n,
      keyword: "false schema",
      data: r,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: e,
    };
  (0, Lz.reportError)(i, Fz, void 0, t);
}
var hu = {},
  Ms = {};
Object.defineProperty(Ms, "__esModule", { value: !0 });
Ms.getRules = Ms.isJSONType = void 0;
const Hz = [
    "string",
    "number",
    "integer",
    "boolean",
    "null",
    "object",
    "array",
  ],
  qz = new Set(Hz);
function Gz(e) {
  return typeof e == "string" && qz.has(e);
}
Ms.isJSONType = Gz;
function Qz() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] },
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {},
  };
}
Ms.getRules = Qz;
var fa = {};
Object.defineProperty(fa, "__esModule", { value: !0 });
fa.shouldUseRule = fa.shouldUseGroup = fa.schemaHasRulesForType = void 0;
function Wz({ schema: e, self: t }, n) {
  const r = t.RULES.types[n];
  return r && r !== !0 && rR(e, r);
}
fa.schemaHasRulesForType = Wz;
function rR(e, t) {
  return t.rules.some((n) => iR(e, n));
}
fa.shouldUseGroup = rR;
function iR(e, t) {
  var n;
  return (
    e[t.keyword] !== void 0 ||
    ((n = t.definition.implements) === null || n === void 0
      ? void 0
      : n.some((r) => e[r] !== void 0))
  );
}
fa.shouldUseRule = iR;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.reportTypeError =
      e.checkDataTypes =
      e.checkDataType =
      e.coerceAndCheckDataType =
      e.getJSONTypes =
      e.getSchemaTypes =
      e.DataType =
        void 0);
  const t = Ms,
    n = fa,
    r = pu,
    i = xt,
    a = Ft;
  var s;
  (function (_) {
    (_[(_.Correct = 0)] = "Correct"), (_[(_.Wrong = 1)] = "Wrong");
  })((s = e.DataType || (e.DataType = {})));
  function o(_) {
    const E = c(_.type);
    if (E.includes("null")) {
      if (_.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!E.length && _.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      _.nullable === !0 && E.push("null");
    }
    return E;
  }
  e.getSchemaTypes = o;
  function c(_) {
    const E = Array.isArray(_) ? _ : _ ? [_] : [];
    if (E.every(t.isJSONType)) return E;
    throw new Error("type must be JSONType or JSONType[]: " + E.join(","));
  }
  e.getJSONTypes = c;
  function l(_, E) {
    const { gen: R, data: A, opts: I } = _,
      S = u(E, I.coerceTypes),
      w =
        E.length > 0 &&
        !(
          S.length === 0 &&
          E.length === 1 &&
          (0, n.schemaHasRulesForType)(_, E[0])
        );
    if (w) {
      const O = m(E, A, I.strictNumbers, s.Wrong);
      R.if(O, () => {
        S.length ? d(_, E, S) : v(_);
      });
    }
    return w;
  }
  e.coerceAndCheckDataType = l;
  const f = new Set(["string", "number", "integer", "boolean", "null"]);
  function u(_, E) {
    return E
      ? _.filter((R) => f.has(R) || (E === "array" && R === "array"))
      : [];
  }
  function d(_, E, R) {
    const { gen: A, data: I, opts: S } = _,
      w = A.let("dataType", (0, i._)`typeof ${I}`),
      O = A.let("coerced", (0, i._)`undefined`);
    S.coerceTypes === "array" &&
      A.if(
        (0, i._)`${w} == 'object' && Array.isArray(${I}) && ${I}.length == 1`,
        () =>
          A.assign(I, (0, i._)`${I}[0]`)
            .assign(w, (0, i._)`typeof ${I}`)
            .if(m(E, I, S.strictNumbers), () => A.assign(O, I)),
      ),
      A.if((0, i._)`${O} !== undefined`);
    for (const j of R)
      (f.has(j) || (j === "array" && S.coerceTypes === "array")) && Q(j);
    A.else(),
      v(_),
      A.endIf(),
      A.if((0, i._)`${O} !== undefined`, () => {
        A.assign(I, O), p(_, O);
      });
    function Q(j) {
      switch (j) {
        case "string":
          A.elseIf((0, i._)`${w} == "number" || ${w} == "boolean"`)
            .assign(O, (0, i._)`"" + ${I}`)
            .elseIf((0, i._)`${I} === null`)
            .assign(O, (0, i._)`""`);
          return;
        case "number":
          A.elseIf(
            (0, i._)`${w} == "boolean" || ${I} === null
              || (${w} == "string" && ${I} && ${I} == +${I})`,
          ).assign(O, (0, i._)`+${I}`);
          return;
        case "integer":
          A.elseIf(
            (0, i._)`${w} === "boolean" || ${I} === null
              || (${w} === "string" && ${I} && ${I} == +${I} && !(${I} % 1))`,
          ).assign(O, (0, i._)`+${I}`);
          return;
        case "boolean":
          A.elseIf((0, i._)`${I} === "false" || ${I} === 0 || ${I} === null`)
            .assign(O, !1)
            .elseIf((0, i._)`${I} === "true" || ${I} === 1`)
            .assign(O, !0);
          return;
        case "null":
          A.elseIf((0, i._)`${I} === "" || ${I} === 0 || ${I} === false`),
            A.assign(O, null);
          return;
        case "array":
          A.elseIf(
            (0, i._)`${w} === "string" || ${w} === "number"
              || ${w} === "boolean" || ${I} === null`,
          ).assign(O, (0, i._)`[${I}]`);
      }
    }
  }
  function p({ gen: _, parentData: E, parentDataProperty: R }, A) {
    _.if((0, i._)`${E} !== undefined`, () => _.assign((0, i._)`${E}[${R}]`, A));
  }
  function h(_, E, R, A = s.Correct) {
    const I = A === s.Correct ? i.operators.EQ : i.operators.NEQ;
    let S;
    switch (_) {
      case "null":
        return (0, i._)`${E} ${I} null`;
      case "array":
        S = (0, i._)`Array.isArray(${E})`;
        break;
      case "object":
        S = (0, i._)`${E} && typeof ${E} == "object" && !Array.isArray(${E})`;
        break;
      case "integer":
        S = w((0, i._)`!(${E} % 1) && !isNaN(${E})`);
        break;
      case "number":
        S = w();
        break;
      default:
        return (0, i._)`typeof ${E} ${I} ${_}`;
    }
    return A === s.Correct ? S : (0, i.not)(S);
    function w(O = i.nil) {
      return (0, i.and)(
        (0, i._)`typeof ${E} == "number"`,
        O,
        R ? (0, i._)`isFinite(${E})` : i.nil,
      );
    }
  }
  e.checkDataType = h;
  function m(_, E, R, A) {
    if (_.length === 1) return h(_[0], E, R, A);
    let I;
    const S = (0, a.toHash)(_);
    if (S.array && S.object) {
      const w = (0, i._)`typeof ${E} != "object"`;
      (I = S.null ? w : (0, i._)`!${E} || ${w}`),
        delete S.null,
        delete S.array,
        delete S.object;
    } else I = i.nil;
    S.number && delete S.integer;
    for (const w in S) I = (0, i.and)(I, h(w, E, R, A));
    return I;
  }
  e.checkDataTypes = m;
  const g = {
    message: ({ schema: _ }) => `must be ${_}`,
    params: ({ schema: _, schemaValue: E }) =>
      typeof _ == "string" ? (0, i._)`{type: ${_}}` : (0, i._)`{type: ${E}}`,
  };
  function v(_) {
    const E = y(_);
    (0, r.reportError)(E, g);
  }
  e.reportTypeError = v;
  function y(_) {
    const { gen: E, data: R, schema: A } = _,
      I = (0, a.schemaRefOrVal)(_, A, "type");
    return {
      gen: E,
      keyword: "type",
      data: R,
      schema: A.type,
      schemaCode: I,
      schemaValue: I,
      parentSchema: A,
      params: {},
      it: _,
    };
  }
})(hu);
var Tp = {};
Object.defineProperty(Tp, "__esModule", { value: !0 });
Tp.assignDefaults = void 0;
const po = xt,
  zz = Ft;
function Kz(e, t) {
  const { properties: n, items: r } = e.schema;
  if (t === "object" && n) for (const i in n) Ux(e, i, n[i].default);
  else
    t === "array" &&
      Array.isArray(r) &&
      r.forEach((i, a) => Ux(e, a, i.default));
}
Tp.assignDefaults = Kz;
function Ux(e, t, n) {
  const { gen: r, compositeRule: i, data: a, opts: s } = e;
  if (n === void 0) return;
  const o = (0, po._)`${a}${(0, po.getProperty)(t)}`;
  if (i) {
    (0, zz.checkStrictMode)(e, `default is ignored for: ${o}`);
    return;
  }
  let c = (0, po._)`${o} === undefined`;
  s.useDefaults === "empty" &&
    (c = (0, po._)`${c} || ${o} === null || ${o} === ""`),
    r.if(c, (0, po._)`${o} = ${(0, po.stringify)(n)}`);
}
var ji = {},
  It = {};
Object.defineProperty(It, "__esModule", { value: !0 });
It.validateUnion =
  It.validateArray =
  It.usePattern =
  It.callValidateCode =
  It.schemaProperties =
  It.allSchemaProperties =
  It.noPropertyInData =
  It.propertyInData =
  It.isOwnProperty =
  It.hasPropFunc =
  It.reportMissingProp =
  It.checkMissingProp =
  It.checkReportMissingProp =
    void 0;
const pn = xt,
  Zy = Ft,
  wa = zi,
  Vz = Ft;
function Yz(e, t) {
  const { gen: n, data: r, it: i } = e;
  n.if(tb(n, r, t, i.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, pn._)`${t}` }, !0), e.error();
  });
}
It.checkReportMissingProp = Yz;
function Xz({ gen: e, data: t, it: { opts: n } }, r, i) {
  return (0, pn.or)(
    ...r.map((a) =>
      (0, pn.and)(tb(e, t, a, n.ownProperties), (0, pn._)`${i} = ${a}`),
    ),
  );
}
It.checkMissingProp = Xz;
function Jz(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
It.reportMissingProp = Jz;
function aR(e) {
  return e.scopeValue("func", {
    ref: Object.prototype.hasOwnProperty,
    code: (0, pn._)`Object.prototype.hasOwnProperty`,
  });
}
It.hasPropFunc = aR;
function eb(e, t, n) {
  return (0, pn._)`${aR(e)}.call(${t}, ${n})`;
}
It.isOwnProperty = eb;
function Zz(e, t, n, r) {
  const i = (0, pn._)`${t}${(0, pn.getProperty)(n)} !== undefined`;
  return r ? (0, pn._)`${i} && ${eb(e, t, n)}` : i;
}
It.propertyInData = Zz;
function tb(e, t, n, r) {
  const i = (0, pn._)`${t}${(0, pn.getProperty)(n)} === undefined`;
  return r ? (0, pn.or)(i, (0, pn.not)(eb(e, t, n))) : i;
}
It.noPropertyInData = tb;
function sR(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
It.allSchemaProperties = sR;
function eK(e, t) {
  return sR(t).filter((n) => !(0, Zy.alwaysValidSchema)(e, t[n]));
}
It.schemaProperties = eK;
function tK(
  {
    schemaCode: e,
    data: t,
    it: { gen: n, topSchemaRef: r, schemaPath: i, errorPath: a },
    it: s,
  },
  o,
  c,
  l,
) {
  const f = l ? (0, pn._)`${e}, ${t}, ${r}${i}` : t,
    u = [
      [wa.default.instancePath, (0, pn.strConcat)(wa.default.instancePath, a)],
      [wa.default.parentData, s.parentData],
      [wa.default.parentDataProperty, s.parentDataProperty],
      [wa.default.rootData, wa.default.rootData],
    ];
  s.opts.dynamicRef &&
    u.push([wa.default.dynamicAnchors, wa.default.dynamicAnchors]);
  const d = (0, pn._)`${f}, ${n.object(...u)}`;
  return c !== pn.nil
    ? (0, pn._)`${o}.call(${c}, ${d})`
    : (0, pn._)`${o}(${d})`;
}
It.callValidateCode = tK;
const nK = (0, pn._)`new RegExp`;
function rK({ gen: e, it: { opts: t } }, n) {
  const r = t.unicodeRegExp ? "u" : "",
    { regExp: i } = t.code,
    a = i(n, r);
  return e.scopeValue("pattern", {
    key: a.toString(),
    ref: a,
    code: (0, pn._)`${
      i.code === "new RegExp" ? nK : (0, Vz.useFunc)(e, i)
    }(${n}, ${r})`,
  });
}
It.usePattern = rK;
function iK(e) {
  const { gen: t, data: n, keyword: r, it: i } = e,
    a = t.name("valid");
  if (i.allErrors) {
    const o = t.let("valid", !0);
    return s(() => t.assign(o, !1)), o;
  }
  return t.var(a, !0), s(() => t.break()), a;
  function s(o) {
    const c = t.const("len", (0, pn._)`${n}.length`);
    t.forRange("i", 0, c, (l) => {
      e.subschema({ keyword: r, dataProp: l, dataPropType: Zy.Type.Num }, a),
        t.if((0, pn.not)(a), o);
    });
  }
}
It.validateArray = iK;
function aK(e) {
  const { gen: t, schema: n, keyword: r, it: i } = e;
  if (!Array.isArray(n)) throw new Error("ajv implementation error");
  if (n.some((c) => (0, Zy.alwaysValidSchema)(i, c)) && !i.opts.unevaluated)
    return;
  const s = t.let("valid", !1),
    o = t.name("_valid");
  t.block(() =>
    n.forEach((c, l) => {
      const f = e.subschema(
        { keyword: r, schemaProp: l, compositeRule: !0 },
        o,
      );
      t.assign(s, (0, pn._)`${s} || ${o}`),
        e.mergeValidEvaluated(f, o) || t.if((0, pn.not)(s));
    }),
  ),
    e.result(
      s,
      () => e.reset(),
      () => e.error(!0),
    );
}
It.validateUnion = aK;
Object.defineProperty(ji, "__esModule", { value: !0 });
ji.validateKeywordUsage =
  ji.validSchemaType =
  ji.funcKeywordCode =
  ji.macroKeywordCode =
    void 0;
const _r = xt,
  Es = zi,
  sK = It,
  oK = pu;
function cK(e, t) {
  const { gen: n, keyword: r, schema: i, parentSchema: a, it: s } = e,
    o = t.macro.call(s.self, i, a, s),
    c = oR(n, r, o);
  s.opts.validateSchema !== !1 && s.self.validateSchema(o, !0);
  const l = n.name("valid");
  e.subschema(
    {
      schema: o,
      schemaPath: _r.nil,
      errSchemaPath: `${s.errSchemaPath}/${r}`,
      topSchemaRef: c,
      compositeRule: !0,
    },
    l,
  ),
    e.pass(l, () => e.error(!0));
}
ji.macroKeywordCode = cK;
function lK(e, t) {
  var n;
  const { gen: r, keyword: i, schema: a, parentSchema: s, $data: o, it: c } = e;
  fK(c, t);
  const l = !o && t.compile ? t.compile.call(c.self, a, s, c) : t.validate,
    f = oR(r, i, l),
    u = r.let("valid");
  e.block$data(u, d), e.ok((n = t.valid) !== null && n !== void 0 ? n : u);
  function d() {
    if (t.errors === !1) m(), t.modifying && Fx(e), g(() => e.error());
    else {
      const v = t.async ? p() : h();
      t.modifying && Fx(e), g(() => uK(e, v));
    }
  }
  function p() {
    const v = r.let("ruleErrs", null);
    return (
      r.try(
        () => m((0, _r._)`await `),
        (y) =>
          r.assign(u, !1).if(
            (0, _r._)`${y} instanceof ${c.ValidationError}`,
            () => r.assign(v, (0, _r._)`${y}.errors`),
            () => r.throw(y),
          ),
      ),
      v
    );
  }
  function h() {
    const v = (0, _r._)`${f}.errors`;
    return r.assign(v, null), m(_r.nil), v;
  }
  function m(v = t.async ? (0, _r._)`await ` : _r.nil) {
    const y = c.opts.passContext ? Es.default.this : Es.default.self,
      _ = !(("compile" in t && !o) || t.schema === !1);
    r.assign(
      u,
      (0, _r._)`${v}${(0, sK.callValidateCode)(e, f, y, _)}`,
      t.modifying,
    );
  }
  function g(v) {
    var y;
    r.if((0, _r.not)((y = t.valid) !== null && y !== void 0 ? y : u), v);
  }
}
ji.funcKeywordCode = lK;
function Fx(e) {
  const { gen: t, data: n, it: r } = e;
  t.if(r.parentData, () =>
    t.assign(n, (0, _r._)`${r.parentData}[${r.parentDataProperty}]`),
  );
}
function uK(e, t) {
  const { gen: n } = e;
  n.if(
    (0, _r._)`Array.isArray(${t})`,
    () => {
      n
        .assign(
          Es.default.vErrors,
          (0,
          _r._)`${Es.default.vErrors} === null ? ${t} : ${Es.default.vErrors}.concat(${t})`,
        )
        .assign(Es.default.errors, (0, _r._)`${Es.default.vErrors}.length`),
        (0, oK.extendErrors)(e);
    },
    () => e.error(),
  );
}
function fK({ schemaEnv: e }, t) {
  if (t.async && !e.$async) throw new Error("async keyword in sync schema");
}
function oR(e, t, n) {
  if (n === void 0) throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue(
    "keyword",
    typeof n == "function"
      ? { ref: n }
      : { ref: n, code: (0, _r.stringify)(n) },
  );
}
function dK(e, t, n = !1) {
  return (
    !t.length ||
    t.some((r) =>
      r === "array"
        ? Array.isArray(e)
        : r === "object"
        ? e && typeof e == "object" && !Array.isArray(e)
        : typeof e == r || (n && typeof e > "u"),
    )
  );
}
ji.validSchemaType = dK;
function pK({ schema: e, opts: t, self: n, errSchemaPath: r }, i, a) {
  if (Array.isArray(i.keyword) ? !i.keyword.includes(a) : i.keyword !== a)
    throw new Error("ajv implementation error");
  const s = i.dependencies;
  if (s != null && s.some((o) => !Object.prototype.hasOwnProperty.call(e, o)))
    throw new Error(
      `parent schema must have dependencies of ${a}: ${s.join(",")}`,
    );
  if (i.validateSchema && !i.validateSchema(e[a])) {
    const c =
      `keyword "${a}" value is invalid at path "${r}": ` +
      n.errorsText(i.validateSchema.errors);
    if (t.validateSchema === "log") n.logger.error(c);
    else throw new Error(c);
  }
}
ji.validateKeywordUsage = pK;
var Qa = {};
Object.defineProperty(Qa, "__esModule", { value: !0 });
Qa.extendSubschemaMode = Qa.extendSubschemaData = Qa.getSubschema = void 0;
const Li = xt,
  cR = Ft;
function hK(
  e,
  {
    keyword: t,
    schemaProp: n,
    schema: r,
    schemaPath: i,
    errSchemaPath: a,
    topSchemaRef: s,
  },
) {
  if (t !== void 0 && r !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const o = e.schema[t];
    return n === void 0
      ? {
          schema: o,
          schemaPath: (0, Li._)`${e.schemaPath}${(0, Li.getProperty)(t)}`,
          errSchemaPath: `${e.errSchemaPath}/${t}`,
        }
      : {
          schema: o[n],
          schemaPath: (0, Li._)`${e.schemaPath}${(0, Li.getProperty)(t)}${(0,
          Li.getProperty)(n)}`,
          errSchemaPath: `${e.errSchemaPath}/${t}/${(0, cR.escapeFragment)(n)}`,
        };
  }
  if (r !== void 0) {
    if (i === void 0 || a === void 0 || s === void 0)
      throw new Error(
        '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"',
      );
    return { schema: r, schemaPath: i, topSchemaRef: s, errSchemaPath: a };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
Qa.getSubschema = hK;
function mK(
  e,
  t,
  { dataProp: n, dataPropType: r, data: i, dataTypes: a, propertyName: s },
) {
  if (i !== void 0 && n !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: o } = t;
  if (n !== void 0) {
    const { errorPath: l, dataPathArr: f, opts: u } = t,
      d = o.let("data", (0, Li._)`${t.data}${(0, Li.getProperty)(n)}`, !0);
    c(d),
      (e.errorPath = (0, Li.str)`${l}${(0, cR.getErrorPath)(
        n,
        r,
        u.jsPropertySyntax,
      )}`),
      (e.parentDataProperty = (0, Li._)`${n}`),
      (e.dataPathArr = [...f, e.parentDataProperty]);
  }
  if (i !== void 0) {
    const l = i instanceof Li.Name ? i : o.let("data", i, !0);
    c(l), s !== void 0 && (e.propertyName = s);
  }
  a && (e.dataTypes = a);
  function c(l) {
    (e.data = l),
      (e.dataLevel = t.dataLevel + 1),
      (e.dataTypes = []),
      (t.definedProperties = new Set()),
      (e.parentData = t.data),
      (e.dataNames = [...t.dataNames, l]);
  }
}
Qa.extendSubschemaData = mK;
function gK(
  e,
  {
    jtdDiscriminator: t,
    jtdMetadata: n,
    compositeRule: r,
    createErrors: i,
    allErrors: a,
  },
) {
  r !== void 0 && (e.compositeRule = r),
    i !== void 0 && (e.createErrors = i),
    a !== void 0 && (e.allErrors = a),
    (e.jtdDiscriminator = t),
    (e.jtdMetadata = n);
}
Qa.extendSubschemaMode = gK;
var rr = {},
  lR = { exports: {} },
  ja = (lR.exports = function (e, t, n) {
    typeof t == "function" && ((n = t), (t = {})), (n = t.cb || n);
    var r = typeof n == "function" ? n : n.pre || function () {},
      i = n.post || function () {};
    Qf(t, r, i, e, "", e);
  });
ja.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0,
};
ja.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 };
ja.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0,
};
ja.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0,
};
function Qf(e, t, n, r, i, a, s, o, c, l) {
  if (r && typeof r == "object" && !Array.isArray(r)) {
    t(r, i, a, s, o, c, l);
    for (var f in r) {
      var u = r[f];
      if (Array.isArray(u)) {
        if (f in ja.arrayKeywords)
          for (var d = 0; d < u.length; d++)
            Qf(e, t, n, u[d], i + "/" + f + "/" + d, a, i, f, r, d);
      } else if (f in ja.propsKeywords) {
        if (u && typeof u == "object")
          for (var p in u)
            Qf(e, t, n, u[p], i + "/" + f + "/" + vK(p), a, i, f, r, p);
      } else
        (f in ja.keywords || (e.allKeys && !(f in ja.skipKeywords))) &&
          Qf(e, t, n, u, i + "/" + f, a, i, f, r);
    }
    n(r, i, a, s, o, c, l);
  }
}
function vK(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var yK = lR.exports;
Object.defineProperty(rr, "__esModule", { value: !0 });
rr.getSchemaRefs =
  rr.resolveUrl =
  rr.normalizeId =
  rr._getFullPath =
  rr.getFullPath =
  rr.inlineRef =
    void 0;
const bK = Ft,
  _K = $p,
  EK = yK,
  wK = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
  ]);
function xK(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !C0(e) : t ? uR(e) <= t : !1;
}
rr.inlineRef = xK;
const AK = new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor",
]);
function C0(e) {
  for (const t in e) {
    if (AK.has(t)) return !0;
    const n = e[t];
    if ((Array.isArray(n) && n.some(C0)) || (typeof n == "object" && C0(n)))
      return !0;
  }
  return !1;
}
function uR(e) {
  let t = 0;
  for (const n in e) {
    if (n === "$ref") return 1 / 0;
    if (
      (t++,
      !wK.has(n) &&
        (typeof e[n] == "object" && (0, bK.eachItem)(e[n], (r) => (t += uR(r))),
        t === 1 / 0))
    )
      return 1 / 0;
  }
  return t;
}
function fR(e, t = "", n) {
  n !== !1 && (t = Uo(t));
  const r = e.parse(t);
  return dR(e, r);
}
rr.getFullPath = fR;
function dR(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
rr._getFullPath = dR;
const SK = /#\/?$/;
function Uo(e) {
  return e ? e.replace(SK, "") : "";
}
rr.normalizeId = Uo;
function IK(e, t, n) {
  return (n = Uo(n)), e.resolve(t, n);
}
rr.resolveUrl = IK;
const $K = /^[a-z_][-a-z0-9._]*$/i;
function CK(e, t) {
  if (typeof e == "boolean") return {};
  const { schemaId: n, uriResolver: r } = this.opts,
    i = Uo(e[n] || t),
    a = { "": i },
    s = fR(r, i, !1),
    o = {},
    c = new Set();
  return (
    EK(e, { allKeys: !0 }, (u, d, p, h) => {
      if (h === void 0) return;
      const m = s + d;
      let g = a[h];
      typeof u[n] == "string" && (g = v.call(this, u[n])),
        y.call(this, u.$anchor),
        y.call(this, u.$dynamicAnchor),
        (a[d] = g);
      function v(_) {
        const E = this.opts.uriResolver.resolve;
        if (((_ = Uo(g ? E(g, _) : _)), c.has(_))) throw f(_);
        c.add(_);
        let R = this.refs[_];
        return (
          typeof R == "string" && (R = this.refs[R]),
          typeof R == "object"
            ? l(u, R.schema, _)
            : _ !== Uo(m) &&
              (_[0] === "#" ? (l(u, o[_], _), (o[_] = u)) : (this.refs[_] = m)),
          _
        );
      }
      function y(_) {
        if (typeof _ == "string") {
          if (!$K.test(_)) throw new Error(`invalid anchor "${_}"`);
          v.call(this, `#${_}`);
        }
      }
    }),
    o
  );
  function l(u, d, p) {
    if (d !== void 0 && !_K(u, d)) throw f(p);
  }
  function f(u) {
    return new Error(`reference "${u}" resolves to more than one schema`);
  }
}
rr.getSchemaRefs = CK;
Object.defineProperty(bi, "__esModule", { value: !0 });
bi.getData = bi.KeywordCxt = bi.validateFunctionCode = void 0;
const pR = oc,
  jx = hu,
  nb = fa,
  Ad = hu,
  RK = Tp,
  wl = ji,
  Nm = Qa,
  Xe = xt,
  vt = zi,
  kK = rr,
  da = Ft,
  zc = pu;
function TK(e) {
  if (gR(e) && (vR(e), mR(e))) {
    PK(e);
    return;
  }
  hR(e, () => (0, pR.topBoolOrEmptySchema)(e));
}
bi.validateFunctionCode = TK;
function hR({ gen: e, validateName: t, schema: n, schemaEnv: r, opts: i }, a) {
  i.code.es5
    ? e.func(
        t,
        (0, Xe._)`${vt.default.data}, ${vt.default.valCxt}`,
        r.$async,
        () => {
          e.code((0, Xe._)`"use strict"; ${Mx(n, i)}`), OK(e, i), e.code(a);
        },
      )
    : e.func(t, (0, Xe._)`${vt.default.data}, ${NK(i)}`, r.$async, () =>
        e.code(Mx(n, i)).code(a),
      );
}
function NK(e) {
  return (0, Xe._)`{${vt.default.instancePath}="", ${vt.default.parentData}, ${
    vt.default.parentDataProperty
  }, ${vt.default.rootData}=${vt.default.data}${
    e.dynamicRef ? (0, Xe._)`, ${vt.default.dynamicAnchors}={}` : Xe.nil
  }}={}`;
}
function OK(e, t) {
  e.if(
    vt.default.valCxt,
    () => {
      e.var(
        vt.default.instancePath,
        (0, Xe._)`${vt.default.valCxt}.${vt.default.instancePath}`,
      ),
        e.var(
          vt.default.parentData,
          (0, Xe._)`${vt.default.valCxt}.${vt.default.parentData}`,
        ),
        e.var(
          vt.default.parentDataProperty,
          (0, Xe._)`${vt.default.valCxt}.${vt.default.parentDataProperty}`,
        ),
        e.var(
          vt.default.rootData,
          (0, Xe._)`${vt.default.valCxt}.${vt.default.rootData}`,
        ),
        t.dynamicRef &&
          e.var(
            vt.default.dynamicAnchors,
            (0, Xe._)`${vt.default.valCxt}.${vt.default.dynamicAnchors}`,
          );
    },
    () => {
      e.var(vt.default.instancePath, (0, Xe._)`""`),
        e.var(vt.default.parentData, (0, Xe._)`undefined`),
        e.var(vt.default.parentDataProperty, (0, Xe._)`undefined`),
        e.var(vt.default.rootData, vt.default.data),
        t.dynamicRef && e.var(vt.default.dynamicAnchors, (0, Xe._)`{}`);
    },
  );
}
function PK(e) {
  const { schema: t, opts: n, gen: r } = e;
  hR(e, () => {
    n.$comment && t.$comment && bR(e),
      FK(e),
      r.let(vt.default.vErrors, null),
      r.let(vt.default.errors, 0),
      n.unevaluated && DK(e),
      yR(e),
      HK(e);
  });
}
function DK(e) {
  const { gen: t, validateName: n } = e;
  (e.evaluated = t.const("evaluated", (0, Xe._)`${n}.evaluated`)),
    t.if((0, Xe._)`${e.evaluated}.dynamicProps`, () =>
      t.assign((0, Xe._)`${e.evaluated}.props`, (0, Xe._)`undefined`),
    ),
    t.if((0, Xe._)`${e.evaluated}.dynamicItems`, () =>
      t.assign((0, Xe._)`${e.evaluated}.items`, (0, Xe._)`undefined`),
    );
}
function Mx(e, t) {
  const n = typeof e == "object" && e[t.schemaId];
  return n && (t.code.source || t.code.process)
    ? (0, Xe._)`/*# sourceURL=${n} */`
    : Xe.nil;
}
function LK(e, t) {
  if (gR(e) && (vR(e), mR(e))) {
    BK(e, t);
    return;
  }
  (0, pR.boolOrEmptySchema)(e, t);
}
function mR({ schema: e, self: t }) {
  if (typeof e == "boolean") return !e;
  for (const n in e) if (t.RULES.all[n]) return !0;
  return !1;
}
function gR(e) {
  return typeof e.schema != "boolean";
}
function BK(e, t) {
  const { schema: n, gen: r, opts: i } = e;
  i.$comment && n.$comment && bR(e), jK(e), MK(e);
  const a = r.const("_errs", vt.default.errors);
  yR(e, a), r.var(t, (0, Xe._)`${a} === ${vt.default.errors}`);
}
function vR(e) {
  (0, da.checkUnknownRules)(e), UK(e);
}
function yR(e, t) {
  if (e.opts.jtd) return Hx(e, [], !1, t);
  const n = (0, jx.getSchemaTypes)(e.schema),
    r = (0, jx.coerceAndCheckDataType)(e, n);
  Hx(e, n, !r, t);
}
function UK(e) {
  const { schema: t, errSchemaPath: n, opts: r, self: i } = e;
  t.$ref &&
    r.ignoreKeywordsWithRef &&
    (0, da.schemaHasRulesButRef)(t, i.RULES) &&
    i.logger.warn(`$ref: keywords ignored in schema at path "${n}"`);
}
function FK(e) {
  const { schema: t, opts: n } = e;
  t.default !== void 0 &&
    n.useDefaults &&
    n.strictSchema &&
    (0, da.checkStrictMode)(e, "default is ignored in the schema root");
}
function jK(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, kK.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function MK(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function bR({ gen: e, schemaEnv: t, schema: n, errSchemaPath: r, opts: i }) {
  const a = n.$comment;
  if (i.$comment === !0) e.code((0, Xe._)`${vt.default.self}.logger.log(${a})`);
  else if (typeof i.$comment == "function") {
    const s = (0, Xe.str)`${r}/$comment`,
      o = e.scopeValue("root", { ref: t.root });
    e.code(
      (0, Xe._)`${vt.default.self}.opts.$comment(${a}, ${s}, ${o}.schema)`,
    );
  }
}
function HK(e) {
  const {
    gen: t,
    schemaEnv: n,
    validateName: r,
    ValidationError: i,
    opts: a,
  } = e;
  n.$async
    ? t.if(
        (0, Xe._)`${vt.default.errors} === 0`,
        () => t.return(vt.default.data),
        () => t.throw((0, Xe._)`new ${i}(${vt.default.vErrors})`),
      )
    : (t.assign((0, Xe._)`${r}.errors`, vt.default.vErrors),
      a.unevaluated && qK(e),
      t.return((0, Xe._)`${vt.default.errors} === 0`));
}
function qK({ gen: e, evaluated: t, props: n, items: r }) {
  n instanceof Xe.Name && e.assign((0, Xe._)`${t}.props`, n),
    r instanceof Xe.Name && e.assign((0, Xe._)`${t}.items`, r);
}
function Hx(e, t, n, r) {
  const { gen: i, schema: a, data: s, allErrors: o, opts: c, self: l } = e,
    { RULES: f } = l;
  if (
    a.$ref &&
    (c.ignoreKeywordsWithRef || !(0, da.schemaHasRulesButRef)(a, f))
  ) {
    i.block(() => wR(e, "$ref", f.all.$ref.definition));
    return;
  }
  c.jtd || GK(e, t),
    i.block(() => {
      for (const d of f.rules) u(d);
      u(f.post);
    });
  function u(d) {
    (0, nb.shouldUseGroup)(a, d) &&
      (d.type
        ? (i.if((0, Ad.checkDataType)(d.type, s, c.strictNumbers)),
          qx(e, d),
          t.length === 1 &&
            t[0] === d.type &&
            n &&
            (i.else(), (0, Ad.reportTypeError)(e)),
          i.endIf())
        : qx(e, d),
      o || i.if((0, Xe._)`${vt.default.errors} === ${r || 0}`));
  }
}
function qx(e, t) {
  const {
    gen: n,
    schema: r,
    opts: { useDefaults: i },
  } = e;
  i && (0, RK.assignDefaults)(e, t.type),
    n.block(() => {
      for (const a of t.rules)
        (0, nb.shouldUseRule)(r, a) && wR(e, a.keyword, a.definition, t.type);
    });
}
function GK(e, t) {
  e.schemaEnv.meta ||
    !e.opts.strictTypes ||
    (QK(e, t), e.opts.allowUnionTypes || WK(e, t), zK(e, e.dataTypes));
}
function QK(e, t) {
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((n) => {
      _R(e.dataTypes, n) ||
        rb(e, `type "${n}" not allowed by context "${e.dataTypes.join(",")}"`);
    }),
      VK(e, t);
  }
}
function WK(e, t) {
  t.length > 1 &&
    !(t.length === 2 && t.includes("null")) &&
    rb(e, "use allowUnionTypes to allow union type keyword");
}
function zK(e, t) {
  const n = e.self.RULES.all;
  for (const r in n) {
    const i = n[r];
    if (typeof i == "object" && (0, nb.shouldUseRule)(e.schema, i)) {
      const { type: a } = i.definition;
      a.length &&
        !a.some((s) => KK(t, s)) &&
        rb(e, `missing type "${a.join(",")}" for keyword "${r}"`);
    }
  }
}
function KK(e, t) {
  return e.includes(t) || (t === "number" && e.includes("integer"));
}
function _R(e, t) {
  return e.includes(t) || (t === "integer" && e.includes("number"));
}
function VK(e, t) {
  const n = [];
  for (const r of e.dataTypes)
    _R(t, r)
      ? n.push(r)
      : t.includes("integer") && r === "number" && n.push("integer");
  e.dataTypes = n;
}
function rb(e, t) {
  const n = e.schemaEnv.baseId + e.errSchemaPath;
  (t += ` at "${n}" (strictTypes)`),
    (0, da.checkStrictMode)(e, t, e.opts.strictTypes);
}
class ER {
  constructor(t, n, r) {
    if (
      ((0, wl.validateKeywordUsage)(t, n, r),
      (this.gen = t.gen),
      (this.allErrors = t.allErrors),
      (this.keyword = r),
      (this.data = t.data),
      (this.schema = t.schema[r]),
      (this.$data =
        n.$data && t.opts.$data && this.schema && this.schema.$data),
      (this.schemaValue = (0, da.schemaRefOrVal)(
        t,
        this.schema,
        r,
        this.$data,
      )),
      (this.schemaType = n.schemaType),
      (this.parentSchema = t.schema),
      (this.params = {}),
      (this.it = t),
      (this.def = n),
      this.$data)
    )
      this.schemaCode = t.gen.const("vSchema", xR(this.$data, t));
    else if (
      ((this.schemaCode = this.schemaValue),
      !(0, wl.validSchemaType)(this.schema, n.schemaType, n.allowUndefined))
    )
      throw new Error(`${r} value must be ${JSON.stringify(n.schemaType)}`);
    ("code" in n ? n.trackErrors : n.errors !== !1) &&
      (this.errsCount = t.gen.const("_errs", vt.default.errors));
  }
  result(t, n, r) {
    this.failResult((0, Xe.not)(t), n, r);
  }
  failResult(t, n, r) {
    this.gen.if(t),
      r ? r() : this.error(),
      n
        ? (this.gen.else(), n(), this.allErrors && this.gen.endIf())
        : this.allErrors
        ? this.gen.endIf()
        : this.gen.else();
  }
  pass(t, n) {
    this.failResult((0, Xe.not)(t), void 0, n);
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(t),
      this.error(),
      this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data) return this.fail(t);
    const { schemaCode: n } = this;
    this.fail(
      (0, Xe._)`${n} !== undefined && (${(0, Xe.or)(this.invalid$data(), t)})`,
    );
  }
  error(t, n, r) {
    if (n) {
      this.setParams(n), this._error(t, r), this.setParams({});
      return;
    }
    this._error(t, r);
  }
  _error(t, n) {
    (t ? zc.reportExtraError : zc.reportError)(this, this.def.error, n);
  }
  $dataError() {
    (0, zc.reportError)(this, this.def.$dataError || zc.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, zc.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, n) {
    n ? Object.assign(this.params, t) : (this.params = t);
  }
  block$data(t, n, r = Xe.nil) {
    this.gen.block(() => {
      this.check$data(t, r), n();
    });
  }
  check$data(t = Xe.nil, n = Xe.nil) {
    if (!this.$data) return;
    const { gen: r, schemaCode: i, schemaType: a, def: s } = this;
    r.if((0, Xe.or)((0, Xe._)`${i} === undefined`, n)),
      t !== Xe.nil && r.assign(t, !0),
      (a.length || s.validateSchema) &&
        (r.elseIf(this.invalid$data()),
        this.$dataError(),
        t !== Xe.nil && r.assign(t, !1)),
      r.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: n, schemaType: r, def: i, it: a } = this;
    return (0, Xe.or)(s(), o());
    function s() {
      if (r.length) {
        if (!(n instanceof Xe.Name))
          throw new Error("ajv implementation error");
        const c = Array.isArray(r) ? r : [r];
        return (0, Xe._)`${(0, Ad.checkDataTypes)(
          c,
          n,
          a.opts.strictNumbers,
          Ad.DataType.Wrong,
        )}`;
      }
      return Xe.nil;
    }
    function o() {
      if (i.validateSchema) {
        const c = t.scopeValue("validate$data", { ref: i.validateSchema });
        return (0, Xe._)`!${c}(${n})`;
      }
      return Xe.nil;
    }
  }
  subschema(t, n) {
    const r = (0, Nm.getSubschema)(this.it, t);
    (0, Nm.extendSubschemaData)(r, this.it, t),
      (0, Nm.extendSubschemaMode)(r, t);
    const i = { ...this.it, ...r, items: void 0, props: void 0 };
    return LK(i, n), i;
  }
  mergeEvaluated(t, n) {
    const { it: r, gen: i } = this;
    r.opts.unevaluated &&
      (r.props !== !0 &&
        t.props !== void 0 &&
        (r.props = da.mergeEvaluated.props(i, t.props, r.props, n)),
      r.items !== !0 &&
        t.items !== void 0 &&
        (r.items = da.mergeEvaluated.items(i, t.items, r.items, n)));
  }
  mergeValidEvaluated(t, n) {
    const { it: r, gen: i } = this;
    if (r.opts.unevaluated && (r.props !== !0 || r.items !== !0))
      return i.if(n, () => this.mergeEvaluated(t, Xe.Name)), !0;
  }
}
bi.KeywordCxt = ER;
function wR(e, t, n, r) {
  const i = new ER(e, n, t);
  "code" in n
    ? n.code(i, r)
    : i.$data && n.validate
    ? (0, wl.funcKeywordCode)(i, n)
    : "macro" in n
    ? (0, wl.macroKeywordCode)(i, n)
    : (n.compile || n.validate) && (0, wl.funcKeywordCode)(i, n);
}
const YK = /^\/(?:[^~]|~0|~1)*$/,
  XK = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function xR(e, { dataLevel: t, dataNames: n, dataPathArr: r }) {
  let i, a;
  if (e === "") return vt.default.rootData;
  if (e[0] === "/") {
    if (!YK.test(e)) throw new Error(`Invalid JSON-pointer: ${e}`);
    (i = e), (a = vt.default.rootData);
  } else {
    const l = XK.exec(e);
    if (!l) throw new Error(`Invalid JSON-pointer: ${e}`);
    const f = +l[1];
    if (((i = l[2]), i === "#")) {
      if (f >= t) throw new Error(c("property/index", f));
      return r[t - f];
    }
    if (f > t) throw new Error(c("data", f));
    if (((a = n[t - f]), !i)) return a;
  }
  let s = a;
  const o = i.split("/");
  for (const l of o)
    l &&
      ((a = (0, Xe._)`${a}${(0, Xe.getProperty)(
        (0, da.unescapeJsonPointer)(l),
      )}`),
      (s = (0, Xe._)`${s} && ${a}`));
  return s;
  function c(l, f) {
    return `Cannot access ${l} ${f} levels up, current level is ${t}`;
  }
}
bi.getData = xR;
var mu = {};
Object.defineProperty(mu, "__esModule", { value: !0 });
class JK extends Error {
  constructor(t) {
    super("validation failed"),
      (this.errors = t),
      (this.ajv = this.validation = !0);
  }
}
mu.default = JK;
var gu = {};
Object.defineProperty(gu, "__esModule", { value: !0 });
const Om = rr;
class ZK extends Error {
  constructor(t, n, r, i) {
    super(i || `can't resolve reference ${r} from id ${n}`),
      (this.missingRef = (0, Om.resolveUrl)(t, n, r)),
      (this.missingSchema = (0, Om.normalizeId)(
        (0, Om.getFullPath)(t, this.missingRef),
      ));
  }
}
gu.default = ZK;
var Lr = {};
Object.defineProperty(Lr, "__esModule", { value: !0 });
Lr.resolveSchema =
  Lr.getCompilingSchema =
  Lr.resolveRef =
  Lr.compileSchema =
  Lr.SchemaEnv =
    void 0;
const ai = xt,
  eV = mu,
  fs = zi,
  mi = rr,
  Gx = Ft,
  tV = bi;
class Np {
  constructor(t) {
    var n;
    (this.refs = {}), (this.dynamicAnchors = {});
    let r;
    typeof t.schema == "object" && (r = t.schema),
      (this.schema = t.schema),
      (this.schemaId = t.schemaId),
      (this.root = t.root || this),
      (this.baseId =
        (n = t.baseId) !== null && n !== void 0
          ? n
          : (0, mi.normalizeId)(r == null ? void 0 : r[t.schemaId || "$id"])),
      (this.schemaPath = t.schemaPath),
      (this.localRefs = t.localRefs),
      (this.meta = t.meta),
      (this.$async = r == null ? void 0 : r.$async),
      (this.refs = {});
  }
}
Lr.SchemaEnv = Np;
function ib(e) {
  const t = AR.call(this, e);
  if (t) return t;
  const n = (0, mi.getFullPath)(this.opts.uriResolver, e.root.baseId),
    { es5: r, lines: i } = this.opts.code,
    { ownProperties: a } = this.opts,
    s = new ai.CodeGen(this.scope, { es5: r, lines: i, ownProperties: a });
  let o;
  e.$async &&
    (o = s.scopeValue("Error", {
      ref: eV.default,
      code: (0, ai._)`require("ajv/dist/runtime/validation_error").default`,
    }));
  const c = s.scopeName("validate");
  e.validateName = c;
  const l = {
    gen: s,
    allErrors: this.opts.allErrors,
    data: fs.default.data,
    parentData: fs.default.parentData,
    parentDataProperty: fs.default.parentDataProperty,
    dataNames: [fs.default.data],
    dataPathArr: [ai.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: new Set(),
    topSchemaRef: s.scopeValue(
      "schema",
      this.opts.code.source === !0
        ? { ref: e.schema, code: (0, ai.stringify)(e.schema) }
        : { ref: e.schema },
    ),
    validateName: c,
    ValidationError: o,
    schema: e.schema,
    schemaEnv: e,
    rootId: n,
    baseId: e.baseId || n,
    schemaPath: ai.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, ai._)`""`,
    opts: this.opts,
    self: this,
  };
  let f;
  try {
    this._compilations.add(e),
      (0, tV.validateFunctionCode)(l),
      s.optimize(this.opts.code.optimize);
    const u = s.toString();
    (f = `${s.scopeRefs(fs.default.scope)}return ${u}`),
      this.opts.code.process && (f = this.opts.code.process(f, e));
    const p = new Function(`${fs.default.self}`, `${fs.default.scope}`, f)(
      this,
      this.scope.get(),
    );
    if (
      (this.scope.value(c, { ref: p }),
      (p.errors = null),
      (p.schema = e.schema),
      (p.schemaEnv = e),
      e.$async && (p.$async = !0),
      this.opts.code.source === !0 &&
        (p.source = {
          validateName: c,
          validateCode: u,
          scopeValues: s._values,
        }),
      this.opts.unevaluated)
    ) {
      const { props: h, items: m } = l;
      (p.evaluated = {
        props: h instanceof ai.Name ? void 0 : h,
        items: m instanceof ai.Name ? void 0 : m,
        dynamicProps: h instanceof ai.Name,
        dynamicItems: m instanceof ai.Name,
      }),
        p.source && (p.source.evaluated = (0, ai.stringify)(p.evaluated));
    }
    return (e.validate = p), e;
  } catch (u) {
    throw (
      (delete e.validate,
      delete e.validateName,
      f && this.logger.error("Error compiling schema, function code:", f),
      u)
    );
  } finally {
    this._compilations.delete(e);
  }
}
Lr.compileSchema = ib;
function nV(e, t, n) {
  var r;
  n = (0, mi.resolveUrl)(this.opts.uriResolver, t, n);
  const i = e.refs[n];
  if (i) return i;
  let a = aV.call(this, e, n);
  if (a === void 0) {
    const s = (r = e.localRefs) === null || r === void 0 ? void 0 : r[n],
      { schemaId: o } = this.opts;
    s && (a = new Np({ schema: s, schemaId: o, root: e, baseId: t }));
  }
  if (a !== void 0) return (e.refs[n] = rV.call(this, a));
}
Lr.resolveRef = nV;
function rV(e) {
  return (0, mi.inlineRef)(e.schema, this.opts.inlineRefs)
    ? e.schema
    : e.validate
    ? e
    : ib.call(this, e);
}
function AR(e) {
  for (const t of this._compilations) if (iV(t, e)) return t;
}
Lr.getCompilingSchema = AR;
function iV(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function aV(e, t) {
  let n;
  for (; typeof (n = this.refs[t]) == "string"; ) t = n;
  return n || this.schemas[t] || Op.call(this, e, t);
}
function Op(e, t) {
  const n = this.opts.uriResolver.parse(t),
    r = (0, mi._getFullPath)(this.opts.uriResolver, n);
  let i = (0, mi.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && r === i) return Pm.call(this, n, e);
  const a = (0, mi.normalizeId)(r),
    s = this.refs[a] || this.schemas[a];
  if (typeof s == "string") {
    const o = Op.call(this, e, s);
    return typeof (o == null ? void 0 : o.schema) != "object"
      ? void 0
      : Pm.call(this, n, o);
  }
  if (typeof (s == null ? void 0 : s.schema) == "object") {
    if ((s.validate || ib.call(this, s), a === (0, mi.normalizeId)(t))) {
      const { schema: o } = s,
        { schemaId: c } = this.opts,
        l = o[c];
      return (
        l && (i = (0, mi.resolveUrl)(this.opts.uriResolver, i, l)),
        new Np({ schema: o, schemaId: c, root: e, baseId: i })
      );
    }
    return Pm.call(this, n, s);
  }
}
Lr.resolveSchema = Op;
const sV = new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions",
]);
function Pm(e, { baseId: t, schema: n, root: r }) {
  var i;
  if (((i = e.fragment) === null || i === void 0 ? void 0 : i[0]) !== "/")
    return;
  for (const o of e.fragment.slice(1).split("/")) {
    if (typeof n == "boolean") return;
    const c = n[(0, Gx.unescapeFragment)(o)];
    if (c === void 0) return;
    n = c;
    const l = typeof n == "object" && n[this.opts.schemaId];
    !sV.has(o) && l && (t = (0, mi.resolveUrl)(this.opts.uriResolver, t, l));
  }
  let a;
  if (
    typeof n != "boolean" &&
    n.$ref &&
    !(0, Gx.schemaHasRulesButRef)(n, this.RULES)
  ) {
    const o = (0, mi.resolveUrl)(this.opts.uriResolver, t, n.$ref);
    a = Op.call(this, r, o);
  }
  const { schemaId: s } = this.opts;
  if (
    ((a = a || new Np({ schema: n, schemaId: s, root: r, baseId: t })),
    a.schema !== a.root.schema)
  )
    return a;
}
const oV =
    "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
  cV = "Meta-schema for $data reference (JSON AnySchema extension proposal)",
  lV = "object",
  uV = ["$data"],
  fV = {
    $data: {
      type: "string",
      anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }],
    },
  },
  dV = !1,
  pV = {
    $id: oV,
    description: cV,
    type: lV,
    required: uV,
    properties: fV,
    additionalProperties: dV,
  };
var ab = {};
Object.defineProperty(ab, "__esModule", { value: !0 });
const SR = H4;
SR.code = 'require("ajv/dist/runtime/uri").default';
ab.default = SR;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.CodeGen =
      e.Name =
      e.nil =
      e.stringify =
      e.str =
      e._ =
      e.KeywordCxt =
        void 0);
  var t = bi;
  Object.defineProperty(e, "KeywordCxt", {
    enumerable: !0,
    get: function () {
      return t.KeywordCxt;
    },
  });
  var n = xt;
  Object.defineProperty(e, "_", {
    enumerable: !0,
    get: function () {
      return n._;
    },
  }),
    Object.defineProperty(e, "str", {
      enumerable: !0,
      get: function () {
        return n.str;
      },
    }),
    Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function () {
        return n.stringify;
      },
    }),
    Object.defineProperty(e, "nil", {
      enumerable: !0,
      get: function () {
        return n.nil;
      },
    }),
    Object.defineProperty(e, "Name", {
      enumerable: !0,
      get: function () {
        return n.Name;
      },
    }),
    Object.defineProperty(e, "CodeGen", {
      enumerable: !0,
      get: function () {
        return n.CodeGen;
      },
    });
  const r = mu,
    i = gu,
    a = Ms,
    s = Lr,
    o = xt,
    c = rr,
    l = hu,
    f = Ft,
    u = pV,
    d = ab,
    p = (L, k) => new RegExp(L, k);
  p.code = "new RegExp";
  const h = ["removeAdditional", "useDefaults", "coerceTypes"],
    m = new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error",
    ]),
    g = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs:
        "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode:
        "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats:
        "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now.",
    },
    v = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode:
        '"minLength"/"maxLength" account for unicode characters by default.',
    },
    y = 200;
  function _(L) {
    var k,
      W,
      F,
      x,
      T,
      V,
      B,
      N,
      ce,
      re,
      ne,
      Y,
      M,
      oe,
      Ee,
      le,
      te,
      ie,
      X,
      he,
      be,
      ye,
      Qe,
      lt,
      Lt;
    const We = L.strict,
      bt = (k = L.code) === null || k === void 0 ? void 0 : k.optimize,
      wt = bt === !0 || bt === void 0 ? 1 : bt || 0,
      ct =
        (F = (W = L.code) === null || W === void 0 ? void 0 : W.regExp) !==
          null && F !== void 0
          ? F
          : p,
      ze = (x = L.uriResolver) !== null && x !== void 0 ? x : d.default;
    return {
      strictSchema:
        (V = (T = L.strictSchema) !== null && T !== void 0 ? T : We) !== null &&
        V !== void 0
          ? V
          : !0,
      strictNumbers:
        (N = (B = L.strictNumbers) !== null && B !== void 0 ? B : We) !==
          null && N !== void 0
          ? N
          : !0,
      strictTypes:
        (re = (ce = L.strictTypes) !== null && ce !== void 0 ? ce : We) !==
          null && re !== void 0
          ? re
          : "log",
      strictTuples:
        (Y = (ne = L.strictTuples) !== null && ne !== void 0 ? ne : We) !==
          null && Y !== void 0
          ? Y
          : "log",
      strictRequired:
        (oe = (M = L.strictRequired) !== null && M !== void 0 ? M : We) !==
          null && oe !== void 0
          ? oe
          : !1,
      code: L.code
        ? { ...L.code, optimize: wt, regExp: ct }
        : { optimize: wt, regExp: ct },
      loopRequired: (Ee = L.loopRequired) !== null && Ee !== void 0 ? Ee : y,
      loopEnum: (le = L.loopEnum) !== null && le !== void 0 ? le : y,
      meta: (te = L.meta) !== null && te !== void 0 ? te : !0,
      messages: (ie = L.messages) !== null && ie !== void 0 ? ie : !0,
      inlineRefs: (X = L.inlineRefs) !== null && X !== void 0 ? X : !0,
      schemaId: (he = L.schemaId) !== null && he !== void 0 ? he : "$id",
      addUsedSchema: (be = L.addUsedSchema) !== null && be !== void 0 ? be : !0,
      validateSchema:
        (ye = L.validateSchema) !== null && ye !== void 0 ? ye : !0,
      validateFormats:
        (Qe = L.validateFormats) !== null && Qe !== void 0 ? Qe : !0,
      unicodeRegExp: (lt = L.unicodeRegExp) !== null && lt !== void 0 ? lt : !0,
      int32range: (Lt = L.int32range) !== null && Lt !== void 0 ? Lt : !0,
      uriResolver: ze,
    };
  }
  class E {
    constructor(k = {}) {
      (this.schemas = {}),
        (this.refs = {}),
        (this.formats = {}),
        (this._compilations = new Set()),
        (this._loading = {}),
        (this._cache = new Map()),
        (k = this.opts = { ...k, ..._(k) });
      const { es5: W, lines: F } = this.opts.code;
      (this.scope = new o.ValueScope({
        scope: {},
        prefixes: m,
        es5: W,
        lines: F,
      })),
        (this.logger = j(k.logger));
      const x = k.validateFormats;
      (k.validateFormats = !1),
        (this.RULES = (0, a.getRules)()),
        R.call(this, g, k, "NOT SUPPORTED"),
        R.call(this, v, k, "DEPRECATED", "warn"),
        (this._metaOpts = O.call(this)),
        k.formats && S.call(this),
        this._addVocabularies(),
        this._addDefaultMetaSchema(),
        k.keywords && w.call(this, k.keywords),
        typeof k.meta == "object" && this.addMetaSchema(k.meta),
        I.call(this),
        (k.validateFormats = x);
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: k, meta: W, schemaId: F } = this.opts;
      let x = u;
      F === "id" && ((x = { ...u }), (x.id = x.$id), delete x.$id),
        W && k && this.addMetaSchema(x, x[F], !1);
    }
    defaultMeta() {
      const { meta: k, schemaId: W } = this.opts;
      return (this.opts.defaultMeta =
        typeof k == "object" ? k[W] || k : void 0);
    }
    validate(k, W) {
      let F;
      if (typeof k == "string") {
        if (((F = this.getSchema(k)), !F))
          throw new Error(`no schema with key or ref "${k}"`);
      } else F = this.compile(k);
      const x = F(W);
      return "$async" in F || (this.errors = F.errors), x;
    }
    compile(k, W) {
      const F = this._addSchema(k, W);
      return F.validate || this._compileSchemaEnv(F);
    }
    compileAsync(k, W) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: F } = this.opts;
      return x.call(this, k, W);
      async function x(re, ne) {
        await T.call(this, re.$schema);
        const Y = this._addSchema(re, ne);
        return Y.validate || V.call(this, Y);
      }
      async function T(re) {
        re && !this.getSchema(re) && (await x.call(this, { $ref: re }, !0));
      }
      async function V(re) {
        try {
          return this._compileSchemaEnv(re);
        } catch (ne) {
          if (!(ne instanceof i.default)) throw ne;
          return (
            B.call(this, ne),
            await N.call(this, ne.missingSchema),
            V.call(this, re)
          );
        }
      }
      function B({ missingSchema: re, missingRef: ne }) {
        if (this.refs[re])
          throw new Error(
            `AnySchema ${re} is loaded but ${ne} cannot be resolved`,
          );
      }
      async function N(re) {
        const ne = await ce.call(this, re);
        this.refs[re] || (await T.call(this, ne.$schema)),
          this.refs[re] || this.addSchema(ne, re, W);
      }
      async function ce(re) {
        const ne = this._loading[re];
        if (ne) return ne;
        try {
          return await (this._loading[re] = F(re));
        } finally {
          delete this._loading[re];
        }
      }
    }
    addSchema(k, W, F, x = this.opts.validateSchema) {
      if (Array.isArray(k)) {
        for (const V of k) this.addSchema(V, void 0, F, x);
        return this;
      }
      let T;
      if (typeof k == "object") {
        const { schemaId: V } = this.opts;
        if (((T = k[V]), T !== void 0 && typeof T != "string"))
          throw new Error(`schema ${V} must be string`);
      }
      return (
        (W = (0, c.normalizeId)(W || T)),
        this._checkUnique(W),
        (this.schemas[W] = this._addSchema(k, F, W, x, !0)),
        this
      );
    }
    addMetaSchema(k, W, F = this.opts.validateSchema) {
      return this.addSchema(k, W, !0, F), this;
    }
    validateSchema(k, W) {
      if (typeof k == "boolean") return !0;
      let F;
      if (((F = k.$schema), F !== void 0 && typeof F != "string"))
        throw new Error("$schema must be a string");
      if (((F = F || this.opts.defaultMeta || this.defaultMeta()), !F))
        return (
          this.logger.warn("meta-schema not available"),
          (this.errors = null),
          !0
        );
      const x = this.validate(F, k);
      if (!x && W) {
        const T = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log") this.logger.error(T);
        else throw new Error(T);
      }
      return x;
    }
    getSchema(k) {
      let W;
      for (; typeof (W = A.call(this, k)) == "string"; ) k = W;
      if (W === void 0) {
        const { schemaId: F } = this.opts,
          x = new s.SchemaEnv({ schema: {}, schemaId: F });
        if (((W = s.resolveSchema.call(this, x, k)), !W)) return;
        this.refs[k] = W;
      }
      return W.validate || this._compileSchemaEnv(W);
    }
    removeSchema(k) {
      if (k instanceof RegExp)
        return (
          this._removeAllSchemas(this.schemas, k),
          this._removeAllSchemas(this.refs, k),
          this
        );
      switch (typeof k) {
        case "undefined":
          return (
            this._removeAllSchemas(this.schemas),
            this._removeAllSchemas(this.refs),
            this._cache.clear(),
            this
          );
        case "string": {
          const W = A.call(this, k);
          return (
            typeof W == "object" && this._cache.delete(W.schema),
            delete this.schemas[k],
            delete this.refs[k],
            this
          );
        }
        case "object": {
          const W = k;
          this._cache.delete(W);
          let F = k[this.opts.schemaId];
          return (
            F &&
              ((F = (0, c.normalizeId)(F)),
              delete this.schemas[F],
              delete this.refs[F]),
            this
          );
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(k) {
      for (const W of k) this.addKeyword(W);
      return this;
    }
    addKeyword(k, W) {
      let F;
      if (typeof k == "string")
        (F = k),
          typeof W == "object" &&
            (this.logger.warn(
              "these parameters are deprecated, see docs for addKeyword",
            ),
            (W.keyword = F));
      else if (typeof k == "object" && W === void 0) {
        if (((W = k), (F = W.keyword), Array.isArray(F) && !F.length))
          throw new Error(
            "addKeywords: keyword must be string or non-empty array",
          );
      } else throw new Error("invalid addKeywords parameters");
      if ((q.call(this, F, W), !W))
        return (0, f.eachItem)(F, (T) => J.call(this, T)), this;
      z.call(this, W);
      const x = {
        ...W,
        type: (0, l.getJSONTypes)(W.type),
        schemaType: (0, l.getJSONTypes)(W.schemaType),
      };
      return (
        (0, f.eachItem)(
          F,
          x.type.length === 0
            ? (T) => J.call(this, T, x)
            : (T) => x.type.forEach((V) => J.call(this, T, x, V)),
        ),
        this
      );
    }
    getKeyword(k) {
      const W = this.RULES.all[k];
      return typeof W == "object" ? W.definition : !!W;
    }
    removeKeyword(k) {
      const { RULES: W } = this;
      delete W.keywords[k], delete W.all[k];
      for (const F of W.rules) {
        const x = F.rules.findIndex((T) => T.keyword === k);
        x >= 0 && F.rules.splice(x, 1);
      }
      return this;
    }
    addFormat(k, W) {
      return (
        typeof W == "string" && (W = new RegExp(W)), (this.formats[k] = W), this
      );
    }
    errorsText(
      k = this.errors,
      { separator: W = ", ", dataVar: F = "data" } = {},
    ) {
      return !k || k.length === 0
        ? "No errors"
        : k
            .map((x) => `${F}${x.instancePath} ${x.message}`)
            .reduce((x, T) => x + W + T);
    }
    $dataMetaSchema(k, W) {
      const F = this.RULES.all;
      k = JSON.parse(JSON.stringify(k));
      for (const x of W) {
        const T = x.split("/").slice(1);
        let V = k;
        for (const B of T) V = V[B];
        for (const B in F) {
          const N = F[B];
          if (typeof N != "object") continue;
          const { $data: ce } = N.definition,
            re = V[B];
          ce && re && (V[B] = G(re));
        }
      }
      return k;
    }
    _removeAllSchemas(k, W) {
      for (const F in k) {
        const x = k[F];
        (!W || W.test(F)) &&
          (typeof x == "string"
            ? delete k[F]
            : x && !x.meta && (this._cache.delete(x.schema), delete k[F]));
      }
    }
    _addSchema(
      k,
      W,
      F,
      x = this.opts.validateSchema,
      T = this.opts.addUsedSchema,
    ) {
      let V;
      const { schemaId: B } = this.opts;
      if (typeof k == "object") V = k[B];
      else {
        if (this.opts.jtd) throw new Error("schema must be object");
        if (typeof k != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let N = this._cache.get(k);
      if (N !== void 0) return N;
      F = (0, c.normalizeId)(V || F);
      const ce = c.getSchemaRefs.call(this, k, F);
      return (
        (N = new s.SchemaEnv({
          schema: k,
          schemaId: B,
          meta: W,
          baseId: F,
          localRefs: ce,
        })),
        this._cache.set(N.schema, N),
        T &&
          !F.startsWith("#") &&
          (F && this._checkUnique(F), (this.refs[F] = N)),
        x && this.validateSchema(k, !0),
        N
      );
    }
    _checkUnique(k) {
      if (this.schemas[k] || this.refs[k])
        throw new Error(`schema with key or id "${k}" already exists`);
    }
    _compileSchemaEnv(k) {
      if (
        (k.meta ? this._compileMetaSchema(k) : s.compileSchema.call(this, k),
        !k.validate)
      )
        throw new Error("ajv implementation error");
      return k.validate;
    }
    _compileMetaSchema(k) {
      const W = this.opts;
      this.opts = this._metaOpts;
      try {
        s.compileSchema.call(this, k);
      } finally {
        this.opts = W;
      }
    }
  }
  (e.default = E),
    (E.ValidationError = r.default),
    (E.MissingRefError = i.default);
  function R(L, k, W, F = "error") {
    for (const x in L) {
      const T = x;
      T in k && this.logger[F](`${W}: option ${x}. ${L[T]}`);
    }
  }
  function A(L) {
    return (L = (0, c.normalizeId)(L)), this.schemas[L] || this.refs[L];
  }
  function I() {
    const L = this.opts.schemas;
    if (L)
      if (Array.isArray(L)) this.addSchema(L);
      else for (const k in L) this.addSchema(L[k], k);
  }
  function S() {
    for (const L in this.opts.formats) {
      const k = this.opts.formats[L];
      k && this.addFormat(L, k);
    }
  }
  function w(L) {
    if (Array.isArray(L)) {
      this.addVocabulary(L);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const k in L) {
      const W = L[k];
      W.keyword || (W.keyword = k), this.addKeyword(W);
    }
  }
  function O() {
    const L = { ...this.opts };
    for (const k of h) delete L[k];
    return L;
  }
  const Q = { log() {}, warn() {}, error() {} };
  function j(L) {
    if (L === !1) return Q;
    if (L === void 0) return console;
    if (L.log && L.warn && L.error) return L;
    throw new Error("logger must implement log, warn and error methods");
  }
  const H = /^[a-z_$][a-z0-9_$:-]*$/i;
  function q(L, k) {
    const { RULES: W } = this;
    if (
      ((0, f.eachItem)(L, (F) => {
        if (W.keywords[F]) throw new Error(`Keyword ${F} is already defined`);
        if (!H.test(F)) throw new Error(`Keyword ${F} has invalid name`);
      }),
      !!k && k.$data && !("code" in k || "validate" in k))
    )
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function J(L, k, W) {
    var F;
    const x = k == null ? void 0 : k.post;
    if (W && x) throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: T } = this;
    let V = x ? T.post : T.rules.find(({ type: N }) => N === W);
    if (
      (V || ((V = { type: W, rules: [] }), T.rules.push(V)),
      (T.keywords[L] = !0),
      !k)
    )
      return;
    const B = {
      keyword: L,
      definition: {
        ...k,
        type: (0, l.getJSONTypes)(k.type),
        schemaType: (0, l.getJSONTypes)(k.schemaType),
      },
    };
    k.before ? Z.call(this, V, B, k.before) : V.rules.push(B),
      (T.all[L] = B),
      (F = k.implements) === null ||
        F === void 0 ||
        F.forEach((N) => this.addKeyword(N));
  }
  function Z(L, k, W) {
    const F = L.rules.findIndex((x) => x.keyword === W);
    F >= 0
      ? L.rules.splice(F, 0, k)
      : (L.rules.push(k), this.logger.warn(`rule ${W} is not defined`));
  }
  function z(L) {
    let { metaSchema: k } = L;
    k !== void 0 &&
      (L.$data && this.opts.$data && (k = G(k)),
      (L.validateSchema = this.compile(k, !0)));
  }
  const U = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
  };
  function G(L) {
    return { anyOf: [L, U] };
  }
})(tR);
var sb = {},
  ob = {},
  cb = {};
Object.defineProperty(cb, "__esModule", { value: !0 });
const hV = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  },
};
cb.default = hV;
var Hs = {};
Object.defineProperty(Hs, "__esModule", { value: !0 });
Hs.callRef = Hs.getValidate = void 0;
const mV = gu,
  Qx = It,
  Or = xt,
  ho = zi,
  Wx = Lr,
  Ef = Ft,
  gV = {
    keyword: "$ref",
    schemaType: "string",
    code(e) {
      const { gen: t, schema: n, it: r } = e,
        { baseId: i, schemaEnv: a, validateName: s, opts: o, self: c } = r,
        { root: l } = a;
      if ((n === "#" || n === "#/") && i === l.baseId) return u();
      const f = Wx.resolveRef.call(c, l, i, n);
      if (f === void 0) throw new mV.default(r.opts.uriResolver, i, n);
      if (f instanceof Wx.SchemaEnv) return d(f);
      return p(f);
      function u() {
        if (a === l) return Wf(e, s, a, a.$async);
        const h = t.scopeValue("root", { ref: l });
        return Wf(e, (0, Or._)`${h}.validate`, l, l.$async);
      }
      function d(h) {
        const m = IR(e, h);
        Wf(e, m, h, h.$async);
      }
      function p(h) {
        const m = t.scopeValue(
            "schema",
            o.code.source === !0
              ? { ref: h, code: (0, Or.stringify)(h) }
              : { ref: h },
          ),
          g = t.name("valid"),
          v = e.subschema(
            {
              schema: h,
              dataTypes: [],
              schemaPath: Or.nil,
              topSchemaRef: m,
              errSchemaPath: n,
            },
            g,
          );
        e.mergeEvaluated(v), e.ok(g);
      }
    },
  };
function IR(e, t) {
  const { gen: n } = e;
  return t.validate
    ? n.scopeValue("validate", { ref: t.validate })
    : (0, Or._)`${n.scopeValue("wrapper", { ref: t })}.validate`;
}
Hs.getValidate = IR;
function Wf(e, t, n, r) {
  const { gen: i, it: a } = e,
    { allErrors: s, schemaEnv: o, opts: c } = a,
    l = c.passContext ? ho.default.this : Or.nil;
  r ? f() : u();
  function f() {
    if (!o.$async) throw new Error("async schema referenced by sync schema");
    const h = i.let("valid");
    i.try(
      () => {
        i.code((0, Or._)`await ${(0, Qx.callValidateCode)(e, t, l)}`),
          p(t),
          s || i.assign(h, !0);
      },
      (m) => {
        i.if((0, Or._)`!(${m} instanceof ${a.ValidationError})`, () =>
          i.throw(m),
        ),
          d(m),
          s || i.assign(h, !1);
      },
    ),
      e.ok(h);
  }
  function u() {
    e.result(
      (0, Qx.callValidateCode)(e, t, l),
      () => p(t),
      () => d(t),
    );
  }
  function d(h) {
    const m = (0, Or._)`${h}.errors`;
    i.assign(
      ho.default.vErrors,
      (0,
      Or._)`${ho.default.vErrors} === null ? ${m} : ${ho.default.vErrors}.concat(${m})`,
    ),
      i.assign(ho.default.errors, (0, Or._)`${ho.default.vErrors}.length`);
  }
  function p(h) {
    var m;
    if (!a.opts.unevaluated) return;
    const g =
      (m = n == null ? void 0 : n.validate) === null || m === void 0
        ? void 0
        : m.evaluated;
    if (a.props !== !0)
      if (g && !g.dynamicProps)
        g.props !== void 0 &&
          (a.props = Ef.mergeEvaluated.props(i, g.props, a.props));
      else {
        const v = i.var("props", (0, Or._)`${h}.evaluated.props`);
        a.props = Ef.mergeEvaluated.props(i, v, a.props, Or.Name);
      }
    if (a.items !== !0)
      if (g && !g.dynamicItems)
        g.items !== void 0 &&
          (a.items = Ef.mergeEvaluated.items(i, g.items, a.items));
      else {
        const v = i.var("items", (0, Or._)`${h}.evaluated.items`);
        a.items = Ef.mergeEvaluated.items(i, v, a.items, Or.Name);
      }
  }
}
Hs.callRef = Wf;
Hs.default = gV;
Object.defineProperty(ob, "__esModule", { value: !0 });
const vV = cb,
  yV = Hs,
  bV = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    vV.default,
    yV.default,
  ];
ob.default = bV;
var lb = {},
  ub = {};
Object.defineProperty(ub, "__esModule", { value: !0 });
const Sd = xt,
  xa = Sd.operators,
  Id = {
    maximum: { okStr: "<=", ok: xa.LTE, fail: xa.GT },
    minimum: { okStr: ">=", ok: xa.GTE, fail: xa.LT },
    exclusiveMaximum: { okStr: "<", ok: xa.LT, fail: xa.GTE },
    exclusiveMinimum: { okStr: ">", ok: xa.GT, fail: xa.LTE },
  },
  _V = {
    message: ({ keyword: e, schemaCode: t }) =>
      (0, Sd.str)`must be ${Id[e].okStr} ${t}`,
    params: ({ keyword: e, schemaCode: t }) =>
      (0, Sd._)`{comparison: ${Id[e].okStr}, limit: ${t}}`,
  },
  EV = {
    keyword: Object.keys(Id),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: _V,
    code(e) {
      const { keyword: t, data: n, schemaCode: r } = e;
      e.fail$data((0, Sd._)`${n} ${Id[t].fail} ${r} || isNaN(${n})`);
    },
  };
ub.default = EV;
var fb = {};
Object.defineProperty(fb, "__esModule", { value: !0 });
const xl = xt,
  wV = {
    message: ({ schemaCode: e }) => (0, xl.str)`must be multiple of ${e}`,
    params: ({ schemaCode: e }) => (0, xl._)`{multipleOf: ${e}}`,
  },
  xV = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: wV,
    code(e) {
      const { gen: t, data: n, schemaCode: r, it: i } = e,
        a = i.opts.multipleOfPrecision,
        s = t.let("res"),
        o = a
          ? (0, xl._)`Math.abs(Math.round(${s}) - ${s}) > 1e-${a}`
          : (0, xl._)`${s} !== parseInt(${s})`;
      e.fail$data((0, xl._)`(${r} === 0 || (${s} = ${n}/${r}, ${o}))`);
    },
  };
fb.default = xV;
var db = {},
  pb = {};
Object.defineProperty(pb, "__esModule", { value: !0 });
function $R(e) {
  const t = e.length;
  let n = 0,
    r = 0,
    i;
  for (; r < t; )
    n++,
      (i = e.charCodeAt(r++)),
      i >= 55296 &&
        i <= 56319 &&
        r < t &&
        ((i = e.charCodeAt(r)), (i & 64512) === 56320 && r++);
  return n;
}
pb.default = $R;
$R.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(db, "__esModule", { value: !0 });
const ws = xt,
  AV = Ft,
  SV = pb,
  IV = {
    message({ keyword: e, schemaCode: t }) {
      const n = e === "maxLength" ? "more" : "fewer";
      return (0, ws.str)`must NOT have ${n} than ${t} characters`;
    },
    params: ({ schemaCode: e }) => (0, ws._)`{limit: ${e}}`,
  },
  $V = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: IV,
    code(e) {
      const { keyword: t, data: n, schemaCode: r, it: i } = e,
        a = t === "maxLength" ? ws.operators.GT : ws.operators.LT,
        s =
          i.opts.unicode === !1
            ? (0, ws._)`${n}.length`
            : (0, ws._)`${(0, AV.useFunc)(e.gen, SV.default)}(${n})`;
      e.fail$data((0, ws._)`${s} ${a} ${r}`);
    },
  };
db.default = $V;
var hb = {};
Object.defineProperty(hb, "__esModule", { value: !0 });
const CV = It,
  $d = xt,
  RV = {
    message: ({ schemaCode: e }) => (0, $d.str)`must match pattern "${e}"`,
    params: ({ schemaCode: e }) => (0, $d._)`{pattern: ${e}}`,
  },
  kV = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: RV,
    code(e) {
      const { data: t, $data: n, schema: r, schemaCode: i, it: a } = e,
        s = a.opts.unicodeRegExp ? "u" : "",
        o = n ? (0, $d._)`(new RegExp(${i}, ${s}))` : (0, CV.usePattern)(e, r);
      e.fail$data((0, $d._)`!${o}.test(${t})`);
    },
  };
hb.default = kV;
var mb = {};
Object.defineProperty(mb, "__esModule", { value: !0 });
const Al = xt,
  TV = {
    message({ keyword: e, schemaCode: t }) {
      const n = e === "maxProperties" ? "more" : "fewer";
      return (0, Al.str)`must NOT have ${n} than ${t} properties`;
    },
    params: ({ schemaCode: e }) => (0, Al._)`{limit: ${e}}`,
  },
  NV = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: TV,
    code(e) {
      const { keyword: t, data: n, schemaCode: r } = e,
        i = t === "maxProperties" ? Al.operators.GT : Al.operators.LT;
      e.fail$data((0, Al._)`Object.keys(${n}).length ${i} ${r}`);
    },
  };
mb.default = NV;
var gb = {};
Object.defineProperty(gb, "__esModule", { value: !0 });
const Kc = It,
  Sl = xt,
  OV = Ft,
  PV = {
    message: ({ params: { missingProperty: e } }) =>
      (0, Sl.str)`must have required property '${e}'`,
    params: ({ params: { missingProperty: e } }) =>
      (0, Sl._)`{missingProperty: ${e}}`,
  },
  DV = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: PV,
    code(e) {
      const { gen: t, schema: n, schemaCode: r, data: i, $data: a, it: s } = e,
        { opts: o } = s;
      if (!a && n.length === 0) return;
      const c = n.length >= o.loopRequired;
      if ((s.allErrors ? l() : f(), o.strictRequired)) {
        const p = e.parentSchema.properties,
          { definedProperties: h } = e.it;
        for (const m of n)
          if ((p == null ? void 0 : p[m]) === void 0 && !h.has(m)) {
            const g = s.schemaEnv.baseId + s.errSchemaPath,
              v = `required property "${m}" is not defined at "${g}" (strictRequired)`;
            (0, OV.checkStrictMode)(s, v, s.opts.strictRequired);
          }
      }
      function l() {
        if (c || a) e.block$data(Sl.nil, u);
        else for (const p of n) (0, Kc.checkReportMissingProp)(e, p);
      }
      function f() {
        const p = t.let("missing");
        if (c || a) {
          const h = t.let("valid", !0);
          e.block$data(h, () => d(p, h)), e.ok(h);
        } else
          t.if((0, Kc.checkMissingProp)(e, n, p)),
            (0, Kc.reportMissingProp)(e, p),
            t.else();
      }
      function u() {
        t.forOf("prop", r, (p) => {
          e.setParams({ missingProperty: p }),
            t.if((0, Kc.noPropertyInData)(t, i, p, o.ownProperties), () =>
              e.error(),
            );
        });
      }
      function d(p, h) {
        e.setParams({ missingProperty: p }),
          t.forOf(
            p,
            r,
            () => {
              t.assign(h, (0, Kc.propertyInData)(t, i, p, o.ownProperties)),
                t.if((0, Sl.not)(h), () => {
                  e.error(), t.break();
                });
            },
            Sl.nil,
          );
      }
    },
  };
gb.default = DV;
var vb = {};
Object.defineProperty(vb, "__esModule", { value: !0 });
const Il = xt,
  LV = {
    message({ keyword: e, schemaCode: t }) {
      const n = e === "maxItems" ? "more" : "fewer";
      return (0, Il.str)`must NOT have ${n} than ${t} items`;
    },
    params: ({ schemaCode: e }) => (0, Il._)`{limit: ${e}}`,
  },
  BV = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: LV,
    code(e) {
      const { keyword: t, data: n, schemaCode: r } = e,
        i = t === "maxItems" ? Il.operators.GT : Il.operators.LT;
      e.fail$data((0, Il._)`${n}.length ${i} ${r}`);
    },
  };
vb.default = BV;
var yb = {},
  vu = {};
Object.defineProperty(vu, "__esModule", { value: !0 });
const CR = $p;
CR.code = 'require("ajv/dist/runtime/equal").default';
vu.default = CR;
Object.defineProperty(yb, "__esModule", { value: !0 });
const Dm = hu,
  Jn = xt,
  UV = Ft,
  FV = vu,
  jV = {
    message: ({ params: { i: e, j: t } }) =>
      (0,
      Jn.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
    params: ({ params: { i: e, j: t } }) => (0, Jn._)`{i: ${e}, j: ${t}}`,
  },
  MV = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: jV,
    code(e) {
      const {
        gen: t,
        data: n,
        $data: r,
        schema: i,
        parentSchema: a,
        schemaCode: s,
        it: o,
      } = e;
      if (!r && !i) return;
      const c = t.let("valid"),
        l = a.items ? (0, Dm.getSchemaTypes)(a.items) : [];
      e.block$data(c, f, (0, Jn._)`${s} === false`), e.ok(c);
      function f() {
        const h = t.let("i", (0, Jn._)`${n}.length`),
          m = t.let("j");
        e.setParams({ i: h, j: m }),
          t.assign(c, !0),
          t.if((0, Jn._)`${h} > 1`, () => (u() ? d : p)(h, m));
      }
      function u() {
        return l.length > 0 && !l.some((h) => h === "object" || h === "array");
      }
      function d(h, m) {
        const g = t.name("item"),
          v = (0, Dm.checkDataTypes)(
            l,
            g,
            o.opts.strictNumbers,
            Dm.DataType.Wrong,
          ),
          y = t.const("indices", (0, Jn._)`{}`);
        t.for((0, Jn._)`;${h}--;`, () => {
          t.let(g, (0, Jn._)`${n}[${h}]`),
            t.if(v, (0, Jn._)`continue`),
            l.length > 1 &&
              t.if((0, Jn._)`typeof ${g} == "string"`, (0, Jn._)`${g} += "_"`),
            t
              .if((0, Jn._)`typeof ${y}[${g}] == "number"`, () => {
                t.assign(m, (0, Jn._)`${y}[${g}]`),
                  e.error(),
                  t.assign(c, !1).break();
              })
              .code((0, Jn._)`${y}[${g}] = ${h}`);
        });
      }
      function p(h, m) {
        const g = (0, UV.useFunc)(t, FV.default),
          v = t.name("outer");
        t.label(v).for((0, Jn._)`;${h}--;`, () =>
          t.for((0, Jn._)`${m} = ${h}; ${m}--;`, () =>
            t.if((0, Jn._)`${g}(${n}[${h}], ${n}[${m}])`, () => {
              e.error(), t.assign(c, !1).break(v);
            }),
          ),
        );
      }
    },
  };
yb.default = MV;
var bb = {};
Object.defineProperty(bb, "__esModule", { value: !0 });
const R0 = xt,
  HV = Ft,
  qV = vu,
  GV = {
    message: "must be equal to constant",
    params: ({ schemaCode: e }) => (0, R0._)`{allowedValue: ${e}}`,
  },
  QV = {
    keyword: "const",
    $data: !0,
    error: GV,
    code(e) {
      const { gen: t, data: n, $data: r, schemaCode: i, schema: a } = e;
      r || (a && typeof a == "object")
        ? e.fail$data((0, R0._)`!${(0, HV.useFunc)(t, qV.default)}(${n}, ${i})`)
        : e.fail((0, R0._)`${a} !== ${n}`);
    },
  };
bb.default = QV;
var _b = {};
Object.defineProperty(_b, "__esModule", { value: !0 });
const al = xt,
  WV = Ft,
  zV = vu,
  KV = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode: e }) => (0, al._)`{allowedValues: ${e}}`,
  },
  VV = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: KV,
    code(e) {
      const { gen: t, data: n, $data: r, schema: i, schemaCode: a, it: s } = e;
      if (!r && i.length === 0)
        throw new Error("enum must have non-empty array");
      const o = i.length >= s.opts.loopEnum;
      let c;
      const l = () => c ?? (c = (0, WV.useFunc)(t, zV.default));
      let f;
      if (o || r) (f = t.let("valid")), e.block$data(f, u);
      else {
        if (!Array.isArray(i)) throw new Error("ajv implementation error");
        const p = t.const("vSchema", a);
        f = (0, al.or)(...i.map((h, m) => d(p, m)));
      }
      e.pass(f);
      function u() {
        t.assign(f, !1),
          t.forOf("v", a, (p) =>
            t.if((0, al._)`${l()}(${n}, ${p})`, () => t.assign(f, !0).break()),
          );
      }
      function d(p, h) {
        const m = i[h];
        return typeof m == "object" && m !== null
          ? (0, al._)`${l()}(${n}, ${p}[${h}])`
          : (0, al._)`${n} === ${m}`;
      }
    },
  };
_b.default = VV;
Object.defineProperty(lb, "__esModule", { value: !0 });
const YV = ub,
  XV = fb,
  JV = db,
  ZV = hb,
  eY = mb,
  tY = gb,
  nY = vb,
  rY = yb,
  iY = bb,
  aY = _b,
  sY = [
    YV.default,
    XV.default,
    JV.default,
    ZV.default,
    eY.default,
    tY.default,
    nY.default,
    rY.default,
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    iY.default,
    aY.default,
  ];
lb.default = sY;
var Eb = {},
  Ic = {};
Object.defineProperty(Ic, "__esModule", { value: !0 });
Ic.validateAdditionalItems = void 0;
const xs = xt,
  k0 = Ft,
  oY = {
    message: ({ params: { len: e } }) =>
      (0, xs.str)`must NOT have more than ${e} items`,
    params: ({ params: { len: e } }) => (0, xs._)`{limit: ${e}}`,
  },
  cY = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: oY,
    code(e) {
      const { parentSchema: t, it: n } = e,
        { items: r } = t;
      if (!Array.isArray(r)) {
        (0, k0.checkStrictMode)(
          n,
          '"additionalItems" is ignored when "items" is not an array of schemas',
        );
        return;
      }
      RR(e, r);
    },
  };
function RR(e, t) {
  const { gen: n, schema: r, data: i, keyword: a, it: s } = e;
  s.items = !0;
  const o = n.const("len", (0, xs._)`${i}.length`);
  if (r === !1)
    e.setParams({ len: t.length }), e.pass((0, xs._)`${o} <= ${t.length}`);
  else if (typeof r == "object" && !(0, k0.alwaysValidSchema)(s, r)) {
    const l = n.var("valid", (0, xs._)`${o} <= ${t.length}`);
    n.if((0, xs.not)(l), () => c(l)), e.ok(l);
  }
  function c(l) {
    n.forRange("i", t.length, o, (f) => {
      e.subschema({ keyword: a, dataProp: f, dataPropType: k0.Type.Num }, l),
        s.allErrors || n.if((0, xs.not)(l), () => n.break());
    });
  }
}
Ic.validateAdditionalItems = RR;
Ic.default = cY;
var wb = {},
  $c = {};
Object.defineProperty($c, "__esModule", { value: !0 });
$c.validateTuple = void 0;
const zx = xt,
  zf = Ft,
  lY = It,
  uY = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(e) {
      const { schema: t, it: n } = e;
      if (Array.isArray(t)) return kR(e, "additionalItems", t);
      (n.items = !0),
        !(0, zf.alwaysValidSchema)(n, t) && e.ok((0, lY.validateArray)(e));
    },
  };
function kR(e, t, n = e.schema) {
  const { gen: r, parentSchema: i, data: a, keyword: s, it: o } = e;
  f(i),
    o.opts.unevaluated &&
      n.length &&
      o.items !== !0 &&
      (o.items = zf.mergeEvaluated.items(r, n.length, o.items));
  const c = r.name("valid"),
    l = r.const("len", (0, zx._)`${a}.length`);
  n.forEach((u, d) => {
    (0, zf.alwaysValidSchema)(o, u) ||
      (r.if((0, zx._)`${l} > ${d}`, () =>
        e.subschema({ keyword: s, schemaProp: d, dataProp: d }, c),
      ),
      e.ok(c));
  });
  function f(u) {
    const { opts: d, errSchemaPath: p } = o,
      h = n.length,
      m = h === u.minItems && (h === u.maxItems || u[t] === !1);
    if (d.strictTuples && !m) {
      const g = `"${s}" is ${h}-tuple, but minItems or maxItems/${t} are not specified or different at path "${p}"`;
      (0, zf.checkStrictMode)(o, g, d.strictTuples);
    }
  }
}
$c.validateTuple = kR;
$c.default = uY;
Object.defineProperty(wb, "__esModule", { value: !0 });
const fY = $c,
  dY = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (e) => (0, fY.validateTuple)(e, "items"),
  };
wb.default = dY;
var xb = {};
Object.defineProperty(xb, "__esModule", { value: !0 });
const Kx = xt,
  pY = Ft,
  hY = It,
  mY = Ic,
  gY = {
    message: ({ params: { len: e } }) =>
      (0, Kx.str)`must NOT have more than ${e} items`,
    params: ({ params: { len: e } }) => (0, Kx._)`{limit: ${e}}`,
  },
  vY = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: gY,
    code(e) {
      const { schema: t, parentSchema: n, it: r } = e,
        { prefixItems: i } = n;
      (r.items = !0),
        !(0, pY.alwaysValidSchema)(r, t) &&
          (i
            ? (0, mY.validateAdditionalItems)(e, i)
            : e.ok((0, hY.validateArray)(e)));
    },
  };
xb.default = vY;
var Ab = {};
Object.defineProperty(Ab, "__esModule", { value: !0 });
const Zr = xt,
  wf = Ft,
  yY = {
    message: ({ params: { min: e, max: t } }) =>
      t === void 0
        ? (0, Zr.str)`must contain at least ${e} valid item(s)`
        : (0,
          Zr.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
    params: ({ params: { min: e, max: t } }) =>
      t === void 0
        ? (0, Zr._)`{minContains: ${e}}`
        : (0, Zr._)`{minContains: ${e}, maxContains: ${t}}`,
  },
  bY = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: yY,
    code(e) {
      const { gen: t, schema: n, parentSchema: r, data: i, it: a } = e;
      let s, o;
      const { minContains: c, maxContains: l } = r;
      a.opts.next ? ((s = c === void 0 ? 1 : c), (o = l)) : (s = 1);
      const f = t.const("len", (0, Zr._)`${i}.length`);
      if ((e.setParams({ min: s, max: o }), o === void 0 && s === 0)) {
        (0, wf.checkStrictMode)(
          a,
          '"minContains" == 0 without "maxContains": "contains" keyword ignored',
        );
        return;
      }
      if (o !== void 0 && s > o) {
        (0, wf.checkStrictMode)(
          a,
          '"minContains" > "maxContains" is always invalid',
        ),
          e.fail();
        return;
      }
      if ((0, wf.alwaysValidSchema)(a, n)) {
        let m = (0, Zr._)`${f} >= ${s}`;
        o !== void 0 && (m = (0, Zr._)`${m} && ${f} <= ${o}`), e.pass(m);
        return;
      }
      a.items = !0;
      const u = t.name("valid");
      o === void 0 && s === 1
        ? p(u, () => t.if(u, () => t.break()))
        : s === 0
        ? (t.let(u, !0), o !== void 0 && t.if((0, Zr._)`${i}.length > 0`, d))
        : (t.let(u, !1), d()),
        e.result(u, () => e.reset());
      function d() {
        const m = t.name("_valid"),
          g = t.let("count", 0);
        p(m, () => t.if(m, () => h(g)));
      }
      function p(m, g) {
        t.forRange("i", 0, f, (v) => {
          e.subschema(
            {
              keyword: "contains",
              dataProp: v,
              dataPropType: wf.Type.Num,
              compositeRule: !0,
            },
            m,
          ),
            g();
        });
      }
      function h(m) {
        t.code((0, Zr._)`${m}++`),
          o === void 0
            ? t.if((0, Zr._)`${m} >= ${s}`, () => t.assign(u, !0).break())
            : (t.if((0, Zr._)`${m} > ${o}`, () => t.assign(u, !1).break()),
              s === 1
                ? t.assign(u, !0)
                : t.if((0, Zr._)`${m} >= ${s}`, () => t.assign(u, !0)));
      }
    },
  };
Ab.default = bY;
var TR = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0);
  const t = xt,
    n = Ft,
    r = It;
  e.error = {
    message: ({ params: { property: c, depsCount: l, deps: f } }) => {
      const u = l === 1 ? "property" : "properties";
      return (0, t.str)`must have ${u} ${f} when property ${c} is present`;
    },
    params: ({
      params: { property: c, depsCount: l, deps: f, missingProperty: u },
    }) => (0, t._)`{property: ${c},
    missingProperty: ${u},
    depsCount: ${l},
    deps: ${f}}`,
  };
  const i = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(c) {
      const [l, f] = a(c);
      s(c, l), o(c, f);
    },
  };
  function a({ schema: c }) {
    const l = {},
      f = {};
    for (const u in c) {
      if (u === "__proto__") continue;
      const d = Array.isArray(c[u]) ? l : f;
      d[u] = c[u];
    }
    return [l, f];
  }
  function s(c, l = c.schema) {
    const { gen: f, data: u, it: d } = c;
    if (Object.keys(l).length === 0) return;
    const p = f.let("missing");
    for (const h in l) {
      const m = l[h];
      if (m.length === 0) continue;
      const g = (0, r.propertyInData)(f, u, h, d.opts.ownProperties);
      c.setParams({ property: h, depsCount: m.length, deps: m.join(", ") }),
        d.allErrors
          ? f.if(g, () => {
              for (const v of m) (0, r.checkReportMissingProp)(c, v);
            })
          : (f.if((0, t._)`${g} && (${(0, r.checkMissingProp)(c, m, p)})`),
            (0, r.reportMissingProp)(c, p),
            f.else());
    }
  }
  e.validatePropertyDeps = s;
  function o(c, l = c.schema) {
    const { gen: f, data: u, keyword: d, it: p } = c,
      h = f.name("valid");
    for (const m in l)
      (0, n.alwaysValidSchema)(p, l[m]) ||
        (f.if(
          (0, r.propertyInData)(f, u, m, p.opts.ownProperties),
          () => {
            const g = c.subschema({ keyword: d, schemaProp: m }, h);
            c.mergeValidEvaluated(g, h);
          },
          () => f.var(h, !0),
        ),
        c.ok(h));
  }
  (e.validateSchemaDeps = o), (e.default = i);
})(TR);
var Sb = {};
Object.defineProperty(Sb, "__esModule", { value: !0 });
const NR = xt,
  _Y = Ft,
  EY = {
    message: "property name must be valid",
    params: ({ params: e }) => (0, NR._)`{propertyName: ${e.propertyName}}`,
  },
  wY = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: EY,
    code(e) {
      const { gen: t, schema: n, data: r, it: i } = e;
      if ((0, _Y.alwaysValidSchema)(i, n)) return;
      const a = t.name("valid");
      t.forIn("key", r, (s) => {
        e.setParams({ propertyName: s }),
          e.subschema(
            {
              keyword: "propertyNames",
              data: s,
              dataTypes: ["string"],
              propertyName: s,
              compositeRule: !0,
            },
            a,
          ),
          t.if((0, NR.not)(a), () => {
            e.error(!0), i.allErrors || t.break();
          });
      }),
        e.ok(a);
    },
  };
Sb.default = wY;
var Pp = {};
Object.defineProperty(Pp, "__esModule", { value: !0 });
const xf = It,
  ci = xt,
  xY = zi,
  Af = Ft,
  AY = {
    message: "must NOT have additional properties",
    params: ({ params: e }) =>
      (0, ci._)`{additionalProperty: ${e.additionalProperty}}`,
  },
  SY = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: AY,
    code(e) {
      const {
        gen: t,
        schema: n,
        parentSchema: r,
        data: i,
        errsCount: a,
        it: s,
      } = e;
      if (!a) throw new Error("ajv implementation error");
      const { allErrors: o, opts: c } = s;
      if (
        ((s.props = !0),
        c.removeAdditional !== "all" && (0, Af.alwaysValidSchema)(s, n))
      )
        return;
      const l = (0, xf.allSchemaProperties)(r.properties),
        f = (0, xf.allSchemaProperties)(r.patternProperties);
      u(), e.ok((0, ci._)`${a} === ${xY.default.errors}`);
      function u() {
        t.forIn("key", i, (g) => {
          !l.length && !f.length ? h(g) : t.if(d(g), () => h(g));
        });
      }
      function d(g) {
        let v;
        if (l.length > 8) {
          const y = (0, Af.schemaRefOrVal)(s, r.properties, "properties");
          v = (0, xf.isOwnProperty)(t, y, g);
        } else
          l.length
            ? (v = (0, ci.or)(...l.map((y) => (0, ci._)`${g} === ${y}`)))
            : (v = ci.nil);
        return (
          f.length &&
            (v = (0, ci.or)(
              v,
              ...f.map(
                (y) => (0, ci._)`${(0, xf.usePattern)(e, y)}.test(${g})`,
              ),
            )),
          (0, ci.not)(v)
        );
      }
      function p(g) {
        t.code((0, ci._)`delete ${i}[${g}]`);
      }
      function h(g) {
        if (c.removeAdditional === "all" || (c.removeAdditional && n === !1)) {
          p(g);
          return;
        }
        if (n === !1) {
          e.setParams({ additionalProperty: g }), e.error(), o || t.break();
          return;
        }
        if (typeof n == "object" && !(0, Af.alwaysValidSchema)(s, n)) {
          const v = t.name("valid");
          c.removeAdditional === "failing"
            ? (m(g, v, !1),
              t.if((0, ci.not)(v), () => {
                e.reset(), p(g);
              }))
            : (m(g, v), o || t.if((0, ci.not)(v), () => t.break()));
        }
      }
      function m(g, v, y) {
        const _ = {
          keyword: "additionalProperties",
          dataProp: g,
          dataPropType: Af.Type.Str,
        };
        y === !1 &&
          Object.assign(_, {
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1,
          }),
          e.subschema(_, v);
      }
    },
  };
Pp.default = SY;
var Ib = {};
Object.defineProperty(Ib, "__esModule", { value: !0 });
const IY = bi,
  Vx = It,
  Lm = Ft,
  Yx = Pp,
  $Y = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(e) {
      const { gen: t, schema: n, parentSchema: r, data: i, it: a } = e;
      a.opts.removeAdditional === "all" &&
        r.additionalProperties === void 0 &&
        Yx.default.code(
          new IY.KeywordCxt(a, Yx.default, "additionalProperties"),
        );
      const s = (0, Vx.allSchemaProperties)(n);
      for (const u of s) a.definedProperties.add(u);
      a.opts.unevaluated &&
        s.length &&
        a.props !== !0 &&
        (a.props = Lm.mergeEvaluated.props(t, (0, Lm.toHash)(s), a.props));
      const o = s.filter((u) => !(0, Lm.alwaysValidSchema)(a, n[u]));
      if (o.length === 0) return;
      const c = t.name("valid");
      for (const u of o)
        l(u)
          ? f(u)
          : (t.if((0, Vx.propertyInData)(t, i, u, a.opts.ownProperties)),
            f(u),
            a.allErrors || t.else().var(c, !0),
            t.endIf()),
          e.it.definedProperties.add(u),
          e.ok(c);
      function l(u) {
        return (
          a.opts.useDefaults && !a.compositeRule && n[u].default !== void 0
        );
      }
      function f(u) {
        e.subschema({ keyword: "properties", schemaProp: u, dataProp: u }, c);
      }
    },
  };
Ib.default = $Y;
var $b = {};
Object.defineProperty($b, "__esModule", { value: !0 });
const Xx = It,
  Sf = xt,
  Jx = Ft,
  Zx = Ft,
  CY = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(e) {
      const { gen: t, schema: n, data: r, parentSchema: i, it: a } = e,
        { opts: s } = a,
        o = (0, Xx.allSchemaProperties)(n),
        c = o.filter((m) => (0, Jx.alwaysValidSchema)(a, n[m]));
      if (
        o.length === 0 ||
        (c.length === o.length && (!a.opts.unevaluated || a.props === !0))
      )
        return;
      const l = s.strictSchema && !s.allowMatchingProperties && i.properties,
        f = t.name("valid");
      a.props !== !0 &&
        !(a.props instanceof Sf.Name) &&
        (a.props = (0, Zx.evaluatedPropsToName)(t, a.props));
      const { props: u } = a;
      d();
      function d() {
        for (const m of o)
          l && p(m), a.allErrors ? h(m) : (t.var(f, !0), h(m), t.if(f));
      }
      function p(m) {
        for (const g in l)
          new RegExp(m).test(g) &&
            (0, Jx.checkStrictMode)(
              a,
              `property ${g} matches pattern ${m} (use allowMatchingProperties)`,
            );
      }
      function h(m) {
        t.forIn("key", r, (g) => {
          t.if((0, Sf._)`${(0, Xx.usePattern)(e, m)}.test(${g})`, () => {
            const v = c.includes(m);
            v ||
              e.subschema(
                {
                  keyword: "patternProperties",
                  schemaProp: m,
                  dataProp: g,
                  dataPropType: Zx.Type.Str,
                },
                f,
              ),
              a.opts.unevaluated && u !== !0
                ? t.assign((0, Sf._)`${u}[${g}]`, !0)
                : !v && !a.allErrors && t.if((0, Sf.not)(f), () => t.break());
          });
        });
      }
    },
  };
$b.default = CY;
var Cb = {};
Object.defineProperty(Cb, "__esModule", { value: !0 });
const RY = Ft,
  kY = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(e) {
      const { gen: t, schema: n, it: r } = e;
      if ((0, RY.alwaysValidSchema)(r, n)) {
        e.fail();
        return;
      }
      const i = t.name("valid");
      e.subschema(
        { keyword: "not", compositeRule: !0, createErrors: !1, allErrors: !1 },
        i,
      ),
        e.failResult(
          i,
          () => e.reset(),
          () => e.error(),
        );
    },
    error: { message: "must NOT be valid" },
  };
Cb.default = kY;
var Rb = {};
Object.defineProperty(Rb, "__esModule", { value: !0 });
const TY = It,
  NY = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: TY.validateUnion,
    error: { message: "must match a schema in anyOf" },
  };
Rb.default = NY;
var kb = {};
Object.defineProperty(kb, "__esModule", { value: !0 });
const Kf = xt,
  OY = Ft,
  PY = {
    message: "must match exactly one schema in oneOf",
    params: ({ params: e }) => (0, Kf._)`{passingSchemas: ${e.passing}}`,
  },
  DY = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: PY,
    code(e) {
      const { gen: t, schema: n, parentSchema: r, it: i } = e;
      if (!Array.isArray(n)) throw new Error("ajv implementation error");
      if (i.opts.discriminator && r.discriminator) return;
      const a = n,
        s = t.let("valid", !1),
        o = t.let("passing", null),
        c = t.name("_valid");
      e.setParams({ passing: o }),
        t.block(l),
        e.result(
          s,
          () => e.reset(),
          () => e.error(!0),
        );
      function l() {
        a.forEach((f, u) => {
          let d;
          (0, OY.alwaysValidSchema)(i, f)
            ? t.var(c, !0)
            : (d = e.subschema(
                { keyword: "oneOf", schemaProp: u, compositeRule: !0 },
                c,
              )),
            u > 0 &&
              t
                .if((0, Kf._)`${c} && ${s}`)
                .assign(s, !1)
                .assign(o, (0, Kf._)`[${o}, ${u}]`)
                .else(),
            t.if(c, () => {
              t.assign(s, !0),
                t.assign(o, u),
                d && e.mergeEvaluated(d, Kf.Name);
            });
        });
      }
    },
  };
kb.default = DY;
var Tb = {};
Object.defineProperty(Tb, "__esModule", { value: !0 });
const LY = Ft,
  BY = {
    keyword: "allOf",
    schemaType: "array",
    code(e) {
      const { gen: t, schema: n, it: r } = e;
      if (!Array.isArray(n)) throw new Error("ajv implementation error");
      const i = t.name("valid");
      n.forEach((a, s) => {
        if ((0, LY.alwaysValidSchema)(r, a)) return;
        const o = e.subschema({ keyword: "allOf", schemaProp: s }, i);
        e.ok(i), e.mergeEvaluated(o);
      });
    },
  };
Tb.default = BY;
var Nb = {};
Object.defineProperty(Nb, "__esModule", { value: !0 });
const Cd = xt,
  OR = Ft,
  UY = {
    message: ({ params: e }) => (0, Cd.str)`must match "${e.ifClause}" schema`,
    params: ({ params: e }) => (0, Cd._)`{failingKeyword: ${e.ifClause}}`,
  },
  FY = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: UY,
    code(e) {
      const { gen: t, parentSchema: n, it: r } = e;
      n.then === void 0 &&
        n.else === void 0 &&
        (0, OR.checkStrictMode)(r, '"if" without "then" and "else" is ignored');
      const i = eA(r, "then"),
        a = eA(r, "else");
      if (!i && !a) return;
      const s = t.let("valid", !0),
        o = t.name("_valid");
      if ((c(), e.reset(), i && a)) {
        const f = t.let("ifClause");
        e.setParams({ ifClause: f }), t.if(o, l("then", f), l("else", f));
      } else i ? t.if(o, l("then")) : t.if((0, Cd.not)(o), l("else"));
      e.pass(s, () => e.error(!0));
      function c() {
        const f = e.subschema(
          { keyword: "if", compositeRule: !0, createErrors: !1, allErrors: !1 },
          o,
        );
        e.mergeEvaluated(f);
      }
      function l(f, u) {
        return () => {
          const d = e.subschema({ keyword: f }, o);
          t.assign(s, o),
            e.mergeValidEvaluated(d, s),
            u ? t.assign(u, (0, Cd._)`${f}`) : e.setParams({ ifClause: f });
        };
      }
    },
  };
function eA(e, t) {
  const n = e.schema[t];
  return n !== void 0 && !(0, OR.alwaysValidSchema)(e, n);
}
Nb.default = FY;
var Ob = {};
Object.defineProperty(Ob, "__esModule", { value: !0 });
const jY = Ft,
  MY = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: e, parentSchema: t, it: n }) {
      t.if === void 0 &&
        (0, jY.checkStrictMode)(n, `"${e}" without "if" is ignored`);
    },
  };
Ob.default = MY;
Object.defineProperty(Eb, "__esModule", { value: !0 });
const HY = Ic,
  qY = wb,
  GY = $c,
  QY = xb,
  WY = Ab,
  zY = TR,
  KY = Sb,
  VY = Pp,
  YY = Ib,
  XY = $b,
  JY = Cb,
  ZY = Rb,
  eX = kb,
  tX = Tb,
  nX = Nb,
  rX = Ob;
function iX(e = !1) {
  const t = [
    JY.default,
    ZY.default,
    eX.default,
    tX.default,
    nX.default,
    rX.default,
    KY.default,
    VY.default,
    zY.default,
    YY.default,
    XY.default,
  ];
  return (
    e ? t.push(qY.default, QY.default) : t.push(HY.default, GY.default),
    t.push(WY.default),
    t
  );
}
Eb.default = iX;
var Pb = {},
  Db = {};
Object.defineProperty(Db, "__esModule", { value: !0 });
const Rn = xt,
  aX = {
    message: ({ schemaCode: e }) => (0, Rn.str)`must match format "${e}"`,
    params: ({ schemaCode: e }) => (0, Rn._)`{format: ${e}}`,
  },
  sX = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: aX,
    code(e, t) {
      const { gen: n, data: r, $data: i, schema: a, schemaCode: s, it: o } = e,
        { opts: c, errSchemaPath: l, schemaEnv: f, self: u } = o;
      if (!c.validateFormats) return;
      i ? d() : p();
      function d() {
        const h = n.scopeValue("formats", {
            ref: u.formats,
            code: c.code.formats,
          }),
          m = n.const("fDef", (0, Rn._)`${h}[${s}]`),
          g = n.let("fType"),
          v = n.let("format");
        n.if(
          (0, Rn._)`typeof ${m} == "object" && !(${m} instanceof RegExp)`,
          () =>
            n
              .assign(g, (0, Rn._)`${m}.type || "string"`)
              .assign(v, (0, Rn._)`${m}.validate`),
          () => n.assign(g, (0, Rn._)`"string"`).assign(v, m),
        ),
          e.fail$data((0, Rn.or)(y(), _()));
        function y() {
          return c.strictSchema === !1 ? Rn.nil : (0, Rn._)`${s} && !${v}`;
        }
        function _() {
          const E = f.$async
              ? (0, Rn._)`(${m}.async ? await ${v}(${r}) : ${v}(${r}))`
              : (0, Rn._)`${v}(${r})`,
            R = (0, Rn._)`(typeof ${v} == "function" ? ${E} : ${v}.test(${r}))`;
          return (0, Rn._)`${v} && ${v} !== true && ${g} === ${t} && !${R}`;
        }
      }
      function p() {
        const h = u.formats[a];
        if (!h) {
          y();
          return;
        }
        if (h === !0) return;
        const [m, g, v] = _(h);
        m === t && e.pass(E());
        function y() {
          if (c.strictSchema === !1) {
            u.logger.warn(R());
            return;
          }
          throw new Error(R());
          function R() {
            return `unknown format "${a}" ignored in schema at path "${l}"`;
          }
        }
        function _(R) {
          const A =
              R instanceof RegExp
                ? (0, Rn.regexpCode)(R)
                : c.code.formats
                ? (0, Rn._)`${c.code.formats}${(0, Rn.getProperty)(a)}`
                : void 0,
            I = n.scopeValue("formats", { key: a, ref: R, code: A });
          return typeof R == "object" && !(R instanceof RegExp)
            ? [R.type || "string", R.validate, (0, Rn._)`${I}.validate`]
            : ["string", R, I];
        }
        function E() {
          if (typeof h == "object" && !(h instanceof RegExp) && h.async) {
            if (!f.$async) throw new Error("async format in sync schema");
            return (0, Rn._)`await ${v}(${r})`;
          }
          return typeof g == "function"
            ? (0, Rn._)`${v}(${r})`
            : (0, Rn._)`${v}.test(${r})`;
        }
      }
    },
  };
Db.default = sX;
Object.defineProperty(Pb, "__esModule", { value: !0 });
const oX = Db,
  cX = [oX.default];
Pb.default = cX;
var cc = {};
Object.defineProperty(cc, "__esModule", { value: !0 });
cc.contentVocabulary = cc.metadataVocabulary = void 0;
cc.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples",
];
cc.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
Object.defineProperty(sb, "__esModule", { value: !0 });
const lX = ob,
  uX = lb,
  fX = Eb,
  dX = Pb,
  tA = cc,
  pX = [
    lX.default,
    uX.default,
    (0, fX.default)(),
    dX.default,
    tA.metadataVocabulary,
    tA.contentVocabulary,
  ];
sb.default = pX;
var Lb = {},
  PR = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.DiscrError = void 0),
    (function (t) {
      (t.Tag = "tag"), (t.Mapping = "mapping");
    })(e.DiscrError || (e.DiscrError = {}));
})(PR);
Object.defineProperty(Lb, "__esModule", { value: !0 });
const So = xt,
  T0 = PR,
  nA = Lr,
  hX = Ft,
  mX = {
    message: ({ params: { discrError: e, tagName: t } }) =>
      e === T0.DiscrError.Tag
        ? `tag "${t}" must be string`
        : `value of tag "${t}" must be in oneOf`,
    params: ({ params: { discrError: e, tag: t, tagName: n } }) =>
      (0, So._)`{error: ${e}, tag: ${n}, tagValue: ${t}}`,
  },
  gX = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: mX,
    code(e) {
      const { gen: t, data: n, schema: r, parentSchema: i, it: a } = e,
        { oneOf: s } = i;
      if (!a.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const o = r.propertyName;
      if (typeof o != "string")
        throw new Error("discriminator: requires propertyName");
      if (r.mapping) throw new Error("discriminator: mapping is not supported");
      if (!s) throw new Error("discriminator: requires oneOf keyword");
      const c = t.let("valid", !1),
        l = t.const("tag", (0, So._)`${n}${(0, So.getProperty)(o)}`);
      t.if(
        (0, So._)`typeof ${l} == "string"`,
        () => f(),
        () =>
          e.error(!1, { discrError: T0.DiscrError.Tag, tag: l, tagName: o }),
      ),
        e.ok(c);
      function f() {
        const p = d();
        t.if(!1);
        for (const h in p)
          t.elseIf((0, So._)`${l} === ${h}`), t.assign(c, u(p[h]));
        t.else(),
          e.error(!1, {
            discrError: T0.DiscrError.Mapping,
            tag: l,
            tagName: o,
          }),
          t.endIf();
      }
      function u(p) {
        const h = t.name("valid"),
          m = e.subschema({ keyword: "oneOf", schemaProp: p }, h);
        return e.mergeEvaluated(m, So.Name), h;
      }
      function d() {
        var p;
        const h = {},
          m = v(i);
        let g = !0;
        for (let E = 0; E < s.length; E++) {
          let R = s[E];
          R != null &&
            R.$ref &&
            !(0, hX.schemaHasRulesButRef)(R, a.self.RULES) &&
            ((R = nA.resolveRef.call(
              a.self,
              a.schemaEnv.root,
              a.baseId,
              R == null ? void 0 : R.$ref,
            )),
            R instanceof nA.SchemaEnv && (R = R.schema));
          const A =
            (p = R == null ? void 0 : R.properties) === null || p === void 0
              ? void 0
              : p[o];
          if (typeof A != "object")
            throw new Error(
              `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${o}"`,
            );
          (g = g && (m || v(R))), y(A, E);
        }
        if (!g) throw new Error(`discriminator: "${o}" must be required`);
        return h;
        function v({ required: E }) {
          return Array.isArray(E) && E.includes(o);
        }
        function y(E, R) {
          if (E.const) _(E.const, R);
          else if (E.enum) for (const A of E.enum) _(A, R);
          else
            throw new Error(
              `discriminator: "properties/${o}" must have "const" or "enum"`,
            );
        }
        function _(E, R) {
          if (typeof E != "string" || E in h)
            throw new Error(
              `discriminator: "${o}" values must be unique strings`,
            );
          h[E] = R;
        }
      }
    },
  };
Lb.default = gX;
const vX = "http://json-schema.org/draft-07/schema#",
  yX = "http://json-schema.org/draft-07/schema#",
  bX = "Core schema meta-schema",
  _X = {
    schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
    nonNegativeInteger: { type: "integer", minimum: 0 },
    nonNegativeIntegerDefault0: {
      allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
    },
    simpleTypes: {
      enum: [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string",
      ],
    },
    stringArray: {
      type: "array",
      items: { type: "string" },
      uniqueItems: !0,
      default: [],
    },
  },
  EX = ["object", "boolean"],
  wX = {
    $id: { type: "string", format: "uri-reference" },
    $schema: { type: "string", format: "uri" },
    $ref: { type: "string", format: "uri-reference" },
    $comment: { type: "string" },
    title: { type: "string" },
    description: { type: "string" },
    default: !0,
    readOnly: { type: "boolean", default: !1 },
    examples: { type: "array", items: !0 },
    multipleOf: { type: "number", exclusiveMinimum: 0 },
    maximum: { type: "number" },
    exclusiveMaximum: { type: "number" },
    minimum: { type: "number" },
    exclusiveMinimum: { type: "number" },
    maxLength: { $ref: "#/definitions/nonNegativeInteger" },
    minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
    pattern: { type: "string", format: "regex" },
    additionalItems: { $ref: "#" },
    items: {
      anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
      default: !0,
    },
    maxItems: { $ref: "#/definitions/nonNegativeInteger" },
    minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
    uniqueItems: { type: "boolean", default: !1 },
    contains: { $ref: "#" },
    maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
    minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
    required: { $ref: "#/definitions/stringArray" },
    additionalProperties: { $ref: "#" },
    definitions: {
      type: "object",
      additionalProperties: { $ref: "#" },
      default: {},
    },
    properties: {
      type: "object",
      additionalProperties: { $ref: "#" },
      default: {},
    },
    patternProperties: {
      type: "object",
      additionalProperties: { $ref: "#" },
      propertyNames: { format: "regex" },
      default: {},
    },
    dependencies: {
      type: "object",
      additionalProperties: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
      },
    },
    propertyNames: { $ref: "#" },
    const: !0,
    enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 },
    type: {
      anyOf: [
        { $ref: "#/definitions/simpleTypes" },
        {
          type: "array",
          items: { $ref: "#/definitions/simpleTypes" },
          minItems: 1,
          uniqueItems: !0,
        },
      ],
    },
    format: { type: "string" },
    contentMediaType: { type: "string" },
    contentEncoding: { type: "string" },
    if: { $ref: "#" },
    then: { $ref: "#" },
    else: { $ref: "#" },
    allOf: { $ref: "#/definitions/schemaArray" },
    anyOf: { $ref: "#/definitions/schemaArray" },
    oneOf: { $ref: "#/definitions/schemaArray" },
    not: { $ref: "#" },
  },
  xX = {
    $schema: vX,
    $id: yX,
    title: bX,
    definitions: _X,
    type: EX,
    properties: wX,
    default: !0,
  };
(function (e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.MissingRefError =
      t.ValidationError =
      t.CodeGen =
      t.Name =
      t.nil =
      t.stringify =
      t.str =
      t._ =
      t.KeywordCxt =
        void 0);
  const n = tR,
    r = sb,
    i = Lb,
    a = xX,
    s = ["/properties"],
    o = "http://json-schema.org/draft-07/schema";
  class c extends n.default {
    _addVocabularies() {
      super._addVocabularies(),
        r.default.forEach((h) => this.addVocabulary(h)),
        this.opts.discriminator && this.addKeyword(i.default);
    }
    _addDefaultMetaSchema() {
      if ((super._addDefaultMetaSchema(), !this.opts.meta)) return;
      const h = this.opts.$data ? this.$dataMetaSchema(a, s) : a;
      this.addMetaSchema(h, o, !1),
        (this.refs["http://json-schema.org/schema"] = o);
    }
    defaultMeta() {
      return (this.opts.defaultMeta =
        super.defaultMeta() || (this.getSchema(o) ? o : void 0));
    }
  }
  (e.exports = t = c),
    Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.default = c);
  var l = bi;
  Object.defineProperty(t, "KeywordCxt", {
    enumerable: !0,
    get: function () {
      return l.KeywordCxt;
    },
  });
  var f = xt;
  Object.defineProperty(t, "_", {
    enumerable: !0,
    get: function () {
      return f._;
    },
  }),
    Object.defineProperty(t, "str", {
      enumerable: !0,
      get: function () {
        return f.str;
      },
    }),
    Object.defineProperty(t, "stringify", {
      enumerable: !0,
      get: function () {
        return f.stringify;
      },
    }),
    Object.defineProperty(t, "nil", {
      enumerable: !0,
      get: function () {
        return f.nil;
      },
    }),
    Object.defineProperty(t, "Name", {
      enumerable: !0,
      get: function () {
        return f.Name;
      },
    }),
    Object.defineProperty(t, "CodeGen", {
      enumerable: !0,
      get: function () {
        return f.CodeGen;
      },
    });
  var u = mu;
  Object.defineProperty(t, "ValidationError", {
    enumerable: !0,
    get: function () {
      return u.default;
    },
  });
  var d = gu;
  Object.defineProperty(t, "MissingRefError", {
    enumerable: !0,
    get: function () {
      return d.default;
    },
  });
})(I0, I0.exports);
var AX = I0.exports;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.formatLimitDefinition = void 0);
  const t = AX,
    n = xt,
    r = n.operators,
    i = {
      formatMaximum: { okStr: "<=", ok: r.LTE, fail: r.GT },
      formatMinimum: { okStr: ">=", ok: r.GTE, fail: r.LT },
      formatExclusiveMaximum: { okStr: "<", ok: r.LT, fail: r.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: r.GT, fail: r.LTE },
    },
    a = {
      message: ({ keyword: o, schemaCode: c }) =>
        n.str`should be ${i[o].okStr} ${c}`,
      params: ({ keyword: o, schemaCode: c }) =>
        n._`{comparison: ${i[o].okStr}, limit: ${c}}`,
    };
  e.formatLimitDefinition = {
    keyword: Object.keys(i),
    type: "string",
    schemaType: "string",
    $data: !0,
    error: a,
    code(o) {
      const { gen: c, data: l, schemaCode: f, keyword: u, it: d } = o,
        { opts: p, self: h } = d;
      if (!p.validateFormats) return;
      const m = new t.KeywordCxt(d, h.RULES.all.format.definition, "format");
      m.$data ? g() : v();
      function g() {
        const _ = c.scopeValue("formats", {
            ref: h.formats,
            code: p.code.formats,
          }),
          E = c.const("fmt", n._`${_}[${m.schemaCode}]`);
        o.fail$data(
          n.or(
            n._`typeof ${E} != "object"`,
            n._`${E} instanceof RegExp`,
            n._`typeof ${E}.compare != "function"`,
            y(E),
          ),
        );
      }
      function v() {
        const _ = m.schema,
          E = h.formats[_];
        if (!E || E === !0) return;
        if (
          typeof E != "object" ||
          E instanceof RegExp ||
          typeof E.compare != "function"
        )
          throw new Error(
            `"${u}": format "${_}" does not define "compare" function`,
          );
        const R = c.scopeValue("formats", {
          key: _,
          ref: E,
          code: p.code.formats
            ? n._`${p.code.formats}${n.getProperty(_)}`
            : void 0,
        });
        o.fail$data(y(R));
      }
      function y(_) {
        return n._`${_}.compare(${l}, ${f}) ${i[u].fail} 0`;
      }
    },
    dependencies: ["format"],
  };
  const s = (o) => (o.addKeyword(e.formatLimitDefinition), o);
  e.default = s;
})(eR);
(function (e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const n = Z4,
    r = eR,
    i = xt,
    a = new i.Name("fullFormats"),
    s = new i.Name("fastFormats"),
    o = (l, f = { keywords: !0 }) => {
      if (Array.isArray(f)) return c(l, f, n.fullFormats, a), l;
      const [u, d] =
          f.mode === "fast" ? [n.fastFormats, s] : [n.fullFormats, a],
        p = f.formats || n.formatNames;
      return c(l, p, u, d), f.keywords && r.default(l), l;
    };
  o.get = (l, f = "full") => {
    const d = (f === "fast" ? n.fastFormats : n.fullFormats)[l];
    if (!d) throw new Error(`Unknown format "${l}"`);
    return d;
  };
  function c(l, f, u, d) {
    var p, h;
    ((p = (h = l.opts.code).formats) !== null && p !== void 0) ||
      (h.formats = i._`require("ajv-formats/dist/formats").${d}`);
    for (const m of f) l.addFormat(m, u[m]);
  }
  (e.exports = t = o),
    Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.default = o);
})(S0, S0.exports);
var SX = S0.exports;
const IX = (e, t, n, r) => {
    if (
      n === "length" ||
      n === "prototype" ||
      n === "arguments" ||
      n === "caller"
    )
      return;
    const i = Object.getOwnPropertyDescriptor(e, n),
      a = Object.getOwnPropertyDescriptor(t, n);
    (!$X(i, a) && r) || Object.defineProperty(e, n, a);
  },
  $X = function (e, t) {
    return (
      e === void 0 ||
      e.configurable ||
      (e.writable === t.writable &&
        e.enumerable === t.enumerable &&
        e.configurable === t.configurable &&
        (e.writable || e.value === t.value))
    );
  },
  CX = (e, t) => {
    const n = Object.getPrototypeOf(t);
    n !== Object.getPrototypeOf(e) && Object.setPrototypeOf(e, n);
  },
  RX = (e, t) => `/* Wrapped ${e}*/
${t}`,
  kX = Object.getOwnPropertyDescriptor(Function.prototype, "toString"),
  TX = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"),
  NX = (e, t, n) => {
    const r = n === "" ? "" : `with ${n.trim()}() `,
      i = RX.bind(null, r, t.toString());
    Object.defineProperty(i, "name", TX),
      Object.defineProperty(e, "toString", { ...kX, value: i });
  },
  OX = (e, t, { ignoreNonConfigurable: n = !1 } = {}) => {
    const { name: r } = e;
    for (const i of Reflect.ownKeys(t)) IX(e, t, i, n);
    return CX(e, t), NX(e, t, r), e;
  };
var PX = OX;
const DX = PX;
var LX = (e, t = {}) => {
    if (typeof e != "function")
      throw new TypeError(
        `Expected the first argument to be a function, got \`${typeof e}\``,
      );
    const { wait: n = 0, before: r = !1, after: i = !0 } = t;
    if (!r && !i)
      throw new Error(
        "Both `before` and `after` are false, function wouldn't be called.",
      );
    let a, s;
    const o = function (...c) {
      const l = this,
        f = () => {
          (a = void 0), i && (s = e.apply(l, c));
        },
        u = r && !a;
      return (
        clearTimeout(a), (a = setTimeout(f, n)), u && (s = e.apply(l, c)), s
      );
    };
    return (
      DX(o, e),
      (o.cancel = () => {
        a && (clearTimeout(a), (a = void 0));
      }),
      o
    );
  },
  N0 = { exports: {} };
const BX = "2.0.0",
  DR = 256,
  UX = Number.MAX_SAFE_INTEGER || 9007199254740991,
  FX = 16,
  jX = DR - 6,
  MX = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease",
  ];
var Dp = {
  MAX_LENGTH: DR,
  MAX_SAFE_COMPONENT_LENGTH: FX,
  MAX_SAFE_BUILD_LENGTH: jX,
  MAX_SAFE_INTEGER: UX,
  RELEASE_TYPES: MX,
  SEMVER_SPEC_VERSION: BX,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2,
};
const HX =
  typeof process == "object" &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
    ? (...e) => console.error("SEMVER", ...e)
    : () => {};
var Lp = HX;
(function (e, t) {
  const {
      MAX_SAFE_COMPONENT_LENGTH: n,
      MAX_SAFE_BUILD_LENGTH: r,
      MAX_LENGTH: i,
    } = Dp,
    a = Lp;
  t = e.exports = {};
  const s = (t.re = []),
    o = (t.safeRe = []),
    c = (t.src = []),
    l = (t.t = {});
  let f = 0;
  const u = "[a-zA-Z0-9-]",
    d = [
      ["\\s", 1],
      ["\\d", i],
      [u, r],
    ],
    p = (m) => {
      for (const [g, v] of d)
        m = m
          .split(`${g}*`)
          .join(`${g}{0,${v}}`)
          .split(`${g}+`)
          .join(`${g}{1,${v}}`);
      return m;
    },
    h = (m, g, v) => {
      const y = p(g),
        _ = f++;
      a(m, _, g),
        (l[m] = _),
        (c[_] = g),
        (s[_] = new RegExp(g, v ? "g" : void 0)),
        (o[_] = new RegExp(y, v ? "g" : void 0));
    };
  h("NUMERICIDENTIFIER", "0|[1-9]\\d*"),
    h("NUMERICIDENTIFIERLOOSE", "\\d+"),
    h("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${u}*`),
    h(
      "MAINVERSION",
      `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${
        c[l.NUMERICIDENTIFIER]
      })`,
    ),
    h(
      "MAINVERSIONLOOSE",
      `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${
        c[l.NUMERICIDENTIFIERLOOSE]
      })`,
    ),
    h(
      "PRERELEASEIDENTIFIER",
      `(?:${c[l.NUMERICIDENTIFIER]}|${c[l.NONNUMERICIDENTIFIER]})`,
    ),
    h(
      "PRERELEASEIDENTIFIERLOOSE",
      `(?:${c[l.NUMERICIDENTIFIERLOOSE]}|${c[l.NONNUMERICIDENTIFIER]})`,
    ),
    h(
      "PRERELEASE",
      `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`,
    ),
    h(
      "PRERELEASELOOSE",
      `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${
        c[l.PRERELEASEIDENTIFIERLOOSE]
      })*))`,
    ),
    h("BUILDIDENTIFIER", `${u}+`),
    h(
      "BUILD",
      `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`,
    ),
    h("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`),
    h("FULL", `^${c[l.FULLPLAIN]}$`),
    h(
      "LOOSEPLAIN",
      `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`,
    ),
    h("LOOSE", `^${c[l.LOOSEPLAIN]}$`),
    h("GTLT", "((?:<|>)?=?)"),
    h("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
    h("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`),
    h(
      "XRANGEPLAIN",
      `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${
        c[l.XRANGEIDENTIFIER]
      })(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${
        c[l.BUILD]
      }?)?)?`,
    ),
    h(
      "XRANGEPLAINLOOSE",
      `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${
        c[l.XRANGEIDENTIFIERLOOSE]
      })(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${
        c[l.BUILD]
      }?)?)?`,
    ),
    h("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`),
    h("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`),
    h(
      "COERCE",
      `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`,
    ),
    h("COERCERTL", c[l.COERCE], !0),
    h("LONETILDE", "(?:~>?)"),
    h("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0),
    (t.tildeTrimReplace = "$1~"),
    h("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`),
    h("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`),
    h("LONECARET", "(?:\\^)"),
    h("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0),
    (t.caretTrimReplace = "$1^"),
    h("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`),
    h("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`),
    h("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`),
    h("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`),
    h(
      "COMPARATORTRIM",
      `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`,
      !0,
    ),
    (t.comparatorTrimReplace = "$1$2$3"),
    h(
      "HYPHENRANGE",
      `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`,
    ),
    h(
      "HYPHENRANGELOOSE",
      `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`,
    ),
    h("STAR", "(<|>)?=?\\s*\\*"),
    h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"),
    h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(N0, N0.exports);
var yu = N0.exports;
const qX = Object.freeze({ loose: !0 }),
  GX = Object.freeze({}),
  QX = (e) => (e ? (typeof e != "object" ? qX : e) : GX);
var Bb = QX;
const rA = /^[0-9]+$/,
  LR = (e, t) => {
    const n = rA.test(e),
      r = rA.test(t);
    return (
      n && r && ((e = +e), (t = +t)),
      e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1
    );
  },
  WX = (e, t) => LR(t, e);
var BR = { compareIdentifiers: LR, rcompareIdentifiers: WX };
const If = Lp,
  { MAX_LENGTH: iA, MAX_SAFE_INTEGER: $f } = Dp,
  { safeRe: aA, t: sA } = yu,
  zX = Bb,
  { compareIdentifiers: mo } = BR;
let KX = class Ti {
  constructor(t, n) {
    if (((n = zX(n)), t instanceof Ti)) {
      if (
        t.loose === !!n.loose &&
        t.includePrerelease === !!n.includePrerelease
      )
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(
        `Invalid version. Must be a string. Got type "${typeof t}".`,
      );
    if (t.length > iA)
      throw new TypeError(`version is longer than ${iA} characters`);
    If("SemVer", t, n),
      (this.options = n),
      (this.loose = !!n.loose),
      (this.includePrerelease = !!n.includePrerelease);
    const r = t.trim().match(n.loose ? aA[sA.LOOSE] : aA[sA.FULL]);
    if (!r) throw new TypeError(`Invalid Version: ${t}`);
    if (
      ((this.raw = t),
      (this.major = +r[1]),
      (this.minor = +r[2]),
      (this.patch = +r[3]),
      this.major > $f || this.major < 0)
    )
      throw new TypeError("Invalid major version");
    if (this.minor > $f || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > $f || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4]
      ? (this.prerelease = r[4].split(".").map((i) => {
          if (/^[0-9]+$/.test(i)) {
            const a = +i;
            if (a >= 0 && a < $f) return a;
          }
          return i;
        }))
      : (this.prerelease = []),
      (this.build = r[5] ? r[5].split(".") : []),
      this.format();
  }
  format() {
    return (
      (this.version = `${this.major}.${this.minor}.${this.patch}`),
      this.prerelease.length &&
        (this.version += `-${this.prerelease.join(".")}`),
      this.version
    );
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (
      (If("SemVer.compare", this.version, this.options, t), !(t instanceof Ti))
    ) {
      if (typeof t == "string" && t === this.version) return 0;
      t = new Ti(t, this.options);
    }
    return t.version === this.version
      ? 0
      : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return (
      t instanceof Ti || (t = new Ti(t, this.options)),
      mo(this.major, t.major) ||
        mo(this.minor, t.minor) ||
        mo(this.patch, t.patch)
    );
  }
  comparePre(t) {
    if (
      (t instanceof Ti || (t = new Ti(t, this.options)),
      this.prerelease.length && !t.prerelease.length)
    )
      return -1;
    if (!this.prerelease.length && t.prerelease.length) return 1;
    if (!this.prerelease.length && !t.prerelease.length) return 0;
    let n = 0;
    do {
      const r = this.prerelease[n],
        i = t.prerelease[n];
      if ((If("prerelease compare", n, r, i), r === void 0 && i === void 0))
        return 0;
      if (i === void 0) return 1;
      if (r === void 0) return -1;
      if (r === i) continue;
      return mo(r, i);
    } while (++n);
  }
  compareBuild(t) {
    t instanceof Ti || (t = new Ti(t, this.options));
    let n = 0;
    do {
      const r = this.build[n],
        i = t.build[n];
      if ((If("prerelease compare", n, r, i), r === void 0 && i === void 0))
        return 0;
      if (i === void 0) return 1;
      if (r === void 0) return -1;
      if (r === i) continue;
      return mo(r, i);
    } while (++n);
  }
  inc(t, n, r) {
    switch (t) {
      case "premajor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          (this.minor = 0),
          this.major++,
          this.inc("pre", n, r);
        break;
      case "preminor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          this.minor++,
          this.inc("pre", n, r);
        break;
      case "prepatch":
        (this.prerelease.length = 0),
          this.inc("patch", n, r),
          this.inc("pre", n, r);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", n, r),
          this.inc("pre", n, r);
        break;
      case "major":
        (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) &&
          this.major++,
          (this.minor = 0),
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, (this.prerelease = []);
        break;
      case "pre": {
        const i = Number(r) ? 1 : 0;
        if (!n && r === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0) this.prerelease = [i];
        else {
          let a = this.prerelease.length;
          for (; --a >= 0; )
            typeof this.prerelease[a] == "number" &&
              (this.prerelease[a]++, (a = -2));
          if (a === -1) {
            if (n === this.prerelease.join(".") && r === !1)
              throw new Error(
                "invalid increment argument: identifier already exists",
              );
            this.prerelease.push(i);
          }
        }
        if (n) {
          let a = [n, i];
          r === !1 && (a = [n]),
            mo(this.prerelease[0], n) === 0
              ? isNaN(this.prerelease[1]) && (this.prerelease = a)
              : (this.prerelease = a);
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return (
      (this.raw = this.format()),
      this.build.length && (this.raw += `+${this.build.join(".")}`),
      this
    );
  }
};
var $r = KX;
const oA = $r,
  VX = (e, t, n = !1) => {
    if (e instanceof oA) return e;
    try {
      return new oA(e, t);
    } catch (r) {
      if (!n) return null;
      throw r;
    }
  };
var Cc = VX;
const YX = Cc,
  XX = (e, t) => {
    const n = YX(e, t);
    return n ? n.version : null;
  };
var JX = XX;
const ZX = Cc,
  eJ = (e, t) => {
    const n = ZX(e.trim().replace(/^[=v]+/, ""), t);
    return n ? n.version : null;
  };
var tJ = eJ;
const cA = $r,
  nJ = (e, t, n, r, i) => {
    typeof n == "string" && ((i = r), (r = n), (n = void 0));
    try {
      return new cA(e instanceof cA ? e.version : e, n).inc(t, r, i).version;
    } catch {
      return null;
    }
  };
var rJ = nJ;
const lA = Cc,
  iJ = (e, t) => {
    const n = lA(e, null, !0),
      r = lA(t, null, !0),
      i = n.compare(r);
    if (i === 0) return null;
    const a = i > 0,
      s = a ? n : r,
      o = a ? r : n,
      c = !!s.prerelease.length;
    if (!!o.prerelease.length && !c)
      return !o.patch && !o.minor
        ? "major"
        : s.patch
        ? "patch"
        : s.minor
        ? "minor"
        : "major";
    const f = c ? "pre" : "";
    return n.major !== r.major
      ? f + "major"
      : n.minor !== r.minor
      ? f + "minor"
      : n.patch !== r.patch
      ? f + "patch"
      : "prerelease";
  };
var aJ = iJ;
const sJ = $r,
  oJ = (e, t) => new sJ(e, t).major;
var cJ = oJ;
const lJ = $r,
  uJ = (e, t) => new lJ(e, t).minor;
var fJ = uJ;
const dJ = $r,
  pJ = (e, t) => new dJ(e, t).patch;
var hJ = pJ;
const mJ = Cc,
  gJ = (e, t) => {
    const n = mJ(e, t);
    return n && n.prerelease.length ? n.prerelease : null;
  };
var vJ = gJ;
const uA = $r,
  yJ = (e, t, n) => new uA(e, n).compare(new uA(t, n));
var $i = yJ;
const bJ = $i,
  _J = (e, t, n) => bJ(t, e, n);
var EJ = _J;
const wJ = $i,
  xJ = (e, t) => wJ(e, t, !0);
var AJ = xJ;
const fA = $r,
  SJ = (e, t, n) => {
    const r = new fA(e, n),
      i = new fA(t, n);
    return r.compare(i) || r.compareBuild(i);
  };
var Ub = SJ;
const IJ = Ub,
  $J = (e, t) => e.sort((n, r) => IJ(n, r, t));
var CJ = $J;
const RJ = Ub,
  kJ = (e, t) => e.sort((n, r) => RJ(r, n, t));
var TJ = kJ;
const NJ = $i,
  OJ = (e, t, n) => NJ(e, t, n) > 0;
var Bp = OJ;
const PJ = $i,
  DJ = (e, t, n) => PJ(e, t, n) < 0;
var Fb = DJ;
const LJ = $i,
  BJ = (e, t, n) => LJ(e, t, n) === 0;
var UR = BJ;
const UJ = $i,
  FJ = (e, t, n) => UJ(e, t, n) !== 0;
var FR = FJ;
const jJ = $i,
  MJ = (e, t, n) => jJ(e, t, n) >= 0;
var jb = MJ;
const HJ = $i,
  qJ = (e, t, n) => HJ(e, t, n) <= 0;
var Mb = qJ;
const GJ = UR,
  QJ = FR,
  WJ = Bp,
  zJ = jb,
  KJ = Fb,
  VJ = Mb,
  YJ = (e, t, n, r) => {
    switch (t) {
      case "===":
        return (
          typeof e == "object" && (e = e.version),
          typeof n == "object" && (n = n.version),
          e === n
        );
      case "!==":
        return (
          typeof e == "object" && (e = e.version),
          typeof n == "object" && (n = n.version),
          e !== n
        );
      case "":
      case "=":
      case "==":
        return GJ(e, n, r);
      case "!=":
        return QJ(e, n, r);
      case ">":
        return WJ(e, n, r);
      case ">=":
        return zJ(e, n, r);
      case "<":
        return KJ(e, n, r);
      case "<=":
        return VJ(e, n, r);
      default:
        throw new TypeError(`Invalid operator: ${t}`);
    }
  };
var jR = YJ;
const XJ = $r,
  JJ = Cc,
  { safeRe: Cf, t: Rf } = yu,
  ZJ = (e, t) => {
    if (e instanceof XJ) return e;
    if ((typeof e == "number" && (e = String(e)), typeof e != "string"))
      return null;
    t = t || {};
    let n = null;
    if (!t.rtl) n = e.match(Cf[Rf.COERCE]);
    else {
      let r;
      for (
        ;
        (r = Cf[Rf.COERCERTL].exec(e)) &&
        (!n || n.index + n[0].length !== e.length);

      )
        (!n || r.index + r[0].length !== n.index + n[0].length) && (n = r),
          (Cf[Rf.COERCERTL].lastIndex = r.index + r[1].length + r[2].length);
      Cf[Rf.COERCERTL].lastIndex = -1;
    }
    return n === null ? null : JJ(`${n[2]}.${n[3] || "0"}.${n[4] || "0"}`, t);
  };
var eZ = ZJ,
  Bm,
  dA;
function tZ() {
  return (
    dA ||
      ((dA = 1),
      (Bm = function (e) {
        e.prototype[Symbol.iterator] = function* () {
          for (let t = this.head; t; t = t.next) yield t.value;
        };
      })),
    Bm
  );
}
var nZ = Ht;
Ht.Node = qs;
Ht.create = Ht;
function Ht(e) {
  var t = this;
  if (
    (t instanceof Ht || (t = new Ht()),
    (t.tail = null),
    (t.head = null),
    (t.length = 0),
    e && typeof e.forEach == "function")
  )
    e.forEach(function (i) {
      t.push(i);
    });
  else if (arguments.length > 0)
    for (var n = 0, r = arguments.length; n < r; n++) t.push(arguments[n]);
  return t;
}
Ht.prototype.removeNode = function (e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next,
    n = e.prev;
  return (
    t && (t.prev = n),
    n && (n.next = t),
    e === this.head && (this.head = t),
    e === this.tail && (this.tail = n),
    e.list.length--,
    (e.next = null),
    (e.prev = null),
    (e.list = null),
    t
  );
};
Ht.prototype.unshiftNode = function (e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    (e.list = this),
      (e.next = t),
      t && (t.prev = e),
      (this.head = e),
      this.tail || (this.tail = e),
      this.length++;
  }
};
Ht.prototype.pushNode = function (e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    (e.list = this),
      (e.prev = t),
      t && (t.next = e),
      (this.tail = e),
      this.head || (this.head = e),
      this.length++;
  }
};
Ht.prototype.push = function () {
  for (var e = 0, t = arguments.length; e < t; e++) iZ(this, arguments[e]);
  return this.length;
};
Ht.prototype.unshift = function () {
  for (var e = 0, t = arguments.length; e < t; e++) aZ(this, arguments[e]);
  return this.length;
};
Ht.prototype.pop = function () {
  if (this.tail) {
    var e = this.tail.value;
    return (
      (this.tail = this.tail.prev),
      this.tail ? (this.tail.next = null) : (this.head = null),
      this.length--,
      e
    );
  }
};
Ht.prototype.shift = function () {
  if (this.head) {
    var e = this.head.value;
    return (
      (this.head = this.head.next),
      this.head ? (this.head.prev = null) : (this.tail = null),
      this.length--,
      e
    );
  }
};
Ht.prototype.forEach = function (e, t) {
  t = t || this;
  for (var n = this.head, r = 0; n !== null; r++)
    e.call(t, n.value, r, this), (n = n.next);
};
Ht.prototype.forEachReverse = function (e, t) {
  t = t || this;
  for (var n = this.tail, r = this.length - 1; n !== null; r--)
    e.call(t, n.value, r, this), (n = n.prev);
};
Ht.prototype.get = function (e) {
  for (var t = 0, n = this.head; n !== null && t < e; t++) n = n.next;
  if (t === e && n !== null) return n.value;
};
Ht.prototype.getReverse = function (e) {
  for (var t = 0, n = this.tail; n !== null && t < e; t++) n = n.prev;
  if (t === e && n !== null) return n.value;
};
Ht.prototype.map = function (e, t) {
  t = t || this;
  for (var n = new Ht(), r = this.head; r !== null; )
    n.push(e.call(t, r.value, this)), (r = r.next);
  return n;
};
Ht.prototype.mapReverse = function (e, t) {
  t = t || this;
  for (var n = new Ht(), r = this.tail; r !== null; )
    n.push(e.call(t, r.value, this)), (r = r.prev);
  return n;
};
Ht.prototype.reduce = function (e, t) {
  var n,
    r = this.head;
  if (arguments.length > 1) n = t;
  else if (this.head) (r = this.head.next), (n = this.head.value);
  else throw new TypeError("Reduce of empty list with no initial value");
  for (var i = 0; r !== null; i++) (n = e(n, r.value, i)), (r = r.next);
  return n;
};
Ht.prototype.reduceReverse = function (e, t) {
  var n,
    r = this.tail;
  if (arguments.length > 1) n = t;
  else if (this.tail) (r = this.tail.prev), (n = this.tail.value);
  else throw new TypeError("Reduce of empty list with no initial value");
  for (var i = this.length - 1; r !== null; i--)
    (n = e(n, r.value, i)), (r = r.prev);
  return n;
};
Ht.prototype.toArray = function () {
  for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++)
    (e[t] = n.value), (n = n.next);
  return e;
};
Ht.prototype.toArrayReverse = function () {
  for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++)
    (e[t] = n.value), (n = n.prev);
  return e;
};
Ht.prototype.slice = function (e, t) {
  (t = t || this.length),
    t < 0 && (t += this.length),
    (e = e || 0),
    e < 0 && (e += this.length);
  var n = new Ht();
  if (t < e || t < 0) return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var r = 0, i = this.head; i !== null && r < e; r++) i = i.next;
  for (; i !== null && r < t; r++, i = i.next) n.push(i.value);
  return n;
};
Ht.prototype.sliceReverse = function (e, t) {
  (t = t || this.length),
    t < 0 && (t += this.length),
    (e = e || 0),
    e < 0 && (e += this.length);
  var n = new Ht();
  if (t < e || t < 0) return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var r = this.length, i = this.tail; i !== null && r > t; r--) i = i.prev;
  for (; i !== null && r > e; r--, i = i.prev) n.push(i.value);
  return n;
};
Ht.prototype.splice = function (e, t, ...n) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var r = 0, i = this.head; i !== null && r < e; r++) i = i.next;
  for (var a = [], r = 0; i && r < t; r++)
    a.push(i.value), (i = this.removeNode(i));
  i === null && (i = this.tail),
    i !== this.head && i !== this.tail && (i = i.prev);
  for (var r = 0; r < n.length; r++) i = rZ(this, i, n[r]);
  return a;
};
Ht.prototype.reverse = function () {
  for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
    var r = n.prev;
    (n.prev = n.next), (n.next = r);
  }
  return (this.head = t), (this.tail = e), this;
};
function rZ(e, t, n) {
  var r = t === e.head ? new qs(n, null, t, e) : new qs(n, t, t.next, e);
  return (
    r.next === null && (e.tail = r),
    r.prev === null && (e.head = r),
    e.length++,
    r
  );
}
function iZ(e, t) {
  (e.tail = new qs(t, e.tail, null, e)),
    e.head || (e.head = e.tail),
    e.length++;
}
function aZ(e, t) {
  (e.head = new qs(t, null, e.head, e)),
    e.tail || (e.tail = e.head),
    e.length++;
}
function qs(e, t, n, r) {
  if (!(this instanceof qs)) return new qs(e, t, n, r);
  (this.list = r),
    (this.value = e),
    t ? ((t.next = this), (this.prev = t)) : (this.prev = null),
    n ? ((n.prev = this), (this.next = n)) : (this.next = null);
}
try {
  tZ()(Ht);
} catch {}
const sZ = nZ,
  As = Symbol("max"),
  ia = Symbol("length"),
  go = Symbol("lengthCalculator"),
  $l = Symbol("allowStale"),
  $s = Symbol("maxAge"),
  ta = Symbol("dispose"),
  pA = Symbol("noDisposeOnSet"),
  Qn = Symbol("lruList"),
  ui = Symbol("cache"),
  MR = Symbol("updateAgeOnGet"),
  Um = () => 1;
class oZ {
  constructor(t) {
    if (
      (typeof t == "number" && (t = { max: t }),
      t || (t = {}),
      t.max && (typeof t.max != "number" || t.max < 0))
    )
      throw new TypeError("max must be a non-negative number");
    this[As] = t.max || 1 / 0;
    const n = t.length || Um;
    if (
      ((this[go] = typeof n != "function" ? Um : n),
      (this[$l] = t.stale || !1),
      t.maxAge && typeof t.maxAge != "number")
    )
      throw new TypeError("maxAge must be a number");
    (this[$s] = t.maxAge || 0),
      (this[ta] = t.dispose),
      (this[pA] = t.noDisposeOnSet || !1),
      (this[MR] = t.updateAgeOnGet || !1),
      this.reset();
  }
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    (this[As] = t || 1 / 0), Vc(this);
  }
  get max() {
    return this[As];
  }
  set allowStale(t) {
    this[$l] = !!t;
  }
  get allowStale() {
    return this[$l];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    (this[$s] = t), Vc(this);
  }
  get maxAge() {
    return this[$s];
  }
  set lengthCalculator(t) {
    typeof t != "function" && (t = Um),
      t !== this[go] &&
        ((this[go] = t),
        (this[ia] = 0),
        this[Qn].forEach((n) => {
          (n.length = this[go](n.value, n.key)), (this[ia] += n.length);
        })),
      Vc(this);
  }
  get lengthCalculator() {
    return this[go];
  }
  get length() {
    return this[ia];
  }
  get itemCount() {
    return this[Qn].length;
  }
  rforEach(t, n) {
    n = n || this;
    for (let r = this[Qn].tail; r !== null; ) {
      const i = r.prev;
      hA(this, t, r, n), (r = i);
    }
  }
  forEach(t, n) {
    n = n || this;
    for (let r = this[Qn].head; r !== null; ) {
      const i = r.next;
      hA(this, t, r, n), (r = i);
    }
  }
  keys() {
    return this[Qn].toArray().map((t) => t.key);
  }
  values() {
    return this[Qn].toArray().map((t) => t.value);
  }
  reset() {
    this[ta] &&
      this[Qn] &&
      this[Qn].length &&
      this[Qn].forEach((t) => this[ta](t.key, t.value)),
      (this[ui] = new Map()),
      (this[Qn] = new sZ()),
      (this[ia] = 0);
  }
  dump() {
    return this[Qn].map((t) =>
      Rd(this, t) ? !1 : { k: t.key, v: t.value, e: t.now + (t.maxAge || 0) },
    )
      .toArray()
      .filter((t) => t);
  }
  dumpLru() {
    return this[Qn];
  }
  set(t, n, r) {
    if (((r = r || this[$s]), r && typeof r != "number"))
      throw new TypeError("maxAge must be a number");
    const i = r ? Date.now() : 0,
      a = this[go](n, t);
    if (this[ui].has(t)) {
      if (a > this[As]) return Fo(this, this[ui].get(t)), !1;
      const c = this[ui].get(t).value;
      return (
        this[ta] && (this[pA] || this[ta](t, c.value)),
        (c.now = i),
        (c.maxAge = r),
        (c.value = n),
        (this[ia] += a - c.length),
        (c.length = a),
        this.get(t),
        Vc(this),
        !0
      );
    }
    const s = new cZ(t, n, a, i, r);
    return s.length > this[As]
      ? (this[ta] && this[ta](t, n), !1)
      : ((this[ia] += s.length),
        this[Qn].unshift(s),
        this[ui].set(t, this[Qn].head),
        Vc(this),
        !0);
  }
  has(t) {
    if (!this[ui].has(t)) return !1;
    const n = this[ui].get(t).value;
    return !Rd(this, n);
  }
  get(t) {
    return Fm(this, t, !0);
  }
  peek(t) {
    return Fm(this, t, !1);
  }
  pop() {
    const t = this[Qn].tail;
    return t ? (Fo(this, t), t.value) : null;
  }
  del(t) {
    Fo(this, this[ui].get(t));
  }
  load(t) {
    this.reset();
    const n = Date.now();
    for (let r = t.length - 1; r >= 0; r--) {
      const i = t[r],
        a = i.e || 0;
      if (a === 0) this.set(i.k, i.v);
      else {
        const s = a - n;
        s > 0 && this.set(i.k, i.v, s);
      }
    }
  }
  prune() {
    this[ui].forEach((t, n) => Fm(this, n, !1));
  }
}
const Fm = (e, t, n) => {
    const r = e[ui].get(t);
    if (r) {
      const i = r.value;
      if (Rd(e, i)) {
        if ((Fo(e, r), !e[$l])) return;
      } else n && (e[MR] && (r.value.now = Date.now()), e[Qn].unshiftNode(r));
      return i.value;
    }
  },
  Rd = (e, t) => {
    if (!t || (!t.maxAge && !e[$s])) return !1;
    const n = Date.now() - t.now;
    return t.maxAge ? n > t.maxAge : e[$s] && n > e[$s];
  },
  Vc = (e) => {
    if (e[ia] > e[As])
      for (let t = e[Qn].tail; e[ia] > e[As] && t !== null; ) {
        const n = t.prev;
        Fo(e, t), (t = n);
      }
  },
  Fo = (e, t) => {
    if (t) {
      const n = t.value;
      e[ta] && e[ta](n.key, n.value),
        (e[ia] -= n.length),
        e[ui].delete(n.key),
        e[Qn].removeNode(t);
    }
  };
class cZ {
  constructor(t, n, r, i, a) {
    (this.key = t),
      (this.value = n),
      (this.length = r),
      (this.now = i),
      (this.maxAge = a || 0);
  }
}
const hA = (e, t, n, r) => {
  let i = n.value;
  Rd(e, i) && (Fo(e, n), e[$l] || (i = void 0)),
    i && t.call(r, i.value, i.key, e);
};
var lZ = oZ,
  jm,
  mA;
function Ci() {
  if (mA) return jm;
  mA = 1;
  class e {
    constructor(q, J) {
      if (((J = r(J)), q instanceof e))
        return q.loose === !!J.loose &&
          q.includePrerelease === !!J.includePrerelease
          ? q
          : new e(q.raw, J);
      if (q instanceof i)
        return (this.raw = q.value), (this.set = [[q]]), this.format(), this;
      if (
        ((this.options = J),
        (this.loose = !!J.loose),
        (this.includePrerelease = !!J.includePrerelease),
        (this.raw = q.trim().split(/\s+/).join(" ")),
        (this.set = this.raw
          .split("||")
          .map((Z) => this.parseRange(Z.trim()))
          .filter((Z) => Z.length)),
        !this.set.length)
      )
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const Z = this.set[0];
        if (
          ((this.set = this.set.filter((z) => !h(z[0]))), this.set.length === 0)
        )
          this.set = [Z];
        else if (this.set.length > 1) {
          for (const z of this.set)
            if (z.length === 1 && m(z[0])) {
              this.set = [z];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return (
        (this.range = this.set
          .map((q) => q.join(" ").trim())
          .join("||")
          .trim()),
        this.range
      );
    }
    toString() {
      return this.range;
    }
    parseRange(q) {
      const Z =
          ((this.options.includePrerelease && d) | (this.options.loose && p)) +
          ":" +
          q,
        z = n.get(Z);
      if (z) return z;
      const U = this.options.loose,
        G = U ? o[c.HYPHENRANGELOOSE] : o[c.HYPHENRANGE];
      (q = q.replace(G, Q(this.options.includePrerelease))),
        a("hyphen replace", q),
        (q = q.replace(o[c.COMPARATORTRIM], l)),
        a("comparator trim", q),
        (q = q.replace(o[c.TILDETRIM], f)),
        a("tilde trim", q),
        (q = q.replace(o[c.CARETTRIM], u)),
        a("caret trim", q);
      let L = q
        .split(" ")
        .map((x) => v(x, this.options))
        .join(" ")
        .split(/\s+/)
        .map((x) => O(x, this.options));
      U &&
        (L = L.filter(
          (x) => (
            a("loose invalid filter", x, this.options),
            !!x.match(o[c.COMPARATORLOOSE])
          ),
        )),
        a("range list", L);
      const k = new Map(),
        W = L.map((x) => new i(x, this.options));
      for (const x of W) {
        if (h(x)) return [x];
        k.set(x.value, x);
      }
      k.size > 1 && k.has("") && k.delete("");
      const F = [...k.values()];
      return n.set(Z, F), F;
    }
    intersects(q, J) {
      if (!(q instanceof e)) throw new TypeError("a Range is required");
      return this.set.some(
        (Z) =>
          g(Z, J) &&
          q.set.some(
            (z) =>
              g(z, J) && Z.every((U) => z.every((G) => U.intersects(G, J))),
          ),
      );
    }
    test(q) {
      if (!q) return !1;
      if (typeof q == "string")
        try {
          q = new s(q, this.options);
        } catch {
          return !1;
        }
      for (let J = 0; J < this.set.length; J++)
        if (j(this.set[J], q, this.options)) return !0;
      return !1;
    }
  }
  jm = e;
  const t = lZ,
    n = new t({ max: 1e3 }),
    r = Bb,
    i = Up(),
    a = Lp,
    s = $r,
    {
      safeRe: o,
      t: c,
      comparatorTrimReplace: l,
      tildeTrimReplace: f,
      caretTrimReplace: u,
    } = yu,
    { FLAG_INCLUDE_PRERELEASE: d, FLAG_LOOSE: p } = Dp,
    h = (H) => H.value === "<0.0.0-0",
    m = (H) => H.value === "",
    g = (H, q) => {
      let J = !0;
      const Z = H.slice();
      let z = Z.pop();
      for (; J && Z.length; )
        (J = Z.every((U) => z.intersects(U, q))), (z = Z.pop());
      return J;
    },
    v = (H, q) => (
      a("comp", H, q),
      (H = R(H, q)),
      a("caret", H),
      (H = _(H, q)),
      a("tildes", H),
      (H = I(H, q)),
      a("xrange", H),
      (H = w(H, q)),
      a("stars", H),
      H
    ),
    y = (H) => !H || H.toLowerCase() === "x" || H === "*",
    _ = (H, q) =>
      H.trim()
        .split(/\s+/)
        .map((J) => E(J, q))
        .join(" "),
    E = (H, q) => {
      const J = q.loose ? o[c.TILDELOOSE] : o[c.TILDE];
      return H.replace(J, (Z, z, U, G, L) => {
        a("tilde", H, Z, z, U, G, L);
        let k;
        return (
          y(z)
            ? (k = "")
            : y(U)
            ? (k = `>=${z}.0.0 <${+z + 1}.0.0-0`)
            : y(G)
            ? (k = `>=${z}.${U}.0 <${z}.${+U + 1}.0-0`)
            : L
            ? (a("replaceTilde pr", L),
              (k = `>=${z}.${U}.${G}-${L} <${z}.${+U + 1}.0-0`))
            : (k = `>=${z}.${U}.${G} <${z}.${+U + 1}.0-0`),
          a("tilde return", k),
          k
        );
      });
    },
    R = (H, q) =>
      H.trim()
        .split(/\s+/)
        .map((J) => A(J, q))
        .join(" "),
    A = (H, q) => {
      a("caret", H, q);
      const J = q.loose ? o[c.CARETLOOSE] : o[c.CARET],
        Z = q.includePrerelease ? "-0" : "";
      return H.replace(J, (z, U, G, L, k) => {
        a("caret", H, z, U, G, L, k);
        let W;
        return (
          y(U)
            ? (W = "")
            : y(G)
            ? (W = `>=${U}.0.0${Z} <${+U + 1}.0.0-0`)
            : y(L)
            ? U === "0"
              ? (W = `>=${U}.${G}.0${Z} <${U}.${+G + 1}.0-0`)
              : (W = `>=${U}.${G}.0${Z} <${+U + 1}.0.0-0`)
            : k
            ? (a("replaceCaret pr", k),
              U === "0"
                ? G === "0"
                  ? (W = `>=${U}.${G}.${L}-${k} <${U}.${G}.${+L + 1}-0`)
                  : (W = `>=${U}.${G}.${L}-${k} <${U}.${+G + 1}.0-0`)
                : (W = `>=${U}.${G}.${L}-${k} <${+U + 1}.0.0-0`))
            : (a("no pr"),
              U === "0"
                ? G === "0"
                  ? (W = `>=${U}.${G}.${L}${Z} <${U}.${G}.${+L + 1}-0`)
                  : (W = `>=${U}.${G}.${L}${Z} <${U}.${+G + 1}.0-0`)
                : (W = `>=${U}.${G}.${L} <${+U + 1}.0.0-0`)),
          a("caret return", W),
          W
        );
      });
    },
    I = (H, q) => (
      a("replaceXRanges", H, q),
      H.split(/\s+/)
        .map((J) => S(J, q))
        .join(" ")
    ),
    S = (H, q) => {
      H = H.trim();
      const J = q.loose ? o[c.XRANGELOOSE] : o[c.XRANGE];
      return H.replace(J, (Z, z, U, G, L, k) => {
        a("xRange", H, Z, z, U, G, L, k);
        const W = y(U),
          F = W || y(G),
          x = F || y(L),
          T = x;
        return (
          z === "=" && T && (z = ""),
          (k = q.includePrerelease ? "-0" : ""),
          W
            ? z === ">" || z === "<"
              ? (Z = "<0.0.0-0")
              : (Z = "*")
            : z && T
            ? (F && (G = 0),
              (L = 0),
              z === ">"
                ? ((z = ">="),
                  F
                    ? ((U = +U + 1), (G = 0), (L = 0))
                    : ((G = +G + 1), (L = 0)))
                : z === "<=" && ((z = "<"), F ? (U = +U + 1) : (G = +G + 1)),
              z === "<" && (k = "-0"),
              (Z = `${z + U}.${G}.${L}${k}`))
            : F
            ? (Z = `>=${U}.0.0${k} <${+U + 1}.0.0-0`)
            : x && (Z = `>=${U}.${G}.0${k} <${U}.${+G + 1}.0-0`),
          a("xRange return", Z),
          Z
        );
      });
    },
    w = (H, q) => (a("replaceStars", H, q), H.trim().replace(o[c.STAR], "")),
    O = (H, q) => (
      a("replaceGTE0", H, q),
      H.trim().replace(o[q.includePrerelease ? c.GTE0PRE : c.GTE0], "")
    ),
    Q = (H) => (q, J, Z, z, U, G, L, k, W, F, x, T, V) => (
      y(Z)
        ? (J = "")
        : y(z)
        ? (J = `>=${Z}.0.0${H ? "-0" : ""}`)
        : y(U)
        ? (J = `>=${Z}.${z}.0${H ? "-0" : ""}`)
        : G
        ? (J = `>=${J}`)
        : (J = `>=${J}${H ? "-0" : ""}`),
      y(W)
        ? (k = "")
        : y(F)
        ? (k = `<${+W + 1}.0.0-0`)
        : y(x)
        ? (k = `<${W}.${+F + 1}.0-0`)
        : T
        ? (k = `<=${W}.${F}.${x}-${T}`)
        : H
        ? (k = `<${W}.${F}.${+x + 1}-0`)
        : (k = `<=${k}`),
      `${J} ${k}`.trim()
    ),
    j = (H, q, J) => {
      for (let Z = 0; Z < H.length; Z++) if (!H[Z].test(q)) return !1;
      if (q.prerelease.length && !J.includePrerelease) {
        for (let Z = 0; Z < H.length; Z++)
          if (
            (a(H[Z].semver),
            H[Z].semver !== i.ANY && H[Z].semver.prerelease.length > 0)
          ) {
            const z = H[Z].semver;
            if (
              z.major === q.major &&
              z.minor === q.minor &&
              z.patch === q.patch
            )
              return !0;
          }
        return !1;
      }
      return !0;
    };
  return jm;
}
var Mm, gA;
function Up() {
  if (gA) return Mm;
  gA = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(f, u) {
      if (((u = n(u)), f instanceof t)) {
        if (f.loose === !!u.loose) return f;
        f = f.value;
      }
      (f = f.trim().split(/\s+/).join(" ")),
        s("comparator", f, u),
        (this.options = u),
        (this.loose = !!u.loose),
        this.parse(f),
        this.semver === e
          ? (this.value = "")
          : (this.value = this.operator + this.semver.version),
        s("comp", this);
    }
    parse(f) {
      const u = this.options.loose ? r[i.COMPARATORLOOSE] : r[i.COMPARATOR],
        d = f.match(u);
      if (!d) throw new TypeError(`Invalid comparator: ${f}`);
      (this.operator = d[1] !== void 0 ? d[1] : ""),
        this.operator === "=" && (this.operator = ""),
        d[2]
          ? (this.semver = new o(d[2], this.options.loose))
          : (this.semver = e);
    }
    toString() {
      return this.value;
    }
    test(f) {
      if (
        (s("Comparator.test", f, this.options.loose),
        this.semver === e || f === e)
      )
        return !0;
      if (typeof f == "string")
        try {
          f = new o(f, this.options);
        } catch {
          return !1;
        }
      return a(f, this.operator, this.semver, this.options);
    }
    intersects(f, u) {
      if (!(f instanceof t)) throw new TypeError("a Comparator is required");
      return this.operator === ""
        ? this.value === ""
          ? !0
          : new c(f.value, u).test(this.value)
        : f.operator === ""
        ? f.value === ""
          ? !0
          : new c(this.value, u).test(f.semver)
        : ((u = n(u)),
          (u.includePrerelease &&
            (this.value === "<0.0.0-0" || f.value === "<0.0.0-0")) ||
          (!u.includePrerelease &&
            (this.value.startsWith("<0.0.0") || f.value.startsWith("<0.0.0")))
            ? !1
            : !!(
                (this.operator.startsWith(">") && f.operator.startsWith(">")) ||
                (this.operator.startsWith("<") && f.operator.startsWith("<")) ||
                (this.semver.version === f.semver.version &&
                  this.operator.includes("=") &&
                  f.operator.includes("=")) ||
                (a(this.semver, "<", f.semver, u) &&
                  this.operator.startsWith(">") &&
                  f.operator.startsWith("<")) ||
                (a(this.semver, ">", f.semver, u) &&
                  this.operator.startsWith("<") &&
                  f.operator.startsWith(">"))
              ));
    }
  }
  Mm = t;
  const n = Bb,
    { safeRe: r, t: i } = yu,
    a = jR,
    s = Lp,
    o = $r,
    c = Ci();
  return Mm;
}
const uZ = Ci(),
  fZ = (e, t, n) => {
    try {
      t = new uZ(t, n);
    } catch {
      return !1;
    }
    return t.test(e);
  };
var Fp = fZ;
const dZ = Ci(),
  pZ = (e, t) =>
    new dZ(e, t).set.map((n) =>
      n
        .map((r) => r.value)
        .join(" ")
        .trim()
        .split(" "),
    );
var hZ = pZ;
const mZ = $r,
  gZ = Ci(),
  vZ = (e, t, n) => {
    let r = null,
      i = null,
      a = null;
    try {
      a = new gZ(t, n);
    } catch {
      return null;
    }
    return (
      e.forEach((s) => {
        a.test(s) &&
          (!r || i.compare(s) === -1) &&
          ((r = s), (i = new mZ(r, n)));
      }),
      r
    );
  };
var yZ = vZ;
const bZ = $r,
  _Z = Ci(),
  EZ = (e, t, n) => {
    let r = null,
      i = null,
      a = null;
    try {
      a = new _Z(t, n);
    } catch {
      return null;
    }
    return (
      e.forEach((s) => {
        a.test(s) &&
          (!r || i.compare(s) === 1) &&
          ((r = s), (i = new bZ(r, n)));
      }),
      r
    );
  };
var wZ = EZ;
const Hm = $r,
  xZ = Ci(),
  vA = Bp,
  AZ = (e, t) => {
    e = new xZ(e, t);
    let n = new Hm("0.0.0");
    if (e.test(n) || ((n = new Hm("0.0.0-0")), e.test(n))) return n;
    n = null;
    for (let r = 0; r < e.set.length; ++r) {
      const i = e.set[r];
      let a = null;
      i.forEach((s) => {
        const o = new Hm(s.semver.version);
        switch (s.operator) {
          case ">":
            o.prerelease.length === 0 ? o.patch++ : o.prerelease.push(0),
              (o.raw = o.format());
          case "":
          case ">=":
            (!a || vA(o, a)) && (a = o);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${s.operator}`);
        }
      }),
        a && (!n || vA(n, a)) && (n = a);
    }
    return n && e.test(n) ? n : null;
  };
var SZ = AZ;
const IZ = Ci(),
  $Z = (e, t) => {
    try {
      return new IZ(e, t).range || "*";
    } catch {
      return null;
    }
  };
var CZ = $Z;
const RZ = $r,
  HR = Up(),
  { ANY: kZ } = HR,
  TZ = Ci(),
  NZ = Fp,
  yA = Bp,
  bA = Fb,
  OZ = Mb,
  PZ = jb,
  DZ = (e, t, n, r) => {
    (e = new RZ(e, r)), (t = new TZ(t, r));
    let i, a, s, o, c;
    switch (n) {
      case ">":
        (i = yA), (a = OZ), (s = bA), (o = ">"), (c = ">=");
        break;
      case "<":
        (i = bA), (a = PZ), (s = yA), (o = "<"), (c = "<=");
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (NZ(e, t, r)) return !1;
    for (let l = 0; l < t.set.length; ++l) {
      const f = t.set[l];
      let u = null,
        d = null;
      if (
        (f.forEach((p) => {
          p.semver === kZ && (p = new HR(">=0.0.0")),
            (u = u || p),
            (d = d || p),
            i(p.semver, u.semver, r)
              ? (u = p)
              : s(p.semver, d.semver, r) && (d = p);
        }),
        u.operator === o ||
          u.operator === c ||
          ((!d.operator || d.operator === o) && a(e, d.semver)))
      )
        return !1;
      if (d.operator === c && s(e, d.semver)) return !1;
    }
    return !0;
  };
var Hb = DZ;
const LZ = Hb,
  BZ = (e, t, n) => LZ(e, t, ">", n);
var UZ = BZ;
const FZ = Hb,
  jZ = (e, t, n) => FZ(e, t, "<", n);
var MZ = jZ;
const _A = Ci(),
  HZ = (e, t, n) => (
    (e = new _A(e, n)), (t = new _A(t, n)), e.intersects(t, n)
  );
var qZ = HZ;
const GZ = Fp,
  QZ = $i;
var WZ = (e, t, n) => {
  const r = [];
  let i = null,
    a = null;
  const s = e.sort((f, u) => QZ(f, u, n));
  for (const f of s)
    GZ(f, t, n)
      ? ((a = f), i || (i = f))
      : (a && r.push([i, a]), (a = null), (i = null));
  i && r.push([i, null]);
  const o = [];
  for (const [f, u] of r)
    f === u
      ? o.push(f)
      : !u && f === s[0]
      ? o.push("*")
      : u
      ? f === s[0]
        ? o.push(`<=${u}`)
        : o.push(`${f} - ${u}`)
      : o.push(`>=${f}`);
  const c = o.join(" || "),
    l = typeof t.raw == "string" ? t.raw : String(t);
  return c.length < l.length ? c : t;
};
const EA = Ci(),
  qb = Up(),
  { ANY: qm } = qb,
  Yc = Fp,
  Gb = $i,
  zZ = (e, t, n = {}) => {
    if (e === t) return !0;
    (e = new EA(e, n)), (t = new EA(t, n));
    let r = !1;
    e: for (const i of e.set) {
      for (const a of t.set) {
        const s = VZ(i, a, n);
        if (((r = r || s !== null), s)) continue e;
      }
      if (r) return !1;
    }
    return !0;
  },
  KZ = [new qb(">=0.0.0-0")],
  wA = [new qb(">=0.0.0")],
  VZ = (e, t, n) => {
    if (e === t) return !0;
    if (e.length === 1 && e[0].semver === qm) {
      if (t.length === 1 && t[0].semver === qm) return !0;
      n.includePrerelease ? (e = KZ) : (e = wA);
    }
    if (t.length === 1 && t[0].semver === qm) {
      if (n.includePrerelease) return !0;
      t = wA;
    }
    const r = new Set();
    let i, a;
    for (const p of e)
      p.operator === ">" || p.operator === ">="
        ? (i = xA(i, p, n))
        : p.operator === "<" || p.operator === "<="
        ? (a = AA(a, p, n))
        : r.add(p.semver);
    if (r.size > 1) return null;
    let s;
    if (i && a) {
      if (((s = Gb(i.semver, a.semver, n)), s > 0)) return null;
      if (s === 0 && (i.operator !== ">=" || a.operator !== "<=")) return null;
    }
    for (const p of r) {
      if ((i && !Yc(p, String(i), n)) || (a && !Yc(p, String(a), n)))
        return null;
      for (const h of t) if (!Yc(p, String(h), n)) return !1;
      return !0;
    }
    let o,
      c,
      l,
      f,
      u =
        a && !n.includePrerelease && a.semver.prerelease.length ? a.semver : !1,
      d =
        i && !n.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
    u &&
      u.prerelease.length === 1 &&
      a.operator === "<" &&
      u.prerelease[0] === 0 &&
      (u = !1);
    for (const p of t) {
      if (
        ((f = f || p.operator === ">" || p.operator === ">="),
        (l = l || p.operator === "<" || p.operator === "<="),
        i)
      ) {
        if (
          (d &&
            p.semver.prerelease &&
            p.semver.prerelease.length &&
            p.semver.major === d.major &&
            p.semver.minor === d.minor &&
            p.semver.patch === d.patch &&
            (d = !1),
          p.operator === ">" || p.operator === ">=")
        ) {
          if (((o = xA(i, p, n)), o === p && o !== i)) return !1;
        } else if (i.operator === ">=" && !Yc(i.semver, String(p), n))
          return !1;
      }
      if (a) {
        if (
          (u &&
            p.semver.prerelease &&
            p.semver.prerelease.length &&
            p.semver.major === u.major &&
            p.semver.minor === u.minor &&
            p.semver.patch === u.patch &&
            (u = !1),
          p.operator === "<" || p.operator === "<=")
        ) {
          if (((c = AA(a, p, n)), c === p && c !== a)) return !1;
        } else if (a.operator === "<=" && !Yc(a.semver, String(p), n))
          return !1;
      }
      if (!p.operator && (a || i) && s !== 0) return !1;
    }
    return !((i && l && !a && s !== 0) || (a && f && !i && s !== 0) || d || u);
  },
  xA = (e, t, n) => {
    if (!e) return t;
    const r = Gb(e.semver, t.semver, n);
    return r > 0
      ? e
      : r < 0 || (t.operator === ">" && e.operator === ">=")
      ? t
      : e;
  },
  AA = (e, t, n) => {
    if (!e) return t;
    const r = Gb(e.semver, t.semver, n);
    return r < 0
      ? e
      : r > 0 || (t.operator === "<" && e.operator === "<=")
      ? t
      : e;
  };
var YZ = zZ;
const Gm = yu,
  SA = Dp,
  XZ = $r,
  IA = BR,
  JZ = Cc,
  ZZ = JX,
  eee = tJ,
  tee = rJ,
  nee = aJ,
  ree = cJ,
  iee = fJ,
  aee = hJ,
  see = vJ,
  oee = $i,
  cee = EJ,
  lee = AJ,
  uee = Ub,
  fee = CJ,
  dee = TJ,
  pee = Bp,
  hee = Fb,
  mee = UR,
  gee = FR,
  vee = jb,
  yee = Mb,
  bee = jR,
  _ee = eZ,
  Eee = Up(),
  wee = Ci(),
  xee = Fp,
  Aee = hZ,
  See = yZ,
  Iee = wZ,
  $ee = SZ,
  Cee = CZ,
  Ree = Hb,
  kee = UZ,
  Tee = MZ,
  Nee = qZ,
  Oee = WZ,
  Pee = YZ;
var Dee = {
    parse: JZ,
    valid: ZZ,
    clean: eee,
    inc: tee,
    diff: nee,
    major: ree,
    minor: iee,
    patch: aee,
    prerelease: see,
    compare: oee,
    rcompare: cee,
    compareLoose: lee,
    compareBuild: uee,
    sort: fee,
    rsort: dee,
    gt: pee,
    lt: hee,
    eq: mee,
    neq: gee,
    gte: vee,
    lte: yee,
    cmp: bee,
    coerce: _ee,
    Comparator: Eee,
    Range: wee,
    satisfies: xee,
    toComparators: Aee,
    maxSatisfying: See,
    minSatisfying: Iee,
    minVersion: $ee,
    validRange: Cee,
    outside: Ree,
    gtr: kee,
    ltr: Tee,
    intersects: Nee,
    simplifyRange: Oee,
    subset: Pee,
    SemVer: XZ,
    re: Gm.re,
    src: Gm.src,
    tokens: Gm.t,
    SEMVER_SPEC_VERSION: SA.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: SA.RELEASE_TYPES,
    compareIdentifiers: IA.compareIdentifiers,
    rcompareIdentifiers: IA.rcompareIdentifiers,
  },
  jp = { exports: {} },
  Qb = { exports: {} };
const qR = (e, t) => {
  for (const n of Reflect.ownKeys(t))
    Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n));
  return e;
};
Qb.exports = qR;
Qb.exports.default = qR;
var Lee = Qb.exports;
const Bee = Lee,
  kd = new WeakMap(),
  GR = (e, t = {}) => {
    if (typeof e != "function") throw new TypeError("Expected a function");
    let n,
      r = 0;
    const i = e.displayName || e.name || "<anonymous>",
      a = function (...s) {
        if ((kd.set(a, ++r), r === 1)) (n = e.apply(this, s)), (e = null);
        else if (t.throw === !0)
          throw new Error(`Function \`${i}\` can only be called once`);
        return n;
      };
    return Bee(a, e), kd.set(a, r), a;
  };
jp.exports = GR;
jp.exports.default = GR;
jp.exports.callCount = (e) => {
  if (!kd.has(e))
    throw new Error(
      `The given function \`${e.name}\` is not wrapped by the \`onetime\` package`,
    );
  return kd.get(e);
};
var Uee = jp.exports;
(function (e, t) {
  var n =
      (Tn && Tn.__classPrivateFieldSet) ||
      function (z, U, G, L, k) {
        if (L === "m") throw new TypeError("Private method is not writable");
        if (L === "a" && !k)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof U == "function" ? z !== U || !k : !U.has(z))
          throw new TypeError(
            "Cannot write private member to an object whose class did not declare it",
          );
        return L === "a" ? k.call(z, G) : k ? (k.value = G) : U.set(z, G), G;
      },
    r =
      (Tn && Tn.__classPrivateFieldGet) ||
      function (z, U, G, L) {
        if (G === "a" && !L)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof U == "function" ? z !== U || !L : !U.has(z))
          throw new TypeError(
            "Cannot read private member from an object whose class did not declare it",
          );
        return G === "m" ? L : G === "a" ? L.call(z) : L ? L.value : U.get(z);
      },
    i,
    a,
    s,
    o,
    c,
    l;
  Object.defineProperty(t, "__esModule", { value: !0 });
  const f = wr,
    u = Xt,
    d = pt,
    p = pr,
    h = gc,
    m = Hi,
    g = sq,
    v = vq,
    y = Eq,
    _ = Ui,
    E = Pz,
    R = SX,
    A = LX,
    I = Dee,
    S = Uee,
    w = "aes-256-cbc",
    O = () => Object.create(null),
    Q = (z) => z != null;
  let j = "";
  try {
    delete require.cache[__filename],
      (j = d.dirname(
        (a = (i = e.parent) === null || i === void 0 ? void 0 : i.filename) !==
          null && a !== void 0
          ? a
          : ".",
      ));
  } catch {}
  const H = (z, U) => {
      const G = new Set(["undefined", "symbol", "function"]),
        L = typeof U;
      if (G.has(L))
        throw new TypeError(
          `Setting a value of type \`${L}\` for key \`${z}\` is not allowed as it's not supported by JSON`,
        );
    },
    q = "__internal__",
    J = `${q}.migrations.version`;
  class Z {
    constructor(U = {}) {
      var G;
      s.set(this, void 0),
        o.set(this, void 0),
        c.set(this, void 0),
        l.set(this, {}),
        (this._deserialize = (T) => JSON.parse(T)),
        (this._serialize = (T) => JSON.stringify(T, void 0, "	"));
      const L = {
          configName: "config",
          fileExtension: "json",
          projectSuffix: "nodejs",
          clearInvalidConfig: !1,
          accessPropertiesByDotNotation: !0,
          configFileMode: 438,
          ...U,
        },
        k = S(() => {
          const T = v.sync({ cwd: j }),
            V = T && JSON.parse(u.readFileSync(T, "utf8"));
          return V ?? {};
        });
      if (!L.cwd) {
        if ((L.projectName || (L.projectName = k().name), !L.projectName))
          throw new Error(
            "Project name could not be inferred. Please specify the `projectName` option.",
          );
        L.cwd = y(L.projectName, { suffix: L.projectSuffix }).config;
      }
      if ((n(this, c, L, "f"), L.schema)) {
        if (typeof L.schema != "object")
          throw new TypeError("The `schema` option must be an object.");
        const T = new E.default({ allErrors: !0, useDefaults: !0 });
        (0, R.default)(T);
        const V = { type: "object", properties: L.schema };
        n(this, s, T.compile(V), "f");
        for (const [B, N] of Object.entries(L.schema))
          N != null && N.default && (r(this, l, "f")[B] = N.default);
      }
      L.defaults && n(this, l, { ...r(this, l, "f"), ...L.defaults }, "f"),
        L.serialize && (this._serialize = L.serialize),
        L.deserialize && (this._deserialize = L.deserialize),
        (this.events = new m.EventEmitter()),
        n(this, o, L.encryptionKey, "f");
      const W = L.fileExtension ? `.${L.fileExtension}` : "";
      this.path = d.resolve(
        L.cwd,
        `${(G = L.configName) !== null && G !== void 0 ? G : "config"}${W}`,
      );
      const F = this.store,
        x = Object.assign(O(), L.defaults, F);
      this._validate(x);
      try {
        h.deepEqual(F, x);
      } catch {
        this.store = x;
      }
      if ((L.watch && this._watch(), L.migrations)) {
        if (
          (L.projectVersion || (L.projectVersion = k().version),
          !L.projectVersion)
        )
          throw new Error(
            "Project version could not be inferred. Please specify the `projectVersion` option.",
          );
        this._migrate(L.migrations, L.projectVersion, L.beforeEachMigration);
      }
    }
    get(U, G) {
      if (r(this, c, "f").accessPropertiesByDotNotation) return this._get(U, G);
      const { store: L } = this;
      return U in L ? L[U] : G;
    }
    set(U, G) {
      if (typeof U != "string" && typeof U != "object")
        throw new TypeError(
          `Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof U}`,
        );
      if (typeof U != "object" && G === void 0)
        throw new TypeError("Use `delete()` to clear values");
      if (this._containsReservedKey(U))
        throw new TypeError(
          `Please don't use the ${q} key, as it's used to manage this module internal operations.`,
        );
      const { store: L } = this,
        k = (W, F) => {
          H(W, F),
            r(this, c, "f").accessPropertiesByDotNotation
              ? g.set(L, W, F)
              : (L[W] = F);
        };
      if (typeof U == "object") {
        const W = U;
        for (const [F, x] of Object.entries(W)) k(F, x);
      } else k(U, G);
      this.store = L;
    }
    has(U) {
      return r(this, c, "f").accessPropertiesByDotNotation
        ? g.has(this.store, U)
        : U in this.store;
    }
    reset(...U) {
      for (const G of U)
        Q(r(this, l, "f")[G]) && this.set(G, r(this, l, "f")[G]);
    }
    delete(U) {
      const { store: G } = this;
      r(this, c, "f").accessPropertiesByDotNotation
        ? g.delete(G, U)
        : delete G[U],
        (this.store = G);
    }
    clear() {
      this.store = O();
      for (const U of Object.keys(r(this, l, "f"))) this.reset(U);
    }
    onDidChange(U, G) {
      if (typeof U != "string")
        throw new TypeError(
          `Expected \`key\` to be of type \`string\`, got ${typeof U}`,
        );
      if (typeof G != "function")
        throw new TypeError(
          `Expected \`callback\` to be of type \`function\`, got ${typeof G}`,
        );
      return this._handleChange(() => this.get(U), G);
    }
    onDidAnyChange(U) {
      if (typeof U != "function")
        throw new TypeError(
          `Expected \`callback\` to be of type \`function\`, got ${typeof U}`,
        );
      return this._handleChange(() => this.store, U);
    }
    get size() {
      return Object.keys(this.store).length;
    }
    get store() {
      try {
        const U = u.readFileSync(this.path, r(this, o, "f") ? null : "utf8"),
          G = this._encryptData(U),
          L = this._deserialize(G);
        return this._validate(L), Object.assign(O(), L);
      } catch (U) {
        if ((U == null ? void 0 : U.code) === "ENOENT")
          return this._ensureDirectory(), O();
        if (r(this, c, "f").clearInvalidConfig && U.name === "SyntaxError")
          return O();
        throw U;
      }
    }
    set store(U) {
      this._ensureDirectory(),
        this._validate(U),
        this._write(U),
        this.events.emit("change");
    }
    *[((s = new WeakMap()),
    (o = new WeakMap()),
    (c = new WeakMap()),
    (l = new WeakMap()),
    Symbol.iterator)]() {
      for (const [U, G] of Object.entries(this.store)) yield [U, G];
    }
    _encryptData(U) {
      if (!r(this, o, "f")) return U.toString();
      try {
        if (r(this, o, "f"))
          try {
            if (U.slice(16, 17).toString() === ":") {
              const G = U.slice(0, 16),
                L = p.pbkdf2Sync(
                  r(this, o, "f"),
                  G.toString(),
                  1e4,
                  32,
                  "sha512",
                ),
                k = p.createDecipheriv(w, L, G);
              U = Buffer.concat([
                k.update(Buffer.from(U.slice(17))),
                k.final(),
              ]).toString("utf8");
            } else {
              const G = p.createDecipher(w, r(this, o, "f"));
              U = Buffer.concat([G.update(Buffer.from(U)), G.final()]).toString(
                "utf8",
              );
            }
          } catch {}
      } catch {}
      return U.toString();
    }
    _handleChange(U, G) {
      let L = U();
      const k = () => {
        const W = L,
          F = U();
        (0, f.isDeepStrictEqual)(F, W) || ((L = F), G.call(this, F, W));
      };
      return (
        this.events.on("change", k),
        () => this.events.removeListener("change", k)
      );
    }
    _validate(U) {
      if (
        !r(this, s, "f") ||
        r(this, s, "f").call(this, U) ||
        !r(this, s, "f").errors
      )
        return;
      const L = r(this, s, "f").errors.map(
        ({ instancePath: k, message: W = "" }) => `\`${k.slice(1)}\` ${W}`,
      );
      throw new Error("Config schema violation: " + L.join("; "));
    }
    _ensureDirectory() {
      u.mkdirSync(d.dirname(this.path), { recursive: !0 });
    }
    _write(U) {
      let G = this._serialize(U);
      if (r(this, o, "f")) {
        const L = p.randomBytes(16),
          k = p.pbkdf2Sync(r(this, o, "f"), L.toString(), 1e4, 32, "sha512"),
          W = p.createCipheriv(w, k, L);
        G = Buffer.concat([
          L,
          Buffer.from(":"),
          W.update(Buffer.from(G)),
          W.final(),
        ]);
      }
      if (process.env.SNAP)
        u.writeFileSync(this.path, G, { mode: r(this, c, "f").configFileMode });
      else
        try {
          _.writeFileSync(this.path, G, {
            mode: r(this, c, "f").configFileMode,
          });
        } catch (L) {
          if ((L == null ? void 0 : L.code) === "EXDEV") {
            u.writeFileSync(this.path, G, {
              mode: r(this, c, "f").configFileMode,
            });
            return;
          }
          throw L;
        }
    }
    _watch() {
      this._ensureDirectory(),
        u.existsSync(this.path) || this._write(O()),
        process.platform === "win32"
          ? u.watch(
              this.path,
              { persistent: !1 },
              A(
                () => {
                  this.events.emit("change");
                },
                { wait: 100 },
              ),
            )
          : u.watchFile(
              this.path,
              { persistent: !1 },
              A(
                () => {
                  this.events.emit("change");
                },
                { wait: 5e3 },
              ),
            );
    }
    _migrate(U, G, L) {
      let k = this._get(J, "0.0.0");
      const W = Object.keys(U).filter((x) =>
        this._shouldPerformMigration(x, k, G),
      );
      let F = { ...this.store };
      for (const x of W)
        try {
          L &&
            L(this, {
              fromVersion: k,
              toVersion: x,
              finalVersion: G,
              versions: W,
            });
          const T = U[x];
          T(this), this._set(J, x), (k = x), (F = { ...this.store });
        } catch (T) {
          throw (
            ((this.store = F),
            new Error(
              `Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${T}`,
            ))
          );
        }
      (this._isVersionInRangeFormat(k) || !I.eq(k, G)) && this._set(J, G);
    }
    _containsReservedKey(U) {
      return typeof U == "object" && Object.keys(U)[0] === q
        ? !0
        : typeof U != "string"
        ? !1
        : r(this, c, "f").accessPropertiesByDotNotation
        ? !!U.startsWith(`${q}.`)
        : !1;
    }
    _isVersionInRangeFormat(U) {
      return I.clean(U) === null;
    }
    _shouldPerformMigration(U, G, L) {
      return this._isVersionInRangeFormat(U)
        ? G !== "0.0.0" && I.satisfies(G, U)
          ? !1
          : I.satisfies(L, U)
        : !(I.lte(U, G) || I.gt(U, L));
    }
    _get(U, G) {
      return g.get(this.store, U, G);
    }
    _set(U, G) {
      const { store: L } = this;
      g.set(L, U, G), (this.store = L);
    }
  }
  (t.default = Z), (e.exports = Z), (e.exports.default = Z);
})(g0, g0.exports);
var Fee = g0.exports;
const $A = pt,
  { app: Vf, ipcMain: O0, ipcRenderer: CA, shell: jee } = xe,
  Mee = Fee;
let RA = !1;
const kA = () => {
  if (!O0 || !Vf)
    throw new Error(
      "Electron Store: You need to call `.initRenderer()` from the main process.",
    );
  const e = { defaultCwd: Vf.getPath("userData"), appVersion: Vf.getVersion() };
  return (
    RA ||
      (O0.on("electron-store-get-data", (t) => {
        t.returnValue = e;
      }),
      (RA = !0)),
    e
  );
};
class Hee extends Mee {
  constructor(t) {
    let n, r;
    if (CA) {
      const i = CA.sendSync("electron-store-get-data");
      if (!i)
        throw new Error(
          "Electron Store: You need to call `.initRenderer()` from the main process.",
        );
      ({ defaultCwd: n, appVersion: r } = i);
    } else O0 && Vf && ({ defaultCwd: n, appVersion: r } = kA());
    (t = { name: "config", ...t }),
      t.projectVersion || (t.projectVersion = r),
      t.cwd
        ? (t.cwd = $A.isAbsolute(t.cwd) ? t.cwd : $A.join(n, t.cwd))
        : (t.cwd = n),
      (t.configName = t.name),
      delete t.name,
      super(t);
  }
  static initRenderer() {
    kA();
  }
  openInEditor() {
    jee.openPath(this.path);
  }
}
var qee = Hee;
const Mp = Wl(qee),
  Hp = process.env.NODE_ENV === "development";
function Gee(e) {
  return e.length > 0;
}
const Qee = (function () {
    return typeof window > "u" ? process.platform : window.Ray.platform;
  })(),
  Wee = {
    Atom: "atom://core/open/file?filename=%path&line=%line",
    Emacs: "emacs://open?url=file://%path&line=%line",
    Idea: "idea://open?file=%path&line=%line",
    MacVim: "mvim://open/?url=file://%path&line=%line",
    PhpStorm: "phpstorm://open?file=%path&line=%line",
    Sublime:
      Qee === "linux"
        ? "subl://%path:%line"
        : "subl://open?url=file://%path&line=%line",
    TextMate: "txmt://open?url=file://%path&line=%line",
    VSCode: "vscode://file/%path:%line",
    "VSCode-insiders": "vscode-insiders://file/%path:%line",
    "Custom URL": "",
  };
let ei = null;
function QR() {
  if (ei) return ei.show();
  (ei = new xe.BrowserWindow(Qp())),
    ei.on("closed", () => (ei = null)),
    Wp(ei, { page: "preferences" }),
    zp(ei);
}
function zee() {
  ei == null || ei.close(), (ei = null);
}
function WR() {
  ei ? zee() : QR();
}
xe.ipcMain.on("open-preferences", QR);
const Kee = Fr.platform() === "win32";
let P0;
function Vee() {
  (P0 = [
    {
      role: "appMenu",
      label: "Menu",
      submenu: [
        {
          label: "About Ray",
          role: process.platform === "linux" ? void 0 : "about",
          click: () => {
            process.platform === "linux" &&
              xe.dialog.showMessageBox({
                title: "Ray",
                message: "Version " + xe.app.getVersion(),
              });
          },
        },
        {
          label: "Check for updates…",
          click: () =>
            vs.autoUpdater.checkForUpdatesAndNotify().then((e) => {
              const t =
                (e == null ? void 0 : e.updateInfo.version) !==
                xe.app.getVersion();
              t &&
                xe.dialog.showMessageBox({
                  message:
                    "A new version is available, it will be downloaded in the background.",
                }),
                t ||
                  xe.dialog.showMessageBox({
                    message: "You are running the latest version.",
                  });
            }),
        },
        { type: "separator" },
        { label: "Services", role: "services", submenu: [] },
        { type: "separator" },
        { label: "Preferences...", accelerator: "CmdOrCtrl+,", click: WR },
        ...(Kee
          ? []
          : [
              { type: "separator" },
              { label: "Hide Ray", accelerator: "CmdOrCtrl+H", role: "hide" },
              {
                label: "Hide Others",
                accelerator: "CmdOrCtrl+Alt+H",
                role: "hideOthers",
              },
              { label: "Show All", role: "unhide" },
            ]),
        { type: "separator" },
        {
          label: "Quit Ray",
          accelerator: process.platform === "darwin" ? "Cmd+Q" : "Alt+F4",
          click: xe.app.quit,
        },
      ],
    },
    {
      label: "File",
      submenu: [
        {
          label: "Find",
          accelerator: "CmdOrCtrl+F",
          click: () => {
            var e;
            return (e = xe.BrowserWindow.getFocusedWindow()) == null
              ? void 0
              : e.webContents.send("toggle-search");
          },
        },
        {
          label: "Close",
          accelerator: "CmdOrCtrl+W",
          click: () => {
            var e;
            return (e = xe.BrowserWindow.getFocusedWindow()) == null
              ? void 0
              : e.close();
          },
        },
      ],
    },
    { role: "editMenu" },
    {
      label: "View",
      submenu: [
        {
          label: "New Blank Screen",
          accelerator: "CmdOrCtrl+K",
          click: () => {
            const e = xe.BrowserWindow.getFocusedWindow();
            if (!e) return;
            const t = Yt.find((n) => n.window.id === e.id);
            t && th(t);
          },
        },
        {
          label: "New Blank Screen and Clear History",
          accelerator: "CmdOrCtrl+L",
          click: () => {
            const e = xe.BrowserWindow.getFocusedWindow();
            if (!e) return;
            const t = Yt.find((n) => n.window.id === e.id);
            t && aT(t);
          },
        },
        { type: "separator" },
        ...(Hp ? [{ role: "toggleDevTools" }] : []),
        { type: "separator" },
        { role: "resetZoom" },
        { role: "zoomIn" },
        { role: "zoomOut" },
        { type: "separator" },
        { role: "togglefullscreen" },
      ],
    },
    {
      role: "windowMenu",
      submenu: [
        {
          label: "Reset to center of screen",
          accelerator: "CmdOrCtrl+Shift+R",
          click: () => {
            var e;
            return (e = xe.BrowserWindow.getFocusedWindow()) == null
              ? void 0
              : e.center();
          },
        },
        {
          label: "Float on top",
          type: "radio",
          checked: rt.floating(),
          accelerator: rt.toggleAlwaysOnTopHotkey(),
          click: () => {
            const e = !rt.floating();
            Wb(e);
          },
        },
      ],
    },
    {
      label: "Help",
      submenu: [
        {
          label: "Documentation…",
          click: () => xe.shell.openExternal("https://spatie.be/docs/ray"),
        },
        {
          label: "Reference…",
          click: () =>
            xe.shell.openExternal(
              "https://spatie.be/docs/ray/v1/usage/reference",
            ),
        },
        {
          label: "Release Notes…",
          click: () =>
            xe.shell.openExternal(
              `https://spatie.be/products/ray/release-notes#${xe.app.getVersion()}`,
            ),
        },
        {
          label: "Manage License…",
          click: () =>
            xe.shell.openExternal("https://spatie.be/profile/purchases"),
        },
        {
          label: "Report a Bug…",
          click: () =>
            xe.shell.openExternal(
              "https://github.com/spatie/ray/issues/new?assignees=&labels=&template=bug_report.md&title=",
            ),
        },
      ],
    },
  ]),
    xe.Menu.setApplicationMenu(xe.Menu.buildFromTemplate(P0));
}
function Yee(e) {
  const t = e(P0);
  xe.Menu.setApplicationMenu(xe.Menu.buildFromTemplate(t));
}
function zR({ floating: e, accelerator: t }) {
  Yee((n) =>
    n.map(
      (i) => (
        i.role !== "windowMenu" ||
          !Array.isArray(i.submenu) ||
          (i.submenu = i.submenu.map(
            (a) => (
              a.label !== "Float on top" ||
                ((a.checked = e ?? a.checked),
                (a.accelerator = t ?? a.accelerator)),
              a
            ),
          )),
        i
      ),
    ),
  );
}
function qp() {
  xe.globalShortcut.unregisterAll(),
    rt.toggleVisibilityGlobalHotkey() &&
      xe.globalShortcut.register(rt.toggleVisibilityGlobalHotkey(), () =>
        xe.BrowserWindow.getAllWindows().forEach((e) =>
          e != null && e.isVisible()
            ? e == null
              ? void 0
              : e.hide()
            : e.show(),
        ),
      ),
    rt.newScreenGlobalHotkey() &&
      xe.globalShortcut.register(rt.newScreenGlobalHotkey(), () =>
        Yt.forEach((e) => th(e)),
      ),
    rt.toggleAlwaysOnTopHotkey() &&
      xe.globalShortcut.register(rt.toggleAlwaysOnTopHotkey(), () => {
        const e = !rt.floating();
        Wb(e);
      });
}
const jt = new Mp({
    name: "preferences",
    watch: !0,
    defaults: {
      port: "23517",
      floating: !1,
      displayTimes: !0,
      scrollOnLog: !0,
      editor: "PhpStorm",
      customEditor: "",
      colorblindMode: "Disabled",
      toggleVisibilityGlobalHotkey: "CmdOrCtrl+Shift+L",
      newScreenGlobalHotkey: "CmdOrCtrl+Shift+K",
      toggleAlwaysOnTopHotkey: "",
      newWindow: "server",
      appVisibility: "both",
      theme: "automatic",
      servers: [],
      historyLimit: 1e5,
    },
    migrations: {
      ">=1.14.0": (e) => {
        const t = e.get("appVisibility");
        ["both", "menubar"].includes(t) || e.set("appVisibility", "both");
      },
      ">=1.18.0": (e) => {
        const t = e
          .get("servers")
          .map((n) => ({
            ...n,
            uuid: n.uuid.replace(".", ""),
            needsCredentialsUpdate: !0,
          }));
        e.set("servers", t);
      },
    },
  }),
  Xee = { light: "light", dark: "dark", automatic: "system" };
function Jee() {
  KR(rt.theme());
}
function KR(e) {
  xe.nativeTheme.themeSource = Xee[e];
}
const rt = {
  instance: jt,
  port() {
    return jt.get("port");
  },
  storePort(e) {
    jt.set("port", e), Yn();
  },
  floating() {
    return jt.get("floating");
  },
  storeFloating(e) {
    jt.set("floating", e), Yn();
  },
  historyLimit() {
    return jt.get("historyLimit");
  },
  storeHistoryLimit(e) {
    jt.set("historyLimit", e), Yn();
  },
  editor() {
    return jt.get("editor");
  },
  storeEditor(e) {
    jt.set("editor", e), Yn();
  },
  customEditor() {
    return jt.get("customEditor");
  },
  storeCustomEditor(e) {
    jt.set("customEditor", e), Yn();
  },
  editorString() {
    const e = this.editor(),
      t = this.customEditor();
    return e ? (e === "Custom URL" ? t : Wee[e]) : "";
  },
  displayTimes() {
    return jt.get("displayTimes");
  },
  storeDisplayTimes(e) {
    jt.set("displayTimes", e), Yn();
  },
  scrollOnLog() {
    return jt.get("scrollOnLog");
  },
  storeScrollOnLog(e) {
    jt.set("scrollOnLog", e), Yn();
  },
  colorblindMode() {
    return jt.get("colorblindMode");
  },
  storeColorblindMode(e) {
    jt.set("colorblindMode", e), Yn();
  },
  toggleVisibilityGlobalHotkey() {
    return jt.get("toggleVisibilityGlobalHotkey");
  },
  storeToggleVisibilityGlobalHotkey(e) {
    jt.set("toggleVisibilityGlobalHotkey", e), Yn();
  },
  newScreenGlobalHotkey() {
    return jt.get("newScreenGlobalHotkey");
  },
  storeNewScreenGlobalHotkey(e) {
    jt.set("newScreenGlobalHotkey", e), Yn();
  },
  toggleAlwaysOnTopHotkey() {
    return jt.get("toggleAlwaysOnTopHotkey");
  },
  storeToggleAlwaysOnTopHotkey(e) {
    jt.set("toggleAlwaysOnTopHotkey", e), Yn();
  },
  appVisibility() {
    return jt.get("appVisibility");
  },
  storeAppVisibility(e) {
    jt.set("appVisibility", e), Yn();
  },
  shouldShowDockIcon() {
    return this.appVisibility() === "both";
  },
  newWindow() {
    return jt.get("newWindow");
  },
  storeNewWindow(e) {
    jt.set("newWindow", e), Yn();
  },
  theme() {
    return jt.get("theme");
  },
  storeTheme(e) {
    jt.set("theme", e), KR(e), Yn();
  },
  servers() {
    return jt.get("servers");
  },
  updateServer(e) {
    jt.set("servers", [...this.servers().filter((t) => t.uuid !== e.uuid), e]),
      Yn();
  },
  removeServer(e) {
    jt.set(
      "servers",
      this.servers().filter((t) => t.uuid !== e),
    ),
      Yn();
  },
  sync: Yn,
};
function VR() {
  return {
    port: rt.port(),
    floating: rt.floating(),
    displayTimes: rt.displayTimes(),
    scrollOnLog: rt.scrollOnLog(),
    editor: rt.editor(),
    customEditor: rt.customEditor(),
    colorblindMode: rt.colorblindMode(),
    toggleVisibilityGlobalHotkey: rt.toggleVisibilityGlobalHotkey(),
    newScreenGlobalHotkey: rt.newScreenGlobalHotkey(),
    toggleAlwaysOnTopHotkey: rt.toggleAlwaysOnTopHotkey(),
    newWindow: rt.newWindow(),
    appVisibility: rt.appVisibility(),
    theme: rt.theme(),
    servers: rt.servers(),
    historyLimit: rt.historyLimit(),
  };
}
function Yn() {
  const e = VR();
  xe.BrowserWindow.getAllWindows().forEach((t) =>
    t.webContents.send("preferences-changed", e),
  );
}
xe.ipcMain.handle("get-preferences", () => VR());
xe.ipcMain.on("set-port", (e, t) => {
  rt.storePort(t), nse();
});
function Wb(e) {
  xe.BrowserWindow.getAllWindows().forEach((t) => t.setAlwaysOnTop(e)),
    rt.storeFloating(e),
    zR({ floating: e });
}
xe.ipcMain.on("set-floating", (e, t) => {
  Wb(t);
});
xe.ipcMain.on("set-display-times", (e, t) => {
  rt.storeDisplayTimes(t);
});
xe.ipcMain.on("set-scroll-on-log", (e, t) => {
  rt.storeScrollOnLog(t);
});
xe.ipcMain.on("set-editor", (e, t) => {
  rt.storeEditor(t);
});
xe.ipcMain.on("set-custom-editor", (e, t) => {
  rt.storeCustomEditor(t);
});
xe.ipcMain.on("set-colorblind-mode", (e, t) => {
  rt.storeColorblindMode(t);
});
xe.ipcMain.on("set-toggle-visibility-global-hotkey", (e, t) => {
  rt.storeToggleVisibilityGlobalHotkey(t), qp();
});
xe.ipcMain.on("set-new-screen-global-hotkey", (e, t) => {
  rt.storeNewScreenGlobalHotkey(t), qp();
});
xe.ipcMain.on("set-toggle-always-on-top-hotkey", (e, t) => {
  rt.storeToggleAlwaysOnTopHotkey(t), qp(), zR({ accelerator: t });
});
xe.ipcMain.on("set-new-window", (e, t) => {
  rt.storeNewWindow(t);
});
xe.ipcMain.on("set-app-visibility", (e, t) => {
  const n = t === "both";
  rt.storeAppVisibility(t),
    Yt.forEach(({ window: r }) => {
      var i, a;
      n
        ? ((i = xe.app.dock) == null || i.show(),
          r.setSkipTaskbar(!1),
          r.setFullScreenable(!0))
        : ((a = xe.app.dock) == null || a.hide(),
          r.setSkipTaskbar(!0),
          r.setFullScreenable(!1)),
        r.show();
    });
});
xe.ipcMain.on("set-theme", (e, t) => {
  rt.storeTheme(t);
});
xe.ipcMain.on("set-history-limit", (e, t) => {
  rt.storeHistoryLimit(t);
});
const Zee = `-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAtxFglxsbAwOGzWrJrVc6
RRIE/eDTo2Wmu/sNt93tvwpNlKAvpZ/n2rEbRYrbuZkGRUP5gCJGi5jkhOB5fgEF
9MvTiZa59aOLDaC9Jk98vrGI4igZJAyKQhLJ2JqNH7Ck5IlMVt+cHkEjmjBM/eru
MWrga4uUPUBZAWqwQtHrELdYQd1wdJmlBNbnkAMceBA1tFyQpcZ5GDDJg+Bi7pS8
ef6aInWNBcyT5GIS8yA6kOolGBcSezzobq/oq/RGMouXJEm1xKLeuYfezrl7+HPS
xZgeBk24kTJnXNV9X4y7axZnOHG2CdpvTapl8QhFFbg23dtnFH2qw+u4QlDksBdy
74zJd7ZsAKzOCtsRNJoOm7BPy2TMWzWIlUvYXHcNe3AMdprTUyCGoYO+lqOImqW/
Vns2b19PepehZfoykKB6nsuDcmaSFCsTquY2MzPL331OhFH6bU6ddEx+IT4+7bYG
bpb4dO3Ef6UJwtXrXFPNJHkKyiesbHHsXnbY2z/oQ3rs1XvjVikZXBL4tG/+E0hf
uunAUrVEgZuQQat83V8nYMeVVGka523styIp2pLPaES9qZoynpj5ZrlLRFrBccBc
wu25DlxMVwm+zYSK2FTEUHdow0zxNuH6GHBP/+5vtn10loN9VxNDvFE4ZSI8TA/3
1hch+DWFkDEt6CP68r9FdKcCAwEAAQ==
-----END PUBLIC KEY-----`;
class YR {
  constructor({
    activation_code: t,
    expires_at: n,
    license_key: r,
    licensed_to: i,
    signature: a,
  }) {
    At(this, "license_key");
    At(this, "licensed_to");
    At(this, "activation_code");
    At(this, "expires_at");
    At(this, "signature");
    (this.license_key = r),
      (this.licensed_to = i),
      (this.activation_code = t),
      (this.expires_at = n),
      (this.signature = a);
  }
  get licenseProperties() {
    return {
      activation_code: this.activation_code,
      expires_at: this.expires_at,
      license_key: this.license_key,
      licensed_to: this.licensed_to,
      signature: this.signature,
    };
  }
  isValid() {
    return pr.verify(
      "sha256",
      Buffer.from(
        JSON.stringify({
          activation_code: this.activation_code,
          expires_at: this.expires_at,
          license_key: this.license_key,
          licensed_to: this.licensed_to,
        }),
      ),
      Zee,
      Buffer.from(this.signature, "base64"),
    );
  }
  isExpired() {
    return Date.now() > this.expires_at * 1e3;
  }
  isActive() {
    return this.isValid() && !this.isExpired();
  }
  humanReadableExpiresAt() {
    return new Date(this.expires_at * 1e3).toLocaleDateString();
  }
}
function TA(e) {
  return new URL(`/api${e}`, "https://spatie.be");
}
const Gp = {
    delete: async (e) =>
      fetch(TA(e), {
        method: "DELETE",
        headers: { Accept: "application/json" },
      }),
    post: async (e, t) => {
      var r;
      const n = await fetch(TA(e), {
        method: "POST",
        body: JSON.stringify(t),
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
        },
      });
      if (
        !n.ok ||
        ((r = n.headers.get("content-type")) != null && r.includes("text/html"))
      )
        throw n;
      return n.json();
    },
  },
  kn = new Mp({
    name: "licensestorage",
    watch: !0,
    defaults: {
      licenseProperties: "",
      endOfGracePeriod: null,
      amountOfRequests: 0,
      hasActiveLicense: !1,
      isLicenseOverlayLocked: !1,
      errorMessage: null,
    },
  }),
  fn = {
    instance: kn,
    getAmountOfRequests() {
      return kn.get("amountOfRequests");
    },
    setAmountOfRequests(e) {
      kn.set("amountOfRequests", e), Ni();
    },
    getHasActiveLicense() {
      return kn.get("hasActiveLicense");
    },
    setHasActiveLicense(e) {
      kn.set("hasActiveLicense", e), Ni(), e && ate();
    },
    getIsLicenseOverlayLocked() {
      return kn.get("isLicenseOverlayLocked");
    },
    setIsLicenseOverlayLocked(e) {
      kn.set("isLicenseOverlayLocked", e), Ni();
    },
    getErrorMessage() {
      return kn.get("errorMessage");
    },
    setErrorMessage(e) {
      kn.set("errorMessage", e), Ni();
    },
    getSignedLicense() {
      const e = kn.get("licenseProperties");
      if (e) return new YR(JSON.parse(e));
    },
    store(e) {
      kn.set({ licenseProperties: JSON.stringify(e.licenseProperties) }), Ni();
    },
    async delete() {
      const e = this.getSignedLicense();
      e && (await Gp.delete(`/activations/${e.activation_code}`)),
        kn.delete("licenseProperties"),
        kn.delete("endOfGracePeriod"),
        Ni();
    },
    startGracePeriod() {
      const e = new Date(),
        t = e.setDate(e.getDate() + 7);
      kn.set("endOfGracePeriod", t), Ni();
    },
    endGracePeriod() {
      kn.delete("endOfGracePeriod"), Ni();
    },
    getGracePeriod() {
      const e = kn.get("endOfGracePeriod"),
        t = e ? e < new Date().getTime() : !1;
      return {
        isInGracePeriod: !!e,
        endOfGracePeriod: e,
        hasGracePeriodExpired: t,
      };
    },
    setEndOfGracePeriod(e) {
      kn.set("endOfGracePeriod", e), Ni();
    },
  };
function ete() {
  kn.set("amountOfRequests", -9999999999999),
    kn.set("hasActiveLicense", !1),
    kn.set("isLicenseOverlayLocked", !1),
    kn.set("errorMessage", null),
    Ni();
}
ete();
function XR() {
  const e = fn.getSignedLicense();
  return {
    ...(!e
      ? {
          licensed_to: "অভিকর্ষ",
          expiry_date: "আজীবন মেয়াদ",
          license_key: "কোন লাইসেন্স নেই",
          is_expired: false,
        }
      : {}),
    is_overlay_locked: false,
    error_message: fn.getErrorMessage() ?? void 0,
    has_grace_period_expired: fn.getGracePeriod().hasGracePeriodExpired,
    end_of_grace_period: 0,
    has_active_license: !fn.getHasActiveLicense(),
    amount_of_requests: fn.getAmountOfRequests(),
  };
}
function Ni() {
  const e = XR();
  xe.BrowserWindow.getAllWindows().forEach((t) =>
    t.webContents.send("license-changed", e),
  );
}
xe.ipcMain.handle("get-license", () => XR());
const Js = new Mp({
  name: "usage",
  defaults: {
    hasReceivedRayRequest: !1,
    mainWindowBounds: {},
    reportedVersion: "0.0.0",
  },
});
let NA = Js.get("hasReceivedRayRequest");
function tte() {
  NA || (Js.set("hasReceivedRayRequest", !0), (NA = !0));
}
function JR() {
  return Js.get("mainWindowBounds");
}
function nte(e) {
  Js.set("mainWindowBounds", e);
}
function rte() {
  return Js.get("reportedVersion");
}
function ite(e) {
  Js.set("reportedVersion", e);
}
xe.ipcMain.handle(
  "get-is-first-time-user",
  () => !Js.get("hasReceivedRayRequest"),
);
async function ate() {
  var n;
  const e = xe.app.getVersion();
  if (e === rte()) return;
  const t = (n = fn.getSignedLicense()) == null ? void 0 : n.activation_code;
  if (t) {
    try {
      await Gp.post(`/activations/${t}/version`, {
        current_version: e,
        arch: process.arch,
        platform: process.platform,
        os_version: Fr.version(),
      });
    } catch {}
    ite(e);
  }
}
const ste = Gl.join(__dirname, "../preload/index.js");
function Qp() {
  return {
    ...ZR(),
    width: 700,
    height: 600,
    minWidth: 400,
    minHeight: 140,
    titleBarStyle: "hiddenInset",
    skipTaskbar: !0,
    show: !1,
    webPreferences: { preload: ste },
  };
}
function ZR() {
  var t;
  const e =
    ((t =
      xe.BrowserWindow.getFocusedWindow() ||
      xe.BrowserWindow.getAllWindows()[0]) == null
      ? void 0
      : t.getBounds()) || JR();
  return (e.x = e.x + 20), (e.y = e.y + 20), e;
}
function Wp(e, t) {
  if (process.env.VITE_DEV_SERVER_URL) {
    const n = new URLSearchParams(JSON.parse(JSON.stringify(t))),
      r = new URL(process.env.VITE_DEV_SERVER_URL);
    (r.search = n.toString()), e.loadURL(r.toString());
  } else e.loadFile(Gl.join(process.env.DIST, "index.html"), { query: t });
}
function zp(e, t = !0) {
  D0(e),
    cte(e),
    rt.floating() && e.setAlwaysOnTop(!0),
    e.once("ready-to-show", () => {
      if (!Hp && t) return e.show();
      e.showInactive();
    });
}
function D0(e, t = !0) {
  t &&
    (xe.screen.on("display-removed", () => D0(e, !1)),
    xe.screen.on("display-metrics-changed", () => D0(e, !1))),
    !e.isDestroyed() && (ote(e.getBounds()) || e.center());
}
function ote(e) {
  const t = xe.screen.getDisplayMatching(e),
    n = t.bounds.x <= e.x,
    r = t.bounds.x + t.bounds.width >= e.x + e.width,
    i = t.bounds.y <= e.y,
    a = t.bounds.y + t.bounds.height >= e.y + e.height;
  return n && r && i && a;
}
function cte(e) {
  e.webContents.setWindowOpenHandler(
    ({ url: t }) => (L0(t), { action: "deny" }),
  ),
    e.webContents.on("will-navigate", async (t, n) => {
      (Hp && n.includes("localhost")) || (t.preventDefault(), await L0(n));
    });
}
async function L0(e) {
  e.startsWith("https:") && (await xe.shell.openExternal(e));
}
var ek = { exports: {} },
  zb = {
    newInvalidAsn1Error: function (e) {
      var t = new Error();
      return (t.name = "InvalidAsn1Error"), (t.message = e || ""), t;
    },
  },
  Kb = {
    EOC: 0,
    Boolean: 1,
    Integer: 2,
    BitString: 3,
    OctetString: 4,
    Null: 5,
    OID: 6,
    ObjectDescriptor: 7,
    External: 8,
    Real: 9,
    Enumeration: 10,
    PDV: 11,
    Utf8String: 12,
    RelativeOID: 13,
    Sequence: 16,
    Set: 17,
    NumericString: 18,
    PrintableString: 19,
    T61String: 20,
    VideotexString: 21,
    IA5String: 22,
    UTCTime: 23,
    GeneralizedTime: 24,
    GraphicString: 25,
    VisibleString: 26,
    GeneralString: 28,
    UniversalString: 29,
    CharacterString: 30,
    BMPString: 31,
    Constructor: 32,
    Context: 128,
  },
  lte = gc,
  tk = Xa().Buffer,
  bu = Kb,
  ute = zb,
  lc = ute.newInvalidAsn1Error;
function Cr(e) {
  if (!e || !tk.isBuffer(e)) throw new TypeError("data must be a node Buffer");
  (this._buf = e), (this._size = e.length), (this._len = 0), (this._offset = 0);
}
Object.defineProperty(Cr.prototype, "length", {
  enumerable: !0,
  get: function () {
    return this._len;
  },
});
Object.defineProperty(Cr.prototype, "offset", {
  enumerable: !0,
  get: function () {
    return this._offset;
  },
});
Object.defineProperty(Cr.prototype, "remain", {
  get: function () {
    return this._size - this._offset;
  },
});
Object.defineProperty(Cr.prototype, "buffer", {
  get: function () {
    return this._buf.slice(this._offset);
  },
});
Cr.prototype.readByte = function (e) {
  if (this._size - this._offset < 1) return null;
  var t = this._buf[this._offset] & 255;
  return e || (this._offset += 1), t;
};
Cr.prototype.peek = function () {
  return this.readByte(!0);
};
Cr.prototype.readLength = function (e) {
  if ((e === void 0 && (e = this._offset), e >= this._size)) return null;
  var t = this._buf[e++] & 255;
  if (t === null) return null;
  if ((t & 128) === 128) {
    if (((t &= 127), t === 0)) throw lc("Indefinite length not supported");
    if (t > 4) throw lc("encoding too long");
    if (this._size - e < t) return null;
    this._len = 0;
    for (var n = 0; n < t; n++)
      this._len = (this._len << 8) + (this._buf[e++] & 255);
  } else this._len = t;
  return e;
};
Cr.prototype.readSequence = function (e) {
  var t = this.peek();
  if (t === null) return null;
  if (e !== void 0 && e !== t)
    throw lc("Expected 0x" + e.toString(16) + ": got 0x" + t.toString(16));
  var n = this.readLength(this._offset + 1);
  return n === null ? null : ((this._offset = n), t);
};
Cr.prototype.readInt = function () {
  return this._readTag(bu.Integer);
};
Cr.prototype.readBoolean = function () {
  return this._readTag(bu.Boolean) !== 0;
};
Cr.prototype.readEnumeration = function () {
  return this._readTag(bu.Enumeration);
};
Cr.prototype.readString = function (e, t) {
  e || (e = bu.OctetString);
  var n = this.peek();
  if (n === null) return null;
  if (n !== e)
    throw lc("Expected 0x" + e.toString(16) + ": got 0x" + n.toString(16));
  var r = this.readLength(this._offset + 1);
  if (r === null || this.length > this._size - r) return null;
  if (((this._offset = r), this.length === 0)) return t ? tk.alloc(0) : "";
  var i = this._buf.slice(this._offset, this._offset + this.length);
  return (this._offset += this.length), t ? i : i.toString("utf8");
};
Cr.prototype.readOID = function (e) {
  e || (e = bu.OID);
  var t = this.readString(e, !0);
  if (t === null) return null;
  for (var n = [], r = 0, i = 0; i < t.length; i++) {
    var a = t[i] & 255;
    (r <<= 7), (r += a & 127), a & 128 || (n.push(r), (r = 0));
  }
  return (
    (r = n.shift()), n.unshift(r % 40), n.unshift((r / 40) >> 0), n.join(".")
  );
};
Cr.prototype._readTag = function (e) {
  lte.ok(e !== void 0);
  var t = this.peek();
  if (t === null) return null;
  if (t !== e)
    throw lc("Expected 0x" + e.toString(16) + ": got 0x" + t.toString(16));
  var n = this.readLength(this._offset + 1);
  if (n === null) return null;
  if (this.length > 4) throw lc("Integer too long: " + this.length);
  if (this.length > this._size - n) return null;
  this._offset = n;
  for (var r = this._buf[this._offset], i = 0, a = 0; a < this.length; a++)
    (i <<= 8), (i |= this._buf[this._offset++] & 255);
  return (r & 128) === 128 && a !== 4 && (i -= 1 << (a * 8)), i >> 0;
};
var fte = Cr,
  Ma = gc,
  Kp = Xa().Buffer,
  Va = Kb,
  dte = zb,
  Vp = dte.newInvalidAsn1Error,
  pte = { size: 1024, growthFactor: 8 };
function hte(e, t) {
  Ma.ok(e),
    Ma.equal(typeof e, "object"),
    Ma.ok(t),
    Ma.equal(typeof t, "object");
  var n = Object.getOwnPropertyNames(e);
  return (
    n.forEach(function (r) {
      if (!t[r]) {
        var i = Object.getOwnPropertyDescriptor(e, r);
        Object.defineProperty(t, r, i);
      }
    }),
    t
  );
}
function mr(e) {
  (e = hte(pte, e || {})),
    (this._buf = Kp.alloc(e.size || 1024)),
    (this._size = this._buf.length),
    (this._offset = 0),
    (this._options = e),
    (this._seq = []);
}
Object.defineProperty(mr.prototype, "buffer", {
  get: function () {
    if (this._seq.length) throw Vp(this._seq.length + " unended sequence(s)");
    return this._buf.slice(0, this._offset);
  },
});
mr.prototype.writeByte = function (e) {
  if (typeof e != "number") throw new TypeError("argument must be a Number");
  this._ensure(1), (this._buf[this._offset++] = e);
};
mr.prototype.writeInt = function (e, t) {
  if (typeof e != "number") throw new TypeError("argument must be a Number");
  typeof t != "number" && (t = Va.Integer);
  for (
    var n = 4;
    (!(e & 4286578688) || (e & 4286578688) === -8388608) && n > 1;

  )
    n--, (e <<= 8);
  if (n > 4) throw Vp("BER ints cannot be > 0xffffffff");
  for (
    this._ensure(2 + n),
      this._buf[this._offset++] = t,
      this._buf[this._offset++] = n;
    n-- > 0;

  )
    (this._buf[this._offset++] = (e & 4278190080) >>> 24), (e <<= 8);
};
mr.prototype.writeNull = function () {
  this.writeByte(Va.Null), this.writeByte(0);
};
mr.prototype.writeEnumeration = function (e, t) {
  if (typeof e != "number") throw new TypeError("argument must be a Number");
  return typeof t != "number" && (t = Va.Enumeration), this.writeInt(e, t);
};
mr.prototype.writeBoolean = function (e, t) {
  if (typeof e != "boolean") throw new TypeError("argument must be a Boolean");
  typeof t != "number" && (t = Va.Boolean),
    this._ensure(3),
    (this._buf[this._offset++] = t),
    (this._buf[this._offset++] = 1),
    (this._buf[this._offset++] = e ? 255 : 0);
};
mr.prototype.writeString = function (e, t) {
  if (typeof e != "string")
    throw new TypeError("argument must be a string (was: " + typeof e + ")");
  typeof t != "number" && (t = Va.OctetString);
  var n = Kp.byteLength(e);
  this.writeByte(t),
    this.writeLength(n),
    n &&
      (this._ensure(n), this._buf.write(e, this._offset), (this._offset += n));
};
mr.prototype.writeBuffer = function (e, t) {
  if (typeof t != "number") throw new TypeError("tag must be a number");
  if (!Kp.isBuffer(e)) throw new TypeError("argument must be a buffer");
  this.writeByte(t),
    this.writeLength(e.length),
    this._ensure(e.length),
    e.copy(this._buf, this._offset, 0, e.length),
    (this._offset += e.length);
};
mr.prototype.writeStringArray = function (e) {
  if (!e instanceof Array)
    throw new TypeError("argument must be an Array[String]");
  var t = this;
  e.forEach(function (n) {
    t.writeString(n);
  });
};
mr.prototype.writeOID = function (e, t) {
  if (typeof e != "string") throw new TypeError("argument must be a string");
  if ((typeof t != "number" && (t = Va.OID), !/^([0-9]+\.){3,}[0-9]+$/.test(e)))
    throw new Error("argument is not a valid OID string");
  function n(s, o) {
    o < 128
      ? s.push(o)
      : o < 16384
      ? (s.push((o >>> 7) | 128), s.push(o & 127))
      : o < 2097152
      ? (s.push((o >>> 14) | 128),
        s.push(((o >>> 7) | 128) & 255),
        s.push(o & 127))
      : o < 268435456
      ? (s.push((o >>> 21) | 128),
        s.push(((o >>> 14) | 128) & 255),
        s.push(((o >>> 7) | 128) & 255),
        s.push(o & 127))
      : (s.push(((o >>> 28) | 128) & 255),
        s.push(((o >>> 21) | 128) & 255),
        s.push(((o >>> 14) | 128) & 255),
        s.push(((o >>> 7) | 128) & 255),
        s.push(o & 127));
  }
  var r = e.split("."),
    i = [];
  i.push(parseInt(r[0], 10) * 40 + parseInt(r[1], 10)),
    r.slice(2).forEach(function (s) {
      n(i, parseInt(s, 10));
    });
  var a = this;
  this._ensure(2 + i.length),
    this.writeByte(t),
    this.writeLength(i.length),
    i.forEach(function (s) {
      a.writeByte(s);
    });
};
mr.prototype.writeLength = function (e) {
  if (typeof e != "number") throw new TypeError("argument must be a Number");
  if ((this._ensure(4), e <= 127)) this._buf[this._offset++] = e;
  else if (e <= 255)
    (this._buf[this._offset++] = 129), (this._buf[this._offset++] = e);
  else if (e <= 65535)
    (this._buf[this._offset++] = 130),
      (this._buf[this._offset++] = e >> 8),
      (this._buf[this._offset++] = e);
  else if (e <= 16777215)
    (this._buf[this._offset++] = 131),
      (this._buf[this._offset++] = e >> 16),
      (this._buf[this._offset++] = e >> 8),
      (this._buf[this._offset++] = e);
  else throw Vp("Length too long (> 4 bytes)");
};
mr.prototype.startSequence = function (e) {
  typeof e != "number" && (e = Va.Sequence | Va.Constructor),
    this.writeByte(e),
    this._seq.push(this._offset),
    this._ensure(3),
    (this._offset += 3);
};
mr.prototype.endSequence = function () {
  var e = this._seq.pop(),
    t = e + 3,
    n = this._offset - t;
  if (n <= 127) this._shift(t, n, -2), (this._buf[e] = n);
  else if (n <= 255)
    this._shift(t, n, -1), (this._buf[e] = 129), (this._buf[e + 1] = n);
  else if (n <= 65535)
    (this._buf[e] = 130), (this._buf[e + 1] = n >> 8), (this._buf[e + 2] = n);
  else if (n <= 16777215)
    this._shift(t, n, 1),
      (this._buf[e] = 131),
      (this._buf[e + 1] = n >> 16),
      (this._buf[e + 2] = n >> 8),
      (this._buf[e + 3] = n);
  else throw Vp("Sequence too long");
};
mr.prototype._shift = function (e, t, n) {
  Ma.ok(e !== void 0),
    Ma.ok(t !== void 0),
    Ma.ok(n),
    this._buf.copy(this._buf, e + n, e, e + t),
    (this._offset += n);
};
mr.prototype._ensure = function (e) {
  if ((Ma.ok(e), this._size - this._offset < e)) {
    var t = this._size * this._options.growthFactor;
    t - this._offset < e && (t += e);
    var n = Kp.alloc(t);
    this._buf.copy(n, 0, 0, this._offset), (this._buf = n), (this._size = t);
  }
};
var mte = mr;
(function (e) {
  var t = zb,
    n = Kb,
    r = fte,
    i = mte;
  e.exports = { Reader: r, Writer: i };
  for (var a in n) n.hasOwnProperty(a) && (e.exports[a] = n[a]);
  for (var s in t) t.hasOwnProperty(s) && (e.exports[s] = t[s]);
})(ek);
var gte = ek.exports,
  Qm = gte,
  Yp = { Ber: Qm, BerReader: Qm.Reader, BerWriter: Qm.Writer },
  nk = { exports: {} };
(function (e) {
  (function (t) {
    var n = function (P) {
        var C,
          $ = new Float64Array(16);
        if (P) for (C = 0; C < P.length; C++) $[C] = P[C];
        return $;
      },
      r = function () {
        throw new Error("no PRNG");
      },
      i = new Uint8Array(16),
      a = new Uint8Array(32);
    a[0] = 9;
    var s = n(),
      o = n([1]),
      c = n([56129, 1]),
      l = n([
        30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505,
        36039, 65139, 11119, 27886, 20995,
      ]),
      f = n([
        61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010,
        6542, 64743, 22239, 55772, 9222,
      ]),
      u = n([
        54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982,
        57905, 49316, 21502, 52590, 14035, 8553,
      ]),
      d = n([
        26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214,
        26214, 26214, 26214, 26214, 26214, 26214,
      ]),
      p = n([
        41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153,
        11085, 57099, 20417, 9344, 11139,
      ]);
    function h(P, C, $, b) {
      (P[C] = ($ >> 24) & 255),
        (P[C + 1] = ($ >> 16) & 255),
        (P[C + 2] = ($ >> 8) & 255),
        (P[C + 3] = $ & 255),
        (P[C + 4] = (b >> 24) & 255),
        (P[C + 5] = (b >> 16) & 255),
        (P[C + 6] = (b >> 8) & 255),
        (P[C + 7] = b & 255);
    }
    function m(P, C, $, b, D) {
      var K,
        se = 0;
      for (K = 0; K < D; K++) se |= P[C + K] ^ $[b + K];
      return (1 & ((se - 1) >>> 8)) - 1;
    }
    function g(P, C, $, b) {
      return m(P, C, $, b, 16);
    }
    function v(P, C, $, b) {
      return m(P, C, $, b, 32);
    }
    function y(P, C, $, b) {
      for (
        var D =
            (b[0] & 255) |
            ((b[1] & 255) << 8) |
            ((b[2] & 255) << 16) |
            ((b[3] & 255) << 24),
          K =
            ($[0] & 255) |
            (($[1] & 255) << 8) |
            (($[2] & 255) << 16) |
            (($[3] & 255) << 24),
          se =
            ($[4] & 255) |
            (($[5] & 255) << 8) |
            (($[6] & 255) << 16) |
            (($[7] & 255) << 24),
          pe =
            ($[8] & 255) |
            (($[9] & 255) << 8) |
            (($[10] & 255) << 16) |
            (($[11] & 255) << 24),
          we =
            ($[12] & 255) |
            (($[13] & 255) << 8) |
            (($[14] & 255) << 16) |
            (($[15] & 255) << 24),
          Re =
            (b[4] & 255) |
            ((b[5] & 255) << 8) |
            ((b[6] & 255) << 16) |
            ((b[7] & 255) << 24),
          ke =
            (C[0] & 255) |
            ((C[1] & 255) << 8) |
            ((C[2] & 255) << 16) |
            ((C[3] & 255) << 24),
          je =
            (C[4] & 255) |
            ((C[5] & 255) << 8) |
            ((C[6] & 255) << 16) |
            ((C[7] & 255) << 24),
          Te =
            (C[8] & 255) |
            ((C[9] & 255) << 8) |
            ((C[10] & 255) << 16) |
            ((C[11] & 255) << 24),
          Me =
            (C[12] & 255) |
            ((C[13] & 255) << 8) |
            ((C[14] & 255) << 16) |
            ((C[15] & 255) << 24),
          Ne =
            (b[8] & 255) |
            ((b[9] & 255) << 8) |
            ((b[10] & 255) << 16) |
            ((b[11] & 255) << 24),
          Ue =
            ($[16] & 255) |
            (($[17] & 255) << 8) |
            (($[18] & 255) << 16) |
            (($[19] & 255) << 24),
          qe =
            ($[20] & 255) |
            (($[21] & 255) << 8) |
            (($[22] & 255) << 16) |
            (($[23] & 255) << 24),
          Fe =
            ($[24] & 255) |
            (($[25] & 255) << 8) |
            (($[26] & 255) << 16) |
            (($[27] & 255) << 24),
          Je =
            ($[28] & 255) |
            (($[29] & 255) << 8) |
            (($[30] & 255) << 16) |
            (($[31] & 255) << 24),
          Ke =
            (b[12] & 255) |
            ((b[13] & 255) << 8) |
            ((b[14] & 255) << 16) |
            ((b[15] & 255) << 24),
          Be = D,
          He = K,
          De = se,
          Le = pe,
          Pe = we,
          Oe = Re,
          ge = ke,
          ve = je,
          Ie = Te,
          Se = Me,
          Ae = Ne,
          Ce = Ue,
          Ve = qe,
          it = Fe,
          mt = Je,
          at = Ke,
          ae,
          _t = 0;
        _t < 20;
        _t += 2
      )
        (ae = (Be + Ve) | 0),
          (Pe ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Pe + Be) | 0),
          (Ie ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (Ie + Pe) | 0),
          (Ve ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Ve + Ie) | 0),
          (Be ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Oe + He) | 0),
          (Se ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Se + Oe) | 0),
          (it ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (it + Se) | 0),
          (He ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (He + it) | 0),
          (Oe ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Ae + ge) | 0),
          (mt ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (mt + Ae) | 0),
          (De ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (De + mt) | 0),
          (ge ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (ge + De) | 0),
          (Ae ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (at + Ce) | 0),
          (Le ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Le + at) | 0),
          (ve ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (ve + Le) | 0),
          (Ce ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Ce + ve) | 0),
          (at ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Be + Le) | 0),
          (He ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (He + Be) | 0),
          (De ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (De + He) | 0),
          (Le ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Le + De) | 0),
          (Be ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Oe + Pe) | 0),
          (ge ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (ge + Oe) | 0),
          (ve ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (ve + ge) | 0),
          (Pe ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Pe + ve) | 0),
          (Oe ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Ae + Se) | 0),
          (Ce ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Ce + Ae) | 0),
          (Ie ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (Ie + Ce) | 0),
          (Se ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Se + Ie) | 0),
          (Ae ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (at + mt) | 0),
          (Ve ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Ve + at) | 0),
          (it ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (it + Ve) | 0),
          (mt ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (mt + it) | 0),
          (at ^= (ae << 18) | (ae >>> (32 - 18)));
      (Be = (Be + D) | 0),
        (He = (He + K) | 0),
        (De = (De + se) | 0),
        (Le = (Le + pe) | 0),
        (Pe = (Pe + we) | 0),
        (Oe = (Oe + Re) | 0),
        (ge = (ge + ke) | 0),
        (ve = (ve + je) | 0),
        (Ie = (Ie + Te) | 0),
        (Se = (Se + Me) | 0),
        (Ae = (Ae + Ne) | 0),
        (Ce = (Ce + Ue) | 0),
        (Ve = (Ve + qe) | 0),
        (it = (it + Fe) | 0),
        (mt = (mt + Je) | 0),
        (at = (at + Ke) | 0),
        (P[0] = (Be >>> 0) & 255),
        (P[1] = (Be >>> 8) & 255),
        (P[2] = (Be >>> 16) & 255),
        (P[3] = (Be >>> 24) & 255),
        (P[4] = (He >>> 0) & 255),
        (P[5] = (He >>> 8) & 255),
        (P[6] = (He >>> 16) & 255),
        (P[7] = (He >>> 24) & 255),
        (P[8] = (De >>> 0) & 255),
        (P[9] = (De >>> 8) & 255),
        (P[10] = (De >>> 16) & 255),
        (P[11] = (De >>> 24) & 255),
        (P[12] = (Le >>> 0) & 255),
        (P[13] = (Le >>> 8) & 255),
        (P[14] = (Le >>> 16) & 255),
        (P[15] = (Le >>> 24) & 255),
        (P[16] = (Pe >>> 0) & 255),
        (P[17] = (Pe >>> 8) & 255),
        (P[18] = (Pe >>> 16) & 255),
        (P[19] = (Pe >>> 24) & 255),
        (P[20] = (Oe >>> 0) & 255),
        (P[21] = (Oe >>> 8) & 255),
        (P[22] = (Oe >>> 16) & 255),
        (P[23] = (Oe >>> 24) & 255),
        (P[24] = (ge >>> 0) & 255),
        (P[25] = (ge >>> 8) & 255),
        (P[26] = (ge >>> 16) & 255),
        (P[27] = (ge >>> 24) & 255),
        (P[28] = (ve >>> 0) & 255),
        (P[29] = (ve >>> 8) & 255),
        (P[30] = (ve >>> 16) & 255),
        (P[31] = (ve >>> 24) & 255),
        (P[32] = (Ie >>> 0) & 255),
        (P[33] = (Ie >>> 8) & 255),
        (P[34] = (Ie >>> 16) & 255),
        (P[35] = (Ie >>> 24) & 255),
        (P[36] = (Se >>> 0) & 255),
        (P[37] = (Se >>> 8) & 255),
        (P[38] = (Se >>> 16) & 255),
        (P[39] = (Se >>> 24) & 255),
        (P[40] = (Ae >>> 0) & 255),
        (P[41] = (Ae >>> 8) & 255),
        (P[42] = (Ae >>> 16) & 255),
        (P[43] = (Ae >>> 24) & 255),
        (P[44] = (Ce >>> 0) & 255),
        (P[45] = (Ce >>> 8) & 255),
        (P[46] = (Ce >>> 16) & 255),
        (P[47] = (Ce >>> 24) & 255),
        (P[48] = (Ve >>> 0) & 255),
        (P[49] = (Ve >>> 8) & 255),
        (P[50] = (Ve >>> 16) & 255),
        (P[51] = (Ve >>> 24) & 255),
        (P[52] = (it >>> 0) & 255),
        (P[53] = (it >>> 8) & 255),
        (P[54] = (it >>> 16) & 255),
        (P[55] = (it >>> 24) & 255),
        (P[56] = (mt >>> 0) & 255),
        (P[57] = (mt >>> 8) & 255),
        (P[58] = (mt >>> 16) & 255),
        (P[59] = (mt >>> 24) & 255),
        (P[60] = (at >>> 0) & 255),
        (P[61] = (at >>> 8) & 255),
        (P[62] = (at >>> 16) & 255),
        (P[63] = (at >>> 24) & 255);
    }
    function _(P, C, $, b) {
      for (
        var D =
            (b[0] & 255) |
            ((b[1] & 255) << 8) |
            ((b[2] & 255) << 16) |
            ((b[3] & 255) << 24),
          K =
            ($[0] & 255) |
            (($[1] & 255) << 8) |
            (($[2] & 255) << 16) |
            (($[3] & 255) << 24),
          se =
            ($[4] & 255) |
            (($[5] & 255) << 8) |
            (($[6] & 255) << 16) |
            (($[7] & 255) << 24),
          pe =
            ($[8] & 255) |
            (($[9] & 255) << 8) |
            (($[10] & 255) << 16) |
            (($[11] & 255) << 24),
          we =
            ($[12] & 255) |
            (($[13] & 255) << 8) |
            (($[14] & 255) << 16) |
            (($[15] & 255) << 24),
          Re =
            (b[4] & 255) |
            ((b[5] & 255) << 8) |
            ((b[6] & 255) << 16) |
            ((b[7] & 255) << 24),
          ke =
            (C[0] & 255) |
            ((C[1] & 255) << 8) |
            ((C[2] & 255) << 16) |
            ((C[3] & 255) << 24),
          je =
            (C[4] & 255) |
            ((C[5] & 255) << 8) |
            ((C[6] & 255) << 16) |
            ((C[7] & 255) << 24),
          Te =
            (C[8] & 255) |
            ((C[9] & 255) << 8) |
            ((C[10] & 255) << 16) |
            ((C[11] & 255) << 24),
          Me =
            (C[12] & 255) |
            ((C[13] & 255) << 8) |
            ((C[14] & 255) << 16) |
            ((C[15] & 255) << 24),
          Ne =
            (b[8] & 255) |
            ((b[9] & 255) << 8) |
            ((b[10] & 255) << 16) |
            ((b[11] & 255) << 24),
          Ue =
            ($[16] & 255) |
            (($[17] & 255) << 8) |
            (($[18] & 255) << 16) |
            (($[19] & 255) << 24),
          qe =
            ($[20] & 255) |
            (($[21] & 255) << 8) |
            (($[22] & 255) << 16) |
            (($[23] & 255) << 24),
          Fe =
            ($[24] & 255) |
            (($[25] & 255) << 8) |
            (($[26] & 255) << 16) |
            (($[27] & 255) << 24),
          Je =
            ($[28] & 255) |
            (($[29] & 255) << 8) |
            (($[30] & 255) << 16) |
            (($[31] & 255) << 24),
          Ke =
            (b[12] & 255) |
            ((b[13] & 255) << 8) |
            ((b[14] & 255) << 16) |
            ((b[15] & 255) << 24),
          Be = D,
          He = K,
          De = se,
          Le = pe,
          Pe = we,
          Oe = Re,
          ge = ke,
          ve = je,
          Ie = Te,
          Se = Me,
          Ae = Ne,
          Ce = Ue,
          Ve = qe,
          it = Fe,
          mt = Je,
          at = Ke,
          ae,
          _t = 0;
        _t < 20;
        _t += 2
      )
        (ae = (Be + Ve) | 0),
          (Pe ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Pe + Be) | 0),
          (Ie ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (Ie + Pe) | 0),
          (Ve ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Ve + Ie) | 0),
          (Be ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Oe + He) | 0),
          (Se ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Se + Oe) | 0),
          (it ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (it + Se) | 0),
          (He ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (He + it) | 0),
          (Oe ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Ae + ge) | 0),
          (mt ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (mt + Ae) | 0),
          (De ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (De + mt) | 0),
          (ge ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (ge + De) | 0),
          (Ae ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (at + Ce) | 0),
          (Le ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Le + at) | 0),
          (ve ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (ve + Le) | 0),
          (Ce ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Ce + ve) | 0),
          (at ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Be + Le) | 0),
          (He ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (He + Be) | 0),
          (De ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (De + He) | 0),
          (Le ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Le + De) | 0),
          (Be ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Oe + Pe) | 0),
          (ge ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (ge + Oe) | 0),
          (ve ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (ve + ge) | 0),
          (Pe ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Pe + ve) | 0),
          (Oe ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Ae + Se) | 0),
          (Ce ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Ce + Ae) | 0),
          (Ie ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (Ie + Ce) | 0),
          (Se ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Se + Ie) | 0),
          (Ae ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (at + mt) | 0),
          (Ve ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Ve + at) | 0),
          (it ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (it + Ve) | 0),
          (mt ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (mt + it) | 0),
          (at ^= (ae << 18) | (ae >>> (32 - 18)));
      (P[0] = (Be >>> 0) & 255),
        (P[1] = (Be >>> 8) & 255),
        (P[2] = (Be >>> 16) & 255),
        (P[3] = (Be >>> 24) & 255),
        (P[4] = (Oe >>> 0) & 255),
        (P[5] = (Oe >>> 8) & 255),
        (P[6] = (Oe >>> 16) & 255),
        (P[7] = (Oe >>> 24) & 255),
        (P[8] = (Ae >>> 0) & 255),
        (P[9] = (Ae >>> 8) & 255),
        (P[10] = (Ae >>> 16) & 255),
        (P[11] = (Ae >>> 24) & 255),
        (P[12] = (at >>> 0) & 255),
        (P[13] = (at >>> 8) & 255),
        (P[14] = (at >>> 16) & 255),
        (P[15] = (at >>> 24) & 255),
        (P[16] = (ge >>> 0) & 255),
        (P[17] = (ge >>> 8) & 255),
        (P[18] = (ge >>> 16) & 255),
        (P[19] = (ge >>> 24) & 255),
        (P[20] = (ve >>> 0) & 255),
        (P[21] = (ve >>> 8) & 255),
        (P[22] = (ve >>> 16) & 255),
        (P[23] = (ve >>> 24) & 255),
        (P[24] = (Ie >>> 0) & 255),
        (P[25] = (Ie >>> 8) & 255),
        (P[26] = (Ie >>> 16) & 255),
        (P[27] = (Ie >>> 24) & 255),
        (P[28] = (Se >>> 0) & 255),
        (P[29] = (Se >>> 8) & 255),
        (P[30] = (Se >>> 16) & 255),
        (P[31] = (Se >>> 24) & 255);
    }
    function E(P, C, $, b) {
      y(P, C, $, b);
    }
    function R(P, C, $, b) {
      _(P, C, $, b);
    }
    var A = new Uint8Array([
      101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107,
    ]);
    function I(P, C, $, b, D, K, se) {
      var pe = new Uint8Array(16),
        we = new Uint8Array(64),
        Re,
        ke;
      for (ke = 0; ke < 16; ke++) pe[ke] = 0;
      for (ke = 0; ke < 8; ke++) pe[ke] = K[ke];
      for (; D >= 64; ) {
        for (E(we, pe, se, A), ke = 0; ke < 64; ke++)
          P[C + ke] = $[b + ke] ^ we[ke];
        for (Re = 1, ke = 8; ke < 16; ke++)
          (Re = (Re + (pe[ke] & 255)) | 0), (pe[ke] = Re & 255), (Re >>>= 8);
        (D -= 64), (C += 64), (b += 64);
      }
      if (D > 0)
        for (E(we, pe, se, A), ke = 0; ke < D; ke++)
          P[C + ke] = $[b + ke] ^ we[ke];
      return 0;
    }
    function S(P, C, $, b, D) {
      var K = new Uint8Array(16),
        se = new Uint8Array(64),
        pe,
        we;
      for (we = 0; we < 16; we++) K[we] = 0;
      for (we = 0; we < 8; we++) K[we] = b[we];
      for (; $ >= 64; ) {
        for (E(se, K, D, A), we = 0; we < 64; we++) P[C + we] = se[we];
        for (pe = 1, we = 8; we < 16; we++)
          (pe = (pe + (K[we] & 255)) | 0), (K[we] = pe & 255), (pe >>>= 8);
        ($ -= 64), (C += 64);
      }
      if ($ > 0) for (E(se, K, D, A), we = 0; we < $; we++) P[C + we] = se[we];
      return 0;
    }
    function w(P, C, $, b, D) {
      var K = new Uint8Array(32);
      R(K, b, D, A);
      for (var se = new Uint8Array(8), pe = 0; pe < 8; pe++)
        se[pe] = b[pe + 16];
      return S(P, C, $, se, K);
    }
    function O(P, C, $, b, D, K, se) {
      var pe = new Uint8Array(32);
      R(pe, K, se, A);
      for (var we = new Uint8Array(8), Re = 0; Re < 8; Re++)
        we[Re] = K[Re + 16];
      return I(P, C, $, b, D, we, pe);
    }
    var Q = function (P) {
      (this.buffer = new Uint8Array(16)),
        (this.r = new Uint16Array(10)),
        (this.h = new Uint16Array(10)),
        (this.pad = new Uint16Array(8)),
        (this.leftover = 0),
        (this.fin = 0);
      var C, $, b, D, K, se, pe, we;
      (C = (P[0] & 255) | ((P[1] & 255) << 8)),
        (this.r[0] = C & 8191),
        ($ = (P[2] & 255) | ((P[3] & 255) << 8)),
        (this.r[1] = ((C >>> 13) | ($ << 3)) & 8191),
        (b = (P[4] & 255) | ((P[5] & 255) << 8)),
        (this.r[2] = (($ >>> 10) | (b << 6)) & 7939),
        (D = (P[6] & 255) | ((P[7] & 255) << 8)),
        (this.r[3] = ((b >>> 7) | (D << 9)) & 8191),
        (K = (P[8] & 255) | ((P[9] & 255) << 8)),
        (this.r[4] = ((D >>> 4) | (K << 12)) & 255),
        (this.r[5] = (K >>> 1) & 8190),
        (se = (P[10] & 255) | ((P[11] & 255) << 8)),
        (this.r[6] = ((K >>> 14) | (se << 2)) & 8191),
        (pe = (P[12] & 255) | ((P[13] & 255) << 8)),
        (this.r[7] = ((se >>> 11) | (pe << 5)) & 8065),
        (we = (P[14] & 255) | ((P[15] & 255) << 8)),
        (this.r[8] = ((pe >>> 8) | (we << 8)) & 8191),
        (this.r[9] = (we >>> 5) & 127),
        (this.pad[0] = (P[16] & 255) | ((P[17] & 255) << 8)),
        (this.pad[1] = (P[18] & 255) | ((P[19] & 255) << 8)),
        (this.pad[2] = (P[20] & 255) | ((P[21] & 255) << 8)),
        (this.pad[3] = (P[22] & 255) | ((P[23] & 255) << 8)),
        (this.pad[4] = (P[24] & 255) | ((P[25] & 255) << 8)),
        (this.pad[5] = (P[26] & 255) | ((P[27] & 255) << 8)),
        (this.pad[6] = (P[28] & 255) | ((P[29] & 255) << 8)),
        (this.pad[7] = (P[30] & 255) | ((P[31] & 255) << 8));
    };
    (Q.prototype.blocks = function (P, C, $) {
      for (
        var b = this.fin ? 0 : 2048,
          D,
          K,
          se,
          pe,
          we,
          Re,
          ke,
          je,
          Te,
          Me,
          Ne,
          Ue,
          qe,
          Fe,
          Je,
          Ke,
          Be,
          He,
          De,
          Le = this.h[0],
          Pe = this.h[1],
          Oe = this.h[2],
          ge = this.h[3],
          ve = this.h[4],
          Ie = this.h[5],
          Se = this.h[6],
          Ae = this.h[7],
          Ce = this.h[8],
          Ve = this.h[9],
          it = this.r[0],
          mt = this.r[1],
          at = this.r[2],
          ae = this.r[3],
          _t = this.r[4],
          Nt = this.r[5],
          Ot = this.r[6],
          yt = this.r[7],
          Ct = this.r[8],
          Rt = this.r[9];
        $ >= 16;

      )
        (D = (P[C + 0] & 255) | ((P[C + 1] & 255) << 8)),
          (Le += D & 8191),
          (K = (P[C + 2] & 255) | ((P[C + 3] & 255) << 8)),
          (Pe += ((D >>> 13) | (K << 3)) & 8191),
          (se = (P[C + 4] & 255) | ((P[C + 5] & 255) << 8)),
          (Oe += ((K >>> 10) | (se << 6)) & 8191),
          (pe = (P[C + 6] & 255) | ((P[C + 7] & 255) << 8)),
          (ge += ((se >>> 7) | (pe << 9)) & 8191),
          (we = (P[C + 8] & 255) | ((P[C + 9] & 255) << 8)),
          (ve += ((pe >>> 4) | (we << 12)) & 8191),
          (Ie += (we >>> 1) & 8191),
          (Re = (P[C + 10] & 255) | ((P[C + 11] & 255) << 8)),
          (Se += ((we >>> 14) | (Re << 2)) & 8191),
          (ke = (P[C + 12] & 255) | ((P[C + 13] & 255) << 8)),
          (Ae += ((Re >>> 11) | (ke << 5)) & 8191),
          (je = (P[C + 14] & 255) | ((P[C + 15] & 255) << 8)),
          (Ce += ((ke >>> 8) | (je << 8)) & 8191),
          (Ve += (je >>> 5) | b),
          (Te = 0),
          (Me = Te),
          (Me += Le * it),
          (Me += Pe * (5 * Rt)),
          (Me += Oe * (5 * Ct)),
          (Me += ge * (5 * yt)),
          (Me += ve * (5 * Ot)),
          (Te = Me >>> 13),
          (Me &= 8191),
          (Me += Ie * (5 * Nt)),
          (Me += Se * (5 * _t)),
          (Me += Ae * (5 * ae)),
          (Me += Ce * (5 * at)),
          (Me += Ve * (5 * mt)),
          (Te += Me >>> 13),
          (Me &= 8191),
          (Ne = Te),
          (Ne += Le * mt),
          (Ne += Pe * it),
          (Ne += Oe * (5 * Rt)),
          (Ne += ge * (5 * Ct)),
          (Ne += ve * (5 * yt)),
          (Te = Ne >>> 13),
          (Ne &= 8191),
          (Ne += Ie * (5 * Ot)),
          (Ne += Se * (5 * Nt)),
          (Ne += Ae * (5 * _t)),
          (Ne += Ce * (5 * ae)),
          (Ne += Ve * (5 * at)),
          (Te += Ne >>> 13),
          (Ne &= 8191),
          (Ue = Te),
          (Ue += Le * at),
          (Ue += Pe * mt),
          (Ue += Oe * it),
          (Ue += ge * (5 * Rt)),
          (Ue += ve * (5 * Ct)),
          (Te = Ue >>> 13),
          (Ue &= 8191),
          (Ue += Ie * (5 * yt)),
          (Ue += Se * (5 * Ot)),
          (Ue += Ae * (5 * Nt)),
          (Ue += Ce * (5 * _t)),
          (Ue += Ve * (5 * ae)),
          (Te += Ue >>> 13),
          (Ue &= 8191),
          (qe = Te),
          (qe += Le * ae),
          (qe += Pe * at),
          (qe += Oe * mt),
          (qe += ge * it),
          (qe += ve * (5 * Rt)),
          (Te = qe >>> 13),
          (qe &= 8191),
          (qe += Ie * (5 * Ct)),
          (qe += Se * (5 * yt)),
          (qe += Ae * (5 * Ot)),
          (qe += Ce * (5 * Nt)),
          (qe += Ve * (5 * _t)),
          (Te += qe >>> 13),
          (qe &= 8191),
          (Fe = Te),
          (Fe += Le * _t),
          (Fe += Pe * ae),
          (Fe += Oe * at),
          (Fe += ge * mt),
          (Fe += ve * it),
          (Te = Fe >>> 13),
          (Fe &= 8191),
          (Fe += Ie * (5 * Rt)),
          (Fe += Se * (5 * Ct)),
          (Fe += Ae * (5 * yt)),
          (Fe += Ce * (5 * Ot)),
          (Fe += Ve * (5 * Nt)),
          (Te += Fe >>> 13),
          (Fe &= 8191),
          (Je = Te),
          (Je += Le * Nt),
          (Je += Pe * _t),
          (Je += Oe * ae),
          (Je += ge * at),
          (Je += ve * mt),
          (Te = Je >>> 13),
          (Je &= 8191),
          (Je += Ie * it),
          (Je += Se * (5 * Rt)),
          (Je += Ae * (5 * Ct)),
          (Je += Ce * (5 * yt)),
          (Je += Ve * (5 * Ot)),
          (Te += Je >>> 13),
          (Je &= 8191),
          (Ke = Te),
          (Ke += Le * Ot),
          (Ke += Pe * Nt),
          (Ke += Oe * _t),
          (Ke += ge * ae),
          (Ke += ve * at),
          (Te = Ke >>> 13),
          (Ke &= 8191),
          (Ke += Ie * mt),
          (Ke += Se * it),
          (Ke += Ae * (5 * Rt)),
          (Ke += Ce * (5 * Ct)),
          (Ke += Ve * (5 * yt)),
          (Te += Ke >>> 13),
          (Ke &= 8191),
          (Be = Te),
          (Be += Le * yt),
          (Be += Pe * Ot),
          (Be += Oe * Nt),
          (Be += ge * _t),
          (Be += ve * ae),
          (Te = Be >>> 13),
          (Be &= 8191),
          (Be += Ie * at),
          (Be += Se * mt),
          (Be += Ae * it),
          (Be += Ce * (5 * Rt)),
          (Be += Ve * (5 * Ct)),
          (Te += Be >>> 13),
          (Be &= 8191),
          (He = Te),
          (He += Le * Ct),
          (He += Pe * yt),
          (He += Oe * Ot),
          (He += ge * Nt),
          (He += ve * _t),
          (Te = He >>> 13),
          (He &= 8191),
          (He += Ie * ae),
          (He += Se * at),
          (He += Ae * mt),
          (He += Ce * it),
          (He += Ve * (5 * Rt)),
          (Te += He >>> 13),
          (He &= 8191),
          (De = Te),
          (De += Le * Rt),
          (De += Pe * Ct),
          (De += Oe * yt),
          (De += ge * Ot),
          (De += ve * Nt),
          (Te = De >>> 13),
          (De &= 8191),
          (De += Ie * _t),
          (De += Se * ae),
          (De += Ae * at),
          (De += Ce * mt),
          (De += Ve * it),
          (Te += De >>> 13),
          (De &= 8191),
          (Te = ((Te << 2) + Te) | 0),
          (Te = (Te + Me) | 0),
          (Me = Te & 8191),
          (Te = Te >>> 13),
          (Ne += Te),
          (Le = Me),
          (Pe = Ne),
          (Oe = Ue),
          (ge = qe),
          (ve = Fe),
          (Ie = Je),
          (Se = Ke),
          (Ae = Be),
          (Ce = He),
          (Ve = De),
          (C += 16),
          ($ -= 16);
      (this.h[0] = Le),
        (this.h[1] = Pe),
        (this.h[2] = Oe),
        (this.h[3] = ge),
        (this.h[4] = ve),
        (this.h[5] = Ie),
        (this.h[6] = Se),
        (this.h[7] = Ae),
        (this.h[8] = Ce),
        (this.h[9] = Ve);
    }),
      (Q.prototype.finish = function (P, C) {
        var $ = new Uint16Array(10),
          b,
          D,
          K,
          se;
        if (this.leftover) {
          for (se = this.leftover, this.buffer[se++] = 1; se < 16; se++)
            this.buffer[se] = 0;
          (this.fin = 1), this.blocks(this.buffer, 0, 16);
        }
        for (b = this.h[1] >>> 13, this.h[1] &= 8191, se = 2; se < 10; se++)
          (this.h[se] += b), (b = this.h[se] >>> 13), (this.h[se] &= 8191);
        for (
          this.h[0] += b * 5,
            b = this.h[0] >>> 13,
            this.h[0] &= 8191,
            this.h[1] += b,
            b = this.h[1] >>> 13,
            this.h[1] &= 8191,
            this.h[2] += b,
            $[0] = this.h[0] + 5,
            b = $[0] >>> 13,
            $[0] &= 8191,
            se = 1;
          se < 10;
          se++
        )
          ($[se] = this.h[se] + b), (b = $[se] >>> 13), ($[se] &= 8191);
        for ($[9] -= 8192, D = (b ^ 1) - 1, se = 0; se < 10; se++) $[se] &= D;
        for (D = ~D, se = 0; se < 10; se++)
          this.h[se] = (this.h[se] & D) | $[se];
        for (
          this.h[0] = (this.h[0] | (this.h[1] << 13)) & 65535,
            this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 65535,
            this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 65535,
            this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 65535,
            this.h[4] =
              ((this.h[4] >>> 12) | (this.h[5] << 1) | (this.h[6] << 14)) &
              65535,
            this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 65535,
            this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 65535,
            this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 65535,
            K = this.h[0] + this.pad[0],
            this.h[0] = K & 65535,
            se = 1;
          se < 8;
          se++
        )
          (K = (((this.h[se] + this.pad[se]) | 0) + (K >>> 16)) | 0),
            (this.h[se] = K & 65535);
        (P[C + 0] = (this.h[0] >>> 0) & 255),
          (P[C + 1] = (this.h[0] >>> 8) & 255),
          (P[C + 2] = (this.h[1] >>> 0) & 255),
          (P[C + 3] = (this.h[1] >>> 8) & 255),
          (P[C + 4] = (this.h[2] >>> 0) & 255),
          (P[C + 5] = (this.h[2] >>> 8) & 255),
          (P[C + 6] = (this.h[3] >>> 0) & 255),
          (P[C + 7] = (this.h[3] >>> 8) & 255),
          (P[C + 8] = (this.h[4] >>> 0) & 255),
          (P[C + 9] = (this.h[4] >>> 8) & 255),
          (P[C + 10] = (this.h[5] >>> 0) & 255),
          (P[C + 11] = (this.h[5] >>> 8) & 255),
          (P[C + 12] = (this.h[6] >>> 0) & 255),
          (P[C + 13] = (this.h[6] >>> 8) & 255),
          (P[C + 14] = (this.h[7] >>> 0) & 255),
          (P[C + 15] = (this.h[7] >>> 8) & 255);
      }),
      (Q.prototype.update = function (P, C, $) {
        var b, D;
        if (this.leftover) {
          for (D = 16 - this.leftover, D > $ && (D = $), b = 0; b < D; b++)
            this.buffer[this.leftover + b] = P[C + b];
          if ((($ -= D), (C += D), (this.leftover += D), this.leftover < 16))
            return;
          this.blocks(this.buffer, 0, 16), (this.leftover = 0);
        }
        if (
          ($ >= 16 &&
            ((D = $ - ($ % 16)), this.blocks(P, C, D), (C += D), ($ -= D)),
          $)
        ) {
          for (b = 0; b < $; b++) this.buffer[this.leftover + b] = P[C + b];
          this.leftover += $;
        }
      });
    function j(P, C, $, b, D, K) {
      var se = new Q(K);
      return se.update($, b, D), se.finish(P, C), 0;
    }
    function H(P, C, $, b, D, K) {
      var se = new Uint8Array(16);
      return j(se, 0, $, b, D, K), g(P, C, se, 0);
    }
    function q(P, C, $, b, D) {
      var K;
      if ($ < 32) return -1;
      for (
        O(P, 0, C, 0, $, b, D), j(P, 16, P, 32, $ - 32, P), K = 0;
        K < 16;
        K++
      )
        P[K] = 0;
      return 0;
    }
    function J(P, C, $, b, D) {
      var K,
        se = new Uint8Array(32);
      if ($ < 32 || (w(se, 0, 32, b, D), H(C, 16, C, 32, $ - 32, se) !== 0))
        return -1;
      for (O(P, 0, C, 0, $, b, D), K = 0; K < 32; K++) P[K] = 0;
      return 0;
    }
    function Z(P, C) {
      var $;
      for ($ = 0; $ < 16; $++) P[$] = C[$] | 0;
    }
    function z(P) {
      var C,
        $,
        b = 1;
      for (C = 0; C < 16; C++)
        ($ = P[C] + b + 65535),
          (b = Math.floor($ / 65536)),
          (P[C] = $ - b * 65536);
      P[0] += b - 1 + 37 * (b - 1);
    }
    function U(P, C, $) {
      for (var b, D = ~($ - 1), K = 0; K < 16; K++)
        (b = D & (P[K] ^ C[K])), (P[K] ^= b), (C[K] ^= b);
    }
    function G(P, C) {
      var $,
        b,
        D,
        K = n(),
        se = n();
      for ($ = 0; $ < 16; $++) se[$] = C[$];
      for (z(se), z(se), z(se), b = 0; b < 2; b++) {
        for (K[0] = se[0] - 65517, $ = 1; $ < 15; $++)
          (K[$] = se[$] - 65535 - ((K[$ - 1] >> 16) & 1)), (K[$ - 1] &= 65535);
        (K[15] = se[15] - 32767 - ((K[14] >> 16) & 1)),
          (D = (K[15] >> 16) & 1),
          (K[14] &= 65535),
          U(se, K, 1 - D);
      }
      for ($ = 0; $ < 16; $++)
        (P[2 * $] = se[$] & 255), (P[2 * $ + 1] = se[$] >> 8);
    }
    function L(P, C) {
      var $ = new Uint8Array(32),
        b = new Uint8Array(32);
      return G($, P), G(b, C), v($, 0, b, 0);
    }
    function k(P) {
      var C = new Uint8Array(32);
      return G(C, P), C[0] & 1;
    }
    function W(P, C) {
      var $;
      for ($ = 0; $ < 16; $++) P[$] = C[2 * $] + (C[2 * $ + 1] << 8);
      P[15] &= 32767;
    }
    function F(P, C, $) {
      for (var b = 0; b < 16; b++) P[b] = C[b] + $[b];
    }
    function x(P, C, $) {
      for (var b = 0; b < 16; b++) P[b] = C[b] - $[b];
    }
    function T(P, C, $) {
      var b,
        D,
        K = 0,
        se = 0,
        pe = 0,
        we = 0,
        Re = 0,
        ke = 0,
        je = 0,
        Te = 0,
        Me = 0,
        Ne = 0,
        Ue = 0,
        qe = 0,
        Fe = 0,
        Je = 0,
        Ke = 0,
        Be = 0,
        He = 0,
        De = 0,
        Le = 0,
        Pe = 0,
        Oe = 0,
        ge = 0,
        ve = 0,
        Ie = 0,
        Se = 0,
        Ae = 0,
        Ce = 0,
        Ve = 0,
        it = 0,
        mt = 0,
        at = 0,
        ae = $[0],
        _t = $[1],
        Nt = $[2],
        Ot = $[3],
        yt = $[4],
        Ct = $[5],
        Rt = $[6],
        hn = $[7],
        Pt = $[8],
        zt = $[9],
        mn = $[10],
        gn = $[11],
        en = $[12],
        Un = $[13],
        Fn = $[14],
        jn = $[15];
      (b = C[0]),
        (K += b * ae),
        (se += b * _t),
        (pe += b * Nt),
        (we += b * Ot),
        (Re += b * yt),
        (ke += b * Ct),
        (je += b * Rt),
        (Te += b * hn),
        (Me += b * Pt),
        (Ne += b * zt),
        (Ue += b * mn),
        (qe += b * gn),
        (Fe += b * en),
        (Je += b * Un),
        (Ke += b * Fn),
        (Be += b * jn),
        (b = C[1]),
        (se += b * ae),
        (pe += b * _t),
        (we += b * Nt),
        (Re += b * Ot),
        (ke += b * yt),
        (je += b * Ct),
        (Te += b * Rt),
        (Me += b * hn),
        (Ne += b * Pt),
        (Ue += b * zt),
        (qe += b * mn),
        (Fe += b * gn),
        (Je += b * en),
        (Ke += b * Un),
        (Be += b * Fn),
        (He += b * jn),
        (b = C[2]),
        (pe += b * ae),
        (we += b * _t),
        (Re += b * Nt),
        (ke += b * Ot),
        (je += b * yt),
        (Te += b * Ct),
        (Me += b * Rt),
        (Ne += b * hn),
        (Ue += b * Pt),
        (qe += b * zt),
        (Fe += b * mn),
        (Je += b * gn),
        (Ke += b * en),
        (Be += b * Un),
        (He += b * Fn),
        (De += b * jn),
        (b = C[3]),
        (we += b * ae),
        (Re += b * _t),
        (ke += b * Nt),
        (je += b * Ot),
        (Te += b * yt),
        (Me += b * Ct),
        (Ne += b * Rt),
        (Ue += b * hn),
        (qe += b * Pt),
        (Fe += b * zt),
        (Je += b * mn),
        (Ke += b * gn),
        (Be += b * en),
        (He += b * Un),
        (De += b * Fn),
        (Le += b * jn),
        (b = C[4]),
        (Re += b * ae),
        (ke += b * _t),
        (je += b * Nt),
        (Te += b * Ot),
        (Me += b * yt),
        (Ne += b * Ct),
        (Ue += b * Rt),
        (qe += b * hn),
        (Fe += b * Pt),
        (Je += b * zt),
        (Ke += b * mn),
        (Be += b * gn),
        (He += b * en),
        (De += b * Un),
        (Le += b * Fn),
        (Pe += b * jn),
        (b = C[5]),
        (ke += b * ae),
        (je += b * _t),
        (Te += b * Nt),
        (Me += b * Ot),
        (Ne += b * yt),
        (Ue += b * Ct),
        (qe += b * Rt),
        (Fe += b * hn),
        (Je += b * Pt),
        (Ke += b * zt),
        (Be += b * mn),
        (He += b * gn),
        (De += b * en),
        (Le += b * Un),
        (Pe += b * Fn),
        (Oe += b * jn),
        (b = C[6]),
        (je += b * ae),
        (Te += b * _t),
        (Me += b * Nt),
        (Ne += b * Ot),
        (Ue += b * yt),
        (qe += b * Ct),
        (Fe += b * Rt),
        (Je += b * hn),
        (Ke += b * Pt),
        (Be += b * zt),
        (He += b * mn),
        (De += b * gn),
        (Le += b * en),
        (Pe += b * Un),
        (Oe += b * Fn),
        (ge += b * jn),
        (b = C[7]),
        (Te += b * ae),
        (Me += b * _t),
        (Ne += b * Nt),
        (Ue += b * Ot),
        (qe += b * yt),
        (Fe += b * Ct),
        (Je += b * Rt),
        (Ke += b * hn),
        (Be += b * Pt),
        (He += b * zt),
        (De += b * mn),
        (Le += b * gn),
        (Pe += b * en),
        (Oe += b * Un),
        (ge += b * Fn),
        (ve += b * jn),
        (b = C[8]),
        (Me += b * ae),
        (Ne += b * _t),
        (Ue += b * Nt),
        (qe += b * Ot),
        (Fe += b * yt),
        (Je += b * Ct),
        (Ke += b * Rt),
        (Be += b * hn),
        (He += b * Pt),
        (De += b * zt),
        (Le += b * mn),
        (Pe += b * gn),
        (Oe += b * en),
        (ge += b * Un),
        (ve += b * Fn),
        (Ie += b * jn),
        (b = C[9]),
        (Ne += b * ae),
        (Ue += b * _t),
        (qe += b * Nt),
        (Fe += b * Ot),
        (Je += b * yt),
        (Ke += b * Ct),
        (Be += b * Rt),
        (He += b * hn),
        (De += b * Pt),
        (Le += b * zt),
        (Pe += b * mn),
        (Oe += b * gn),
        (ge += b * en),
        (ve += b * Un),
        (Ie += b * Fn),
        (Se += b * jn),
        (b = C[10]),
        (Ue += b * ae),
        (qe += b * _t),
        (Fe += b * Nt),
        (Je += b * Ot),
        (Ke += b * yt),
        (Be += b * Ct),
        (He += b * Rt),
        (De += b * hn),
        (Le += b * Pt),
        (Pe += b * zt),
        (Oe += b * mn),
        (ge += b * gn),
        (ve += b * en),
        (Ie += b * Un),
        (Se += b * Fn),
        (Ae += b * jn),
        (b = C[11]),
        (qe += b * ae),
        (Fe += b * _t),
        (Je += b * Nt),
        (Ke += b * Ot),
        (Be += b * yt),
        (He += b * Ct),
        (De += b * Rt),
        (Le += b * hn),
        (Pe += b * Pt),
        (Oe += b * zt),
        (ge += b * mn),
        (ve += b * gn),
        (Ie += b * en),
        (Se += b * Un),
        (Ae += b * Fn),
        (Ce += b * jn),
        (b = C[12]),
        (Fe += b * ae),
        (Je += b * _t),
        (Ke += b * Nt),
        (Be += b * Ot),
        (He += b * yt),
        (De += b * Ct),
        (Le += b * Rt),
        (Pe += b * hn),
        (Oe += b * Pt),
        (ge += b * zt),
        (ve += b * mn),
        (Ie += b * gn),
        (Se += b * en),
        (Ae += b * Un),
        (Ce += b * Fn),
        (Ve += b * jn),
        (b = C[13]),
        (Je += b * ae),
        (Ke += b * _t),
        (Be += b * Nt),
        (He += b * Ot),
        (De += b * yt),
        (Le += b * Ct),
        (Pe += b * Rt),
        (Oe += b * hn),
        (ge += b * Pt),
        (ve += b * zt),
        (Ie += b * mn),
        (Se += b * gn),
        (Ae += b * en),
        (Ce += b * Un),
        (Ve += b * Fn),
        (it += b * jn),
        (b = C[14]),
        (Ke += b * ae),
        (Be += b * _t),
        (He += b * Nt),
        (De += b * Ot),
        (Le += b * yt),
        (Pe += b * Ct),
        (Oe += b * Rt),
        (ge += b * hn),
        (ve += b * Pt),
        (Ie += b * zt),
        (Se += b * mn),
        (Ae += b * gn),
        (Ce += b * en),
        (Ve += b * Un),
        (it += b * Fn),
        (mt += b * jn),
        (b = C[15]),
        (Be += b * ae),
        (He += b * _t),
        (De += b * Nt),
        (Le += b * Ot),
        (Pe += b * yt),
        (Oe += b * Ct),
        (ge += b * Rt),
        (ve += b * hn),
        (Ie += b * Pt),
        (Se += b * zt),
        (Ae += b * mn),
        (Ce += b * gn),
        (Ve += b * en),
        (it += b * Un),
        (mt += b * Fn),
        (at += b * jn),
        (K += 38 * He),
        (se += 38 * De),
        (pe += 38 * Le),
        (we += 38 * Pe),
        (Re += 38 * Oe),
        (ke += 38 * ge),
        (je += 38 * ve),
        (Te += 38 * Ie),
        (Me += 38 * Se),
        (Ne += 38 * Ae),
        (Ue += 38 * Ce),
        (qe += 38 * Ve),
        (Fe += 38 * it),
        (Je += 38 * mt),
        (Ke += 38 * at),
        (D = 1),
        (b = K + D + 65535),
        (D = Math.floor(b / 65536)),
        (K = b - D * 65536),
        (b = se + D + 65535),
        (D = Math.floor(b / 65536)),
        (se = b - D * 65536),
        (b = pe + D + 65535),
        (D = Math.floor(b / 65536)),
        (pe = b - D * 65536),
        (b = we + D + 65535),
        (D = Math.floor(b / 65536)),
        (we = b - D * 65536),
        (b = Re + D + 65535),
        (D = Math.floor(b / 65536)),
        (Re = b - D * 65536),
        (b = ke + D + 65535),
        (D = Math.floor(b / 65536)),
        (ke = b - D * 65536),
        (b = je + D + 65535),
        (D = Math.floor(b / 65536)),
        (je = b - D * 65536),
        (b = Te + D + 65535),
        (D = Math.floor(b / 65536)),
        (Te = b - D * 65536),
        (b = Me + D + 65535),
        (D = Math.floor(b / 65536)),
        (Me = b - D * 65536),
        (b = Ne + D + 65535),
        (D = Math.floor(b / 65536)),
        (Ne = b - D * 65536),
        (b = Ue + D + 65535),
        (D = Math.floor(b / 65536)),
        (Ue = b - D * 65536),
        (b = qe + D + 65535),
        (D = Math.floor(b / 65536)),
        (qe = b - D * 65536),
        (b = Fe + D + 65535),
        (D = Math.floor(b / 65536)),
        (Fe = b - D * 65536),
        (b = Je + D + 65535),
        (D = Math.floor(b / 65536)),
        (Je = b - D * 65536),
        (b = Ke + D + 65535),
        (D = Math.floor(b / 65536)),
        (Ke = b - D * 65536),
        (b = Be + D + 65535),
        (D = Math.floor(b / 65536)),
        (Be = b - D * 65536),
        (K += D - 1 + 37 * (D - 1)),
        (D = 1),
        (b = K + D + 65535),
        (D = Math.floor(b / 65536)),
        (K = b - D * 65536),
        (b = se + D + 65535),
        (D = Math.floor(b / 65536)),
        (se = b - D * 65536),
        (b = pe + D + 65535),
        (D = Math.floor(b / 65536)),
        (pe = b - D * 65536),
        (b = we + D + 65535),
        (D = Math.floor(b / 65536)),
        (we = b - D * 65536),
        (b = Re + D + 65535),
        (D = Math.floor(b / 65536)),
        (Re = b - D * 65536),
        (b = ke + D + 65535),
        (D = Math.floor(b / 65536)),
        (ke = b - D * 65536),
        (b = je + D + 65535),
        (D = Math.floor(b / 65536)),
        (je = b - D * 65536),
        (b = Te + D + 65535),
        (D = Math.floor(b / 65536)),
        (Te = b - D * 65536),
        (b = Me + D + 65535),
        (D = Math.floor(b / 65536)),
        (Me = b - D * 65536),
        (b = Ne + D + 65535),
        (D = Math.floor(b / 65536)),
        (Ne = b - D * 65536),
        (b = Ue + D + 65535),
        (D = Math.floor(b / 65536)),
        (Ue = b - D * 65536),
        (b = qe + D + 65535),
        (D = Math.floor(b / 65536)),
        (qe = b - D * 65536),
        (b = Fe + D + 65535),
        (D = Math.floor(b / 65536)),
        (Fe = b - D * 65536),
        (b = Je + D + 65535),
        (D = Math.floor(b / 65536)),
        (Je = b - D * 65536),
        (b = Ke + D + 65535),
        (D = Math.floor(b / 65536)),
        (Ke = b - D * 65536),
        (b = Be + D + 65535),
        (D = Math.floor(b / 65536)),
        (Be = b - D * 65536),
        (K += D - 1 + 37 * (D - 1)),
        (P[0] = K),
        (P[1] = se),
        (P[2] = pe),
        (P[3] = we),
        (P[4] = Re),
        (P[5] = ke),
        (P[6] = je),
        (P[7] = Te),
        (P[8] = Me),
        (P[9] = Ne),
        (P[10] = Ue),
        (P[11] = qe),
        (P[12] = Fe),
        (P[13] = Je),
        (P[14] = Ke),
        (P[15] = Be);
    }
    function V(P, C) {
      T(P, C, C);
    }
    function B(P, C) {
      var $ = n(),
        b;
      for (b = 0; b < 16; b++) $[b] = C[b];
      for (b = 253; b >= 0; b--) V($, $), b !== 2 && b !== 4 && T($, $, C);
      for (b = 0; b < 16; b++) P[b] = $[b];
    }
    function N(P, C) {
      var $ = n(),
        b;
      for (b = 0; b < 16; b++) $[b] = C[b];
      for (b = 250; b >= 0; b--) V($, $), b !== 1 && T($, $, C);
      for (b = 0; b < 16; b++) P[b] = $[b];
    }
    function ce(P, C, $) {
      var b = new Uint8Array(32),
        D = new Float64Array(80),
        K,
        se,
        pe = n(),
        we = n(),
        Re = n(),
        ke = n(),
        je = n(),
        Te = n();
      for (se = 0; se < 31; se++) b[se] = C[se];
      for (
        b[31] = (C[31] & 127) | 64, b[0] &= 248, W(D, $), se = 0;
        se < 16;
        se++
      )
        (we[se] = D[se]), (ke[se] = pe[se] = Re[se] = 0);
      for (pe[0] = ke[0] = 1, se = 254; se >= 0; --se)
        (K = (b[se >>> 3] >>> (se & 7)) & 1),
          U(pe, we, K),
          U(Re, ke, K),
          F(je, pe, Re),
          x(pe, pe, Re),
          F(Re, we, ke),
          x(we, we, ke),
          V(ke, je),
          V(Te, pe),
          T(pe, Re, pe),
          T(Re, we, je),
          F(je, pe, Re),
          x(pe, pe, Re),
          V(we, pe),
          x(Re, ke, Te),
          T(pe, Re, c),
          F(pe, pe, ke),
          T(Re, Re, pe),
          T(pe, ke, Te),
          T(ke, we, D),
          V(we, je),
          U(pe, we, K),
          U(Re, ke, K);
      for (se = 0; se < 16; se++)
        (D[se + 16] = pe[se]),
          (D[se + 32] = Re[se]),
          (D[se + 48] = we[se]),
          (D[se + 64] = ke[se]);
      var Me = D.subarray(32),
        Ne = D.subarray(16);
      return B(Me, Me), T(Ne, Ne, Me), G(P, Ne), 0;
    }
    function re(P, C) {
      return ce(P, C, a);
    }
    function ne(P, C) {
      return r(C, 32), re(P, C);
    }
    function Y(P, C, $) {
      var b = new Uint8Array(32);
      return ce(b, $, C), R(P, i, b, A);
    }
    var M = q,
      oe = J;
    function Ee(P, C, $, b, D, K) {
      var se = new Uint8Array(32);
      return Y(se, D, K), M(P, C, $, b, se);
    }
    function le(P, C, $, b, D, K) {
      var se = new Uint8Array(32);
      return Y(se, D, K), oe(P, C, $, b, se);
    }
    var te = [
      1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399,
      3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265,
      2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394,
      310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
      1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317,
      3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139,
      264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901,
      1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
      2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879,
      3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901,
      113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964,
      773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
      1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142,
      2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273,
      3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344,
      3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
      430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593,
      883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403,
      1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012,
      2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
      2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573,
      3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711,
      3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554,
      174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
      685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100,
      1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866,
      1607167915, 987167468, 1816402316, 1246189591,
    ];
    function ie(P, C, $, b) {
      for (
        var D = new Int32Array(16),
          K = new Int32Array(16),
          se,
          pe,
          we,
          Re,
          ke,
          je,
          Te,
          Me,
          Ne,
          Ue,
          qe,
          Fe,
          Je,
          Ke,
          Be,
          He,
          De,
          Le,
          Pe,
          Oe,
          ge,
          ve,
          Ie,
          Se,
          Ae,
          Ce,
          Ve = P[0],
          it = P[1],
          mt = P[2],
          at = P[3],
          ae = P[4],
          _t = P[5],
          Nt = P[6],
          Ot = P[7],
          yt = C[0],
          Ct = C[1],
          Rt = C[2],
          hn = C[3],
          Pt = C[4],
          zt = C[5],
          mn = C[6],
          gn = C[7],
          en = 0;
        b >= 128;

      ) {
        for (Pe = 0; Pe < 16; Pe++)
          (Oe = 8 * Pe + en),
            (D[Pe] =
              ($[Oe + 0] << 24) |
              ($[Oe + 1] << 16) |
              ($[Oe + 2] << 8) |
              $[Oe + 3]),
            (K[Pe] =
              ($[Oe + 4] << 24) |
              ($[Oe + 5] << 16) |
              ($[Oe + 6] << 8) |
              $[Oe + 7]);
        for (Pe = 0; Pe < 80; Pe++)
          if (
            ((se = Ve),
            (pe = it),
            (we = mt),
            (Re = at),
            (ke = ae),
            (je = _t),
            (Te = Nt),
            (Me = Ot),
            (Ne = yt),
            (Ue = Ct),
            (qe = Rt),
            (Fe = hn),
            (Je = Pt),
            (Ke = zt),
            (Be = mn),
            (He = gn),
            (ge = Ot),
            (ve = gn),
            (Ie = ve & 65535),
            (Se = ve >>> 16),
            (Ae = ge & 65535),
            (Ce = ge >>> 16),
            (ge =
              ((ae >>> 14) | (Pt << (32 - 14))) ^
              ((ae >>> 18) | (Pt << (32 - 18))) ^
              ((Pt >>> (41 - 32)) | (ae << (32 - (41 - 32))))),
            (ve =
              ((Pt >>> 14) | (ae << (32 - 14))) ^
              ((Pt >>> 18) | (ae << (32 - 18))) ^
              ((ae >>> (41 - 32)) | (Pt << (32 - (41 - 32))))),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (ge = (ae & _t) ^ (~ae & Nt)),
            (ve = (Pt & zt) ^ (~Pt & mn)),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (ge = te[Pe * 2]),
            (ve = te[Pe * 2 + 1]),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (ge = D[Pe % 16]),
            (ve = K[Pe % 16]),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (Se += Ie >>> 16),
            (Ae += Se >>> 16),
            (Ce += Ae >>> 16),
            (De = (Ae & 65535) | (Ce << 16)),
            (Le = (Ie & 65535) | (Se << 16)),
            (ge = De),
            (ve = Le),
            (Ie = ve & 65535),
            (Se = ve >>> 16),
            (Ae = ge & 65535),
            (Ce = ge >>> 16),
            (ge =
              ((Ve >>> 28) | (yt << (32 - 28))) ^
              ((yt >>> (34 - 32)) | (Ve << (32 - (34 - 32)))) ^
              ((yt >>> (39 - 32)) | (Ve << (32 - (39 - 32))))),
            (ve =
              ((yt >>> 28) | (Ve << (32 - 28))) ^
              ((Ve >>> (34 - 32)) | (yt << (32 - (34 - 32)))) ^
              ((Ve >>> (39 - 32)) | (yt << (32 - (39 - 32))))),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (ge = (Ve & it) ^ (Ve & mt) ^ (it & mt)),
            (ve = (yt & Ct) ^ (yt & Rt) ^ (Ct & Rt)),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (Se += Ie >>> 16),
            (Ae += Se >>> 16),
            (Ce += Ae >>> 16),
            (Me = (Ae & 65535) | (Ce << 16)),
            (He = (Ie & 65535) | (Se << 16)),
            (ge = Re),
            (ve = Fe),
            (Ie = ve & 65535),
            (Se = ve >>> 16),
            (Ae = ge & 65535),
            (Ce = ge >>> 16),
            (ge = De),
            (ve = Le),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (Se += Ie >>> 16),
            (Ae += Se >>> 16),
            (Ce += Ae >>> 16),
            (Re = (Ae & 65535) | (Ce << 16)),
            (Fe = (Ie & 65535) | (Se << 16)),
            (it = se),
            (mt = pe),
            (at = we),
            (ae = Re),
            (_t = ke),
            (Nt = je),
            (Ot = Te),
            (Ve = Me),
            (Ct = Ne),
            (Rt = Ue),
            (hn = qe),
            (Pt = Fe),
            (zt = Je),
            (mn = Ke),
            (gn = Be),
            (yt = He),
            Pe % 16 === 15)
          )
            for (Oe = 0; Oe < 16; Oe++)
              (ge = D[Oe]),
                (ve = K[Oe]),
                (Ie = ve & 65535),
                (Se = ve >>> 16),
                (Ae = ge & 65535),
                (Ce = ge >>> 16),
                (ge = D[(Oe + 9) % 16]),
                (ve = K[(Oe + 9) % 16]),
                (Ie += ve & 65535),
                (Se += ve >>> 16),
                (Ae += ge & 65535),
                (Ce += ge >>> 16),
                (De = D[(Oe + 1) % 16]),
                (Le = K[(Oe + 1) % 16]),
                (ge =
                  ((De >>> 1) | (Le << (32 - 1))) ^
                  ((De >>> 8) | (Le << (32 - 8))) ^
                  (De >>> 7)),
                (ve =
                  ((Le >>> 1) | (De << (32 - 1))) ^
                  ((Le >>> 8) | (De << (32 - 8))) ^
                  ((Le >>> 7) | (De << (32 - 7)))),
                (Ie += ve & 65535),
                (Se += ve >>> 16),
                (Ae += ge & 65535),
                (Ce += ge >>> 16),
                (De = D[(Oe + 14) % 16]),
                (Le = K[(Oe + 14) % 16]),
                (ge =
                  ((De >>> 19) | (Le << (32 - 19))) ^
                  ((Le >>> (61 - 32)) | (De << (32 - (61 - 32)))) ^
                  (De >>> 6)),
                (ve =
                  ((Le >>> 19) | (De << (32 - 19))) ^
                  ((De >>> (61 - 32)) | (Le << (32 - (61 - 32)))) ^
                  ((Le >>> 6) | (De << (32 - 6)))),
                (Ie += ve & 65535),
                (Se += ve >>> 16),
                (Ae += ge & 65535),
                (Ce += ge >>> 16),
                (Se += Ie >>> 16),
                (Ae += Se >>> 16),
                (Ce += Ae >>> 16),
                (D[Oe] = (Ae & 65535) | (Ce << 16)),
                (K[Oe] = (Ie & 65535) | (Se << 16));
        (ge = Ve),
          (ve = yt),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[0]),
          (ve = C[0]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[0] = Ve = (Ae & 65535) | (Ce << 16)),
          (C[0] = yt = (Ie & 65535) | (Se << 16)),
          (ge = it),
          (ve = Ct),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[1]),
          (ve = C[1]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[1] = it = (Ae & 65535) | (Ce << 16)),
          (C[1] = Ct = (Ie & 65535) | (Se << 16)),
          (ge = mt),
          (ve = Rt),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[2]),
          (ve = C[2]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[2] = mt = (Ae & 65535) | (Ce << 16)),
          (C[2] = Rt = (Ie & 65535) | (Se << 16)),
          (ge = at),
          (ve = hn),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[3]),
          (ve = C[3]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[3] = at = (Ae & 65535) | (Ce << 16)),
          (C[3] = hn = (Ie & 65535) | (Se << 16)),
          (ge = ae),
          (ve = Pt),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[4]),
          (ve = C[4]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[4] = ae = (Ae & 65535) | (Ce << 16)),
          (C[4] = Pt = (Ie & 65535) | (Se << 16)),
          (ge = _t),
          (ve = zt),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[5]),
          (ve = C[5]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[5] = _t = (Ae & 65535) | (Ce << 16)),
          (C[5] = zt = (Ie & 65535) | (Se << 16)),
          (ge = Nt),
          (ve = mn),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[6]),
          (ve = C[6]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[6] = Nt = (Ae & 65535) | (Ce << 16)),
          (C[6] = mn = (Ie & 65535) | (Se << 16)),
          (ge = Ot),
          (ve = gn),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[7]),
          (ve = C[7]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[7] = Ot = (Ae & 65535) | (Ce << 16)),
          (C[7] = gn = (Ie & 65535) | (Se << 16)),
          (en += 128),
          (b -= 128);
      }
      return b;
    }
    function X(P, C, $) {
      var b = new Int32Array(8),
        D = new Int32Array(8),
        K = new Uint8Array(256),
        se,
        pe = $;
      for (
        b[0] = 1779033703,
          b[1] = 3144134277,
          b[2] = 1013904242,
          b[3] = 2773480762,
          b[4] = 1359893119,
          b[5] = 2600822924,
          b[6] = 528734635,
          b[7] = 1541459225,
          D[0] = 4089235720,
          D[1] = 2227873595,
          D[2] = 4271175723,
          D[3] = 1595750129,
          D[4] = 2917565137,
          D[5] = 725511199,
          D[6] = 4215389547,
          D[7] = 327033209,
          ie(b, D, C, $),
          $ %= 128,
          se = 0;
        se < $;
        se++
      )
        K[se] = C[pe - $ + se];
      for (
        K[$] = 128,
          $ = 256 - 128 * ($ < 112 ? 1 : 0),
          K[$ - 9] = 0,
          h(K, $ - 8, (pe / 536870912) | 0, pe << 3),
          ie(b, D, K, $),
          se = 0;
        se < 8;
        se++
      )
        h(P, 8 * se, b[se], D[se]);
      return 0;
    }
    function he(P, C) {
      var $ = n(),
        b = n(),
        D = n(),
        K = n(),
        se = n(),
        pe = n(),
        we = n(),
        Re = n(),
        ke = n();
      x($, P[1], P[0]),
        x(ke, C[1], C[0]),
        T($, $, ke),
        F(b, P[0], P[1]),
        F(ke, C[0], C[1]),
        T(b, b, ke),
        T(D, P[3], C[3]),
        T(D, D, f),
        T(K, P[2], C[2]),
        F(K, K, K),
        x(se, b, $),
        x(pe, K, D),
        F(we, K, D),
        F(Re, b, $),
        T(P[0], se, pe),
        T(P[1], Re, we),
        T(P[2], we, pe),
        T(P[3], se, Re);
    }
    function be(P, C, $) {
      var b;
      for (b = 0; b < 4; b++) U(P[b], C[b], $);
    }
    function ye(P, C) {
      var $ = n(),
        b = n(),
        D = n();
      B(D, C[2]), T($, C[0], D), T(b, C[1], D), G(P, b), (P[31] ^= k($) << 7);
    }
    function Qe(P, C, $) {
      var b, D;
      for (Z(P[0], s), Z(P[1], o), Z(P[2], o), Z(P[3], s), D = 255; D >= 0; --D)
        (b = ($[(D / 8) | 0] >> (D & 7)) & 1),
          be(P, C, b),
          he(C, P),
          he(P, P),
          be(P, C, b);
    }
    function lt(P, C) {
      var $ = [n(), n(), n(), n()];
      Z($[0], u), Z($[1], d), Z($[2], o), T($[3], u, d), Qe(P, $, C);
    }
    function Lt(P, C, $) {
      var b = new Uint8Array(64),
        D = [n(), n(), n(), n()],
        K;
      for (
        $ || r(C, 32),
          X(b, C, 32),
          b[0] &= 248,
          b[31] &= 127,
          b[31] |= 64,
          lt(D, b),
          ye(P, D),
          K = 0;
        K < 32;
        K++
      )
        C[K + 32] = P[K];
      return 0;
    }
    var We = new Float64Array([
      237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16,
    ]);
    function bt(P, C) {
      var $, b, D, K;
      for (b = 63; b >= 32; --b) {
        for ($ = 0, D = b - 32, K = b - 12; D < K; ++D)
          (C[D] += $ - 16 * C[b] * We[D - (b - 32)]),
            ($ = (C[D] + 128) >> 8),
            (C[D] -= $ * 256);
        (C[D] += $), (C[b] = 0);
      }
      for ($ = 0, D = 0; D < 32; D++)
        (C[D] += $ - (C[31] >> 4) * We[D]), ($ = C[D] >> 8), (C[D] &= 255);
      for (D = 0; D < 32; D++) C[D] -= $ * We[D];
      for (b = 0; b < 32; b++) (C[b + 1] += C[b] >> 8), (P[b] = C[b] & 255);
    }
    function wt(P) {
      var C = new Float64Array(64),
        $;
      for ($ = 0; $ < 64; $++) C[$] = P[$];
      for ($ = 0; $ < 64; $++) P[$] = 0;
      bt(P, C);
    }
    function ct(P, C, $, b) {
      var D = new Uint8Array(64),
        K = new Uint8Array(64),
        se = new Uint8Array(64),
        pe,
        we,
        Re = new Float64Array(64),
        ke = [n(), n(), n(), n()];
      X(D, b, 32), (D[0] &= 248), (D[31] &= 127), (D[31] |= 64);
      var je = $ + 64;
      for (pe = 0; pe < $; pe++) P[64 + pe] = C[pe];
      for (pe = 0; pe < 32; pe++) P[32 + pe] = D[32 + pe];
      for (
        X(se, P.subarray(32), $ + 32), wt(se), lt(ke, se), ye(P, ke), pe = 32;
        pe < 64;
        pe++
      )
        P[pe] = b[pe];
      for (X(K, P, $ + 64), wt(K), pe = 0; pe < 64; pe++) Re[pe] = 0;
      for (pe = 0; pe < 32; pe++) Re[pe] = se[pe];
      for (pe = 0; pe < 32; pe++)
        for (we = 0; we < 32; we++) Re[pe + we] += K[pe] * D[we];
      return bt(P.subarray(32), Re), je;
    }
    function ze(P, C) {
      var $ = n(),
        b = n(),
        D = n(),
        K = n(),
        se = n(),
        pe = n(),
        we = n();
      return (
        Z(P[2], o),
        W(P[1], C),
        V(D, P[1]),
        T(K, D, l),
        x(D, D, P[2]),
        F(K, P[2], K),
        V(se, K),
        V(pe, se),
        T(we, pe, se),
        T($, we, D),
        T($, $, K),
        N($, $),
        T($, $, D),
        T($, $, K),
        T($, $, K),
        T(P[0], $, K),
        V(b, P[0]),
        T(b, b, K),
        L(b, D) && T(P[0], P[0], p),
        V(b, P[0]),
        T(b, b, K),
        L(b, D)
          ? -1
          : (k(P[0]) === C[31] >> 7 && x(P[0], s, P[0]), T(P[3], P[0], P[1]), 0)
      );
    }
    function dt(P, C, $, b) {
      var D,
        K,
        se = new Uint8Array(32),
        pe = new Uint8Array(64),
        we = [n(), n(), n(), n()],
        Re = [n(), n(), n(), n()];
      if (((K = -1), $ < 64 || ze(Re, b))) return -1;
      for (D = 0; D < $; D++) P[D] = C[D];
      for (D = 0; D < 32; D++) P[D + 32] = b[D];
      if (
        (X(pe, P, $),
        wt(pe),
        Qe(we, Re, pe),
        lt(Re, C.subarray(32)),
        he(we, Re),
        ye(se, we),
        ($ -= 64),
        v(C, 0, se, 0))
      ) {
        for (D = 0; D < $; D++) P[D] = 0;
        return -1;
      }
      for (D = 0; D < $; D++) P[D] = C[D + 64];
      return (K = $), K;
    }
    var ht = 32,
      an = 24,
      $n = 32,
      Wt = 16,
      Jt = 32,
      Zt = 32,
      jr = 32,
      Nn = 32,
      Vr = 32,
      Vi = an,
      On = $n,
      ni = Wt,
      An = 64,
      Mr = 32,
      Hr = 64,
      Yi = 32,
      qr = 64;
    t.lowlevel = {
      crypto_core_hsalsa20: R,
      crypto_stream_xor: O,
      crypto_stream: w,
      crypto_stream_salsa20_xor: I,
      crypto_stream_salsa20: S,
      crypto_onetimeauth: j,
      crypto_onetimeauth_verify: H,
      crypto_verify_16: g,
      crypto_verify_32: v,
      crypto_secretbox: q,
      crypto_secretbox_open: J,
      crypto_scalarmult: ce,
      crypto_scalarmult_base: re,
      crypto_box_beforenm: Y,
      crypto_box_afternm: M,
      crypto_box: Ee,
      crypto_box_open: le,
      crypto_box_keypair: ne,
      crypto_hash: X,
      crypto_sign: ct,
      crypto_sign_keypair: Lt,
      crypto_sign_open: dt,
      crypto_secretbox_KEYBYTES: ht,
      crypto_secretbox_NONCEBYTES: an,
      crypto_secretbox_ZEROBYTES: $n,
      crypto_secretbox_BOXZEROBYTES: Wt,
      crypto_scalarmult_BYTES: Jt,
      crypto_scalarmult_SCALARBYTES: Zt,
      crypto_box_PUBLICKEYBYTES: jr,
      crypto_box_SECRETKEYBYTES: Nn,
      crypto_box_BEFORENMBYTES: Vr,
      crypto_box_NONCEBYTES: Vi,
      crypto_box_ZEROBYTES: On,
      crypto_box_BOXZEROBYTES: ni,
      crypto_sign_BYTES: An,
      crypto_sign_PUBLICKEYBYTES: Mr,
      crypto_sign_SECRETKEYBYTES: Hr,
      crypto_sign_SEEDBYTES: Yi,
      crypto_hash_BYTES: qr,
    };
    function ns(P, C) {
      if (P.length !== ht) throw new Error("bad key size");
      if (C.length !== an) throw new Error("bad nonce size");
    }
    function kc(P, C) {
      if (P.length !== jr) throw new Error("bad public key size");
      if (C.length !== Nn) throw new Error("bad secret key size");
    }
    function Bn() {
      var P, C;
      for (C = 0; C < arguments.length; C++)
        if (
          (P = Object.prototype.toString.call(arguments[C])) !==
          "[object Uint8Array]"
        )
          throw new TypeError("unexpected type " + P + ", use Uint8Array");
    }
    function no(P) {
      for (var C = 0; C < P.length; C++) P[C] = 0;
    }
    t.util ||
      ((t.util = {}),
      (t.util.decodeUTF8 =
        t.util.encodeUTF8 =
        t.util.encodeBase64 =
        t.util.decodeBase64 =
          function () {
            throw new Error(
              "nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js",
            );
          })),
      (t.randomBytes = function (P) {
        var C = new Uint8Array(P);
        return r(C, P), C;
      }),
      (t.secretbox = function (P, C, $) {
        Bn(P, C, $), ns($, C);
        for (
          var b = new Uint8Array($n + P.length),
            D = new Uint8Array(b.length),
            K = 0;
          K < P.length;
          K++
        )
          b[K + $n] = P[K];
        return q(D, b, b.length, C, $), D.subarray(Wt);
      }),
      (t.secretbox.open = function (P, C, $) {
        Bn(P, C, $), ns($, C);
        for (
          var b = new Uint8Array(Wt + P.length),
            D = new Uint8Array(b.length),
            K = 0;
          K < P.length;
          K++
        )
          b[K + Wt] = P[K];
        return b.length < 32 || J(D, b, b.length, C, $) !== 0
          ? !1
          : D.subarray($n);
      }),
      (t.secretbox.keyLength = ht),
      (t.secretbox.nonceLength = an),
      (t.secretbox.overheadLength = Wt),
      (t.scalarMult = function (P, C) {
        if ((Bn(P, C), P.length !== Zt)) throw new Error("bad n size");
        if (C.length !== Jt) throw new Error("bad p size");
        var $ = new Uint8Array(Jt);
        return ce($, P, C), $;
      }),
      (t.scalarMult.base = function (P) {
        if ((Bn(P), P.length !== Zt)) throw new Error("bad n size");
        var C = new Uint8Array(Jt);
        return re(C, P), C;
      }),
      (t.scalarMult.scalarLength = Zt),
      (t.scalarMult.groupElementLength = Jt),
      (t.box = function (P, C, $, b) {
        var D = t.box.before($, b);
        return t.secretbox(P, C, D);
      }),
      (t.box.before = function (P, C) {
        Bn(P, C), kc(P, C);
        var $ = new Uint8Array(Vr);
        return Y($, P, C), $;
      }),
      (t.box.after = t.secretbox),
      (t.box.open = function (P, C, $, b) {
        var D = t.box.before($, b);
        return t.secretbox.open(P, C, D);
      }),
      (t.box.open.after = t.secretbox.open),
      (t.box.keyPair = function () {
        var P = new Uint8Array(jr),
          C = new Uint8Array(Nn);
        return ne(P, C), { publicKey: P, secretKey: C };
      }),
      (t.box.keyPair.fromSecretKey = function (P) {
        if ((Bn(P), P.length !== Nn)) throw new Error("bad secret key size");
        var C = new Uint8Array(jr);
        return re(C, P), { publicKey: C, secretKey: new Uint8Array(P) };
      }),
      (t.box.publicKeyLength = jr),
      (t.box.secretKeyLength = Nn),
      (t.box.sharedKeyLength = Vr),
      (t.box.nonceLength = Vi),
      (t.box.overheadLength = t.secretbox.overheadLength),
      (t.sign = function (P, C) {
        if ((Bn(P, C), C.length !== Hr)) throw new Error("bad secret key size");
        var $ = new Uint8Array(An + P.length);
        return ct($, P, P.length, C), $;
      }),
      (t.sign.open = function (P, C) {
        if (arguments.length !== 2)
          throw new Error(
            "nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?",
          );
        if ((Bn(P, C), C.length !== Mr)) throw new Error("bad public key size");
        var $ = new Uint8Array(P.length),
          b = dt($, P, P.length, C);
        if (b < 0) return null;
        for (var D = new Uint8Array(b), K = 0; K < D.length; K++) D[K] = $[K];
        return D;
      }),
      (t.sign.detached = function (P, C) {
        for (
          var $ = t.sign(P, C), b = new Uint8Array(An), D = 0;
          D < b.length;
          D++
        )
          b[D] = $[D];
        return b;
      }),
      (t.sign.detached.verify = function (P, C, $) {
        if ((Bn(P, C, $), C.length !== An))
          throw new Error("bad signature size");
        if ($.length !== Mr) throw new Error("bad public key size");
        var b = new Uint8Array(An + P.length),
          D = new Uint8Array(An + P.length),
          K;
        for (K = 0; K < An; K++) b[K] = C[K];
        for (K = 0; K < P.length; K++) b[K + An] = P[K];
        return dt(D, b, b.length, $) >= 0;
      }),
      (t.sign.keyPair = function () {
        var P = new Uint8Array(Mr),
          C = new Uint8Array(Hr);
        return Lt(P, C), { publicKey: P, secretKey: C };
      }),
      (t.sign.keyPair.fromSecretKey = function (P) {
        if ((Bn(P), P.length !== Hr)) throw new Error("bad secret key size");
        for (var C = new Uint8Array(Mr), $ = 0; $ < C.length; $++)
          C[$] = P[32 + $];
        return { publicKey: C, secretKey: new Uint8Array(P) };
      }),
      (t.sign.keyPair.fromSeed = function (P) {
        if ((Bn(P), P.length !== Yi)) throw new Error("bad seed size");
        for (
          var C = new Uint8Array(Mr), $ = new Uint8Array(Hr), b = 0;
          b < 32;
          b++
        )
          $[b] = P[b];
        return Lt(C, $, !0), { publicKey: C, secretKey: $ };
      }),
      (t.sign.publicKeyLength = Mr),
      (t.sign.secretKeyLength = Hr),
      (t.sign.seedLength = Yi),
      (t.sign.signatureLength = An),
      (t.hash = function (P) {
        Bn(P);
        var C = new Uint8Array(qr);
        return X(C, P, P.length), C;
      }),
      (t.hash.hashLength = qr),
      (t.verify = function (P, C) {
        return (
          Bn(P, C),
          P.length === 0 || C.length === 0 || P.length !== C.length
            ? !1
            : m(P, 0, C, 0, P.length) === 0
        );
      }),
      (t.setPRNG = function (P) {
        r = P;
      }),
      (function () {
        var P = typeof self < "u" ? self.crypto || self.msCrypto : null;
        if (P && P.getRandomValues) {
          var C = 65536;
          t.setPRNG(function ($, b) {
            var D,
              K = new Uint8Array(b);
            for (D = 0; D < b; D += C)
              P.getRandomValues(K.subarray(D, D + Math.min(b - D, C)));
            for (D = 0; D < b; D++) $[D] = K[D];
            no(K);
          });
        } else
          typeof d$ < "u" &&
            ((P = pr),
            P &&
              P.randomBytes &&
              t.setPRNG(function ($, b) {
                var D,
                  K = P.randomBytes(b);
                for (D = 0; D < b; D++) $[D] = K[D];
                no(K);
              }));
      })();
  })(e.exports ? e.exports : (self.nacl = self.nacl || {}));
})(nk);
var vte = nk.exports,
  Wm = vte.lowlevel.crypto_hash,
  sa = 0,
  Zs = function () {
    (this.S = [
      new Uint32Array([
        3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670,
        3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374,
        1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416,
        1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379,
        3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982,
        1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464,
        3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006,
        3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050,
        732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708,
        2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067,
        1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745,
        3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033,
        772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826,
        1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571,
        1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486,
        1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502,
        3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902,
        469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251,
        122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683,
        2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531,
        1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396,
        3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435,
        3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882,
        3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056,
        1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064,
        1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595,
        3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392,
        3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851,
        2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539,
        1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580,
        2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160,
        2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540,
        1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551,
        3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937,
        3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981,
        2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143,
        3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398,
        577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418,
        2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193,
        298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269,
        3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943,
        4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956,
        1404054877, 2845806497, 146425753, 1854211946,
      ]),
      new Uint32Array([
        1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493,
        2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449,
        422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325,
        1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673,
        1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473,
        1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447,
        1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805,
        4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981,
        3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892,
        3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881,
        3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856,
        1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655,
        3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252,
        1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668,
        3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616,
        3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781,
        1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859,
        1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206,
        2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330,
        694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202,
        3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277,
        423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102,
        3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133,
        1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780,
        354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286,
        53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820,
        4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346,
        2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511,
        2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927,
        300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857,
        1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956,
        2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347,
        1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338,
        3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373,
        3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030,
        4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533,
        157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106,
        497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875,
        2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966,
        3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476,
        2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037,
        1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792,
        356393447, 2410691914, 3873677099, 3682840055,
      ]),
      new Uint32Array([
        3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079,
        3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287,
        507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711,
        1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444,
        2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812,
        170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054,
        1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612,
        3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499,
        499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714,
        1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951,
        1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544,
        3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748,
        4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314,
        1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167,
        845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280,
        3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701,
        1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857,
        3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200,
        1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100,
        980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669,
        3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507,
        3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355,
        3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081,
        2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300,
        1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866,
        1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610,
        1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518,
        1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100,
        2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756,
        1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170,
        1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788,
        2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396,
        3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297,
        1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264,
        448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134,
        2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375,
        2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320,
        6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572,
        3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056,
        963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620,
        3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352,
        2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119,
        3617206836, 2455994898, 1729034894, 1080033504,
      ]),
      new Uint32Array([
        976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578,
        3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283,
        3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217,
        3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814,
        691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906,
        1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820,
        2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233,
        1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353,
        2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191,
        753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344,
        530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254,
        1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136,
        2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250,
        60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426,
        457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805,
        55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263,
        1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142,
        1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792,
        2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957,
        1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891,
        3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579,
        2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400,
        1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388,
        886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488,
        1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036,
        3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993,
        3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674,
        3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343,
        4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370,
        261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801,
        3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347,
        1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142,
        453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566,
        3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879,
        370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899,
        2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580,
        3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322,
        1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758,
        1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379,
        950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296,
        2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436,
        29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231,
        3075367218, 3463963227, 1469046755, 985887462,
      ]),
    ]),
      (this.P = new Uint32Array([
        608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832,
        137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300,
        3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731,
      ]));
  };
function Td(e, t, n) {
  return ((e[0][t[n + 3]] + e[1][t[n + 2]]) ^ e[2][t[n + 1]]) + e[3][t[n]];
}
Zs.prototype.encipher = function (e, t) {
  t === void 0 &&
    ((t = new Uint8Array(e.buffer)),
    e.byteOffset !== 0 && (t = t.subarray(e.byteOffset))),
    (e[0] ^= this.P[0]);
  for (var n = 1; n < 16; n += 2)
    (e[1] ^= Td(this.S, t, 0) ^ this.P[n]),
      (e[0] ^= Td(this.S, t, 4) ^ this.P[n + 1]);
  var r = e[0];
  (e[0] = e[1] ^ this.P[17]), (e[1] = r);
};
Zs.prototype.decipher = function (e) {
  var t = new Uint8Array(e.buffer);
  e.byteOffset !== 0 && (t = t.subarray(e.byteOffset)), (e[0] ^= this.P[17]);
  for (var n = 16; n > 0; n -= 2)
    (e[1] ^= Td(this.S, t, 0) ^ this.P[n]),
      (e[0] ^= Td(this.S, t, 4) ^ this.P[n - 1]);
  var r = e[0];
  (e[0] = e[1] ^ this.P[0]), (e[1] = r);
};
function Ss(e, t) {
  var n,
    r = 0;
  for (n = 0; n < 4; n++, sa++) sa >= t && (sa = 0), (r = (r << 8) | e[sa]);
  return r;
}
Zs.prototype.expand0state = function (e, t) {
  var n = new Uint32Array(2),
    r,
    i,
    a = new Uint8Array(n.buffer);
  for (r = 0, sa = 0; r < 18; r++) this.P[r] ^= Ss(e, t);
  for (sa = 0, r = 0; r < 18; r += 2)
    this.encipher(n, a), (this.P[r] = n[0]), (this.P[r + 1] = n[1]);
  for (r = 0; r < 4; r++)
    for (i = 0; i < 256; i += 2)
      this.encipher(n, a), (this.S[r][i] = n[0]), (this.S[r][i + 1] = n[1]);
};
Zs.prototype.expandstate = function (e, t, n, r) {
  var i = new Uint32Array(2),
    a,
    s;
  for (a = 0, sa = 0; a < 18; a++) this.P[a] ^= Ss(n, r);
  for (a = 0, sa = 0; a < 18; a += 2)
    (i[0] ^= Ss(e, t)),
      (i[1] ^= Ss(e, t)),
      this.encipher(i),
      (this.P[a] = i[0]),
      (this.P[a + 1] = i[1]);
  for (a = 0; a < 4; a++)
    for (s = 0; s < 256; s += 2)
      (i[0] ^= Ss(e, t)),
        (i[1] ^= Ss(e, t)),
        this.encipher(i),
        (this.S[a][s] = i[0]),
        (this.S[a][s + 1] = i[1]);
  sa = 0;
};
Zs.prototype.enc = function (e, t) {
  for (var n = 0; n < t; n++) this.encipher(e.subarray(n * 2));
};
Zs.prototype.dec = function (e, t) {
  for (var n = 0; n < t; n++) this.decipher(e.subarray(n * 2));
};
var Yf = 8,
  B0 = 32;
function U0(e, t, n) {
  var r = new Zs(),
    i = new Uint32Array(Yf),
    a,
    s = new Uint8Array([
      79, 120, 121, 99, 104, 114, 111, 109, 97, 116, 105, 99, 66, 108, 111, 119,
      102, 105, 115, 104, 83, 119, 97, 116, 68, 121, 110, 97, 109, 105, 116,
      101,
    ]);
  for (r.expandstate(t, 64, e, 64), a = 0; a < 64; a++)
    r.expand0state(t, 64), r.expand0state(e, 64);
  for (a = 0; a < Yf; a++) i[a] = Ss(s, s.byteLength);
  for (a = 0; a < 64; a++) r.enc(i, i.byteLength / 8);
  for (a = 0; a < Yf; a++)
    (n[4 * a + 3] = i[a] >>> 24),
      (n[4 * a + 2] = i[a] >>> 16),
      (n[4 * a + 1] = i[a] >>> 8),
      (n[4 * a + 0] = i[a]);
}
function yte(e, t, n, r, i, a, s) {
  var o = new Uint8Array(64),
    c = new Uint8Array(64),
    l = new Uint8Array(B0),
    f = new Uint8Array(B0),
    u = new Uint8Array(r + 4),
    d,
    p,
    h,
    m,
    g,
    v,
    y = a;
  if (
    s < 1 ||
    t === 0 ||
    r === 0 ||
    a === 0 ||
    a > l.byteLength * l.byteLength ||
    r > 1 << 20
  )
    return -1;
  for (
    m = Math.floor((a + l.byteLength - 1) / l.byteLength),
      h = Math.floor((a + m - 1) / m),
      d = 0;
    d < r;
    d++
  )
    u[d] = n[d];
  for (Wm(o, e, t), v = 1; a > 0; v++) {
    for (
      u[r + 0] = v >>> 24,
        u[r + 1] = v >>> 16,
        u[r + 2] = v >>> 8,
        u[r + 3] = v,
        Wm(c, u, r + 4),
        U0(o, c, f),
        d = l.byteLength;
      d--;

    )
      l[d] = f[d];
    for (d = 1; d < s; d++)
      for (Wm(c, f, f.byteLength), U0(o, c, f), p = 0; p < l.byteLength; p++)
        l[p] ^= f[p];
    for (
      h = Math.min(h, a), d = 0;
      d < h && ((g = d * m + (v - 1)), !(g >= y));
      d++
    )
      i[g] = l[d];
    a -= d;
  }
  return 0;
}
var rk = { BLOCKS: Yf, HASHSIZE: B0, hash: U0, pbkdf: yte },
  zm = { exports: {} },
  OA;
function es() {
  return (
    OA ||
      ((OA = 1),
      (function (e) {
        const t = pr;
        let n;
        try {
          n = require("cpu-features")();
        } catch {}
        const { bindingAvailable: r, CIPHER_INFO: i, MAC_INFO: a } = eo(),
          s = (() => {
            if (typeof t.sign == "function" && typeof t.verify == "function") {
              const R = `-----BEGIN PRIVATE KEY-----\r
MC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\r
-----END PRIVATE KEY-----`,
                A = Buffer.from("a");
              let I, S;
              try {
                (I = t.sign(null, A, R)), (S = t.verify(null, A, R, I));
              } catch {}
              return Buffer.isBuffer(I) && I.length === 64 && S === !0;
            }
            return !1;
          })(),
          o =
            typeof t.diffieHellman == "function" &&
            typeof t.generateKeyPairSync == "function" &&
            typeof t.createPublicKey == "function",
          c = [
            "ecdh-sha2-nistp256",
            "ecdh-sha2-nistp384",
            "ecdh-sha2-nistp521",
            "diffie-hellman-group-exchange-sha256",
            "diffie-hellman-group14-sha256",
            "diffie-hellman-group15-sha512",
            "diffie-hellman-group16-sha512",
            "diffie-hellman-group17-sha512",
            "diffie-hellman-group18-sha512",
          ];
        o &&
          (c.unshift("curve25519-sha256"),
          c.unshift("curve25519-sha256@libssh.org"));
        const l = c.concat([
            "diffie-hellman-group-exchange-sha1",
            "diffie-hellman-group14-sha1",
            "diffie-hellman-group1-sha1",
          ]),
          f = [
            "ecdsa-sha2-nistp256",
            "ecdsa-sha2-nistp384",
            "ecdsa-sha2-nistp521",
            "rsa-sha2-512",
            "rsa-sha2-256",
            "ssh-rsa",
          ];
        s && f.unshift("ssh-ed25519");
        const u = f.concat(["ssh-dss"]),
          d = (() => {
            const R = t.getCiphers();
            return (A) => R.includes(i[A].sslName);
          })();
        let p = [
          "aes128-gcm@openssh.com",
          "aes256-gcm@openssh.com",
          "aes128-ctr",
          "aes192-ctr",
          "aes256-ctr",
        ];
        n && n.flags && !n.flags.aes
          ? r
            ? p.unshift("chacha20-poly1305@openssh.com")
            : p.push("chacha20-poly1305@openssh.com")
          : r && n && n.arch === "x86"
          ? p.splice(4, 0, "chacha20-poly1305@openssh.com")
          : p.push("chacha20-poly1305@openssh.com"),
          (p = p.filter(d));
        const h = p.concat(
            [
              "aes256-cbc",
              "aes192-cbc",
              "aes128-cbc",
              "blowfish-cbc",
              "3des-cbc",
              "aes128-gcm",
              "aes256-gcm",
              "arcfour256",
              "arcfour128",
              "cast128-cbc",
              "arcfour",
            ].filter(d),
          ),
          m = (() => {
            const R = t.getHashes();
            return (A) => R.includes(a[A].sslName);
          })(),
          g = [
            "hmac-sha2-256-etm@openssh.com",
            "hmac-sha2-512-etm@openssh.com",
            "hmac-sha1-etm@openssh.com",
            "hmac-sha2-256",
            "hmac-sha2-512",
            "hmac-sha1",
          ].filter(m),
          v = g.concat(
            [
              "hmac-md5",
              "hmac-sha2-256-96",
              "hmac-sha2-512-96",
              "hmac-ripemd160",
              "hmac-sha1-96",
              "hmac-md5-96",
            ].filter(m),
          ),
          y = ["none", "zlib@openssh.com", "zlib"],
          _ = y.concat([]),
          E = {
            BAD_DHGEX: 1,
            OLD_EXIT: 2,
            DYN_RPORT_BUG: 4,
            BUG_DHGEX_LARGE: 8,
            IMPLY_RSA_SHA2_SIGALGS: 16,
          };
        (e.exports = {
          MESSAGE: {
            DISCONNECT: 1,
            IGNORE: 2,
            UNIMPLEMENTED: 3,
            DEBUG: 4,
            SERVICE_REQUEST: 5,
            SERVICE_ACCEPT: 6,
            EXT_INFO: 7,
            KEXINIT: 20,
            NEWKEYS: 21,
            KEXDH_INIT: 30,
            KEXDH_REPLY: 31,
            KEXDH_GEX_GROUP: 31,
            KEXDH_GEX_INIT: 32,
            KEXDH_GEX_REPLY: 33,
            KEXDH_GEX_REQUEST: 34,
            KEXECDH_INIT: 30,
            KEXECDH_REPLY: 31,
            USERAUTH_REQUEST: 50,
            USERAUTH_FAILURE: 51,
            USERAUTH_SUCCESS: 52,
            USERAUTH_BANNER: 53,
            USERAUTH_PASSWD_CHANGEREQ: 60,
            USERAUTH_PK_OK: 60,
            USERAUTH_INFO_REQUEST: 60,
            USERAUTH_INFO_RESPONSE: 61,
            GLOBAL_REQUEST: 80,
            REQUEST_SUCCESS: 81,
            REQUEST_FAILURE: 82,
            CHANNEL_OPEN: 90,
            CHANNEL_OPEN_CONFIRMATION: 91,
            CHANNEL_OPEN_FAILURE: 92,
            CHANNEL_WINDOW_ADJUST: 93,
            CHANNEL_DATA: 94,
            CHANNEL_EXTENDED_DATA: 95,
            CHANNEL_EOF: 96,
            CHANNEL_CLOSE: 97,
            CHANNEL_REQUEST: 98,
            CHANNEL_SUCCESS: 99,
            CHANNEL_FAILURE: 100,
          },
          DISCONNECT_REASON: {
            HOST_NOT_ALLOWED_TO_CONNECT: 1,
            PROTOCOL_ERROR: 2,
            KEY_EXCHANGE_FAILED: 3,
            RESERVED: 4,
            MAC_ERROR: 5,
            COMPRESSION_ERROR: 6,
            SERVICE_NOT_AVAILABLE: 7,
            PROTOCOL_VERSION_NOT_SUPPORTED: 8,
            HOST_KEY_NOT_VERIFIABLE: 9,
            CONNECTION_LOST: 10,
            BY_APPLICATION: 11,
            TOO_MANY_CONNECTIONS: 12,
            AUTH_CANCELED_BY_USER: 13,
            NO_MORE_AUTH_METHODS_AVAILABLE: 14,
            ILLEGAL_USER_NAME: 15,
          },
          DISCONNECT_REASON_STR: void 0,
          CHANNEL_OPEN_FAILURE: {
            ADMINISTRATIVELY_PROHIBITED: 1,
            CONNECT_FAILED: 2,
            UNKNOWN_CHANNEL_TYPE: 3,
            RESOURCE_SHORTAGE: 4,
          },
          TERMINAL_MODE: {
            TTY_OP_END: 0,
            VINTR: 1,
            VQUIT: 2,
            VERASE: 3,
            VKILL: 4,
            VEOF: 5,
            VEOL: 6,
            VEOL2: 7,
            VSTART: 8,
            VSTOP: 9,
            VSUSP: 10,
            VDSUSP: 11,
            VREPRINT: 12,
            VWERASE: 13,
            VLNEXT: 14,
            VFLUSH: 15,
            VSWTCH: 16,
            VSTATUS: 17,
            VDISCARD: 18,
            IGNPAR: 30,
            PARMRK: 31,
            INPCK: 32,
            ISTRIP: 33,
            INLCR: 34,
            IGNCR: 35,
            ICRNL: 36,
            IUCLC: 37,
            IXON: 38,
            IXANY: 39,
            IXOFF: 40,
            IMAXBEL: 41,
            ISIG: 50,
            ICANON: 51,
            XCASE: 52,
            ECHO: 53,
            ECHOE: 54,
            ECHOK: 55,
            ECHONL: 56,
            NOFLSH: 57,
            TOSTOP: 58,
            IEXTEN: 59,
            ECHOCTL: 60,
            ECHOKE: 61,
            PENDIN: 62,
            OPOST: 70,
            OLCUC: 71,
            ONLCR: 72,
            OCRNL: 73,
            ONOCR: 74,
            ONLRET: 75,
            CS7: 90,
            CS8: 91,
            PARENB: 92,
            PARODD: 93,
            TTY_OP_ISPEED: 128,
            TTY_OP_OSPEED: 129,
          },
          CHANNEL_EXTENDED_DATATYPE: { STDERR: 1 },
          SIGNALS: [
            "ABRT",
            "ALRM",
            "FPE",
            "HUP",
            "ILL",
            "INT",
            "QUIT",
            "SEGV",
            "TERM",
            "USR1",
            "USR2",
            "KILL",
            "PIPE",
          ].reduce((R, A) => ({ ...R, [A]: 1 }), {}),
          COMPAT: E,
          COMPAT_CHECKS: [
            ["Cisco-1.25", E.BAD_DHGEX],
            [/^Cisco-1[.]/, E.BUG_DHGEX_LARGE],
            [/^[0-9.]+$/, E.OLD_EXIT],
            [/^OpenSSH_5[.][0-9]+/, E.DYN_RPORT_BUG],
            [/^OpenSSH_7[.]4/, E.IMPLY_RSA_SHA2_SIGALGS],
          ],
          DEFAULT_KEX: c,
          SUPPORTED_KEX: l,
          DEFAULT_SERVER_HOST_KEY: f,
          SUPPORTED_SERVER_HOST_KEY: u,
          DEFAULT_CIPHER: p,
          SUPPORTED_CIPHER: h,
          DEFAULT_MAC: g,
          SUPPORTED_MAC: v,
          DEFAULT_COMPRESSION: y,
          SUPPORTED_COMPRESSION: _,
          curve25519Supported: o,
          eddsaSupported: s,
        }),
          (e.exports.DISCONNECT_REASON_BY_VALUE = Array.from(
            Object.entries(e.exports.DISCONNECT_REASON),
          ).reduce((R, [A, I]) => ({ ...R, [I]: A }), {}));
      })(zm)),
    zm.exports
  );
}
var Km, PA;
function Ki() {
  if (PA) return Km;
  PA = 1;
  const e = Yp.Ber;
  let t;
  const n = Buffer[Symbol.species],
    r = Object.getPrototypeOf(Uint8Array.prototype).fill;
  function i(u, d) {
    return u[d++] * 16777216 + u[d++] * 65536 + u[d++] * 256 + u[d];
  }
  function a(u, d, p, h, m) {
    m || (m = 0), h > u.length && (h = u.length);
    let g = h - p;
    const v = d.length - m;
    return (
      g > v && (g = v),
      d.set(new Uint8Array(u.buffer, u.byteOffset + p, g), m),
      g
    );
  }
  function s(u, d, p) {
    return (
      p === void 0 && (p = u.length), new n(u.buffer, u.byteOffset + d, p - d)
    );
  }
  function o() {
    let u = 0,
      d;
    const p = {
      init: (h, m) => {
        (d = h), (u = typeof m == "number" ? m : 0);
      },
      pos: () => u,
      length: () => (d ? d.length : 0),
      avail: () => (d && u < d.length ? d.length - u : 0),
      clear: () => {
        d = void 0;
      },
      readUInt32BE: () => {
        if (!(!d || u + 3 >= d.length))
          return d[u++] * 16777216 + d[u++] * 65536 + d[u++] * 256 + d[u++];
      },
      readUInt64BE: (h) => {
        if (!(!d || u + 7 >= d.length))
          switch (h) {
            case "always":
              return BigInt(`0x${d.hexSlice(u, (u += 8))}`);
            case "maybe":
              if (d[u] > 31) return BigInt(`0x${d.hexSlice(u, (u += 8))}`);
            default:
              return (
                d[u++] * 72057594037927940 +
                d[u++] * 281474976710656 +
                d[u++] * 1099511627776 +
                d[u++] * 4294967296 +
                d[u++] * 16777216 +
                d[u++] * 65536 +
                d[u++] * 256 +
                d[u++]
              );
          }
      },
      skip: (h) => {
        d && h > 0 && (u += h);
      },
      skipString: () => {
        const h = p.readUInt32BE();
        if (h !== void 0) return (u += h), u <= d.length ? h : void 0;
      },
      readByte: () => {
        if (d && u < d.length) return d[u++];
      },
      readBool: () => {
        if (d && u < d.length) return !!d[u++];
      },
      readList: () => {
        const h = p.readString(!0);
        if (h !== void 0) return h ? h.split(",") : [];
      },
      readString: (h, m) => {
        typeof h == "number" && ((m = h), (h = void 0));
        const g = p.readUInt32BE();
        if (
          g !== void 0 &&
          !(d.length - u < g || (typeof m == "number" && g > m))
        )
          return h
            ? Buffer.isBuffer(h)
              ? a(d, h, u, (u += g))
              : d.utf8Slice(u, (u += g))
            : s(d, u, (u += g));
      },
      readRaw: (h) => {
        if (d) {
          if (typeof h != "number") return s(d, u, (u += d.length - u));
          if (d.length - u >= h) return s(d, u, (u += h));
        }
      },
    };
    return p;
  }
  function c(u, d, p) {
    const h = new Error(u);
    return (
      typeof d == "boolean"
        ? ((p = d), (h.level = "protocol"))
        : (h.level = d || "protocol"),
      (h.fatal = !!p),
      h
    );
  }
  function l(u, d, p) {
    return (
      (u[p++] = d >>> 24),
      (u[p++] = d >>> 16),
      (u[p++] = d >>> 8),
      (u[p++] = d),
      p
    );
  }
  const f = o();
  return (
    (Km = {
      bufferCopy: a,
      bufferSlice: s,
      FastBuffer: n,
      bufferFill: (u, d, p, h) => r.call(u, d, p, h),
      makeError: c,
      doFatalError: (u, d, p, h) => {
        let m;
        return (
          t === void 0 && ({ DISCONNECT_REASON: t } = es()),
          d instanceof Error
            ? ((m = d), typeof p != "number" ? (h = t.PROTOCOL_ERROR) : (h = p))
            : (m = c(d, p, !0)),
          typeof h != "number" && (h = t.PROTOCOL_ERROR),
          u.disconnect(h),
          u._destruct(),
          u._onError(m),
          1 / 0
        );
      },
      readUInt32BE: i,
      writeUInt32BE: l,
      writeUInt32LE: (u, d, p) => (
        (u[p++] = d),
        (u[p++] = d >>> 8),
        (u[p++] = d >>> 16),
        (u[p++] = d >>> 24),
        p
      ),
      makeBufferParser: o,
      bufferParser: o(),
      readString: (u, d, p, h) => {
        typeof p == "number" && ((h = p), (p = void 0)),
          d === void 0 && (d = 0);
        const m = u.length - d;
        if (d < 0 || d >= u.length || m < 4) return;
        const g = i(u, d);
        if (m < 4 + g || (typeof h == "number" && g > h)) return;
        d += 4;
        const v = d + g;
        return (
          (u._pos = v),
          p
            ? Buffer.isBuffer(p)
              ? a(u, p, d, v)
              : u.utf8Slice(d, v)
            : s(u, d, v)
        );
      },
      sigSSHToASN1: (u, d) => {
        switch (d) {
          case "ssh-dss": {
            if (u.length > 40) return u;
            const p = new e.Writer();
            p.startSequence();
            let h = u.slice(0, 20),
              m = u.slice(20);
            if (h[0] & 128) {
              const g = Buffer.allocUnsafe(21);
              (g[0] = 0), h.copy(g, 1), (h = g);
            } else h[0] === 0 && !(h[1] & 128) && (h = h.slice(1));
            if (m[0] & 128) {
              const g = Buffer.allocUnsafe(21);
              (g[0] = 0), m.copy(g, 1), (m = g);
            } else m[0] === 0 && !(m[1] & 128) && (m = m.slice(1));
            return (
              p.writeBuffer(h, e.Integer),
              p.writeBuffer(m, e.Integer),
              p.endSequence(),
              p.buffer
            );
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            f.init(u, 0);
            const p = f.readString(),
              h = f.readString();
            if ((f.clear(), p === void 0 || h === void 0)) return;
            const m = new e.Writer();
            return (
              m.startSequence(),
              m.writeBuffer(p, e.Integer),
              m.writeBuffer(h, e.Integer),
              m.endSequence(),
              m.buffer
            );
          }
          default:
            return u;
        }
      },
      convertSignature: (u, d) => {
        switch (d) {
          case "ssh-dss": {
            if (u.length <= 40) return u;
            const p = new e.Reader(u);
            p.readSequence();
            let h = p.readString(e.Integer, !0),
              m = p.readString(e.Integer, !0),
              g = 0,
              v = 0;
            if (h.length < 20) {
              const _ = Buffer.allocUnsafe(20);
              _.set(h, 1), (h = _), (h[0] = 0);
            }
            if (m.length < 20) {
              const _ = Buffer.allocUnsafe(20);
              _.set(m, 1), (m = _), (m[0] = 0);
            }
            h.length > 20 && h[0] === 0 && (g = 1),
              m.length > 20 && m[0] === 0 && (v = 1);
            const y = Buffer.allocUnsafe(h.length - g + (m.length - v));
            return (
              a(h, y, g, h.length, 0), a(m, y, v, m.length, h.length - g), y
            );
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            if (u[0] === 0) return u;
            const p = new e.Reader(u);
            p.readSequence();
            const h = p.readString(e.Integer, !0),
              m = p.readString(e.Integer, !0);
            if (h === null || m === null) return;
            const g = Buffer.allocUnsafe(4 + h.length + 4 + m.length);
            return (
              l(g, h.length, 0),
              g.set(h, 4),
              l(g, m.length, 4 + h.length),
              g.set(m, 4 + 4 + h.length),
              g
            );
          }
        }
        return u;
      },
      sendPacket: (u, d, p) =>
        !p && u._kexinit !== void 0
          ? (u._queue === void 0 && (u._queue = []),
            u._queue.push(d),
            u._debug && u._debug("Outbound: ... packet queued"),
            !1)
          : (u._cipher.encrypt(d), !0),
    }),
    Km
  );
}
var Vm = { exports: {} },
  DA;
function bte() {
  return (
    DA ||
      ((DA = 1),
      (function (e, t) {
        var n = (function () {
          var r =
            typeof document < "u" && document.currentScript
              ? document.currentScript.src
              : void 0;
          return (
            typeof __filename < "u" && (r = r || __filename),
            function (i) {
              i = i || {};
              var a;
              a || (a = typeof i < "u" ? i : {});
              var s, o;
              a.ready = new Promise(function (te, ie) {
                (s = te), (o = ie);
              });
              var c = {},
                l;
              for (l in a) a.hasOwnProperty(l) && (c[l] = a[l]);
              var f = typeof window == "object",
                u = typeof importScripts == "function",
                d =
                  typeof process == "object" &&
                  typeof process.versions == "object" &&
                  typeof process.versions.node == "string",
                p = "",
                h,
                m,
                g,
                v,
                y;
              d
                ? ((p = u ? pt.dirname(p) + "/" : __dirname + "/"),
                  (h = function (te, ie) {
                    var X = re(te);
                    return X
                      ? ie
                        ? X
                        : X.toString()
                      : (v || (v = Xt),
                        y || (y = pt),
                        (te = y.normalize(te)),
                        v.readFileSync(te, ie ? null : "utf8"));
                  }),
                  (g = function (te) {
                    return (
                      (te = h(te, !0)),
                      te.buffer || (te = new Uint8Array(te)),
                      I(te.buffer),
                      te
                    );
                  }),
                  (m = function (te, ie, X) {
                    var he = re(te);
                    he && ie(he),
                      v || (v = Xt),
                      y || (y = pt),
                      (te = y.normalize(te)),
                      v.readFile(te, function (be, ye) {
                        be ? X(be) : ie(ye.buffer);
                      });
                  }),
                  1 < process.argv.length &&
                    process.argv[1].replace(/\\/g, "/"),
                  process.argv.slice(2),
                  (a.inspect = function () {
                    return "[Emscripten Module object]";
                  }))
                : (f || u) &&
                  (u
                    ? (p = self.location.href)
                    : typeof document < "u" &&
                      document.currentScript &&
                      (p = document.currentScript.src),
                  r && (p = r),
                  p.indexOf("blob:") !== 0
                    ? (p = p.substr(0, p.lastIndexOf("/") + 1))
                    : (p = ""),
                  (h = function (te) {
                    try {
                      var ie = new XMLHttpRequest();
                      return (
                        ie.open("GET", te, !1), ie.send(null), ie.responseText
                      );
                    } catch (be) {
                      if ((te = re(te))) {
                        ie = [];
                        for (var X = 0; X < te.length; X++) {
                          var he = te[X];
                          255 < he && (he &= 255),
                            ie.push(String.fromCharCode(he));
                        }
                        return ie.join("");
                      }
                      throw be;
                    }
                  }),
                  u &&
                    (g = function (te) {
                      try {
                        var ie = new XMLHttpRequest();
                        return (
                          ie.open("GET", te, !1),
                          (ie.responseType = "arraybuffer"),
                          ie.send(null),
                          new Uint8Array(ie.response)
                        );
                      } catch (X) {
                        if ((te = re(te))) return te;
                        throw X;
                      }
                    }),
                  (m = function (te, ie, X) {
                    var he = new XMLHttpRequest();
                    he.open("GET", te, !0),
                      (he.responseType = "arraybuffer"),
                      (he.onload = function () {
                        if (he.status == 200 || (he.status == 0 && he.response))
                          ie(he.response);
                        else {
                          var be = re(te);
                          be ? ie(be.buffer) : X();
                        }
                      }),
                      (he.onerror = X),
                      he.send(null);
                  })),
                a.print || console.log.bind(console);
              var _ = a.printErr || console.warn.bind(console);
              for (l in c) c.hasOwnProperty(l) && (a[l] = c[l]);
              c = null;
              var E;
              a.wasmBinary && (E = a.wasmBinary),
                a.noExitRuntime,
                typeof WebAssembly != "object" &&
                  W("no native wasm support detected");
              var R,
                A = !1;
              function I(te, ie) {
                te || W("Assertion failed: " + ie);
              }
              function S(te) {
                var ie = a["_" + te];
                return (
                  I(
                    ie,
                    "Cannot call unknown function " +
                      te +
                      ", make sure it is exported",
                  ),
                  ie
                );
              }
              function w(te, ie, X, he) {
                var be = {
                    string: function (We) {
                      var bt = 0;
                      if (We != null && We !== 0) {
                        var wt = (We.length << 2) + 1;
                        bt = oe(wt);
                        var ct = bt,
                          ze = H;
                        if (0 < wt) {
                          wt = ct + wt - 1;
                          for (var dt = 0; dt < We.length; ++dt) {
                            var ht = We.charCodeAt(dt);
                            if (55296 <= ht && 57343 >= ht) {
                              var an = We.charCodeAt(++dt);
                              ht = (65536 + ((ht & 1023) << 10)) | (an & 1023);
                            }
                            if (127 >= ht) {
                              if (ct >= wt) break;
                              ze[ct++] = ht;
                            } else {
                              if (2047 >= ht) {
                                if (ct + 1 >= wt) break;
                                ze[ct++] = 192 | (ht >> 6);
                              } else {
                                if (65535 >= ht) {
                                  if (ct + 2 >= wt) break;
                                  ze[ct++] = 224 | (ht >> 12);
                                } else {
                                  if (ct + 3 >= wt) break;
                                  (ze[ct++] = 240 | (ht >> 18)),
                                    (ze[ct++] = 128 | ((ht >> 12) & 63));
                                }
                                ze[ct++] = 128 | ((ht >> 6) & 63);
                              }
                              ze[ct++] = 128 | (ht & 63);
                            }
                          }
                          ze[ct] = 0;
                        }
                      }
                      return bt;
                    },
                    array: function (We) {
                      var bt = oe(We.length);
                      return j.set(We, bt), bt;
                    },
                  },
                  ye = S(te),
                  Qe = [];
                if (((te = 0), he))
                  for (var lt = 0; lt < he.length; lt++) {
                    var Lt = be[X[lt]];
                    Lt
                      ? (te === 0 && (te = Y()), (Qe[lt] = Lt(he[lt])))
                      : (Qe[lt] = he[lt]);
                  }
                return (
                  (X = ye.apply(null, Qe)),
                  (X = (function (We) {
                    if (ie === "string")
                      if (We) {
                        for (
                          var bt = H, wt = We + NaN, ct = We;
                          bt[ct] && !(ct >= wt);

                        )
                          ++ct;
                        if (16 < ct - We && bt.subarray && O)
                          We = O.decode(bt.subarray(We, ct));
                        else {
                          for (wt = ""; We < ct; ) {
                            var ze = bt[We++];
                            if (ze & 128) {
                              var dt = bt[We++] & 63;
                              if ((ze & 224) == 192)
                                wt += String.fromCharCode(
                                  ((ze & 31) << 6) | dt,
                                );
                              else {
                                var ht = bt[We++] & 63;
                                (ze =
                                  (ze & 240) == 224
                                    ? ((ze & 15) << 12) | (dt << 6) | ht
                                    : ((ze & 7) << 18) |
                                      (dt << 12) |
                                      (ht << 6) |
                                      (bt[We++] & 63)),
                                  65536 > ze
                                    ? (wt += String.fromCharCode(ze))
                                    : ((ze -= 65536),
                                      (wt += String.fromCharCode(
                                        55296 | (ze >> 10),
                                        56320 | (ze & 1023),
                                      )));
                              }
                            } else wt += String.fromCharCode(ze);
                          }
                          We = wt;
                        }
                      } else We = "";
                    else We = ie === "boolean" ? !!We : We;
                    return We;
                  })(X)),
                  te !== 0 && M(te),
                  X
                );
              }
              var O =
                  typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0,
                Q,
                j,
                H;
              function q() {
                var te = R.buffer;
                (Q = te),
                  (a.HEAP8 = j = new Int8Array(te)),
                  (a.HEAP16 = new Int16Array(te)),
                  (a.HEAP32 = new Int32Array(te)),
                  (a.HEAPU8 = H = new Uint8Array(te)),
                  (a.HEAPU16 = new Uint16Array(te)),
                  (a.HEAPU32 = new Uint32Array(te)),
                  (a.HEAPF32 = new Float32Array(te)),
                  (a.HEAPF64 = new Float64Array(te));
              }
              var J,
                Z = [],
                z = [],
                U = [];
              function G() {
                var te = a.preRun.shift();
                Z.unshift(te);
              }
              var L = 0,
                k = null;
              (a.preloadedImages = {}), (a.preloadedAudios = {});
              function W(te) {
                throw (
                  (a.onAbort && a.onAbort(te),
                  _(te),
                  (A = !0),
                  (te = new WebAssembly.RuntimeError(
                    "abort(" +
                      te +
                      "). Build with -s ASSERTIONS=1 for more info.",
                  )),
                  o(te),
                  te)
                );
              }
              var F = "data:application/octet-stream;base64,",
                x;
              if (
                ((x =
                  "data:application/octet-stream;base64,AGFzbQEAAAABIAZgAX8Bf2ADf39/AGABfwBgAABgAAF/YAZ/f39/f38AAgcBAWEBYQAAAwsKAAEDAQAAAgQFAgQFAXABAQEFBwEBgAKAgAIGCQF/AUGAjMACCwclCQFiAgABYwADAWQACQFlAAgBZgAHAWcABgFoAAUBaQAKAWoBAAqGTQpPAQJ/QYAIKAIAIgEgAEEDakF8cSICaiEAAkAgAkEAIAAgAU0bDQAgAD8AQRB0SwRAIAAQAEUNAQtBgAggADYCACABDwtBhAhBMDYCAEF/C4wFAg5+Cn8gACgCJCEUIAAoAiAhFSAAKAIcIREgACgCGCESIAAoAhQhEyACQRBPBEAgAC0ATEVBGHQhFyAAKAIEIhZBBWytIQ8gACgCCCIYQQVsrSENIAAoAgwiGUEFbK0hCyAAKAIQIhpBBWytIQkgADUCACEIIBqtIRAgGa0hDiAYrSEMIBatIQoDQCASIAEtAAMiEiABLQAEQQh0ciABLQAFQRB0ciABLQAGIhZBGHRyQQJ2Qf///x9xaq0iAyAOfiABLwAAIAEtAAJBEHRyIBNqIBJBGHRBgICAGHFqrSIEIBB+fCARIAEtAAdBCHQgFnIgAS0ACEEQdHIgAS0ACSIRQRh0ckEEdkH///8fcWqtIgUgDH58IAEtAApBCHQgEXIgAS0AC0EQdHIgAS0ADEEYdHJBBnYgFWqtIgYgCn58IBQgF2ogAS8ADSABLQAPQRB0cmqtIgcgCH58IAMgDH4gBCAOfnwgBSAKfnwgBiAIfnwgByAJfnwgAyAKfiAEIAx+fCAFIAh+fCAGIAl+fCAHIAt+fCADIAh+IAQgCn58IAUgCX58IAYgC358IAcgDX58IAMgCX4gBCAIfnwgBSALfnwgBiANfnwgByAPfnwiA0IaiEL/////D4N8IgRCGohC/////w+DfCIFQhqIQv////8Pg3wiBkIaiEL/////D4N8IgdCGoinQQVsIAOnQf///x9xaiITQRp2IASnQf///x9xaiESIAWnQf///x9xIREgBqdB////H3EhFSAHp0H///8fcSEUIBNB////H3EhEyABQRBqIQEgAkEQayICQQ9LDQALCyAAIBQ2AiQgACAVNgIgIAAgETYCHCAAIBI2AhggACATNgIUCwMAAQu2BAEGfwJAIAAoAjgiBARAIABBPGohBQJAIAJBECAEayIDIAIgA0kbIgZFDQAgBkEDcSEHAkAgBkEBa0EDSQRAQQAhAwwBCyAGQXxxIQhBACEDA0AgBSADIARqaiABIANqLQAAOgAAIAUgA0EBciIEIAAoAjhqaiABIARqLQAAOgAAIAUgA0ECciIEIAAoAjhqaiABIARqLQAAOgAAIAUgA0EDciIEIAAoAjhqaiABIARqLQAAOgAAIANBBGohAyAAKAI4IQQgCEEEayIIDQALCyAHRQ0AA0AgBSADIARqaiABIANqLQAAOgAAIANBAWohAyAAKAI4IQQgB0EBayIHDQALCyAAIAQgBmoiAzYCOCADQRBJDQEgACAFQRAQAiAAQQA2AjggAiAGayECIAEgBmohAQsgAkEQTwRAIAAgASACQXBxIgMQAiACQQ9xIQIgASADaiEBCyACRQ0AIAJBA3EhBCAAQTxqIQVBACEDIAJBAWtBA08EQCACQXxxIQcDQCAFIAAoAjggA2pqIAEgA2otAAA6AAAgBSADQQFyIgYgACgCOGpqIAEgBmotAAA6AAAgBSADQQJyIgYgACgCOGpqIAEgBmotAAA6AAAgBSADQQNyIgYgACgCOGpqIAEgBmotAAA6AAAgA0EEaiEDIAdBBGsiBw0ACwsgBARAA0AgBSAAKAI4IANqaiABIANqLQAAOgAAIANBAWohAyAEQQFrIgQNAAsLIAAgACgCOCACajYCOAsLoS0BDH8jAEEQayIMJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEH0AU0EQEGICCgCACIFQRAgAEELakF4cSAAQQtJGyIIQQN2IgJ2IgFBA3EEQCABQX9zQQFxIAJqIgNBA3QiAUG4CGooAgAiBEEIaiEAAkAgBCgCCCICIAFBsAhqIgFGBEBBiAggBUF+IAN3cTYCAAwBCyACIAE2AgwgASACNgIICyAEIANBA3QiAUEDcjYCBCABIARqIgEgASgCBEEBcjYCBAwNCyAIQZAIKAIAIgpNDQEgAQRAAkBBAiACdCIAQQAgAGtyIAEgAnRxIgBBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2aiIDQQN0IgBBuAhqKAIAIgQoAggiASAAQbAIaiIARgRAQYgIIAVBfiADd3EiBTYCAAwBCyABIAA2AgwgACABNgIICyAEQQhqIQAgBCAIQQNyNgIEIAQgCGoiAiADQQN0IgEgCGsiA0EBcjYCBCABIARqIAM2AgAgCgRAIApBA3YiAUEDdEGwCGohB0GcCCgCACEEAn8gBUEBIAF0IgFxRQRAQYgIIAEgBXI2AgAgBwwBCyAHKAIICyEBIAcgBDYCCCABIAQ2AgwgBCAHNgIMIAQgATYCCAtBnAggAjYCAEGQCCADNgIADA0LQYwIKAIAIgZFDQEgBkEAIAZrcUEBayIAIABBDHZBEHEiAnYiAUEFdkEIcSIAIAJyIAEgAHYiAUECdkEEcSIAciABIAB2IgFBAXZBAnEiAHIgASAAdiIBQQF2QQFxIgByIAEgAHZqQQJ0QbgKaigCACIBKAIEQXhxIAhrIQMgASECA0ACQCACKAIQIgBFBEAgAigCFCIARQ0BCyAAKAIEQXhxIAhrIgIgAyACIANJIgIbIQMgACABIAIbIQEgACECDAELCyABIAhqIgkgAU0NAiABKAIYIQsgASABKAIMIgRHBEAgASgCCCIAQZgIKAIASRogACAENgIMIAQgADYCCAwMCyABQRRqIgIoAgAiAEUEQCABKAIQIgBFDQQgAUEQaiECCwNAIAIhByAAIgRBFGoiAigCACIADQAgBEEQaiECIAQoAhAiAA0ACyAHQQA2AgAMCwtBfyEIIABBv39LDQAgAEELaiIAQXhxIQhBjAgoAgAiCUUNAEEAIAhrIQMCQAJAAkACf0EAIAhBgAJJDQAaQR8gCEH///8HSw0AGiAAQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgCCAAQRVqdkEBcXJBHGoLIgVBAnRBuApqKAIAIgJFBEBBACEADAELQQAhACAIQQBBGSAFQQF2ayAFQR9GG3QhAQNAAkAgAigCBEF4cSAIayIHIANPDQAgAiEEIAciAw0AQQAhAyACIQAMAwsgACACKAIUIgcgByACIAFBHXZBBHFqKAIQIgJGGyAAIAcbIQAgAUEBdCEBIAINAAsLIAAgBHJFBEBBACEEQQIgBXQiAEEAIABrciAJcSIARQ0DIABBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2akECdEG4CmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAhrIgEgA0khAiABIAMgAhshAyAAIAQgAhshBCAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAERQ0AIANBkAgoAgAgCGtPDQAgBCAIaiIGIARNDQEgBCgCGCEFIAQgBCgCDCIBRwRAIAQoAggiAEGYCCgCAEkaIAAgATYCDCABIAA2AggMCgsgBEEUaiICKAIAIgBFBEAgBCgCECIARQ0EIARBEGohAgsDQCACIQcgACIBQRRqIgIoAgAiAA0AIAFBEGohAiABKAIQIgANAAsgB0EANgIADAkLIAhBkAgoAgAiAk0EQEGcCCgCACEDAkAgAiAIayIBQRBPBEBBkAggATYCAEGcCCADIAhqIgA2AgAgACABQQFyNgIEIAIgA2ogATYCACADIAhBA3I2AgQMAQtBnAhBADYCAEGQCEEANgIAIAMgAkEDcjYCBCACIANqIgAgACgCBEEBcjYCBAsgA0EIaiEADAsLIAhBlAgoAgAiBkkEQEGUCCAGIAhrIgE2AgBBoAhBoAgoAgAiAiAIaiIANgIAIAAgAUEBcjYCBCACIAhBA3I2AgQgAkEIaiEADAsLQQAhACAIQS9qIgkCf0HgCygCAARAQegLKAIADAELQewLQn83AgBB5AtCgKCAgICABDcCAEHgCyAMQQxqQXBxQdiq1aoFczYCAEH0C0EANgIAQcQLQQA2AgBBgCALIgFqIgVBACABayIHcSICIAhNDQpBwAsoAgAiBARAQbgLKAIAIgMgAmoiASADTQ0LIAEgBEsNCwtBxAstAABBBHENBQJAAkBBoAgoAgAiAwRAQcgLIQADQCADIAAoAgAiAU8EQCABIAAoAgRqIANLDQMLIAAoAggiAA0ACwtBABABIgFBf0YNBiACIQVB5AsoAgAiA0EBayIAIAFxBEAgAiABayAAIAFqQQAgA2txaiEFCyAFIAhNDQYgBUH+////B0sNBkHACygCACIEBEBBuAsoAgAiAyAFaiIAIANNDQcgACAESw0HCyAFEAEiACABRw0BDAgLIAUgBmsgB3EiBUH+////B0sNBSAFEAEiASAAKAIAIAAoAgRqRg0EIAEhAAsCQCAAQX9GDQAgCEEwaiAFTQ0AQegLKAIAIgEgCSAFa2pBACABa3EiAUH+////B0sEQCAAIQEMCAsgARABQX9HBEAgASAFaiEFIAAhAQwIC0EAIAVrEAEaDAULIAAiAUF/Rw0GDAQLAAtBACEEDAcLQQAhAQwFCyABQX9HDQILQcQLQcQLKAIAQQRyNgIACyACQf7///8HSw0BIAIQASEBQQAQASEAIAFBf0YNASAAQX9GDQEgACABTQ0BIAAgAWsiBSAIQShqTQ0BC0G4C0G4CygCACAFaiIANgIAQbwLKAIAIABJBEBBvAsgADYCAAsCQAJAAkBBoAgoAgAiBwRAQcgLIQADQCABIAAoAgAiAyAAKAIEIgJqRg0CIAAoAggiAA0ACwwCC0GYCCgCACIAQQAgACABTRtFBEBBmAggATYCAAtBACEAQcwLIAU2AgBByAsgATYCAEGoCEF/NgIAQawIQeALKAIANgIAQdQLQQA2AgADQCAAQQN0IgNBuAhqIANBsAhqIgI2AgAgA0G8CGogAjYCACAAQQFqIgBBIEcNAAtBlAggBUEoayIDQXggAWtBB3FBACABQQhqQQdxGyIAayICNgIAQaAIIAAgAWoiADYCACAAIAJBAXI2AgQgASADakEoNgIEQaQIQfALKAIANgIADAILIAAtAAxBCHENACADIAdLDQAgASAHTQ0AIAAgAiAFajYCBEGgCCAHQXggB2tBB3FBACAHQQhqQQdxGyIAaiICNgIAQZQIQZQIKAIAIAVqIgEgAGsiADYCACACIABBAXI2AgQgASAHakEoNgIEQaQIQfALKAIANgIADAELQZgIKAIAIAFLBEBBmAggATYCAAsgASAFaiECQcgLIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQcgLIQADQCAHIAAoAgAiAk8EQCACIAAoAgRqIgQgB0sNAwsgACgCCCEADAALAAsgACABNgIAIAAgACgCBCAFajYCBCABQXggAWtBB3FBACABQQhqQQdxG2oiCSAIQQNyNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIFIAggCWoiBmshAiAFIAdGBEBBoAggBjYCAEGUCEGUCCgCACACaiIANgIAIAYgAEEBcjYCBAwDCyAFQZwIKAIARgRAQZwIIAY2AgBBkAhBkAgoAgAgAmoiADYCACAGIABBAXI2AgQgACAGaiAANgIADAMLIAUoAgQiAEEDcUEBRgRAIABBeHEhBwJAIABB/wFNBEAgBSgCCCIDIABBA3YiAEEDdEGwCGpGGiADIAUoAgwiAUYEQEGICEGICCgCAEF+IAB3cTYCAAwCCyADIAE2AgwgASADNgIIDAELIAUoAhghCAJAIAUgBSgCDCIBRwRAIAUoAggiACABNgIMIAEgADYCCAwBCwJAIAVBFGoiACgCACIDDQAgBUEQaiIAKAIAIgMNAEEAIQEMAQsDQCAAIQQgAyIBQRRqIgAoAgAiAw0AIAFBEGohACABKAIQIgMNAAsgBEEANgIACyAIRQ0AAkAgBSAFKAIcIgNBAnRBuApqIgAoAgBGBEAgACABNgIAIAENAUGMCEGMCCgCAEF+IAN3cTYCAAwCCyAIQRBBFCAIKAIQIAVGG2ogATYCACABRQ0BCyABIAg2AhggBSgCECIABEAgASAANgIQIAAgATYCGAsgBSgCFCIARQ0AIAEgADYCFCAAIAE2AhgLIAUgB2ohBSACIAdqIQILIAUgBSgCBEF+cTYCBCAGIAJBAXI2AgQgAiAGaiACNgIAIAJB/wFNBEAgAkEDdiIAQQN0QbAIaiECAn9BiAgoAgAiAUEBIAB0IgBxRQRAQYgIIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgBjYCCCAAIAY2AgwgBiACNgIMIAYgADYCCAwDC0EfIQAgAkH///8HTQRAIAJBCHYiACAAQYD+P2pBEHZBCHEiA3QiACAAQYDgH2pBEHZBBHEiAXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgASADciAAcmsiAEEBdCACIABBFWp2QQFxckEcaiEACyAGIAA2AhwgBkIANwIQIABBAnRBuApqIQQCQEGMCCgCACIDQQEgAHQiAXFFBEBBjAggASADcjYCACAEIAY2AgAgBiAENgIYDAELIAJBAEEZIABBAXZrIABBH0YbdCEAIAQoAgAhAQNAIAEiAygCBEF4cSACRg0DIABBHXYhASAAQQF0IQAgAyABQQRxaiIEKAIQIgENAAsgBCAGNgIQIAYgAzYCGAsgBiAGNgIMIAYgBjYCCAwCC0GUCCAFQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBBoAggACABaiIANgIAIAAgAkEBcjYCBCABIANqQSg2AgRBpAhB8AsoAgA2AgAgByAEQScgBGtBB3FBACAEQSdrQQdxG2pBL2siACAAIAdBEGpJGyICQRs2AgQgAkHQCykCADcCECACQcgLKQIANwIIQdALIAJBCGo2AgBBzAsgBTYCAEHICyABNgIAQdQLQQA2AgAgAkEYaiEAA0AgAEEHNgIEIABBCGohASAAQQRqIQAgASAESQ0ACyACIAdGDQMgAiACKAIEQX5xNgIEIAcgAiAHayIEQQFyNgIEIAIgBDYCACAEQf8BTQRAIARBA3YiAEEDdEGwCGohAgJ/QYgIKAIAIgFBASAAdCIAcUUEQEGICCAAIAFyNgIAIAIMAQsgAigCCAshACACIAc2AgggACAHNgIMIAcgAjYCDCAHIAA2AggMBAtBHyEAIAdCADcCECAEQf///wdNBEAgBEEIdiIAIABBgP4/akEQdkEIcSICdCIAIABBgOAfakEQdkEEcSIBdCIAIABBgIAPakEQdkECcSIAdEEPdiABIAJyIAByayIAQQF0IAQgAEEVanZBAXFyQRxqIQALIAcgADYCHCAAQQJ0QbgKaiEDAkBBjAgoAgAiAkEBIAB0IgFxRQRAQYwIIAEgAnI2AgAgAyAHNgIAIAcgAzYCGAwBCyAEQQBBGSAAQQF2ayAAQR9GG3QhACADKAIAIQEDQCABIgIoAgRBeHEgBEYNBCAAQR12IQEgAEEBdCEAIAIgAUEEcWoiAygCECIBDQALIAMgBzYCECAHIAI2AhgLIAcgBzYCDCAHIAc2AggMAwsgAygCCCIAIAY2AgwgAyAGNgIIIAZBADYCGCAGIAM2AgwgBiAANgIICyAJQQhqIQAMBQsgAigCCCIAIAc2AgwgAiAHNgIIIAdBADYCGCAHIAI2AgwgByAANgIIC0GUCCgCACIAIAhNDQBBlAggACAIayIBNgIAQaAIQaAIKAIAIgIgCGoiADYCACAAIAFBAXI2AgQgAiAIQQNyNgIEIAJBCGohAAwDC0GECEEwNgIAQQAhAAwCCwJAIAVFDQACQCAEKAIcIgJBAnRBuApqIgAoAgAgBEYEQCAAIAE2AgAgAQ0BQYwIIAlBfiACd3EiCTYCAAwCCyAFQRBBFCAFKAIQIARGG2ogATYCACABRQ0BCyABIAU2AhggBCgCECIABEAgASAANgIQIAAgATYCGAsgBCgCFCIARQ0AIAEgADYCFCAAIAE2AhgLAkAgA0EPTQRAIAQgAyAIaiIAQQNyNgIEIAAgBGoiACAAKAIEQQFyNgIEDAELIAQgCEEDcjYCBCAGIANBAXI2AgQgAyAGaiADNgIAIANB/wFNBEAgA0EDdiIAQQN0QbAIaiECAn9BiAgoAgAiAUEBIAB0IgBxRQRAQYgIIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgBjYCCCAAIAY2AgwgBiACNgIMIAYgADYCCAwBC0EfIQAgA0H///8HTQRAIANBCHYiACAAQYD+P2pBEHZBCHEiAnQiACAAQYDgH2pBEHZBBHEiAXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgASACciAAcmsiAEEBdCADIABBFWp2QQFxckEcaiEACyAGIAA2AhwgBkIANwIQIABBAnRBuApqIQICQAJAIAlBASAAdCIBcUUEQEGMCCABIAlyNgIAIAIgBjYCACAGIAI2AhgMAQsgA0EAQRkgAEEBdmsgAEEfRht0IQAgAigCACEIA0AgCCIBKAIEQXhxIANGDQIgAEEddiECIABBAXQhACABIAJBBHFqIgIoAhAiCA0ACyACIAY2AhAgBiABNgIYCyAGIAY2AgwgBiAGNgIIDAELIAEoAggiACAGNgIMIAEgBjYCCCAGQQA2AhggBiABNgIMIAYgADYCCAsgBEEIaiEADAELAkAgC0UNAAJAIAEoAhwiAkECdEG4CmoiACgCACABRgRAIAAgBDYCACAEDQFBjAggBkF+IAJ3cTYCAAwCCyALQRBBFCALKAIQIAFGG2ogBDYCACAERQ0BCyAEIAs2AhggASgCECIABEAgBCAANgIQIAAgBDYCGAsgASgCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAEgAyAIaiIAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIEDAELIAEgCEEDcjYCBCAJIANBAXI2AgQgAyAJaiADNgIAIAoEQCAKQQN2IgBBA3RBsAhqIQRBnAgoAgAhAgJ/QQEgAHQiACAFcUUEQEGICCAAIAVyNgIAIAQMAQsgBCgCCAshACAEIAI2AgggACACNgIMIAIgBDYCDCACIAA2AggLQZwIIAk2AgBBkAggAzYCAAsgAUEIaiEACyAMQRBqJAAgAAsQACMAIABrQXBxIgAkACAACwYAIAAkAAsEACMAC4AJAgh/BH4jAEGQAWsiBiQAIAYgBS0AA0EYdEGAgIAYcSAFLwAAIAUtAAJBEHRycjYCACAGIAUoAANBAnZBg/7/H3E2AgQgBiAFKAAGQQR2Qf+B/x9xNgIIIAYgBSgACUEGdkH//8AfcTYCDCAFLwANIQggBS0ADyEJIAZCADcCFCAGQgA3AhwgBkEANgIkIAYgCCAJQRB0QYCAPHFyNgIQIAYgBSgAEDYCKCAGIAUoABQ2AiwgBiAFKAAYNgIwIAUoABwhBSAGQQA6AEwgBkEANgI4IAYgBTYCNCAGIAEgAhAEIAQEQCAGIAMgBBAECyAGKAI4IgEEQCAGQTxqIgIgAWpBAToAACABQQFqQQ9NBEAgASAGakE9aiEEAkBBDyABayIDRQ0AIAMgBGoiAUEBa0EAOgAAIARBADoAACADQQNJDQAgAUECa0EAOgAAIARBADoAASABQQNrQQA6AAAgBEEAOgACIANBB0kNACABQQRrQQA6AAAgBEEAOgADIANBCUkNACAEQQAgBGtBA3EiAWoiBEEANgIAIAQgAyABa0F8cSIBaiIDQQRrQQA2AgAgAUEJSQ0AIARBADYCCCAEQQA2AgQgA0EIa0EANgIAIANBDGtBADYCACABQRlJDQAgBEEANgIYIARBADYCFCAEQQA2AhAgBEEANgIMIANBEGtBADYCACADQRRrQQA2AgAgA0EYa0EANgIAIANBHGtBADYCACABIARBBHFBGHIiAWsiA0EgSQ0AIAEgBGohAQNAIAFCADcDGCABQgA3AxAgAUIANwMIIAFCADcDACABQSBqIQEgA0EgayIDQR9LDQALCwsgBkEBOgBMIAYgAkEQEAILIAY1AjQhECAGNQIwIREgBjUCLCEOIAAgBjUCKCAGKAIkIAYoAiAgBigCHCAGKAIYIgNBGnZqIgJBGnZqIgFBGnZqIgtBgICAYHIgAUH///8fcSINIAJB////H3EiCCAGKAIUIAtBGnZBBWxqIgFB////H3EiCUEFaiIFQRp2IANB////H3EgAUEadmoiA2oiAUEadmoiAkEadmoiBEEadmoiDEEfdSIHIANxIAEgDEEfdkEBayIDQf///x9xIgpxciIBQRp0IAUgCnEgByAJcXJyrXwiDzwAACAAIA9CGIg8AAMgACAPQhCIPAACIAAgD0IIiDwAASAAIA4gByAIcSACIApxciICQRR0IAFBBnZyrXwgD0IgiHwiDjwABCAAIA5CGIg8AAcgACAOQhCIPAAGIAAgDkIIiDwABSAAIBEgByANcSAEIApxciIBQQ50IAJBDHZyrXwgDkIgiHwiDjwACCAAIA5CGIg8AAsgACAOQhCIPAAKIAAgDkIIiDwACSAAIBAgAyAMcSAHIAtxckEIdCABQRJ2cq18IA5CIIh8Ig48AAwgACAOQhiIPAAPIAAgDkIQiDwADiAAIA5CCIg8AA0gBkIANwIwIAZCADcCKCAGQgA3AiAgBkIANwIYIAZCADcCECAGQgA3AgggBkIANwIAIAZBkAFqJAALpwwBB38CQCAARQ0AIABBCGsiAyAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAMgAygCACIBayIDQZgIKAIASQ0BIAAgAWohACADQZwIKAIARwRAIAFB/wFNBEAgAygCCCICIAFBA3YiBEEDdEGwCGpGGiACIAMoAgwiAUYEQEGICEGICCgCAEF+IAR3cTYCAAwDCyACIAE2AgwgASACNgIIDAILIAMoAhghBgJAIAMgAygCDCIBRwRAIAMoAggiAiABNgIMIAEgAjYCCAwBCwJAIANBFGoiAigCACIEDQAgA0EQaiICKAIAIgQNAEEAIQEMAQsDQCACIQcgBCIBQRRqIgIoAgAiBA0AIAFBEGohAiABKAIQIgQNAAsgB0EANgIACyAGRQ0BAkAgAyADKAIcIgJBAnRBuApqIgQoAgBGBEAgBCABNgIAIAENAUGMCEGMCCgCAEF+IAJ3cTYCAAwDCyAGQRBBFCAGKAIQIANGG2ogATYCACABRQ0CCyABIAY2AhggAygCECICBEAgASACNgIQIAIgATYCGAsgAygCFCICRQ0BIAEgAjYCFCACIAE2AhgMAQsgBSgCBCIBQQNxQQNHDQBBkAggADYCACAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAA8LIAMgBU8NACAFKAIEIgFBAXFFDQACQCABQQJxRQRAIAVBoAgoAgBGBEBBoAggAzYCAEGUCEGUCCgCACAAaiIANgIAIAMgAEEBcjYCBCADQZwIKAIARw0DQZAIQQA2AgBBnAhBADYCAA8LIAVBnAgoAgBGBEBBnAggAzYCAEGQCEGQCCgCACAAaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgAPCyABQXhxIABqIQACQCABQf8BTQRAIAUoAggiAiABQQN2IgRBA3RBsAhqRhogAiAFKAIMIgFGBEBBiAhBiAgoAgBBfiAEd3E2AgAMAgsgAiABNgIMIAEgAjYCCAwBCyAFKAIYIQYCQCAFIAUoAgwiAUcEQCAFKAIIIgJBmAgoAgBJGiACIAE2AgwgASACNgIIDAELAkAgBUEUaiICKAIAIgQNACAFQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQACQCAFIAUoAhwiAkECdEG4CmoiBCgCAEYEQCAEIAE2AgAgAQ0BQYwIQYwIKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiABNgIAIAFFDQELIAEgBjYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQZwIKAIARw0BQZAIIAA2AgAPCyAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAAsgAEH/AU0EQCAAQQN2IgFBA3RBsAhqIQACf0GICCgCACICQQEgAXQiAXFFBEBBiAggASACcjYCACAADAELIAAoAggLIQIgACADNgIIIAIgAzYCDCADIAA2AgwgAyACNgIIDwtBHyECIANCADcCECAAQf///wdNBEAgAEEIdiIBIAFBgP4/akEQdkEIcSIBdCICIAJBgOAfakEQdkEEcSICdCIEIARBgIAPakEQdkECcSIEdEEPdiABIAJyIARyayIBQQF0IAAgAUEVanZBAXFyQRxqIQILIAMgAjYCHCACQQJ0QbgKaiEBAkACQAJAQYwIKAIAIgRBASACdCIHcUUEQEGMCCAEIAdyNgIAIAEgAzYCACADIAE2AhgMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgASgCACEBA0AgASIEKAIEQXhxIABGDQIgAkEddiEBIAJBAXQhAiAEIAFBBHFqIgdBEGooAgAiAQ0ACyAHIAM2AhAgAyAENgIYCyADIAM2AgwgAyADNgIIDAELIAQoAggiACADNgIMIAQgAzYCCCADQQA2AhggAyAENgIMIAMgADYCCAtBqAhBqAgoAgBBAWsiAEF/IAAbNgIACwsLCQEAQYEICwIGUA=="),
                !x.startsWith(F))
              ) {
                var T = x;
                x = a.locateFile ? a.locateFile(T, p) : p + T;
              }
              function V() {
                var te = x;
                try {
                  if (te == x && E) return new Uint8Array(E);
                  var ie = re(te);
                  if (ie) return ie;
                  if (g) return g(te);
                  throw "both async and sync fetching of the wasm failed";
                } catch (X) {
                  W(X);
                }
              }
              function B() {
                if (!E && (f || u)) {
                  if (typeof fetch == "function" && !x.startsWith("file://"))
                    return fetch(x, { credentials: "same-origin" })
                      .then(function (te) {
                        if (!te.ok)
                          throw (
                            "failed to load wasm binary file at '" + x + "'"
                          );
                        return te.arrayBuffer();
                      })
                      .catch(function () {
                        return V();
                      });
                  if (m)
                    return new Promise(function (te, ie) {
                      m(
                        x,
                        function (X) {
                          te(new Uint8Array(X));
                        },
                        ie,
                      );
                    });
                }
                return Promise.resolve().then(function () {
                  return V();
                });
              }
              function N(te) {
                for (; 0 < te.length; ) {
                  var ie = te.shift();
                  if (typeof ie == "function") ie(a);
                  else {
                    var X = ie.m;
                    typeof X == "number"
                      ? ie.l === void 0
                        ? J.get(X)()
                        : J.get(X)(ie.l)
                      : X(ie.l === void 0 ? null : ie.l);
                  }
                }
              }
              var ce =
                typeof atob == "function"
                  ? atob
                  : function (te) {
                      var ie = "",
                        X = 0;
                      te = te.replace(/[^A-Za-z0-9\+\/=]/g, "");
                      do {
                        var he =
                            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(
                              te.charAt(X++),
                            ),
                          be =
                            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(
                              te.charAt(X++),
                            ),
                          ye =
                            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(
                              te.charAt(X++),
                            ),
                          Qe =
                            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(
                              te.charAt(X++),
                            );
                        (he = (he << 2) | (be >> 4)),
                          (be = ((be & 15) << 4) | (ye >> 2));
                        var lt = ((ye & 3) << 6) | Qe;
                        (ie += String.fromCharCode(he)),
                          ye !== 64 && (ie += String.fromCharCode(be)),
                          Qe !== 64 && (ie += String.fromCharCode(lt));
                      } while (X < te.length);
                      return ie;
                    };
              function re(te) {
                if (te.startsWith(F)) {
                  if (((te = te.slice(F.length)), typeof d == "boolean" && d)) {
                    var ie = Buffer.from(te, "base64");
                    ie = new Uint8Array(
                      ie.buffer,
                      ie.byteOffset,
                      ie.byteLength,
                    );
                  } else
                    try {
                      var X = ce(te),
                        he = new Uint8Array(X.length);
                      for (te = 0; te < X.length; ++te)
                        he[te] = X.charCodeAt(te);
                      ie = he;
                    } catch {
                      throw Error("Converting base64 string to bytes failed.");
                    }
                  return ie;
                }
              }
              var ne = {
                a: function (te) {
                  var ie = H.length;
                  if (((te >>>= 0), 2147483648 < te)) return !1;
                  for (var X = 1; 4 >= X; X *= 2) {
                    var he = ie * (1 + 0.2 / X);
                    (he = Math.min(he, te + 100663296)),
                      (he = Math.max(te, he)),
                      0 < he % 65536 && (he += 65536 - (he % 65536));
                    e: {
                      try {
                        R.grow(
                          (Math.min(2147483648, he) - Q.byteLength + 65535) >>>
                            16,
                        ),
                          q();
                        var be = 1;
                        break e;
                      } catch {}
                      be = void 0;
                    }
                    if (be) return !0;
                  }
                  return !1;
                },
              };
              (function () {
                function te(be) {
                  (a.asm = be.exports),
                    (R = a.asm.b),
                    q(),
                    (J = a.asm.j),
                    z.unshift(a.asm.c),
                    L--,
                    a.monitorRunDependencies && a.monitorRunDependencies(L),
                    L == 0 && k && ((be = k), (k = null), be());
                }
                function ie(be) {
                  te(be.instance);
                }
                function X(be) {
                  return B()
                    .then(function (ye) {
                      return WebAssembly.instantiate(ye, he);
                    })
                    .then(be, function (ye) {
                      _("failed to asynchronously prepare wasm: " + ye), W(ye);
                    });
                }
                var he = { a: ne };
                if (
                  (L++,
                  a.monitorRunDependencies && a.monitorRunDependencies(L),
                  a.instantiateWasm)
                )
                  try {
                    return a.instantiateWasm(he, te);
                  } catch (be) {
                    return (
                      _(
                        "Module.instantiateWasm callback failed with error: " +
                          be,
                      ),
                      !1
                    );
                  }
                return (
                  (function () {
                    return E ||
                      typeof WebAssembly.instantiateStreaming != "function" ||
                      x.startsWith(F) ||
                      x.startsWith("file://") ||
                      typeof fetch != "function"
                      ? X(ie)
                      : fetch(x, { credentials: "same-origin" }).then(
                          function (be) {
                            return WebAssembly.instantiateStreaming(
                              be,
                              he,
                            ).then(ie, function (ye) {
                              return (
                                _("wasm streaming compile failed: " + ye),
                                _("falling back to ArrayBuffer instantiation"),
                                X(ie)
                              );
                            });
                          },
                        );
                  })().catch(o),
                  {}
                );
              })(),
                (a.___wasm_call_ctors = function () {
                  return (a.___wasm_call_ctors = a.asm.c).apply(
                    null,
                    arguments,
                  );
                }),
                (a._poly1305_auth = function () {
                  return (a._poly1305_auth = a.asm.d).apply(null, arguments);
                });
              var Y = (a.stackSave = function () {
                  return (Y = a.stackSave = a.asm.e).apply(null, arguments);
                }),
                M = (a.stackRestore = function () {
                  return (M = a.stackRestore = a.asm.f).apply(null, arguments);
                }),
                oe = (a.stackAlloc = function () {
                  return (oe = a.stackAlloc = a.asm.g).apply(null, arguments);
                });
              (a._malloc = function () {
                return (a._malloc = a.asm.h).apply(null, arguments);
              }),
                (a._free = function () {
                  return (a._free = a.asm.i).apply(null, arguments);
                }),
                (a.cwrap = function (te, ie, X, he) {
                  X = X || [];
                  var be = X.every(function (ye) {
                    return ye === "number";
                  });
                  return ie !== "string" && be && !he
                    ? S(te)
                    : function () {
                        return w(te, ie, X, arguments);
                      };
                });
              var Ee;
              k = function te() {
                Ee || le(), Ee || (k = te);
              };
              function le() {
                function te() {
                  if (!Ee && ((Ee = !0), (a.calledRun = !0), !A)) {
                    if (
                      (N(z),
                      s(a),
                      a.onRuntimeInitialized && a.onRuntimeInitialized(),
                      a.postRun)
                    )
                      for (
                        typeof a.postRun == "function" &&
                        (a.postRun = [a.postRun]);
                        a.postRun.length;

                      ) {
                        var ie = a.postRun.shift();
                        U.unshift(ie);
                      }
                    N(U);
                  }
                }
                if (!(0 < L)) {
                  if (a.preRun)
                    for (
                      typeof a.preRun == "function" && (a.preRun = [a.preRun]);
                      a.preRun.length;

                    )
                      G();
                  N(Z),
                    0 < L ||
                      (a.setStatus
                        ? (a.setStatus("Running..."),
                          setTimeout(function () {
                            setTimeout(function () {
                              a.setStatus("");
                            }, 1),
                              te();
                          }, 1))
                        : te());
                }
              }
              if (((a.run = le), a.preInit))
                for (
                  typeof a.preInit == "function" && (a.preInit = [a.preInit]);
                  0 < a.preInit.length;

                )
                  a.preInit.pop()();
              return le(), i.ready;
            }
          );
        })();
        e.exports = n;
      })(Vm)),
    Vm.exports
  );
}
var Ym, LA;
function eo() {
  if (LA) return Ym;
  LA = 1;
  const {
      createCipheriv: e,
      createDecipheriv: t,
      createHmac: n,
      randomFillSync: r,
      timingSafeEqual: i,
    } = pr,
    { readUInt32BE: a, writeUInt32BE: s } = Ki(),
    o = Buffer[Symbol.species],
    c = 2 ** 32 - 1,
    l = Buffer.alloc(0),
    f = Buffer.alloc(4),
    u = new Map(),
    d = 35e3;
  let p, h, m, g, v, y, _;
  try {
    (p = require("./crypto/build/Release/sshcrypto.node")),
      ({
        AESGCMCipher: h,
        ChaChaPolyCipher: m,
        GenericCipher: g,
        AESGCMDecipher: v,
        ChaChaPolyDecipher: y,
        GenericDecipher: _,
      } = p);
  } catch {}
  const E = 1,
    R = (() => {
      function ne(Y, M, oe, Ee, le, te, ie) {
        return {
          sslName: Y,
          blockLen: M,
          keyLen: oe,
          ivLen: Ee !== 0 || ie & E ? Ee : M,
          authLen: le,
          discardLen: te,
          stream: !!(ie & E),
        };
      }
      return {
        "chacha20-poly1305@openssh.com": ne("chacha20", 8, 64, 0, 16, 0, E),
        "aes128-gcm": ne("aes-128-gcm", 16, 16, 12, 16, 0, E),
        "aes256-gcm": ne("aes-256-gcm", 16, 32, 12, 16, 0, E),
        "aes128-gcm@openssh.com": ne("aes-128-gcm", 16, 16, 12, 16, 0, E),
        "aes256-gcm@openssh.com": ne("aes-256-gcm", 16, 32, 12, 16, 0, E),
        "aes128-cbc": ne("aes-128-cbc", 16, 16, 0, 0, 0, 0),
        "aes192-cbc": ne("aes-192-cbc", 16, 24, 0, 0, 0, 0),
        "aes256-cbc": ne("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "rijndael-cbc@lysator.liu.se": ne("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "3des-cbc": ne("des-ede3-cbc", 8, 24, 0, 0, 0, 0),
        "blowfish-cbc": ne("bf-cbc", 8, 16, 0, 0, 0, 0),
        "idea-cbc": ne("idea-cbc", 8, 16, 0, 0, 0, 0),
        "cast128-cbc": ne("cast-cbc", 8, 16, 0, 0, 0, 0),
        "aes128-ctr": ne("aes-128-ctr", 16, 16, 16, 0, 0, E),
        "aes192-ctr": ne("aes-192-ctr", 16, 24, 16, 0, 0, E),
        "aes256-ctr": ne("aes-256-ctr", 16, 32, 16, 0, 0, E),
        "3des-ctr": ne("des-ede3", 8, 24, 8, 0, 0, E),
        "blowfish-ctr": ne("bf-ecb", 8, 16, 8, 0, 0, E),
        "cast128-ctr": ne("cast5-ecb", 8, 16, 8, 0, 0, E),
        arcfour: ne("rc4", 8, 16, 0, 0, 1536, E),
        arcfour128: ne("rc4", 8, 16, 0, 0, 1536, E),
        arcfour256: ne("rc4", 8, 32, 0, 0, 1536, E),
        arcfour512: ne("rc4", 8, 64, 0, 0, 1536, E),
      };
    })(),
    A = (() => {
      function ne(Y, M, oe, Ee) {
        return { sslName: Y, len: M, actualLen: oe, isETM: Ee };
      }
      return {
        "hmac-md5": ne("md5", 16, 16, !1),
        "hmac-md5-96": ne("md5", 16, 12, !1),
        "hmac-ripemd160": ne("ripemd160", 20, 20, !1),
        "hmac-sha1": ne("sha1", 20, 20, !1),
        "hmac-sha1-etm@openssh.com": ne("sha1", 20, 20, !0),
        "hmac-sha1-96": ne("sha1", 20, 12, !1),
        "hmac-sha2-256": ne("sha256", 32, 32, !1),
        "hmac-sha2-256-etm@openssh.com": ne("sha256", 32, 32, !0),
        "hmac-sha2-256-96": ne("sha256", 32, 12, !1),
        "hmac-sha2-512": ne("sha512", 64, 64, !1),
        "hmac-sha2-512-etm@openssh.com": ne("sha512", 64, 64, !0),
        "hmac-sha2-512-96": ne("sha512", 64, 12, !1),
      };
    })();
  class I {
    constructor(Y, M) {
      (this.outSeqno = Y), (this._onWrite = M), (this._dead = !1);
    }
    free() {
      this._dead = !0;
    }
    allocPacket(Y) {
      let M = 5 + Y,
        oe = 8 - (M & (8 - 1));
      oe < 4 && (oe += 8), (M += oe);
      const Ee = Buffer.allocUnsafe(M);
      return s(Ee, M - 4, 0), (Ee[4] = oe), r(Ee, 5 + Y, oe), Ee;
    }
    encrypt(Y) {
      this._dead ||
        (this._onWrite(Y), (this.outSeqno = (this.outSeqno + 1) >>> 0));
    }
  }
  const S = Buffer.alloc(32),
    w = Buffer.alloc(16);
  let O, Q, j;
  class H {
    constructor(Y) {
      const M = Y.outbound;
      (this.outSeqno = M.seqno),
        (this._onWrite = M.onWrite),
        (this._encKeyMain = M.cipherKey.slice(0, 32)),
        (this._encKeyPktLen = M.cipherKey.slice(32)),
        (this._dead = !1);
    }
    free() {
      this._dead = !0;
    }
    allocPacket(Y) {
      let M = 5 + Y,
        oe = 8 - ((M - 4) & (8 - 1));
      oe < 4 && (oe += 8), (M += oe);
      const Ee = Buffer.allocUnsafe(M);
      return s(Ee, M - 4, 0), (Ee[4] = oe), r(Ee, 5 + Y, oe), Ee;
    }
    encrypt(Y) {
      if (this._dead) return;
      (w[0] = 0), s(w, this.outSeqno, 12);
      const M = e("chacha20", this._encKeyMain, w).update(S),
        oe = e("chacha20", this._encKeyPktLen, w).update(Y.slice(0, 4));
      this._onWrite(oe), (w[0] = 1);
      const Ee = e("chacha20", this._encKeyMain, w).update(Y.slice(4));
      this._onWrite(Ee), j(Q, oe, oe.length, Ee, Ee.length, M);
      const le = Buffer.allocUnsafe(16);
      le.set(new Uint8Array(O.HEAPU8.buffer, Q, 16), 0),
        this._onWrite(le),
        (this.outSeqno = (this.outSeqno + 1) >>> 0);
    }
  }
  class q {
    constructor(Y) {
      const M = Y.outbound;
      (this.outSeqno = M.seqno),
        (this._onWrite = M.onWrite),
        (this._instance = new m(M.cipherKey)),
        (this._dead = !1);
    }
    free() {
      (this._dead = !0), this._instance.free();
    }
    allocPacket(Y) {
      let M = 5 + Y,
        oe = 8 - ((M - 4) & (8 - 1));
      oe < 4 && (oe += 8), (M += oe);
      const Ee = Buffer.allocUnsafe(M + 16);
      return s(Ee, M - 4, 0), (Ee[4] = oe), r(Ee, 5 + Y, oe), Ee;
    }
    encrypt(Y) {
      this._dead ||
        (this._instance.encrypt(Y, this.outSeqno),
        this._onWrite(Y),
        (this.outSeqno = (this.outSeqno + 1) >>> 0));
    }
  }
  class J {
    constructor(Y) {
      const M = Y.outbound;
      (this.outSeqno = M.seqno),
        (this._onWrite = M.onWrite),
        (this._encSSLName = M.cipherInfo.sslName),
        (this._encKey = M.cipherKey),
        (this._encIV = M.cipherIV),
        (this._dead = !1);
    }
    free() {
      this._dead = !0;
    }
    allocPacket(Y) {
      let M = 5 + Y,
        oe = 16 - ((M - 4) & (16 - 1));
      oe < 4 && (oe += 16), (M += oe);
      const Ee = Buffer.allocUnsafe(M);
      return s(Ee, M - 4, 0), (Ee[4] = oe), r(Ee, 5 + Y, oe), Ee;
    }
    encrypt(Y) {
      if (this._dead) return;
      const M = e(this._encSSLName, this._encKey, this._encIV);
      M.setAutoPadding(!1);
      const oe = Y.slice(0, 4);
      M.setAAD(oe), this._onWrite(oe);
      const Ee = M.update(Y.slice(4));
      this._onWrite(Ee);
      const le = M.final();
      le.length && this._onWrite(le);
      const te = M.getAuthTag();
      this._onWrite(te),
        V(this._encIV),
        (this.outSeqno = (this.outSeqno + 1) >>> 0);
    }
  }
  class Z {
    constructor(Y) {
      const M = Y.outbound;
      (this.outSeqno = M.seqno),
        (this._onWrite = M.onWrite),
        (this._instance = new h(M.cipherInfo.sslName, M.cipherKey, M.cipherIV)),
        (this._dead = !1);
    }
    free() {
      (this._dead = !0), this._instance.free();
    }
    allocPacket(Y) {
      let M = 5 + Y,
        oe = 16 - ((M - 4) & (16 - 1));
      oe < 4 && (oe += 16), (M += oe);
      const Ee = Buffer.allocUnsafe(M + 16);
      return s(Ee, M - 4, 0), (Ee[4] = oe), r(Ee, 5 + Y, oe), Ee;
    }
    encrypt(Y) {
      this._dead ||
        (this._instance.encrypt(Y),
        this._onWrite(Y),
        (this.outSeqno = (this.outSeqno + 1) >>> 0));
    }
  }
  class z {
    constructor(Y) {
      const M = Y.outbound;
      (this.outSeqno = M.seqno),
        (this._onWrite = M.onWrite),
        (this._encBlockLen = M.cipherInfo.blockLen),
        (this._cipherInstance = e(
          M.cipherInfo.sslName,
          M.cipherKey,
          M.cipherIV,
        )),
        (this._macSSLName = M.macInfo.sslName),
        (this._macKey = M.macKey),
        (this._macActualLen = M.macInfo.actualLen),
        (this._macETM = M.macInfo.isETM),
        (this._aadLen = this._macETM ? 4 : 0),
        (this._dead = !1);
      const oe = M.cipherInfo.discardLen;
      if (oe) {
        let Ee = u.get(oe);
        Ee === void 0 && ((Ee = Buffer.alloc(oe)), u.set(oe, Ee)),
          this._cipherInstance.update(Ee);
      }
    }
    free() {
      this._dead = !0;
    }
    allocPacket(Y) {
      const M = this._encBlockLen;
      let oe = 4 + 1 + Y,
        Ee = M - ((oe - this._aadLen) & (M - 1));
      Ee < 4 && (Ee += M), (oe += Ee);
      const le = Buffer.allocUnsafe(oe);
      return s(le, oe - 4, 0), (le[4] = Ee), r(le, 5 + Y, Ee), le;
    }
    encrypt(Y) {
      if (this._dead) return;
      let M;
      if (this._macETM) {
        const Ee = new Uint8Array(Y.buffer, Y.byteOffset, 4),
          le = this._cipherInstance.update(
            new Uint8Array(Y.buffer, Y.byteOffset + 4, Y.length - 4),
          );
        this._onWrite(Ee),
          this._onWrite(le),
          (M = n(this._macSSLName, this._macKey)),
          s(f, this.outSeqno, 0),
          M.update(f),
          M.update(Ee),
          M.update(le);
      } else {
        const Ee = this._cipherInstance.update(Y);
        this._onWrite(Ee),
          (M = n(this._macSSLName, this._macKey)),
          s(f, this.outSeqno, 0),
          M.update(f),
          M.update(Y);
      }
      let oe = M.digest();
      oe.length > this._macActualLen && (oe = oe.slice(0, this._macActualLen)),
        this._onWrite(oe),
        (this.outSeqno = (this.outSeqno + 1) >>> 0);
    }
  }
  class U {
    constructor(Y) {
      const M = Y.outbound;
      (this.outSeqno = M.seqno),
        (this._onWrite = M.onWrite),
        (this._encBlockLen = M.cipherInfo.blockLen),
        (this._macLen = M.macInfo.len),
        (this._macActualLen = M.macInfo.actualLen),
        (this._aadLen = M.macInfo.isETM ? 4 : 0),
        (this._instance = new g(
          M.cipherInfo.sslName,
          M.cipherKey,
          M.cipherIV,
          M.macInfo.sslName,
          M.macKey,
          M.macInfo.isETM,
        )),
        (this._dead = !1);
    }
    free() {
      (this._dead = !0), this._instance.free();
    }
    allocPacket(Y) {
      const M = this._encBlockLen;
      let oe = 4 + 1 + Y,
        Ee = M - ((oe - this._aadLen) & (M - 1));
      Ee < 4 && (Ee += M), (oe += Ee);
      const le = Buffer.allocUnsafe(oe + this._macLen);
      return s(le, oe - 4, 0), (le[4] = Ee), r(le, 5 + Y, Ee), le;
    }
    encrypt(Y) {
      this._dead ||
        (this._instance.encrypt(Y, this.outSeqno),
        this._macActualLen < this._macLen &&
          (Y = new o(
            Y.buffer,
            Y.byteOffset,
            Y.length - (this._macLen - this._macActualLen),
          )),
        this._onWrite(Y),
        (this.outSeqno = (this.outSeqno + 1) >>> 0));
    }
  }
  class G {
    constructor(Y, M) {
      (this.inSeqno = Y),
        (this._onPayload = M),
        (this._len = 0),
        (this._lenBytes = 0),
        (this._packet = null),
        (this._packetPos = 0);
    }
    free() {}
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._lenBytes < 4) {
          let le = Math.min(4 - this._lenBytes, oe - M);
          for (this._lenBytes += le; le--; )
            this._len = (this._len << 8) + Y[M++];
          if (this._lenBytes < 4) return;
          if (this._len > d || this._len < 8 || (4 + this._len) & 7)
            throw new Error("Bad packet length");
          if (M >= oe) return;
        }
        if (this._packetPos < this._len) {
          const le = Math.min(this._len - this._packetPos, oe - M);
          let te;
          if (
            (M !== 0 || le !== oe
              ? (te = new Uint8Array(Y.buffer, Y.byteOffset + M, le))
              : (te = Y),
            le === this._len
              ? (this._packet = te)
              : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(te, this._packetPos)),
            (M += le),
            (this._packetPos += le),
            this._packetPos < this._len)
          )
            return;
        }
        const Ee = this._packet
          ? new o(
              this._packet.buffer,
              this._packet.byteOffset + 1,
              this._packet.length - this._packet[0] - 1,
            )
          : l;
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          (this._len = 0),
          (this._lenBytes = 0),
          (this._packet = null),
          (this._packetPos = 0);
        {
          const le = this._onPayload(Ee);
          if (le !== void 0) return le === !1 ? M : le;
        }
      }
    }
  }
  class L {
    constructor(Y) {
      const M = Y.inbound;
      (this.inSeqno = M.seqno),
        (this._onPayload = M.onPayload),
        (this._decKeyMain = M.decipherKey.slice(0, 32)),
        (this._decKeyPktLen = M.decipherKey.slice(32)),
        (this._len = 0),
        (this._lenBuf = Buffer.alloc(4)),
        (this._lenPos = 0),
        (this._packet = null),
        (this._pktLen = 0),
        (this._mac = Buffer.allocUnsafe(16)),
        (this._calcMac = Buffer.allocUnsafe(16)),
        (this._macPos = 0);
    }
    free() {}
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._lenPos < 4) {
          let ie = Math.min(4 - this._lenPos, oe - M);
          for (; ie--; ) this._lenBuf[this._lenPos++] = Y[M++];
          if (this._lenPos < 4) return;
          (w[0] = 0), s(w, this.inSeqno, 12);
          const X = t("chacha20", this._decKeyPktLen, w).update(this._lenBuf);
          if (
            ((this._len = a(X, 0)),
            this._len > d || this._len < 8 || this._len & 7)
          )
            throw new Error("Bad packet length");
        }
        if (this._pktLen < this._len) {
          if (M >= oe) return;
          const ie = Math.min(this._len - this._pktLen, oe - M);
          let X;
          if (
            (M !== 0 || ie !== oe
              ? (X = new Uint8Array(Y.buffer, Y.byteOffset + M, ie))
              : (X = Y),
            ie === this._len
              ? (this._packet = X)
              : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(X, this._pktLen)),
            (M += ie),
            (this._pktLen += ie),
            this._pktLen < this._len || M >= oe)
          )
            return;
        }
        {
          const ie = Math.min(16 - this._macPos, oe - M);
          if (
            (M !== 0 || ie !== oe
              ? this._mac.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, ie),
                  this._macPos,
                )
              : this._mac.set(Y, this._macPos),
            (M += ie),
            (this._macPos += ie),
            this._macPos < 16)
          )
            return;
        }
        (w[0] = 0), s(w, this.inSeqno, 12);
        const Ee = e("chacha20", this._decKeyMain, w).update(S);
        if (
          (j(Q, this._lenBuf, 4, this._packet, this._packet.length, Ee),
          this._calcMac.set(new Uint8Array(O.HEAPU8.buffer, Q, 16), 0),
          !i(this._calcMac, this._mac))
        )
          throw new Error("Invalid MAC");
        w[0] = 1;
        const le = t("chacha20", this._decKeyMain, w).update(this._packet),
          te = new o(le.buffer, le.byteOffset + 1, le.length - le[0] - 1);
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          (this._len = 0),
          (this._lenPos = 0),
          (this._packet = null),
          (this._pktLen = 0),
          (this._macPos = 0);
        {
          const ie = this._onPayload(te);
          if (ie !== void 0) return ie === !1 ? M : ie;
        }
      }
    }
  }
  class k {
    constructor(Y) {
      const M = Y.inbound;
      (this.inSeqno = M.seqno),
        (this._onPayload = M.onPayload),
        (this._instance = new y(M.decipherKey)),
        (this._len = 0),
        (this._lenBuf = Buffer.alloc(4)),
        (this._lenPos = 0),
        (this._packet = null),
        (this._pktLen = 0),
        (this._mac = Buffer.allocUnsafe(16)),
        (this._macPos = 0);
    }
    free() {
      this._instance.free();
    }
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._lenPos < 4) {
          let le = Math.min(4 - this._lenPos, oe - M);
          for (; le--; ) this._lenBuf[this._lenPos++] = Y[M++];
          if (this._lenPos < 4) return;
          if (
            ((this._len = this._instance.decryptLen(
              this._lenBuf,
              this.inSeqno,
            )),
            this._len > d || this._len < 8 || this._len & 7)
          )
            throw new Error("Bad packet length");
          if (M >= oe) return;
        }
        if (this._pktLen < this._len) {
          const le = Math.min(this._len - this._pktLen, oe - M);
          let te;
          if (
            (M !== 0 || le !== oe
              ? (te = new Uint8Array(Y.buffer, Y.byteOffset + M, le))
              : (te = Y),
            le === this._len
              ? (this._packet = te)
              : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(te, this._pktLen)),
            (M += le),
            (this._pktLen += le),
            this._pktLen < this._len || M >= oe)
          )
            return;
        }
        {
          const le = Math.min(16 - this._macPos, oe - M);
          if (
            (M !== 0 || le !== oe
              ? this._mac.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, le),
                  this._macPos,
                )
              : this._mac.set(Y, this._macPos),
            (M += le),
            (this._macPos += le),
            this._macPos < 16)
          )
            return;
        }
        this._instance.decrypt(this._packet, this._mac, this.inSeqno);
        const Ee = new o(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1,
        );
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          (this._len = 0),
          (this._lenPos = 0),
          (this._packet = null),
          (this._pktLen = 0),
          (this._macPos = 0);
        {
          const le = this._onPayload(Ee);
          if (le !== void 0) return le === !1 ? M : le;
        }
      }
    }
  }
  class W {
    constructor(Y) {
      const M = Y.inbound;
      (this.inSeqno = M.seqno),
        (this._onPayload = M.onPayload),
        (this._decipherInstance = null),
        (this._decipherSSLName = M.decipherInfo.sslName),
        (this._decipherKey = M.decipherKey),
        (this._decipherIV = M.decipherIV),
        (this._len = 0),
        (this._lenBytes = 0),
        (this._packet = null),
        (this._packetPos = 0),
        (this._pktLen = 0),
        (this._tag = Buffer.allocUnsafe(16)),
        (this._tagPos = 0);
    }
    free() {}
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._lenBytes < 4) {
          let le = Math.min(4 - this._lenBytes, oe - M);
          for (this._lenBytes += le; le--; )
            this._len = (this._len << 8) + Y[M++];
          if (this._lenBytes < 4) return;
          if (this._len + 20 > d || this._len < 16 || this._len & 15)
            throw new Error("Bad packet length");
          (this._decipherInstance = t(
            this._decipherSSLName,
            this._decipherKey,
            this._decipherIV,
          )),
            this._decipherInstance.setAutoPadding(!1),
            this._decipherInstance.setAAD(B(this._len));
        }
        if (this._pktLen < this._len) {
          if (M >= oe) return;
          const le = Math.min(this._len - this._pktLen, oe - M);
          let te;
          if (
            (M !== 0 || le !== oe
              ? (te = this._decipherInstance.update(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, le),
                ))
              : (te = this._decipherInstance.update(Y)),
            te.length &&
              (le === this._len
                ? (this._packet = te)
                : (this._packet ||
                    (this._packet = Buffer.allocUnsafe(this._len)),
                  this._packet.set(te, this._packetPos)),
              (this._packetPos += te.length)),
            (M += le),
            (this._pktLen += le),
            this._pktLen < this._len || M >= oe)
          )
            return;
        }
        {
          const le = Math.min(16 - this._tagPos, oe - M);
          if (
            (M !== 0 || le !== oe
              ? this._tag.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, le),
                  this._tagPos,
                )
              : this._tag.set(Y, this._tagPos),
            (M += le),
            (this._tagPos += le),
            this._tagPos < 16)
          )
            return;
        }
        {
          this._decipherInstance.setAuthTag(this._tag);
          const le = this._decipherInstance.final();
          le.length &&
            (this._packet
              ? this._packet.set(le, this._packetPos)
              : (this._packet = le));
        }
        const Ee = this._packet
          ? new o(
              this._packet.buffer,
              this._packet.byteOffset + 1,
              this._packet.length - this._packet[0] - 1,
            )
          : l;
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          V(this._decipherIV),
          (this._len = 0),
          (this._lenBytes = 0),
          (this._packet = null),
          (this._packetPos = 0),
          (this._pktLen = 0),
          (this._tagPos = 0);
        {
          const le = this._onPayload(Ee);
          if (le !== void 0) return le === !1 ? M : le;
        }
      }
    }
  }
  class F {
    constructor(Y) {
      const M = Y.inbound;
      (this.inSeqno = M.seqno),
        (this._onPayload = M.onPayload),
        (this._instance = new v(
          M.decipherInfo.sslName,
          M.decipherKey,
          M.decipherIV,
        )),
        (this._len = 0),
        (this._lenBytes = 0),
        (this._packet = null),
        (this._pktLen = 0),
        (this._tag = Buffer.allocUnsafe(16)),
        (this._tagPos = 0);
    }
    free() {}
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._lenBytes < 4) {
          let le = Math.min(4 - this._lenBytes, oe - M);
          for (this._lenBytes += le; le--; )
            this._len = (this._len << 8) + Y[M++];
          if (this._lenBytes < 4) return;
          if (this._len + 20 > d || this._len < 16 || this._len & 15)
            throw new Error(`Bad packet length: ${this._len}`);
        }
        if (this._pktLen < this._len) {
          if (M >= oe) return;
          const le = Math.min(this._len - this._pktLen, oe - M);
          let te;
          if (
            (M !== 0 || le !== oe
              ? (te = new Uint8Array(Y.buffer, Y.byteOffset + M, le))
              : (te = Y),
            le === this._len
              ? (this._packet = te)
              : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(te, this._pktLen)),
            (M += le),
            (this._pktLen += le),
            this._pktLen < this._len || M >= oe)
          )
            return;
        }
        {
          const le = Math.min(16 - this._tagPos, oe - M);
          if (
            (M !== 0 || le !== oe
              ? this._tag.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, le),
                  this._tagPos,
                )
              : this._tag.set(Y, this._tagPos),
            (M += le),
            (this._tagPos += le),
            this._tagPos < 16)
          )
            return;
        }
        this._instance.decrypt(this._packet, this._len, this._tag);
        const Ee = new o(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1,
        );
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          (this._len = 0),
          (this._lenBytes = 0),
          (this._packet = null),
          (this._pktLen = 0),
          (this._tagPos = 0);
        {
          const le = this._onPayload(Ee);
          if (le !== void 0) return le === !1 ? M : le;
        }
      }
    }
  }
  class x {
    constructor(Y) {
      const M = Y.inbound;
      (this.inSeqno = M.seqno),
        (this._onPayload = M.onPayload),
        (this._decipherInstance = t(
          M.decipherInfo.sslName,
          M.decipherKey,
          M.decipherIV,
        )),
        this._decipherInstance.setAutoPadding(!1),
        (this._block = Buffer.allocUnsafe(
          M.macInfo.isETM ? 4 : M.decipherInfo.blockLen,
        )),
        (this._blockSize = M.decipherInfo.blockLen),
        (this._blockPos = 0),
        (this._len = 0),
        (this._packet = null),
        (this._packetPos = 0),
        (this._pktLen = 0),
        (this._mac = Buffer.allocUnsafe(M.macInfo.actualLen)),
        (this._macPos = 0),
        (this._macSSLName = M.macInfo.sslName),
        (this._macKey = M.macKey),
        (this._macActualLen = M.macInfo.actualLen),
        (this._macETM = M.macInfo.isETM),
        (this._macInstance = null);
      const oe = M.decipherInfo.discardLen;
      if (oe) {
        let Ee = u.get(oe);
        Ee === void 0 && ((Ee = Buffer.alloc(oe)), u.set(oe, Ee)),
          this._decipherInstance.update(Ee);
      }
    }
    free() {}
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._blockPos < this._block.length) {
          const te = Math.min(this._block.length - this._blockPos, oe - M);
          if (
            (M !== 0 || te !== oe || te < Y.length
              ? this._block.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, te),
                  this._blockPos,
                )
              : this._block.set(Y, this._blockPos),
            (M += te),
            (this._blockPos += te),
            this._blockPos < this._block.length)
          )
            return;
          let ie, X;
          if (
            (this._macETM
              ? (this._len = X = a(this._block, 0))
              : ((ie = this._decipherInstance.update(this._block)),
                (this._len = a(ie, 0)),
                (X = 4 + this._len - this._blockSize)),
            this._len > d || this._len < 5 || X & (this._blockSize - 1))
          )
            throw new Error("Bad packet length");
          if (
            ((this._macInstance = n(this._macSSLName, this._macKey)),
            s(f, this.inSeqno, 0),
            this._macInstance.update(f),
            this._macETM
              ? this._macInstance.update(this._block)
              : (this._macInstance.update(
                  new Uint8Array(ie.buffer, ie.byteOffset, 4),
                ),
                (this._pktLen = ie.length - 4),
                (this._packetPos = this._pktLen),
                (this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(
                  new Uint8Array(ie.buffer, ie.byteOffset + 4, this._packetPos),
                  0,
                )),
            M >= oe)
          )
            return;
        }
        if (this._pktLen < this._len) {
          const te = Math.min(this._len - this._pktLen, oe - M);
          let ie;
          M !== 0 || te !== oe
            ? (ie = new Uint8Array(Y.buffer, Y.byteOffset + M, te))
            : (ie = Y),
            this._macETM && this._macInstance.update(ie);
          const X = this._decipherInstance.update(ie);
          if (
            (X.length &&
              (te === this._len
                ? (this._packet = X)
                : (this._packet ||
                    (this._packet = Buffer.allocUnsafe(this._len)),
                  this._packet.set(X, this._packetPos)),
              (this._packetPos += X.length)),
            (M += te),
            (this._pktLen += te),
            this._pktLen < this._len || M >= oe)
          )
            return;
        }
        {
          const te = Math.min(this._macActualLen - this._macPos, oe - M);
          if (
            (M !== 0 || te !== oe
              ? this._mac.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, te),
                  this._macPos,
                )
              : this._mac.set(Y, this._macPos),
            (M += te),
            (this._macPos += te),
            this._macPos < this._macActualLen)
          )
            return;
        }
        this._macETM || this._macInstance.update(this._packet);
        let Ee = this._macInstance.digest();
        if (
          (this._macActualLen < Ee.length &&
            (Ee = new Uint8Array(Ee.buffer, Ee.byteOffset, this._macActualLen)),
          !N(Ee, this._mac))
        )
          throw new Error("Invalid MAC");
        const le = new o(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1,
        );
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          (this._blockPos = 0),
          (this._len = 0),
          (this._packet = null),
          (this._packetPos = 0),
          (this._pktLen = 0),
          (this._macPos = 0),
          (this._macInstance = null);
        {
          const te = this._onPayload(le);
          if (te !== void 0) return te === !1 ? M : te;
        }
      }
    }
  }
  class T {
    constructor(Y) {
      const M = Y.inbound;
      (this.inSeqno = M.seqno),
        (this._onPayload = M.onPayload),
        (this._instance = new _(
          M.decipherInfo.sslName,
          M.decipherKey,
          M.decipherIV,
          M.macInfo.sslName,
          M.macKey,
          M.macInfo.isETM,
          M.macInfo.actualLen,
        )),
        (this._block = Buffer.allocUnsafe(
          M.macInfo.isETM || M.decipherInfo.stream
            ? 4
            : M.decipherInfo.blockLen,
        )),
        (this._blockPos = 0),
        (this._len = 0),
        (this._packet = null),
        (this._pktLen = 0),
        (this._mac = Buffer.allocUnsafe(M.macInfo.actualLen)),
        (this._macPos = 0),
        (this._macActualLen = M.macInfo.actualLen),
        (this._macETM = M.macInfo.isETM);
    }
    free() {
      this._instance.free();
    }
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._blockPos < this._block.length) {
          const le = Math.min(this._block.length - this._blockPos, oe - M);
          if (
            (M !== 0 || le !== oe || le < Y.length
              ? this._block.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, le),
                  this._blockPos,
                )
              : this._block.set(Y, this._blockPos),
            (M += le),
            (this._blockPos += le),
            this._blockPos < this._block.length)
          )
            return;
          let te;
          if (
            (this._macETM
              ? (this._len = te = a(this._block, 0))
              : (this._instance.decryptBlock(this._block),
                (this._len = a(this._block, 0)),
                (te = 4 + this._len - this._block.length)),
            this._len > d || this._len < 5 || te & (this._block.length - 1))
          )
            throw new Error("Bad packet length");
          if (
            (this._macETM ||
              ((this._pktLen = this._block.length - 4),
              this._pktLen &&
                ((this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(
                  new Uint8Array(
                    this._block.buffer,
                    this._block.byteOffset + 4,
                    this._pktLen,
                  ),
                  0,
                ))),
            M >= oe)
          )
            return;
        }
        if (this._pktLen < this._len) {
          const le = Math.min(this._len - this._pktLen, oe - M);
          let te;
          if (
            (M !== 0 || le !== oe
              ? (te = new Uint8Array(Y.buffer, Y.byteOffset + M, le))
              : (te = Y),
            le === this._len
              ? (this._packet = te)
              : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(te, this._pktLen)),
            (M += le),
            (this._pktLen += le),
            this._pktLen < this._len || M >= oe)
          )
            return;
        }
        {
          const le = Math.min(this._macActualLen - this._macPos, oe - M);
          if (
            (M !== 0 || le !== oe
              ? this._mac.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, le),
                  this._macPos,
                )
              : this._mac.set(Y, this._macPos),
            (M += le),
            (this._macPos += le),
            this._macPos < this._macActualLen)
          )
            return;
        }
        this._instance.decrypt(
          this._packet,
          this.inSeqno,
          this._block,
          this._mac,
        );
        const Ee = new o(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1,
        );
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          (this._blockPos = 0),
          (this._len = 0),
          (this._packet = null),
          (this._pktLen = 0),
          (this._macPos = 0),
          (this._macInstance = null);
        {
          const le = this._onPayload(Ee);
          if (le !== void 0) return le === !1 ? M : le;
        }
      }
    }
  }
  function V(ne) {
    ++ne[11] >>> 8 &&
      ++ne[10] >>> 8 &&
      ++ne[9] >>> 8 &&
      ++ne[8] >>> 8 &&
      ++ne[7] >>> 8 &&
      ++ne[6] >>> 8 &&
      ++ne[5] >>> 8 &&
      ++ne[4] >>> 8;
  }
  const B = (() => {
    const ne = Buffer.alloc(4);
    return (Y) => (
      (ne[0] = Y >>> 24), (ne[1] = Y >>> 16), (ne[2] = Y >>> 8), (ne[3] = Y), ne
    );
  })();
  function N(ne, Y) {
    return ne.length !== Y.length ? (i(ne, ne), !1) : i(ne, Y);
  }
  function ce(ne) {
    if (typeof ne != "object" || ne === null) throw new Error("Invalid config");
    if (typeof ne.outbound != "object" || ne.outbound === null)
      throw new Error("Invalid outbound");
    const Y = ne.outbound;
    if (typeof Y.onWrite != "function")
      throw new Error("Invalid outbound.onWrite");
    if (typeof Y.cipherInfo != "object" || Y.cipherInfo === null)
      throw new Error("Invalid outbound.cipherInfo");
    if (
      !Buffer.isBuffer(Y.cipherKey) ||
      Y.cipherKey.length !== Y.cipherInfo.keyLen
    )
      throw new Error("Invalid outbound.cipherKey");
    if (
      Y.cipherInfo.ivLen &&
      (!Buffer.isBuffer(Y.cipherIV) || Y.cipherIV.length !== Y.cipherInfo.ivLen)
    )
      throw new Error("Invalid outbound.cipherIV");
    if (typeof Y.seqno != "number" || Y.seqno < 0 || Y.seqno > c)
      throw new Error("Invalid outbound.seqno");
    const M = !!Y.forceNative;
    switch (Y.cipherInfo.sslName) {
      case "aes-128-gcm":
      case "aes-256-gcm":
        return h && !M ? new Z(ne) : new J(ne);
      case "chacha20":
        return m && !M ? new q(ne) : new H(ne);
      default: {
        if (typeof Y.macInfo != "object" || Y.macInfo === null)
          throw new Error("Invalid outbound.macInfo");
        if (!Buffer.isBuffer(Y.macKey) || Y.macKey.length !== Y.macInfo.len)
          throw new Error("Invalid outbound.macKey");
        return g && !M ? new U(ne) : new z(ne);
      }
    }
  }
  function re(ne) {
    if (typeof ne != "object" || ne === null) throw new Error("Invalid config");
    if (typeof ne.inbound != "object" || ne.inbound === null)
      throw new Error("Invalid inbound");
    const Y = ne.inbound;
    if (typeof Y.onPayload != "function")
      throw new Error("Invalid inbound.onPayload");
    if (typeof Y.decipherInfo != "object" || Y.decipherInfo === null)
      throw new Error("Invalid inbound.decipherInfo");
    if (
      !Buffer.isBuffer(Y.decipherKey) ||
      Y.decipherKey.length !== Y.decipherInfo.keyLen
    )
      throw new Error("Invalid inbound.decipherKey");
    if (
      Y.decipherInfo.ivLen &&
      (!Buffer.isBuffer(Y.decipherIV) ||
        Y.decipherIV.length !== Y.decipherInfo.ivLen)
    )
      throw new Error("Invalid inbound.decipherIV");
    if (typeof Y.seqno != "number" || Y.seqno < 0 || Y.seqno > c)
      throw new Error("Invalid inbound.seqno");
    const M = !!Y.forceNative;
    switch (Y.decipherInfo.sslName) {
      case "aes-128-gcm":
      case "aes-256-gcm":
        return v && !M ? new F(ne) : new W(ne);
      case "chacha20":
        return y && !M ? new k(ne) : new L(ne);
      default: {
        if (typeof Y.macInfo != "object" || Y.macInfo === null)
          throw new Error("Invalid inbound.macInfo");
        if (!Buffer.isBuffer(Y.macKey) || Y.macKey.length !== Y.macInfo.len)
          throw new Error("Invalid inbound.macKey");
        return _ && !M ? new T(ne) : new x(ne);
      }
    }
  }
  return (
    (Ym = {
      CIPHER_INFO: R,
      MAC_INFO: A,
      bindingAvailable: !!p,
      init: (() =>
        new Promise(async (ne, Y) => {
          try {
            (O = await bte()()),
              (Q = O._malloc(16)),
              (j = O.cwrap("poly1305_auth", null, [
                "number",
                "array",
                "number",
                "array",
                "number",
                "array",
              ]));
          } catch (M) {
            return Y(M);
          }
          ne();
        }))(),
      NullCipher: I,
      createCipher: ce,
      NullDecipher: G,
      createDecipher: re,
    }),
    Ym
  );
}
const {
    createDecipheriv: Vb,
    createECDH: _te,
    createHash: Cl,
    createHmac: Ete,
    createSign: wte,
    createVerify: xte,
    getCiphers: Ate,
    sign: BA,
    verify: UA,
  } = pr,
  Ste = Ate(),
  { Ber: ft } = Yp,
  Ite = rk.pbkdf,
  { CIPHER_INFO: Rl } = eo(),
  { eddsaSupported: Yb, SUPPORTED_CIPHER: $te } = es(),
  {
    bufferSlice: Cs,
    makeBufferParser: Cte,
    readString: ot,
    readUInt32BE: sl,
    writeUInt32BE: Kn,
  } = Ki(),
  oa = Symbol("Hash Algorithm"),
  pi = Symbol("Private key PEM"),
  Bi = Symbol("Public key PEM"),
  Wa = Symbol("Public key SSH"),
  Rc = Symbol("Decrypted Key"),
  F0 = Object.create(null);
{
  const e = Object.keys(Rl);
  for (let t = 0; t < e.length; ++t) {
    const n = Rl[e[t]].sslName;
    !n || F0[n] || (F0[n] = Rl[e[t]]);
  }
}
const kf = Cte();
function _i(e, t) {
  t = t.base64Slice(0, t.length);
  let n = t.replace(
    /.{64}/g,
    `$&
`,
  );
  return (
    t.length & 63 &&
      (n += `
`),
    `-----BEGIN ${e} KEY-----
${n}-----END ${e} KEY-----`
  );
}
function ql(e, t) {
  const n = Buffer.allocUnsafe(e.length + t.length);
  return n.set(e, 0), n.set(t, e.length), n;
}
function Xb(e, t) {
  const n = e.length;
  let r = e._pos || 0;
  for (let i = 0; i < t; ++i) {
    const a = n - r;
    if (r >= n || a < 4) return !1;
    const s = sl(e, r);
    if (a < 4 + s) return !1;
    r += 4 + s;
  }
  return (e._pos = r), !0;
}
function _u(e, t) {
  const n = new ft.Writer();
  return (
    n.startSequence(),
    n.startSequence(),
    n.writeOID("1.2.840.113549.1.1.1"),
    n.writeNull(),
    n.endSequence(),
    n.startSequence(ft.BitString),
    n.writeByte(0),
    n.startSequence(),
    n.writeBuffer(e, ft.Integer),
    n.writeBuffer(t, ft.Integer),
    n.endSequence(),
    n.endSequence(),
    n.endSequence(),
    _i("PUBLIC", n.buffer)
  );
}
function Eu(e, t) {
  const n = Buffer.allocUnsafe(15 + t.length + 4 + e.length);
  Kn(n, 7, 0), n.utf8Write("ssh-rsa", 4, 7);
  let r = 4 + 7;
  return (
    Kn(n, t.length, r),
    n.set(t, (r += 4)),
    Kn(n, e.length, (r += t.length)),
    n.set(e, r + 4),
    n
  );
}
const ik = (() => {
  function e(r, i, a, s, o, c, l, f) {
    const u = new ft.Writer();
    return (
      u.startSequence(),
      u.writeInt(0, ft.Integer),
      u.writeBuffer(r, ft.Integer),
      u.writeBuffer(i, ft.Integer),
      u.writeBuffer(a, ft.Integer),
      u.writeBuffer(s, ft.Integer),
      u.writeBuffer(o, ft.Integer),
      u.writeBuffer(c, ft.Integer),
      u.writeBuffer(l, ft.Integer),
      u.writeBuffer(f, ft.Integer),
      u.endSequence(),
      u.buffer
    );
  }
  function t(r) {
    return BigInt(`0x${r.hexSlice(0, r.length)}`);
  }
  function n(r) {
    let i = r.toString(16);
    if (i.length & 1) i = `0${i}`;
    else {
      const a = i.charCodeAt(0);
      (a === 56 || a === 57 || (a >= 97 && a <= 102)) && (i = `00${i}`);
    }
    return Buffer.from(i, "hex");
  }
  return function (i, a, s, o, c, l) {
    const f = t(s),
      u = n(f % (t(c) - 1n)),
      d = n(f % (t(l) - 1n));
    return _i("RSA PRIVATE", e(i, a, s, c, l, u, d, o));
  };
})();
function wu(e, t, n, r) {
  const i = new ft.Writer();
  return (
    i.startSequence(),
    i.startSequence(),
    i.writeOID("1.2.840.10040.4.1"),
    i.startSequence(),
    i.writeBuffer(e, ft.Integer),
    i.writeBuffer(t, ft.Integer),
    i.writeBuffer(n, ft.Integer),
    i.endSequence(),
    i.endSequence(),
    i.startSequence(ft.BitString),
    i.writeByte(0),
    i.writeBuffer(r, ft.Integer),
    i.endSequence(),
    i.endSequence(),
    _i("PUBLIC", i.buffer)
  );
}
function xu(e, t, n, r) {
  const i = Buffer.allocUnsafe(
    15 + e.length + 4 + t.length + 4 + n.length + 4 + r.length,
  );
  Kn(i, 7, 0), i.utf8Write("ssh-dss", 4, 7);
  let a = 4 + 7;
  return (
    Kn(i, e.length, a),
    i.set(e, (a += 4)),
    Kn(i, t.length, (a += e.length)),
    i.set(t, (a += 4)),
    Kn(i, n.length, (a += t.length)),
    i.set(n, (a += 4)),
    Kn(i, r.length, (a += n.length)),
    i.set(r, a + 4),
    i
  );
}
function ak(e, t, n, r, i) {
  const a = new ft.Writer();
  return (
    a.startSequence(),
    a.writeInt(0, ft.Integer),
    a.writeBuffer(e, ft.Integer),
    a.writeBuffer(t, ft.Integer),
    a.writeBuffer(n, ft.Integer),
    a.writeBuffer(r, ft.Integer),
    a.writeBuffer(i, ft.Integer),
    a.endSequence(),
    _i("DSA PRIVATE", a.buffer)
  );
}
function sk(e) {
  const t = new ft.Writer();
  return (
    t.startSequence(),
    t.startSequence(),
    t.writeOID("1.3.101.112"),
    t.endSequence(),
    t.startSequence(ft.BitString),
    t.writeByte(0),
    t._ensure(e.length),
    t._buf.set(e, t._offset),
    (t._offset += e.length),
    t.endSequence(),
    t.endSequence(),
    _i("PUBLIC", t.buffer)
  );
}
function ok(e) {
  const t = Buffer.allocUnsafe(19 + e.length);
  return (
    Kn(t, 11, 0),
    t.utf8Write("ssh-ed25519", 4, 11),
    Kn(t, e.length, 15),
    t.set(e, 19),
    t
  );
}
function Rte(e) {
  const t = new ft.Writer();
  return (
    t.startSequence(),
    t.writeInt(0, ft.Integer),
    t.startSequence(),
    t.writeOID("1.3.101.112"),
    t.endSequence(),
    t.startSequence(ft.OctetString),
    t.writeBuffer(e, ft.OctetString),
    t.endSequence(),
    t.endSequence(),
    _i("PRIVATE", t.buffer)
  );
}
function Jb(e, t) {
  const n = new ft.Writer();
  return (
    n.startSequence(),
    n.startSequence(),
    n.writeOID("1.2.840.10045.2.1"),
    n.writeOID(e),
    n.endSequence(),
    n.startSequence(ft.BitString),
    n.writeByte(0),
    n._ensure(t.length),
    n._buf.set(t, n._offset),
    (n._offset += t.length),
    n.endSequence(),
    n.endSequence(),
    _i("PUBLIC", n.buffer)
  );
}
function Zb(e, t) {
  let n;
  switch (e) {
    case "1.2.840.10045.3.1.7":
      n = "nistp256";
      break;
    case "1.3.132.0.34":
      n = "nistp384";
      break;
    case "1.3.132.0.35":
      n = "nistp521";
      break;
    default:
      return;
  }
  const r = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + t.length);
  return (
    Kn(r, 19, 0),
    r.utf8Write(`ecdsa-sha2-${n}`, 4, 19),
    Kn(r, 8, 23),
    r.utf8Write(n, 27, 8),
    Kn(r, t.length, 35),
    r.set(t, 39),
    r
  );
}
function kte(e, t, n) {
  const r = new ft.Writer();
  return (
    r.startSequence(),
    r.writeInt(1, ft.Integer),
    r.writeBuffer(n, ft.OctetString),
    r.startSequence(160),
    r.writeOID(e),
    r.endSequence(),
    r.startSequence(161),
    r.startSequence(ft.BitString),
    r.writeByte(0),
    r._ensure(t.length),
    r._buf.set(t, r._offset),
    (r._offset += t.length),
    r.endSequence(),
    r.endSequence(),
    r.endSequence(),
    _i("EC PRIVATE", r.buffer)
  );
}
function Tte(e, t) {
  const n = _te(e);
  return n.setPrivateKey(t), n.getPublicKey();
}
const Au = {
  sign: (() =>
    typeof BA == "function"
      ? function (t, n) {
          const r = this[pi];
          if (r === null) return new Error("No private key available");
          (!n || typeof n != "string") && (n = this[oa]);
          try {
            return BA(n, t, r);
          } catch (i) {
            return i;
          }
        }
      : function (t, n) {
          const r = this[pi];
          if (r === null) return new Error("No private key available");
          (!n || typeof n != "string") && (n = this[oa]);
          const i = wte(n);
          i.update(t);
          try {
            return i.sign(r);
          } catch (a) {
            return a;
          }
        })(),
  verify: (() =>
    typeof UA == "function"
      ? function (t, n, r) {
          const i = this[Bi];
          if (i === null) return new Error("No public key available");
          (!r || typeof r != "string") && (r = this[oa]);
          try {
            return UA(r, t, i, n);
          } catch (a) {
            return a;
          }
        }
      : function (t, n, r) {
          const i = this[Bi];
          if (i === null) return new Error("No public key available");
          (!r || typeof r != "string") && (r = this[oa]);
          const a = xte(r);
          a.update(t);
          try {
            return a.verify(i, n);
          } catch (s) {
            return s;
          }
        })(),
  isPrivateKey: function () {
    return this[pi] !== null;
  },
  getPrivatePEM: function () {
    return this[pi];
  },
  getPublicPEM: function () {
    return this[Bi];
  },
  getPublicSSH: function () {
    return this[Wa];
  },
  equals: function (t) {
    const n = uk(t);
    return n instanceof Error
      ? !1
      : this.type === n.type &&
          this[pi] === n[pi] &&
          this[Bi] === n[Bi] &&
          this[Wa] === n[Wa];
  },
};
function Nd(e, t, n, r, i, a, s) {
  (this.type = e),
    (this.comment = t),
    (this[pi] = n),
    (this[Bi] = r),
    (this[Wa] = i),
    (this[oa] = a),
    (this[Rc] = s);
}
Nd.prototype = Au;
{
  let t = function (n, r, i) {
    const a = [];
    if (n.length < 8) return new Error("Malformed OpenSSH private key");
    const s = sl(n, 0),
      o = sl(n, 4);
    if (s !== o)
      return i
        ? new Error("OpenSSH key integrity check failed -- bad passphrase?")
        : new Error("OpenSSH key integrity check failed");
    n._pos = 8;
    let c, l;
    for (c = 0; c < r; ++c) {
      let u, d, p, h;
      const m = ot(n, n._pos, !0);
      if (m === void 0) return new Error("Malformed OpenSSH private key");
      switch (m) {
        case "ssh-rsa": {
          const v = ot(n, n._pos);
          if (v === void 0) return new Error("Malformed OpenSSH private key");
          const y = ot(n, n._pos);
          if (y === void 0) return new Error("Malformed OpenSSH private key");
          const _ = ot(n, n._pos);
          if (_ === void 0) return new Error("Malformed OpenSSH private key");
          const E = ot(n, n._pos);
          if (E === void 0) return new Error("Malformed OpenSSH private key");
          const R = ot(n, n._pos);
          if (R === void 0) return new Error("Malformed OpenSSH private key");
          const A = ot(n, n._pos);
          if (A === void 0) return new Error("Malformed OpenSSH private key");
          (p = _u(v, y)),
            (h = Eu(v, y)),
            (d = ik(v, y, _, E, R, A)),
            (u = "sha1");
          break;
        }
        case "ssh-dss": {
          const v = ot(n, n._pos);
          if (v === void 0) return new Error("Malformed OpenSSH private key");
          const y = ot(n, n._pos);
          if (y === void 0) return new Error("Malformed OpenSSH private key");
          const _ = ot(n, n._pos);
          if (_ === void 0) return new Error("Malformed OpenSSH private key");
          const E = ot(n, n._pos);
          if (E === void 0) return new Error("Malformed OpenSSH private key");
          const R = ot(n, n._pos);
          if (R === void 0) return new Error("Malformed OpenSSH private key");
          (p = wu(v, y, _, E)),
            (h = xu(v, y, _, E)),
            (d = ak(v, y, _, E, R)),
            (u = "sha1");
          break;
        }
        case "ssh-ed25519": {
          if (!Yb)
            return new Error(`Unsupported OpenSSH private key type: ${m}`);
          const v = ot(n, n._pos);
          if (v === void 0 || v.length !== 32)
            return new Error("Malformed OpenSSH private key");
          const y = ot(n, n._pos);
          if (y === void 0 || y.length !== 64)
            return new Error("Malformed OpenSSH private key");
          (p = sk(v)), (h = ok(v)), (d = Rte(Cs(y, 0, 32))), (u = null);
          break;
        }
        case "ecdsa-sha2-nistp256":
          (u = "sha256"), (l = "1.2.840.10045.3.1.7");
        case "ecdsa-sha2-nistp384":
          u === void 0 && ((u = "sha384"), (l = "1.3.132.0.34"));
        case "ecdsa-sha2-nistp521": {
          if (
            (u === void 0 && ((u = "sha512"), (l = "1.3.132.0.35")), !Xb(n, 1))
          )
            return new Error("Malformed OpenSSH private key");
          const v = ot(n, n._pos);
          if (v === void 0) return new Error("Malformed OpenSSH private key");
          const y = ot(n, n._pos);
          if (y === void 0) return new Error("Malformed OpenSSH private key");
          (p = Jb(l, v)), (h = Zb(l, v)), (d = kte(l, v, y));
          break;
        }
        default:
          return new Error(`Unsupported OpenSSH private key type: ${m}`);
      }
      const g = ot(n, n._pos, !0);
      if (g === void 0) return new Error("Malformed OpenSSH private key");
      a.push(new Nd(m, g, d, p, h, u, i));
    }
    let f = 0;
    for (c = n._pos; c < n.length; ++c)
      if (n[c] !== ++f % 255) return new Error("Malformed OpenSSH private key");
    return a;
  };
  const e =
    /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\r\n|\n)([\s\S]+)(?:\r\n|\n)-----END OPENSSH PRIVATE KEY-----$/;
  Nd.parse = (n, r) => {
    const i = e.exec(n);
    if (i === null) return null;
    let a;
    const s = Buffer.from(i[1], "base64");
    if (s.length < 31) return new Error("Malformed OpenSSH private key");
    const o = s.utf8Slice(0, 15);
    if (o !== "openssh-key-v1\0")
      return new Error(`Unsupported OpenSSH key magic: ${o}`);
    const c = ot(s, 15, !0);
    if (c === void 0) return new Error("Malformed OpenSSH private key");
    if (c !== "none" && $te.indexOf(c) === -1)
      return new Error(`Unsupported cipher for OpenSSH key: ${c}`);
    const l = ot(s, s._pos, !0);
    if (l === void 0) return new Error("Malformed OpenSSH private key");
    if (l !== "none") {
      if (c === "none") return new Error("Malformed OpenSSH private key");
      if (l !== "bcrypt")
        return new Error(`Unsupported kdf name for OpenSSH key: ${l}`);
      if (!r)
        return new Error(
          "Encrypted private OpenSSH key detected, but no passphrase given",
        );
    } else if (c !== "none") return new Error("Malformed OpenSSH private key");
    let f, u, d;
    c !== "none" && (f = Rl[c]);
    const p = ot(s, s._pos);
    if (p === void 0) return new Error("Malformed OpenSSH private key");
    if (p.length)
      switch (l) {
        case "none":
          return new Error("Malformed OpenSSH private key");
        case "bcrypt": {
          const m = ot(p, 0);
          if (m === void 0 || p._pos + 4 > p.length)
            return new Error("Malformed OpenSSH private key");
          const g = sl(p, p._pos),
            v = Buffer.allocUnsafe(f.keyLen + f.ivLen);
          if (Ite(r, r.length, m, m.length, v, v.length, g) !== 0)
            return new Error("Failed to generate information to decrypt key");
          (u = Cs(v, 0, f.keyLen)), (d = Cs(v, f.keyLen, v.length));
          break;
        }
      }
    else if (l !== "none") return new Error("Malformed OpenSSH private key");
    if (s._pos + 3 >= s.length)
      return new Error("Malformed OpenSSH private key");
    const h = sl(s, s._pos);
    if (((s._pos += 4), h > 0)) {
      for (let g = 0; g < h; ++g) {
        const v = ot(s, s._pos);
        if (v === void 0) return new Error("Malformed OpenSSH private key");
        if (ot(v, 0, !0) === void 0)
          return new Error("Malformed OpenSSH private key");
      }
      let m = ot(s, s._pos);
      if (m === void 0) return new Error("Malformed OpenSSH private key");
      if (u !== void 0) {
        if (m.length < f.blockLen || m.length % f.blockLen !== 0)
          return new Error("Malformed OpenSSH private key");
        try {
          const g = { authTagLength: f.authLen },
            v = Vb(f.sslName, u, d, g);
          if ((v.setAutoPadding(!1), f.authLen > 0)) {
            if (s.length - s._pos < f.authLen)
              return new Error("Malformed OpenSSH private key");
            v.setAuthTag(Cs(s, s._pos, (s._pos += f.authLen)));
          }
          m = ql(v.update(m), v.final());
        } catch (g) {
          return g;
        }
      }
      if (s._pos !== s.length)
        return new Error("Malformed OpenSSH private key");
      a = t(m, h, u !== void 0);
    } else a = [];
    return a instanceof Error ? a : a[0];
  };
}
function Od(e, t, n, r, i, a, s) {
  (this.type = e),
    (this.comment = t),
    (this[pi] = n),
    (this[Bi] = r),
    (this[Wa] = i),
    (this[oa] = a),
    (this[Rc] = s);
}
Od.prototype = Au;
{
  const e =
    /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\r\n|\n)((?:[^:]+:\s*[\S].*(?:\r\n|\n))*)([\s\S]+)(?:\r\n|\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;
  Od.parse = (t, n) => {
    const r = e.exec(t);
    if (r === null) return null;
    let i = Buffer.from(r[3], "base64"),
      a = r[2],
      s = !1;
    if (a !== void 0) {
      a = a.split(/\r\n|\n/g);
      for (let h = 0; h < a.length; ++h) {
        const m = a[h];
        let g = m.indexOf(":");
        if (m.slice(0, g) === "DEK-Info") {
          const v = m.slice(g + 2);
          if (((g = v.indexOf(",")), g === -1)) continue;
          const y = v.slice(0, g).toLowerCase();
          if (Ste.indexOf(y) === -1)
            return new Error(
              `Cipher (${y}) not supported for encrypted OpenSSH private key`,
            );
          const _ = F0[y];
          if (!_)
            return new Error(
              `Cipher (${y}) not supported for encrypted OpenSSH private key`,
            );
          const E = Buffer.from(v.slice(g + 1), "hex");
          if (E.length !== _.ivLen)
            return new Error("Malformed encrypted OpenSSH private key");
          if (!n)
            return new Error(
              "Encrypted OpenSSH private key detected, but no passphrase given",
            );
          const R = Cs(E, 0, 8);
          let A = Cl("md5").update(n).update(R).digest();
          for (; A.length < _.keyLen; )
            A = ql(A, Cl("md5").update(A).update(n).update(R).digest());
          A.length > _.keyLen && (A = Cs(A, 0, _.keyLen));
          try {
            const I = Vb(y, A, E);
            I.setAutoPadding(!1), (i = ql(I.update(i), I.final())), (s = !0);
          } catch (I) {
            return I;
          }
        }
      }
    }
    let o,
      c,
      l,
      f,
      u,
      d,
      p = "Malformed OpenSSH private key";
    switch ((s && (p += ". Bad passphrase?"), r[1])) {
      case "RSA":
        (o = "ssh-rsa"), (c = _i("RSA PRIVATE", i));
        try {
          (d = new ft.Reader(i)), d.readSequence(), d.readInt();
          const h = d.readString(ft.Integer, !0);
          if (h === null) return new Error(p);
          const m = d.readString(ft.Integer, !0);
          if (m === null) return new Error(p);
          (l = _u(h, m)), (f = Eu(h, m));
        } catch {
          return new Error(p);
        }
        u = "sha1";
        break;
      case "DSA":
        (o = "ssh-dss"), (c = _i("DSA PRIVATE", i));
        try {
          (d = new ft.Reader(i)), d.readSequence(), d.readInt();
          const h = d.readString(ft.Integer, !0);
          if (h === null) return new Error(p);
          const m = d.readString(ft.Integer, !0);
          if (m === null) return new Error(p);
          const g = d.readString(ft.Integer, !0);
          if (g === null) return new Error(p);
          const v = d.readString(ft.Integer, !0);
          if (v === null) return new Error(p);
          (l = wu(h, m, g, v)), (f = xu(h, m, g, v));
        } catch {
          return new Error(p);
        }
        u = "sha1";
        break;
      case "EC": {
        let h, m, g;
        try {
          (d = new ft.Reader(i)),
            d.readSequence(),
            d.readInt(),
            (m = d.readString(ft.OctetString, !0)),
            d.readByte();
          const y = d.readLength();
          if (y !== null) {
            if (((d._offset = y), (g = d.readOID()), g === null))
              return new Error(p);
            switch (g) {
              case "1.2.840.10045.3.1.7":
                (h = "prime256v1"), (o = "ecdsa-sha2-nistp256"), (u = "sha256");
                break;
              case "1.3.132.0.34":
                (h = "secp384r1"), (o = "ecdsa-sha2-nistp384"), (u = "sha384");
                break;
              case "1.3.132.0.35":
                (h = "secp521r1"), (o = "ecdsa-sha2-nistp521"), (u = "sha512");
                break;
              default:
                return new Error(`Unsupported private key EC OID: ${g}`);
            }
          } else return new Error(p);
        } catch {
          return new Error(p);
        }
        c = _i("EC PRIVATE", i);
        const v = Tte(h, m);
        (l = Jb(g, v)), (f = Zb(g, v));
        break;
      }
    }
    return new Od(o, "", c, l, f, u, s);
  };
}
function Pd(e, t, n, r, i, a, s) {
  (this.type = e),
    (this.comment = t),
    (this[pi] = n),
    (this[Bi] = r),
    (this[Wa] = i),
    (this[oa] = a),
    (this[Rc] = s);
}
Pd.prototype = Au;
{
  const e = Buffer.alloc(0),
    t = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
    n = Buffer.from([0, 0, 0, 0]),
    r = Buffer.from([0, 0, 0, 1]),
    i =
      /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\r?\nEncryption: (aes256-cbc|none)\r?\nComment: ([^\r\n]*)\r?\nPublic-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-MAC: ([^\r\n]+)/;
  Pd.parse = (a, s) => {
    const o = i.exec(a);
    if (o === null) return null;
    const c = o[2],
      l = c !== "none";
    if (l && !s)
      return new Error(
        "Encrypted PPK private key detected, but no passphrase given",
      );
    let f = Buffer.from(o[5], "base64");
    if (l) {
      const O = Rl[c];
      let Q = ql(
        Cl("sha1").update(n).update(s).digest(),
        Cl("sha1").update(r).update(s).digest(),
      );
      Q.length > O.keyLen && (Q = Cs(Q, 0, O.keyLen));
      try {
        const j = Vb(O.sslName, Q, t);
        j.setAutoPadding(!1), (f = ql(j.update(f), j.final()));
      } catch (j) {
        return j;
      }
    }
    const u = o[1],
      d = o[3],
      p = Buffer.from(o[4], "base64"),
      h = o[6],
      m = u.length,
      g = c.length,
      v = Buffer.byteLength(d),
      y = p.length,
      _ = f.length,
      E = Buffer.allocUnsafe(4 + m + 4 + g + 4 + v + 4 + y + 4 + _);
    let R = 0;
    if (
      (Kn(E, m, R),
      E.utf8Write(u, (R += 4), m),
      Kn(E, g, (R += m)),
      E.utf8Write(c, (R += 4), g),
      Kn(E, v, (R += g)),
      E.utf8Write(d, (R += 4), v),
      Kn(E, y, (R += v)),
      E.set(p, (R += 4)),
      Kn(E, _, (R += y)),
      E.set(f, R + 4),
      s || (s = e),
      Ete(
        "sha1",
        Cl("sha1").update("putty-private-key-file-mac-key").update(s).digest(),
      )
        .update(E)
        .digest("hex") !== h)
    )
      return l
        ? new Error("PPK private key integrity check failed -- bad passphrase?")
        : new Error("PPK private key integrity check failed");
    let I, S, w;
    switch (((p._pos = 0), Xb(p, 1), u)) {
      case "ssh-rsa": {
        const O = ot(p, p._pos);
        if (O === void 0) return new Error("Malformed PPK public key");
        const Q = ot(p, p._pos);
        if (Q === void 0) return new Error("Malformed PPK public key");
        const j = ot(f, 0);
        if (j === void 0) return new Error("Malformed PPK private key");
        const H = ot(f, f._pos);
        if (H === void 0) return new Error("Malformed PPK private key");
        const q = ot(f, f._pos);
        if (q === void 0) return new Error("Malformed PPK private key");
        const J = ot(f, f._pos);
        if (J === void 0) return new Error("Malformed PPK private key");
        (I = _u(Q, O)), (S = Eu(Q, O)), (w = ik(Q, O, j, J, H, q));
        break;
      }
      case "ssh-dss": {
        const O = ot(p, p._pos);
        if (O === void 0) return new Error("Malformed PPK public key");
        const Q = ot(p, p._pos);
        if (Q === void 0) return new Error("Malformed PPK public key");
        const j = ot(p, p._pos);
        if (j === void 0) return new Error("Malformed PPK public key");
        const H = ot(p, p._pos);
        if (H === void 0) return new Error("Malformed PPK public key");
        const q = ot(f, 0);
        if (q === void 0) return new Error("Malformed PPK private key");
        (I = wu(O, Q, j, H)), (S = xu(O, Q, j, H)), (w = ak(O, Q, j, H, q));
        break;
      }
    }
    return new Pd(u, d, w, I, S, "sha1", l);
  };
}
function Xp(e, t, n, r, i) {
  (this.type = e),
    (this.comment = t),
    (this[pi] = null),
    (this[Bi] = n),
    (this[Wa] = r),
    (this[oa] = i),
    (this[Rc] = !1);
}
Xp.prototype = Au;
{
  let e;
  Yb
    ? (e =
        /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/)
    : (e =
        /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/),
    (Xp.parse = (t) => {
      const n = e.exec(t);
      if (n === null) return null;
      const r = n[1],
        i = n[2],
        a = Buffer.from(n[3], "base64"),
        s = n[4] || "",
        o = ot(a, a._pos, !0);
      return o === void 0 || o.indexOf(i) !== 0
        ? new Error("Malformed OpenSSH public key")
        : e1(a, i, s, r);
    });
}
function Dd(e, t, n, r, i) {
  (this.type = e),
    (this.comment = t),
    (this[pi] = null),
    (this[Bi] = n),
    (this[Wa] = r),
    (this[oa] = i),
    (this[Rc] = !1);
}
Dd.prototype = Au;
{
  const e =
      /^---- BEGIN SSH2 PUBLIC KEY ----(?:\r?\n)((?:.{0,72}\r?\n)+)---- END SSH2 PUBLIC KEY ----$/,
    t = /^[A-Z0-9a-z/+=\r\n]+$/,
    n = /^([\x21-\x39\x3B-\x7E]{1,64}): ((?:[^\\]*\\\r?\n)*[^\r\n]+)\r?\n/gm,
    r = /\\\r?\n/g;
  Dd.parse = (i) => {
    let a = e.exec(i);
    if (a === null) return null;
    const s = a[1];
    let o = 0,
      c = "";
    for (; (a = n.exec(s)); ) {
      const p = a[1],
        h = a[2].replace(r, "");
      if (h.length > 1024)
        return (n.lastIndex = 0), new Error("Malformed RFC4716 public key");
      (o = n.lastIndex),
        p.toLowerCase() === "comment" &&
          ((c = h),
          c.length > 1 &&
            c.charCodeAt(0) === 34 &&
            c.charCodeAt(c.length - 1) === 34 &&
            (c = c.slice(1, -1)));
    }
    let l = s.slice(o);
    if (!t.test(l)) return new Error("Malformed RFC4716 public key");
    l = Buffer.from(l, "base64");
    const f = ot(l, 0, !0);
    if (f === void 0) return new Error("Malformed RFC4716 public key");
    let u = null,
      d = null;
    switch (f) {
      case "ssh-rsa": {
        const p = ot(l, l._pos);
        if (p === void 0) return new Error("Malformed RFC4716 public key");
        const h = ot(l, l._pos);
        if (h === void 0) return new Error("Malformed RFC4716 public key");
        (u = _u(h, p)), (d = Eu(h, p));
        break;
      }
      case "ssh-dss": {
        const p = ot(l, l._pos);
        if (p === void 0) return new Error("Malformed RFC4716 public key");
        const h = ot(l, l._pos);
        if (h === void 0) return new Error("Malformed RFC4716 public key");
        const m = ot(l, l._pos);
        if (m === void 0) return new Error("Malformed RFC4716 public key");
        const g = ot(l, l._pos);
        if (g === void 0) return new Error("Malformed RFC4716 public key");
        (u = wu(p, h, m, g)), (d = xu(p, h, m, g));
        break;
      }
      default:
        return new Error("Malformed RFC4716 public key");
    }
    return new Dd(f, c, u, d, "sha1");
  };
}
function e1(e, t, n, r) {
  if (!ck(t)) return new Error(`Unsupported OpenSSH public key type: ${t}`);
  let i,
    a,
    s = null,
    o = null;
  switch (t) {
    case "ssh-rsa": {
      const c = ot(e, e._pos || 0);
      if (c === void 0) return new Error("Malformed OpenSSH public key");
      const l = ot(e, e._pos);
      if (l === void 0) return new Error("Malformed OpenSSH public key");
      (s = _u(l, c)), (o = Eu(l, c)), (i = "sha1");
      break;
    }
    case "ssh-dss": {
      const c = ot(e, e._pos || 0);
      if (c === void 0) return new Error("Malformed OpenSSH public key");
      const l = ot(e, e._pos);
      if (l === void 0) return new Error("Malformed OpenSSH public key");
      const f = ot(e, e._pos);
      if (f === void 0) return new Error("Malformed OpenSSH public key");
      const u = ot(e, e._pos);
      if (u === void 0) return new Error("Malformed OpenSSH public key");
      (s = wu(c, l, f, u)), (o = xu(c, l, f, u)), (i = "sha1");
      break;
    }
    case "ssh-ed25519": {
      const c = ot(e, e._pos || 0);
      if (c === void 0 || c.length !== 32)
        return new Error("Malformed OpenSSH public key");
      (s = sk(c)), (o = ok(c)), (i = null);
      break;
    }
    case "ecdsa-sha2-nistp256":
      (i = "sha256"), (a = "1.2.840.10045.3.1.7");
    case "ecdsa-sha2-nistp384":
      i === void 0 && ((i = "sha384"), (a = "1.3.132.0.34"));
    case "ecdsa-sha2-nistp521": {
      if ((i === void 0 && ((i = "sha512"), (a = "1.3.132.0.35")), !Xb(e, 1)))
        return new Error("Malformed OpenSSH public key");
      const c = ot(e, e._pos || 0);
      if (c === void 0) return new Error("Malformed OpenSSH public key");
      (s = Jb(a, c)), (o = Zb(a, c));
      break;
    }
    default:
      return new Error(`Unsupported OpenSSH public key type: ${t}`);
  }
  return new Xp(r, n, s, o, i);
}
function ck(e) {
  switch (e) {
    case "ssh-rsa":
    case "ssh-dss":
    case "ecdsa-sha2-nistp256":
    case "ecdsa-sha2-nistp384":
    case "ecdsa-sha2-nistp521":
      return !0;
    case "ssh-ed25519":
      if (Yb) return !0;
    default:
      return !1;
  }
}
function lk(e) {
  return e ? typeof e[Rc] == "boolean" : !1;
}
function uk(e, t) {
  if (lk(e)) return e;
  let n;
  if (Buffer.isBuffer(e)) (n = e), (e = e.utf8Slice(0, e.length).trim());
  else if (typeof e == "string") e = e.trim();
  else return new Error("Key data must be a Buffer or string");
  if (t != null) {
    if (typeof t == "string") t = Buffer.from(t);
    else if (!Buffer.isBuffer(t))
      return new Error("Passphrase must be a string or Buffer when supplied");
  }
  let r;
  if (
    (r = Nd.parse(e, t)) !== null ||
    (r = Od.parse(e, t)) !== null ||
    (r = Pd.parse(e, t)) !== null ||
    (r = Xp.parse(e)) !== null ||
    (r = Dd.parse(e)) !== null
  )
    return r;
  if (n) {
    kf.init(n, 0);
    const i = kf.readString(!0);
    i !== void 0 &&
      ((e = kf.readRaw()),
      e !== void 0 &&
        ((r = e1(e, i, "", i)), r instanceof Error && (r = null))),
      kf.clear();
  }
  return r || new Error("Unsupported key format");
}
var to = {
  isParsedKey: lk,
  isSupportedKeyType: ck,
  parseDERKey: (e, t) => e1(e, t, "", t),
  parseKey: uk,
};
const { Socket: fk } = ha,
  { Duplex: dk } = Kr,
  { resolve: Nte } = pt,
  { readFile: FA } = Xt,
  { execFile: Ote, spawn: Pte } = Ql,
  { isParsedKey: jA, parseKey: ol } = to,
  {
    makeBufferParser: Dte,
    readUInt32BE: t1,
    writeUInt32BE: kr,
    writeUInt32LE: MA,
  } = Ki();
function kl(e) {
  let t = !1;
  return (...n) => {
    t || ((t = !0), e(...n));
  };
}
function Lte(e, t) {
  const n = Buffer.allocUnsafe(e.length + t.length);
  return e.copy(n, 0), t.copy(n, e.length), n;
}
function j0() {}
const Bte = Buffer.alloc(0),
  _n = Dte();
let n1 = class {
    getIdentities(t) {
      t(new Error("Missing getIdentities() implementation"));
    }
    sign(t, n, r, i) {
      typeof r == "function" && (i = r),
        i(new Error("Missing sign() implementation"));
    }
  },
  Jp = class extends n1 {
    constructor(t) {
      super(), (this.socketPath = t);
    }
    getStream(t) {
      t = kl(t);
      const n = new fk();
      n.on("connect", () => {
        t(null, n);
      }),
        n.on("close", r).on("end", r).on("error", r),
        n.connect(this.socketPath);
      function r() {
        try {
          n.destroy();
        } catch {}
        t(new Error("Failed to connect to agent"));
      }
    }
    getIdentities(t) {
      (t = kl(t)),
        this.getStream((n, r) => {
          function i(s) {
            if (r)
              try {
                r.destroy();
              } catch {}
            s || (s = new Error("Failed to retrieve identities from agent")),
              t(s);
          }
          if (n) return i(n);
          const a = new M0(!0);
          a.on("error", i),
            a.pipe(r).pipe(a),
            r.on("close", i).on("end", i).on("error", i),
            a.getIdentities((s, o) => {
              if (s) return i(s);
              try {
                r.destroy();
              } catch {}
              t(null, o);
            });
        });
    }
    sign(t, n, r, i) {
      typeof r == "function"
        ? ((i = r), (r = void 0))
        : (typeof r != "object" || r === null) && (r = void 0),
        (i = kl(i)),
        this.getStream((a, s) => {
          function o(l) {
            if (s)
              try {
                s.destroy();
              } catch {}
            l || (l = new Error("Failed to sign data with agent")), i(l);
          }
          if (a) return o(a);
          const c = new M0(!0);
          c.on("error", o),
            c.pipe(s).pipe(c),
            s.on("close", o).on("end", o).on("error", o),
            c.sign(t, n, r, (l, f) => {
              if (l) return o(l);
              try {
                s.destroy();
              } catch {}
              i(null, f);
            });
        });
    }
  };
const pk = (() => {
    const s = Nte(__dirname, "..", "util/pagent.exe"),
      o = {
        10: new Error("Invalid pagent.exe arguments"),
        11: new Error("Pageant is not running"),
        12: new Error("pagent.exe could not create an mmap"),
        13: new Error("pagent.exe could not set mode for stdin"),
        14: new Error("pagent.exe could not set mode for stdout"),
        15: new Error("pagent.exe did not get expected input payload"),
      };
    function c(f) {
      (f.buffer = null), f.proc && (f.proc.kill(), (f.proc = void 0));
    }
    class l extends dk {
      constructor() {
        super(), (this.proc = void 0), (this.buffer = null);
      }
      _read(u) {}
      _write(u, d, p) {
        if (this.buffer === null) this.buffer = u;
        else {
          const v = Buffer.allocUnsafe(this.buffer.length + u.length);
          this.buffer.copy(v, 0),
            u.copy(v, this.buffer.length),
            (this.buffer = v);
        }
        if (this.buffer.length < 4) return p();
        const h = t1(this.buffer, 0);
        if (this.buffer.length - 4 < h) return p();
        if (((u = this.buffer.slice(0, 4 + h)), this.buffer.length > 4 + h))
          return p(new Error("Unexpected multiple agent requests"));
        this.buffer = null;
        let m;
        const g = (this.proc = Pte(s, [u.length]));
        g.stdout.on("data", (v) => {
          this.push(v);
        }),
          g.on("error", (v) => {
            (m = v), p(m);
          }),
          g.on("close", (v) => {
            if (((this.proc = void 0), !m)) {
              if ((m = o[v])) return p(m);
              p();
            }
          }),
          g.stdin.end(u);
      }
      _final(u) {
        c(this), u();
      }
      _destroy(u, d) {
        c(this), d();
      }
    }
    return class extends Jp {
      getStream(u) {
        u(null, new l());
      }
    };
  })(),
  hk = (() => {
    const e =
      /^!<socket >(\d+) s ([A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8})/;
    return class extends Jp {
      getStream(n) {
        n = kl(n);
        let r = this.socketPath,
          i = !1;
        FA(r, function a(s, o) {
          if (s) {
            if (i) return n(new Error("Invalid cygwin unix socket path"));
            Ote("cygpath", ["-w", r], (A, I, S) => {
              if (A || I.length === 0)
                return n(new Error("Invalid cygwin unix socket path"));
              (i = !0), (r = I.toString().replace(/[\r\n]/g, "")), FA(r, a);
            });
            return;
          }
          const c = e.exec(o.toString("ascii"));
          if (!c) return n(new Error("Malformed cygwin unix socket file"));
          let l,
            f = 0,
            u = !1;
          const d = [];
          let p,
            h = Buffer.alloc(12);
          const m = parseInt(c[1], 10),
            g = c[2].replace(/-/g, ""),
            v = Buffer.allocUnsafe(16);
          for (let A = 0, I = 0; I < 32; ++A, I += 2)
            v[A] = parseInt(g.substring(I, I + 2), 16);
          for (let A = 0; A < 16; A += 4) MA(v, t1(v, A), A);
          R();
          function y() {
            (f = 0), (l = "secret"), p.write(v);
          }
          function _(A) {
            if (((f += A.length), l === "secret")) {
              f === 16 && ((f = 0), (l = "creds"), p.write(h));
              return;
            }
            if (l === "creds" && (u || d.push(A), f === 12)) {
              if (
                (p.removeListener("connect", y),
                p.removeListener("data", _),
                p.removeListener("error", E),
                p.removeListener("end", E),
                p.removeListener("close", E),
                u)
              )
                return n(null, p);
              (u = !0),
                (h = Buffer.concat(d)),
                MA(h, process.pid, 0),
                p.on("error", () => {}),
                p.destroy(),
                R();
            }
          }
          function E() {
            n(new Error("Problem negotiating cygwin unix socket security"));
          }
          function R() {
            (p = new fk()),
              p.on("connect", y),
              p.on("data", _),
              p.on("error", E),
              p.on("end", E),
              p.on("close", E),
              p.connect(m);
          }
        });
      }
    };
  })(),
  Ute = /^[/\\][/\\]\.[/\\]pipe[/\\].+/;
function mk(e) {
  return process.platform === "win32" && !Ute.test(e)
    ? e === "pageant"
      ? new pk()
      : new hk(e)
    : new Jp(e);
}
const M0 = (() => {
    function l(S) {
      let w;
      for (; S[y].length; ) {
        const O = S[y][0][u];
        if (O === void 0) break;
        S[y].shift(), (w = S.push(O));
      }
      return w;
    }
    const f = Symbol("Inbound Request Type"),
      u = Symbol("Inbound Request Response"),
      d = Symbol("Inbound Request Context");
    class p {
      constructor(w, O) {
        (this[f] = w), (this[u] = void 0), (this[d] = O);
      }
      hasResponded() {
        return this[u] !== void 0;
      }
      getType() {
        return this[f];
      }
      getContext() {
        return this[d];
      }
    }
    function h(S, w, O) {
      return (w[u] = O), l(S);
    }
    function m(S) {
      if (((S[E] = null), S[_] === 0)) {
        const w = S[y];
        if (w && w.length) {
          S[y] = [];
          for (const O of w) O.cb(new Error("No reply from server"));
        }
      }
      try {
        S.end();
      } catch {}
      setImmediate(() => {
        S[I] || S.emit("end"), S[A] || S.emit("close");
      });
    }
    function g() {
      this[A] = !0;
    }
    function v() {
      this[I] = !0;
    }
    const y = Symbol("Requests"),
      _ = Symbol("Agent Protocol Role"),
      E = Symbol("Agent Protocol Buffer"),
      R = Symbol("Agent Protocol Current Message Length"),
      A = Symbol("Agent Protocol Closed"),
      I = Symbol("Agent Protocol Ended");
    return class extends dk {
      constructor(w) {
        super({ autoDestroy: !0, emitClose: !1 }),
          (this[_] = w ? 0 : 1),
          (this[y] = []),
          (this[E] = null),
          (this[R] = -1),
          this.once("end", v),
          this.once("close", g);
      }
      _read(w) {}
      _write(w, O, Q) {
        this[E] === null ? (this[E] = w) : (this[E] = Lte(this[E], w));
        let j = this[E],
          H = j.length,
          q = 0;
        for (
          ;
          q < H &&
          !(H < 5 || (this[R] === -1 && (this[R] = t1(j, q)), H < 4 + this[R]));

        ) {
          const J = j[(q += 4)];
          if ((++q, this[_] === 0)) {
            if (this[y].length === 0)
              return Q(new Error("Received unexpected message from server"));
            const Z = this[y].shift();
            switch (J) {
              case 5:
                Z.cb(new Error("Agent responded with failure"));
                break;
              case 12: {
                if (Z.type !== 11)
                  return Q(
                    new Error("Agent responded with wrong message type"),
                  );
                _n.init(j, q);
                const z = _n.readUInt32BE();
                if (z === void 0)
                  return _n.clear(), Q(new Error("Malformed agent response"));
                const U = [];
                for (let G = 0; G < z; ++G) {
                  let L = _n.readString();
                  if (L === void 0)
                    return _n.clear(), Q(new Error("Malformed agent response"));
                  const k = _n.readString(!0);
                  if (k === void 0)
                    return _n.clear(), Q(new Error("Malformed agent response"));
                  (L = ol(L)),
                    !(L instanceof Error) &&
                      ((L.comment = L.comment || k), U.push(L));
                }
                (q = _n.pos()), _n.clear(), Z.cb(null, U);
                break;
              }
              case 14: {
                if (Z.type !== 13)
                  return Q(
                    new Error("Agent responded with wrong message type"),
                  );
                _n.init(j, q);
                let z = _n.readString();
                if (((q = _n.pos()), _n.clear(), z === void 0))
                  return Q(new Error("Malformed agent response"));
                if (
                  (_n.init(z, 0),
                  _n.readString(!0),
                  (z = _n.readString()),
                  _n.clear(),
                  z === void 0)
                )
                  return Q(new Error("Malformed OpenSSH signature format"));
                Z.cb(null, z);
                break;
              }
              default:
                return Q(
                  new Error("Agent responded with unsupported message type"),
                );
            }
          } else
            switch (J) {
              case 11: {
                const Z = new p(J);
                this[y].push(Z), this.emit("identities", Z);
                break;
              }
              case 13: {
                _n.init(j, q);
                let Z = _n.readString();
                const z = _n.readString(),
                  U = _n.readUInt32BE();
                if (((q = _n.pos()), _n.clear(), U === void 0)) {
                  const W = new p(J);
                  return this[y].push(W), this.failureReply(W);
                }
                if (((Z = ol(Z)), Z instanceof Error)) {
                  const W = new p(J);
                  return this[y].push(W), this.failureReply(W);
                }
                const G = { hash: void 0 };
                let L;
                Z.type === "ssh-rsa" &&
                  (U & 2
                    ? ((L = "rsa-sha2-256"), (G.hash = "sha256"))
                    : U & 4 && ((L = "rsa-sha2-512"), (G.hash = "sha512"))),
                  L === void 0 && (L = Z.type);
                const k = new p(J, L);
                this[y].push(k), this.emit("sign", k, Z, z, G);
                break;
              }
              default: {
                const Z = new p(J);
                this[y].push(Z), this.failureReply(Z);
              }
            }
          if (((this[R] = -1), q === H)) {
            this[E] = null;
            break;
          } else (this[E] = j = j.slice(q)), (H = j.length), (q = 0);
        }
        Q();
      }
      _destroy(w, O) {
        m(this), O();
      }
      _final(w) {
        m(this), w();
      }
      sign(w, O, Q, j) {
        if (this[_] !== 0)
          throw new Error("Client-only method called with server role");
        typeof Q == "function"
          ? ((j = Q), (Q = void 0))
          : (typeof Q != "object" || Q === null) && (Q = void 0);
        let H = 0;
        if (((w = ol(w)), w instanceof Error))
          throw new Error("Invalid public key argument");
        if (w.type === "ssh-rsa" && Q)
          switch (Q.hash) {
            case "sha256":
              H = 2;
              break;
            case "sha512":
              H = 4;
              break;
          }
        w = w.getPublicSSH();
        const q = 13,
          J = w.length,
          Z = O.length;
        let z = 0;
        const U = Buffer.allocUnsafe(4 + 1 + 4 + J + 4 + Z + 4);
        return (
          kr(U, U.length - 4, z),
          (U[(z += 4)] = q),
          kr(U, J, ++z),
          w.copy(U, (z += 4)),
          kr(U, Z, (z += J)),
          O.copy(U, (z += 4)),
          kr(U, H, (z += Z)),
          typeof j != "function" && (j = j0),
          this[y].push({ type: q, cb: j }),
          this.push(U)
        );
      }
      getIdentities(w) {
        if (this[_] !== 0)
          throw new Error("Client-only method called with server role");
        const O = 11;
        let Q = 0;
        const j = Buffer.allocUnsafe(4 + 1);
        return (
          kr(j, j.length - 4, Q),
          (j[(Q += 4)] = O),
          typeof w != "function" && (w = j0),
          this[y].push({ type: O, cb: w }),
          this.push(j)
        );
      }
      failureReply(w) {
        if (this[_] !== 1)
          throw new Error("Server-only method called with client role");
        if (!(w instanceof p)) throw new Error("Wrong request argument");
        if (w.hasResponded()) return !0;
        let O = 0;
        const Q = Buffer.allocUnsafe(4 + 1);
        return kr(Q, Q.length - 4, O), (Q[(O += 4)] = 5), h(this, w, Q);
      }
      getIdentitiesReply(w, O) {
        if (this[_] !== 1)
          throw new Error("Server-only method called with client role");
        if (!(w instanceof p)) throw new Error("Wrong request argument");
        if (w.hasResponded()) return !0;
        if (w.getType() !== 11) throw new Error("Invalid response to request");
        if (!Array.isArray(O))
          throw new Error("Keys argument must be an array");
        let Q = 4;
        const j = [];
        for (let J = 0; J < O.length; ++J) {
          const Z = O[J];
          if (typeof Z != "object" || Z === null)
            throw new Error(`Invalid key entry: ${Z}`);
          let z, U;
          if (jA(Z)) z = Z;
          else if (jA(Z.pubKey)) z = Z.pubKey;
          else if (
            typeof Z.pubKey != "object" ||
            Z.pubKey === null ||
            (({ pubKey: z, comment: U } = Z.pubKey),
            (z = ol(z)),
            z instanceof Error)
          )
            continue;
          (U = z.comment || U),
            (z = z.getPublicSSH()),
            (Q += 4 + z.length),
            U && typeof U == "string"
              ? (U = Buffer.from(U))
              : Buffer.isBuffer(U) || (U = Bte),
            (Q += 4 + U.length),
            j.push({ pubKey: z, comment: U });
        }
        let H = 0;
        const q = Buffer.allocUnsafe(4 + 1 + Q);
        kr(q, q.length - 4, H),
          (q[(H += 4)] = 12),
          kr(q, j.length, ++H),
          (H += 4);
        for (let J = 0; J < j.length; ++J) {
          const { pubKey: Z, comment: z } = j[J];
          kr(q, Z.length, H),
            Z.copy(q, (H += 4)),
            kr(q, z.length, (H += Z.length)),
            (H += 4),
            z.length && (z.copy(q, H), (H += z.length));
        }
        return h(this, w, q);
      }
      signReply(w, O) {
        if (this[_] !== 1)
          throw new Error("Server-only method called with client role");
        if (!(w instanceof p)) throw new Error("Wrong request argument");
        if (w.hasResponded()) return !0;
        if (w.getType() !== 13) throw new Error("Invalid response to request");
        if (!Buffer.isBuffer(O))
          throw new Error("Signature argument must be a Buffer");
        if (O.length === 0)
          throw new Error("Signature argument must be non-empty");
        let Q = 0;
        const j = w.getContext(),
          H = Buffer.byteLength(j),
          q = Buffer.allocUnsafe(4 + 1 + 4 + 4 + H + 4 + O.length);
        return (
          kr(q, q.length - 4, Q),
          (q[(Q += 4)] = 14),
          kr(q, 4 + H + 4 + O.length, ++Q),
          kr(q, H, (Q += 4)),
          q.utf8Write(j, (Q += 4), H),
          kr(q, O.length, (Q += H)),
          O.copy(q, (Q += 4)),
          h(this, w, q)
        );
      }
    };
  })(),
  Xm = Symbol("Agent"),
  si = Symbol("Agent Keys"),
  Ji = Symbol("Agent Keys Index"),
  vo = Symbol("Agent Init Callbacks");
let Fte = class {
  constructor(t) {
    if (typeof t == "string") t = mk(t);
    else if (!gk(t)) throw new Error("Invalid agent argument");
    (this[Xm] = t), (this[si] = null), (this[Ji] = -1), (this[vo] = null);
  }
  init(t) {
    if ((typeof t != "function" && (t = j0), this[si] === null))
      if (this[vo] === null) {
        this[vo] = [t];
        const n = (...r) => {
          process.nextTick(() => {
            const i = this[vo];
            this[vo] = null;
            for (const a of i) a(...r);
          });
        };
        this[Xm].getIdentities(
          kl((r, i) => {
            if (r) return n(r);
            if (!Array.isArray(i))
              return n(
                new Error("Agent implementation failed to provide keys"),
              );
            const a = [];
            for (let s of i) (s = ol(s)), !(s instanceof Error) && a.push(s);
            (this[si] = a), (this[Ji] = -1), n();
          }),
        );
      } else this[vo].push(t);
    else process.nextTick(t);
  }
  nextKey() {
    return this[si] === null || ++this[Ji] >= this[si].length
      ? !1
      : this[si][this[Ji]];
  }
  currentKey() {
    return this[si] === null || this[Ji] >= this[si].length
      ? null
      : this[si][this[Ji]];
  }
  pos() {
    return this[si] === null || this[Ji] >= this[si].length ? -1 : this[Ji];
  }
  reset() {
    this[Ji] = -1;
  }
  sign(...t) {
    this[Xm].sign(...t);
  }
};
function gk(e) {
  return e instanceof n1;
}
var vk = {
    AgentContext: Fte,
    AgentProtocol: M0,
    BaseAgent: n1,
    createAgent: mk,
    CygwinAgent: hk,
    isAgent: gk,
    OpenSSHAgent: Jp,
    PageantAgent: pk,
  },
  yk = {};
const { kMaxLength: jte } = ks,
  {
    createInflate: Mte,
    constants: {
      DEFLATE: Hte,
      INFLATE: qte,
      Z_DEFAULT_CHUNK: Gte,
      Z_DEFAULT_COMPRESSION: Qte,
      Z_DEFAULT_MEMLEVEL: Wte,
      Z_DEFAULT_STRATEGY: zte,
      Z_DEFAULT_WINDOWBITS: Kte,
      Z_PARTIAL_FLUSH: Vte,
    },
  } = mc,
  Yte = Mte()._handle.constructor;
function Xte() {
  throw new Error("Should not get here");
}
function Jte(e, t, n) {
  const r = this._owner,
    i = new Error(e);
  (i.errno = t), (i.code = n), (r._err = i);
}
function r1(e) {
  e._handle && (e._handle.close(), (e._handle = null));
}
class bk {
  constructor(t) {
    const n = Kte,
      r = Qte,
      i = Wte,
      a = zte,
      s = void 0;
    (this._err = void 0),
      (this._writeState = new Uint32Array(2)),
      (this._chunkSize = Gte),
      (this._maxOutputLength = jte),
      (this._outBuffer = Buffer.allocUnsafe(this._chunkSize)),
      (this._outOffset = 0),
      (this._handle = new Yte(t)),
      (this._handle._owner = this),
      (this._handle.onerror = Jte),
      this._handle.init(n, r, i, a, this._writeState, Xte, s);
  }
  writeSync(t, n) {
    const r = this._handle;
    if (!r) throw new Error("Invalid Zlib instance");
    let i = t.length,
      a = this._chunkSize - this._outOffset,
      s = 0,
      o,
      c,
      l,
      f = 0;
    const u = this._writeState;
    let d = this._outBuffer,
      p = this._outOffset;
    const h = this._chunkSize;
    for (;;) {
      if ((r.writeSync(Vte, t, s, i, d, p, a), this._err)) throw this._err;
      (o = u[0]), (c = u[1]);
      const g = i - c,
        v = a - o;
      if (v > 0) {
        const y = p === 0 && v === d.length ? d : d.slice(p, p + v);
        if (
          ((p += v),
          l ? (l.push === void 0 ? (l = [l, y]) : l.push(y)) : (l = y),
          (f += y.byteLength),
          f > this._maxOutputLength)
        )
          throw (
            (r1(this),
            new Error(
              `Output length exceeded maximum of ${this._maxOutputLength}`,
            ))
          );
      } else if (v !== 0) throw new Error("have should not go down");
      if (
        ((o === 0 || p >= h) && ((a = h), (p = 0), (d = Buffer.allocUnsafe(h))),
        o === 0)
      )
        (s += g), (i = c);
      else break;
    }
    if (
      ((this._outBuffer = d),
      (this._outOffset = p),
      f === 0 && (l = Buffer.alloc(0)),
      n)
    )
      return (l.totalLen = f), l;
    if (l.push === void 0) return l;
    const m = Buffer.allocUnsafe(f);
    for (let g = 0, v = 0; g < l.length; ++g) {
      const y = l[g];
      m.set(y, v), (v += y.length);
    }
    return m;
  }
}
let Zte = class {
    constructor(t) {
      (this.allocStart = 0),
        (this.allocStartKEX = 0),
        (this._protocol = t),
        (this._zlib = new bk(Hte));
    }
    cleanup() {
      this._zlib && r1(this._zlib);
    }
    alloc(t, n) {
      return Buffer.allocUnsafe(t);
    }
    finalize(t, n) {
      if (this._protocol._kexinit === void 0 || n) {
        const r = this._zlib.writeSync(t, !0),
          i = this._protocol._cipher.allocPacket(r.totalLen);
        if (r.push === void 0) i.set(r, 5);
        else
          for (let a = 0, s = 5; a < r.length; ++a) {
            const o = r[a];
            i.set(o, s), (s += o.length);
          }
        return i;
      }
      return t;
    }
  },
  ene = class {
    constructor(t) {
      (this.allocStart = 5), (this.allocStartKEX = 5), (this._protocol = t);
    }
    cleanup() {}
    alloc(t, n) {
      return this._protocol._kexinit === void 0 || n
        ? this._protocol._cipher.allocPacket(t)
        : Buffer.allocUnsafe(t);
    }
    finalize(t, n) {
      return t;
    }
  },
  tne = class {
    constructor() {
      this._zlib = new bk(qte);
    }
    cleanup() {
      this._zlib && r1(this._zlib);
    }
    read(t) {
      return this._zlib.writeSync(t, !1);
    }
  },
  nne = class {
    cleanup() {}
    read(t) {
      return t;
    }
  };
var _k = {
  PacketReader: nne,
  PacketWriter: ene,
  ZlibPacketReader: tne,
  ZlibPacketWriter: Zte,
};
const {
    bufferSlice: Jm,
    bufferParser: de,
    doFatalError: sn,
    sigSSHToASN1: HA,
    writeUInt32BE: qA,
  } = Ki(),
  {
    CHANNEL_OPEN_FAILURE: rne,
    COMPAT: ine,
    MESSAGE: un,
    TERMINAL_MODE: Ek,
  } = es(),
  { parseKey: ane } = to,
  sne = Array.from(Object.entries(Ek)).reduce(
    (e, [t, n]) => ({ ...e, [t]: n }),
    {},
  );
var one = {
    [un.DISCONNECT]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readString(!0),
        i = de.readString();
      if ((de.clear(), i === void 0))
        return sn(e, "Inbound: Malformed DISCONNECT packet");
      e._debug && e._debug(`Inbound: Received DISCONNECT (${n}, "${r}")`);
      const a = e._handlers.DISCONNECT;
      a && a(e, n, r);
    },
    [un.IGNORE]: (e, t) => {
      e._debug && e._debug("Inbound: Received IGNORE");
    },
    [un.UNIMPLEMENTED]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE();
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed UNIMPLEMENTED packet");
      e._debug && e._debug(`Inbound: Received UNIMPLEMENTED (seqno ${n})`);
    },
    [un.DEBUG]: (e, t) => {
      de.init(t, 1);
      const n = de.readBool(),
        r = de.readString(!0),
        i = de.readString();
      if ((de.clear(), i === void 0))
        return sn(e, "Inbound: Malformed DEBUG packet");
      e._debug && e._debug("Inbound: Received DEBUG");
      const a = e._handlers.DEBUG;
      a && a(e, n, r);
    },
    [un.SERVICE_REQUEST]: (e, t) => {
      de.init(t, 1);
      const n = de.readString(!0);
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed SERVICE_REQUEST packet");
      e._debug && e._debug(`Inbound: Received SERVICE_REQUEST (${n})`);
      const r = e._handlers.SERVICE_REQUEST;
      r && r(e, n);
    },
    [un.SERVICE_ACCEPT]: (e, t) => {
      de.init(t, 1);
      const n = de.readString(!0);
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed SERVICE_ACCEPT packet");
      e._debug && e._debug(`Inbound: Received SERVICE_ACCEPT (${n})`);
      const r = e._handlers.SERVICE_ACCEPT;
      r && r(e, n);
    },
    [un.EXT_INFO]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE();
      let r;
      if (n !== void 0) {
        r = [];
        for (let a = 0; a < n; ++a) {
          const s = de.readString(!0),
            o = de.readString();
          if (o !== void 0)
            switch (s) {
              case "server-sig-algs": {
                const c = o.latin1Slice(0, o.length).split(",");
                r.push({ name: s, algs: c });
                continue;
              }
              default:
                continue;
            }
          r = void 0;
          break;
        }
      }
      if ((de.clear(), r === void 0))
        return sn(e, "Inbound: Malformed EXT_INFO packet");
      e._debug && e._debug("Inbound: Received EXT_INFO");
      const i = e._handlers.EXT_INFO;
      i && i(e, r);
    },
    [un.USERAUTH_REQUEST]: (e, t) => {
      de.init(t, 1);
      const n = de.readString(!0),
        r = de.readString(!0),
        i = de.readString(!0);
      let a, s;
      switch (i) {
        case "none":
          a = null;
          break;
        case "password": {
          const c = de.readBool();
          if (c !== void 0 && ((a = de.readString(!0)), a !== void 0 && c)) {
            const l = de.readString(!0);
            l !== void 0
              ? (a = { oldPassword: a, newPassword: l })
              : (a = void 0);
          }
          break;
        }
        case "publickey": {
          const c = de.readBool();
          if (c !== void 0) {
            const l = de.readString(!0);
            let f = l;
            const u = de.readString();
            let d;
            switch (l) {
              case "rsa-sha2-256":
                (f = "ssh-rsa"), (d = "sha256");
                break;
              case "rsa-sha2-512":
                (f = "ssh-rsa"), (d = "sha512");
                break;
            }
            if (c) {
              const p = de.pos();
              let h = de.readString();
              if (
                h !== void 0 &&
                (h.length > 4 + l.length + 4 &&
                  h.utf8Slice(4, 4 + l.length) === l &&
                  (h = Jm(h, 4 + l.length + 4)),
                (h = HA(h, f)),
                h)
              ) {
                const m = e._kex.sessionID,
                  g = Buffer.allocUnsafe(4 + m.length + p);
                qA(g, m.length, 0),
                  g.set(m, 4),
                  g.set(
                    new Uint8Array(t.buffer, t.byteOffset, p),
                    4 + m.length,
                  ),
                  (a = {
                    keyAlgo: f,
                    key: u,
                    signature: h,
                    blob: g,
                    hashAlgo: d,
                  });
              }
            } else
              (a = { keyAlgo: f, key: u, hashAlgo: d }),
                (s = "publickey -- check");
          }
          break;
        }
        case "hostbased": {
          const c = de.readString(!0);
          let l = c;
          const f = de.readString(),
            u = de.readString(!0),
            d = de.readString(!0);
          let p;
          switch (c) {
            case "rsa-sha2-256":
              (l = "ssh-rsa"), (p = "sha256");
              break;
            case "rsa-sha2-512":
              (l = "ssh-rsa"), (p = "sha512");
              break;
          }
          const h = de.pos();
          let m = de.readString();
          if (
            m !== void 0 &&
            (m.length > 4 + c.length + 4 &&
              m.utf8Slice(4, 4 + c.length) === c &&
              (m = Jm(m, 4 + c.length + 4)),
            (m = HA(m, l)),
            m !== void 0)
          ) {
            const g = e._kex.sessionID,
              v = Buffer.allocUnsafe(4 + g.length + h);
            qA(v, g.length, 0),
              v.set(g, 4),
              v.set(new Uint8Array(t.buffer, t.byteOffset, h), 4 + g.length),
              (a = {
                keyAlgo: l,
                key: f,
                signature: m,
                blob: v,
                localHostname: u,
                localUsername: d,
                hashAlgo: p,
              });
          }
          break;
        }
        case "keyboard-interactive":
          de.skipString(), (a = de.readList());
          break;
        default:
          i !== void 0 && (a = de.readRaw());
      }
      if ((de.clear(), a === void 0))
        return sn(e, "Inbound: Malformed USERAUTH_REQUEST packet");
      s === void 0 && (s = i),
        e._authsQueue.push(i),
        e._debug && e._debug(`Inbound: Received USERAUTH_REQUEST (${s})`);
      const o = e._handlers.USERAUTH_REQUEST;
      o && o(e, n, r, i, a);
    },
    [un.USERAUTH_FAILURE]: (e, t) => {
      de.init(t, 1);
      const n = de.readList(),
        r = de.readBool();
      if ((de.clear(), r === void 0))
        return sn(e, "Inbound: Malformed USERAUTH_FAILURE packet");
      e._debug && e._debug(`Inbound: Received USERAUTH_FAILURE (${n})`),
        e._authsQueue.shift();
      const i = e._handlers.USERAUTH_FAILURE;
      i && i(e, n, r);
    },
    [un.USERAUTH_SUCCESS]: (e, t) => {
      e._debug && e._debug("Inbound: Received USERAUTH_SUCCESS"),
        e._authsQueue.shift();
      const n = e._handlers.USERAUTH_SUCCESS;
      n && n(e);
    },
    [un.USERAUTH_BANNER]: (e, t) => {
      de.init(t, 1);
      const n = de.readString(!0),
        r = de.readString();
      if ((de.clear(), r === void 0))
        return sn(e, "Inbound: Malformed USERAUTH_BANNER packet");
      e._debug && e._debug("Inbound: Received USERAUTH_BANNER");
      const i = e._handlers.USERAUTH_BANNER;
      i && i(e, n);
    },
    60: (e, t) => {
      if (!e._authsQueue.length) {
        e._debug && e._debug("Inbound: Received payload type 60 without auth");
        return;
      }
      switch (e._authsQueue[0]) {
        case "password": {
          de.init(t, 1);
          const n = de.readString(!0),
            r = de.readString();
          if ((de.clear(), r === void 0))
            return sn(e, "Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet");
          e._debug && e._debug("Inbound: Received USERAUTH_PASSWD_CHANGEREQ");
          const i = e._handlers.USERAUTH_PASSWD_CHANGEREQ;
          i && i(e, n);
          break;
        }
        case "publickey": {
          de.init(t, 1);
          const n = de.readString(!0),
            r = de.readString();
          if ((de.clear(), r === void 0))
            return sn(e, "Inbound: Malformed USERAUTH_PK_OK packet");
          e._debug && e._debug("Inbound: Received USERAUTH_PK_OK"),
            e._authsQueue.shift();
          const i = e._handlers.USERAUTH_PK_OK;
          i && i(e, n, r);
          break;
        }
        case "keyboard-interactive": {
          de.init(t, 1);
          const n = de.readString(!0),
            r = de.readString(!0);
          de.readString();
          const i = de.readUInt32BE();
          let a;
          if (i !== void 0) {
            a = new Array(i);
            let o;
            for (o = 0; o < i; ++o) {
              const c = de.readString(!0),
                l = de.readBool();
              if (l === void 0) break;
              a[o] = { prompt: c, echo: l };
            }
            o !== i && (a = void 0);
          }
          if ((de.clear(), a === void 0))
            return sn(e, "Inbound: Malformed USERAUTH_INFO_REQUEST packet");
          e._debug && e._debug("Inbound: Received USERAUTH_INFO_REQUEST");
          const s = e._handlers.USERAUTH_INFO_REQUEST;
          s && s(e, n, r, a);
          break;
        }
        default:
          e._debug && e._debug("Inbound: Received unexpected payload type 60");
      }
    },
    61: (e, t) => {
      if (!e._authsQueue.length) {
        e._debug && e._debug("Inbound: Received payload type 61 without auth");
        return;
      }
      if (e._authsQueue[0] !== "keyboard-interactive")
        return sn(e, "Inbound: Received unexpected payload type 61");
      de.init(t, 1);
      const n = de.readUInt32BE();
      let r;
      if (n !== void 0) {
        r = new Array(n);
        let a;
        for (a = 0; a < n; ++a) {
          const s = de.readString(!0);
          if (s === void 0) break;
          r[a] = s;
        }
        a !== n && (r = void 0);
      }
      if ((de.clear(), r === void 0))
        return sn(e, "Inbound: Malformed USERAUTH_INFO_RESPONSE packet");
      e._debug && e._debug("Inbound: Received USERAUTH_INFO_RESPONSE");
      const i = e._handlers.USERAUTH_INFO_RESPONSE;
      i && i(e, r);
    },
    [un.GLOBAL_REQUEST]: (e, t) => {
      de.init(t, 1);
      const n = de.readString(!0),
        r = de.readBool();
      let i;
      if (r !== void 0)
        switch (n) {
          case "tcpip-forward":
          case "cancel-tcpip-forward": {
            const s = de.readString(!0),
              o = de.readUInt32BE();
            o !== void 0 && (i = { bindAddr: s, bindPort: o });
            break;
          }
          case "streamlocal-forward@openssh.com":
          case "cancel-streamlocal-forward@openssh.com": {
            const s = de.readString(!0);
            s !== void 0 && (i = { socketPath: s });
            break;
          }
          case "no-more-sessions@openssh.com":
            i = null;
            break;
          case "hostkeys-00@openssh.com": {
            for (i = []; de.avail() > 0; ) {
              const s = de.readString();
              if (s === void 0) {
                i = void 0;
                break;
              }
              const o = ane(s);
              o instanceof Error || i.push(o);
            }
            break;
          }
          default:
            i = de.readRaw();
        }
      if ((de.clear(), i === void 0))
        return sn(e, "Inbound: Malformed GLOBAL_REQUEST packet");
      e._debug && e._debug(`Inbound: GLOBAL_REQUEST (${n})`);
      const a = e._handlers.GLOBAL_REQUEST;
      a ? a(e, n, r, i) : e.requestFailure();
    },
    [un.REQUEST_SUCCESS]: (e, t) => {
      const n = t.length > 1 ? Jm(t, 1) : null;
      e._debug && e._debug("Inbound: REQUEST_SUCCESS");
      const r = e._handlers.REQUEST_SUCCESS;
      r && r(e, n);
    },
    [un.REQUEST_FAILURE]: (e, t) => {
      e._debug && e._debug("Inbound: Received REQUEST_FAILURE");
      const n = e._handlers.REQUEST_FAILURE;
      n && n(e);
    },
    [un.CHANNEL_OPEN]: (e, t) => {
      de.init(t, 1);
      const n = de.readString(!0),
        r = de.readUInt32BE(),
        i = de.readUInt32BE(),
        a = de.readUInt32BE();
      let s;
      switch (n) {
        case "forwarded-tcpip":
        case "direct-tcpip": {
          const c = de.readString(!0),
            l = de.readUInt32BE(),
            f = de.readString(!0),
            u = de.readUInt32BE();
          u !== void 0 &&
            (s = {
              type: n,
              sender: r,
              window: i,
              packetSize: a,
              data: { destIP: c, destPort: l, srcIP: f, srcPort: u },
            });
          break;
        }
        case "forwarded-streamlocal@openssh.com":
        case "direct-streamlocal@openssh.com": {
          const c = de.readString(!0);
          c !== void 0 &&
            (s = {
              type: n,
              sender: r,
              window: i,
              packetSize: a,
              data: { socketPath: c },
            });
          break;
        }
        case "x11": {
          const c = de.readString(!0),
            l = de.readUInt32BE();
          l !== void 0 &&
            (s = {
              type: n,
              sender: r,
              window: i,
              packetSize: a,
              data: { srcIP: c, srcPort: l },
            });
          break;
        }
        default:
          s = { type: n, sender: r, window: i, packetSize: a, data: {} };
      }
      if ((de.clear(), s === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_OPEN packet");
      e._debug && e._debug(`Inbound: CHANNEL_OPEN (s:${r}, ${n})`);
      const o = e._handlers.CHANNEL_OPEN;
      o
        ? o(e, s)
        : e.channelOpenFail(s.sender, rne.ADMINISTRATIVELY_PROHIBITED, "", "");
    },
    [un.CHANNEL_OPEN_CONFIRMATION]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readUInt32BE(),
        i = de.readUInt32BE(),
        a = de.readUInt32BE(),
        s = de.avail() ? de.readRaw() : void 0;
      if ((de.clear(), a === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet");
      e._debug &&
        e._debug(`Inbound: CHANNEL_OPEN_CONFIRMATION (r:${n}, s:${r})`);
      const o = e._handlers.CHANNEL_OPEN_CONFIRMATION;
      o && o(e, { recipient: n, sender: r, window: i, packetSize: a, data: s });
    },
    [un.CHANNEL_OPEN_FAILURE]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readUInt32BE(),
        i = de.readString(!0),
        a = de.readString();
      if ((de.clear(), a === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_OPEN_FAILURE packet");
      e._debug && e._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${n})`);
      const s = e._handlers.CHANNEL_OPEN_FAILURE;
      s && s(e, n, r, i);
    },
    [un.CHANNEL_WINDOW_ADJUST]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readUInt32BE();
      if ((de.clear(), r === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_WINDOW_ADJUST packet");
      e._debug && e._debug(`Inbound: CHANNEL_WINDOW_ADJUST (r:${n}, ${r})`);
      const i = e._handlers.CHANNEL_WINDOW_ADJUST;
      i && i(e, n, r);
    },
    [un.CHANNEL_DATA]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readString();
      if ((de.clear(), r === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_DATA packet");
      e._debug && e._debug(`Inbound: CHANNEL_DATA (r:${n}, ${r.length})`);
      const i = e._handlers.CHANNEL_DATA;
      i && i(e, n, r);
    },
    [un.CHANNEL_EXTENDED_DATA]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readUInt32BE(),
        i = de.readString();
      if ((de.clear(), i === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_EXTENDED_DATA packet");
      e._debug &&
        e._debug(`Inbound: CHANNEL_EXTENDED_DATA (r:${n}, ${i.length})`);
      const a = e._handlers.CHANNEL_EXTENDED_DATA;
      a && a(e, n, i, r);
    },
    [un.CHANNEL_EOF]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE();
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_EOF packet");
      e._debug && e._debug(`Inbound: CHANNEL_EOF (r:${n})`);
      const r = e._handlers.CHANNEL_EOF;
      r && r(e, n);
    },
    [un.CHANNEL_CLOSE]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE();
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_CLOSE packet");
      e._debug && e._debug(`Inbound: CHANNEL_CLOSE (r:${n})`);
      const r = e._handlers.CHANNEL_CLOSE;
      r && r(e, n);
    },
    [un.CHANNEL_REQUEST]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readString(!0),
        i = de.readBool();
      let a;
      if (i !== void 0)
        switch (r) {
          case "exit-status":
            (a = de.readUInt32BE()),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${a})`);
            break;
          case "exit-signal": {
            let o, c;
            if (e._compatFlags & ine.OLD_EXIT) {
              const f = de.readUInt32BE();
              switch (f) {
                case 1:
                  o = "HUP";
                  break;
                case 2:
                  o = "INT";
                  break;
                case 3:
                  o = "QUIT";
                  break;
                case 6:
                  o = "ABRT";
                  break;
                case 9:
                  o = "KILL";
                  break;
                case 14:
                  o = "ALRM";
                  break;
                case 15:
                  o = "TERM";
                  break;
                default:
                  f !== void 0 && (o = `UNKNOWN (${f})`);
              }
              c = !1;
            } else
              (o = de.readString(!0)),
                (c = de.readBool()),
                c === void 0 && (o = void 0);
            const l = de.readString(!0);
            de.skipString() !== void 0 &&
              (a = { signal: o, coreDumped: c, errorMessage: l }),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${o})`);
            break;
          }
          case "pty-req": {
            const o = de.readString(!0),
              c = de.readUInt32BE(),
              l = de.readUInt32BE(),
              f = de.readUInt32BE(),
              u = de.readUInt32BE(),
              d = de.readString();
            if (d !== void 0) {
              de.init(d, 1);
              let p = {};
              for (; de.avail(); ) {
                const h = de.readByte();
                if (h === Ek.TTY_OP_END) break;
                const m = sne[h],
                  g = de.readUInt32BE();
                if (h === void 0 || m === void 0 || g === void 0) {
                  p = void 0;
                  break;
                }
                p[m] = g;
              }
              p !== void 0 &&
                (a = {
                  term: o,
                  cols: c,
                  rows: l,
                  width: f,
                  height: u,
                  modes: p,
                });
            }
            e._debug && e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r})`);
            break;
          }
          case "window-change": {
            const o = de.readUInt32BE(),
              c = de.readUInt32BE(),
              l = de.readUInt32BE(),
              f = de.readUInt32BE();
            f !== void 0 && (a = { cols: o, rows: c, width: l, height: f }),
              e._debug && e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r})`);
            break;
          }
          case "x11-req": {
            const o = de.readBool(),
              c = de.readString(!0),
              l = de.readString(),
              f = de.readUInt32BE();
            f !== void 0 &&
              (a = { single: o, protocol: c, cookie: l, screen: f }),
              e._debug && e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r})`);
            break;
          }
          case "env": {
            const o = de.readString(!0),
              c = de.readString(!0);
            c !== void 0 && (a = { name: o, value: c }),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${o}=${c})`);
            break;
          }
          case "shell":
            (a = null),
              e._debug && e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r})`);
            break;
          case "exec":
            (a = de.readString(!0)),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${a})`);
            break;
          case "subsystem":
            (a = de.readString(!0)),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${a})`);
            break;
          case "signal":
            (a = de.readString(!0)),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${a})`);
            break;
          case "xon-xoff":
            (a = de.readBool()),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${a})`);
            break;
          case "auth-agent-req@openssh.com":
            (a = null),
              e._debug && e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r})`);
            break;
          default:
            (a = de.avail() ? de.readRaw() : null),
              e._debug && e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r})`);
        }
      if ((de.clear(), a === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_REQUEST packet");
      const s = e._handlers.CHANNEL_REQUEST;
      s && s(e, n, r, i, a);
    },
    [un.CHANNEL_SUCCESS]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE();
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_SUCCESS packet");
      e._debug && e._debug(`Inbound: CHANNEL_SUCCESS (r:${n})`);
      const r = e._handlers.CHANNEL_SUCCESS;
      r && r(e, n);
    },
    [un.CHANNEL_FAILURE]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE();
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_FAILURE packet");
      e._debug && e._debug(`Inbound: CHANNEL_FAILURE (r:${n})`);
      const r = e._handlers.CHANNEL_FAILURE;
      r && r(e, n);
    },
  },
  Zm,
  GA;
function wk() {
  if (GA) return Zm;
  GA = 1;
  const e = new Array(256);
  return (
    [i1().HANDLERS, one].forEach((t) => {
      for (let [n, r] of Object.entries(t))
        (n = +n), isFinite(n) && n >= 0 && n < e.length && (e[n] = r);
    }),
    (Zm = e),
    Zm
  );
}
var eg, QA;
function i1() {
  if (QA) return eg;
  QA = 1;
  const {
      createDiffieHellman: e,
      createDiffieHellmanGroup: t,
      createECDH: n,
      createHash: r,
      createPublicKey: i,
      diffieHellman: a,
      generateKeyPairSync: s,
      randomFillSync: o,
    } = pr,
    { Ber: c } = Yp,
    {
      COMPAT: l,
      curve25519Supported: f,
      DEFAULT_KEX: u,
      DEFAULT_SERVER_HOST_KEY: d,
      DEFAULT_CIPHER: p,
      DEFAULT_MAC: h,
      DEFAULT_COMPRESSION: m,
      DISCONNECT_REASON: g,
      MESSAGE: v,
    } = es(),
    { CIPHER_INFO: y, createCipher: _, createDecipher: E, MAC_INFO: R } = eo(),
    { parseDERKey: A } = to,
    {
      bufferFill: I,
      bufferParser: S,
      convertSignature: w,
      doFatalError: O,
      FastBuffer: Q,
      sigSSHToASN1: j,
      writeUInt32BE: H,
    } = Ki(),
    {
      PacketReader: q,
      PacketWriter: J,
      ZlibPacketReader: Z,
      ZlibPacketWriter: z,
    } = _k;
  let U;
  const G = 2048,
    L = 8192,
    k = Buffer.alloc(0);
  function W(ne) {
    let Y;
    if (ne._compatFlags & l.BAD_DHGEX) {
      const M = ne._offer.lists.kex;
      let oe = M.array,
        Ee = !1;
      for (let le = 0; le < oe.length; ++le)
        oe[le].includes("group-exchange") &&
          (Ee || ((Ee = !0), (oe = oe.slice())), oe.splice(le--, 1));
      if (Ee) {
        let le = 17 + ne._offer.totalSize + 1 + 4;
        const te = Buffer.from(oe.join(","));
        le -= M.buffer.length - te.length;
        const ie = ne._offer.lists.all,
          X = new Uint8Array(
            ie.buffer,
            ie.byteOffset + 4 + M.buffer.length,
            ie.length - (4 + M.buffer.length),
          );
        (Y = Buffer.allocUnsafe(le)),
          H(Y, te.length, 17),
          Y.set(te, 17 + 4),
          Y.set(X, 17 + 4 + te.length);
      }
    }
    Y === void 0 &&
      ((Y = Buffer.allocUnsafe(1 + 16 + ne._offer.totalSize + 1 + 4)),
      ne._offer.copyAllTo(Y, 17)),
      ne._debug && ne._debug("Outbound: Sending KEXINIT"),
      (Y[0] = v.KEXINIT),
      o(Y, 1, 16),
      I(Y, 0, Y.length - 5),
      (ne._kexinit = Y),
      (ne._packetRW.write.allocStart = 0);
    {
      const M = ne._packetRW.write.allocStartKEX,
        oe = ne._packetRW.write.alloc(Y.length, !0);
      oe.set(Y, M), ne._cipher.encrypt(ne._packetRW.write.finalize(oe, !0));
    }
  }
  function F(ne, Y) {
    const M = {
      kex: void 0,
      serverHostKey: void 0,
      cs: { cipher: void 0, mac: void 0, compress: void 0, lang: void 0 },
      sc: { cipher: void 0, mac: void 0, compress: void 0, lang: void 0 },
    };
    if (
      (S.init(Y, 17),
      (M.kex = S.readList()) === void 0 ||
        (M.serverHostKey = S.readList()) === void 0 ||
        (M.cs.cipher = S.readList()) === void 0 ||
        (M.sc.cipher = S.readList()) === void 0 ||
        (M.cs.mac = S.readList()) === void 0 ||
        (M.sc.mac = S.readList()) === void 0 ||
        (M.cs.compress = S.readList()) === void 0 ||
        (M.sc.compress = S.readList()) === void 0 ||
        (M.cs.lang = S.readList()) === void 0 ||
        (M.sc.lang = S.readList()) === void 0)
    )
      return (
        S.clear(),
        O(ne, "Received malformed KEXINIT", "handshake", g.KEY_EXCHANGE_FAILED)
      );
    const oe = S.pos(),
      Ee = oe < Y.length && Y[oe] === 1;
    S.clear();
    const le = ne._offer,
      te = M;
    let ie = le.lists.kex.array;
    if (ne._compatFlags & l.BAD_DHGEX) {
      let dt = !1;
      for (let ht = 0; ht < ie.length; ++ht)
        ie[ht].indexOf("group-exchange") !== -1 &&
          (dt || ((dt = !0), (ie = ie.slice())), ie.splice(ht--, 1));
    }
    let X, he, be;
    const ye = ne._debug;
    ye && ye("Inbound: Handshake in progress"),
      ye && ye(`Handshake: (local) KEX method: ${ie}`),
      ye && ye(`Handshake: (remote) KEX method: ${te.kex}`);
    let Qe;
    for (
      ne._server
        ? ((he = ie), (X = te.kex), (Qe = X.indexOf("ext-info-c") !== -1))
        : ((he = te.kex), (X = ie), (Qe = he.indexOf("ext-info-s") !== -1)),
        be = 0;
      be < X.length && he.indexOf(X[be]) === -1;
      ++be
    );
    if (be === X.length)
      return (
        ye && ye("Handshake: No matching key exchange algorithm"),
        O(
          ne,
          "Handshake failed: no matching key exchange algorithm",
          "handshake",
          g.KEY_EXCHANGE_FAILED,
        )
      );
    (M.kex = X[be]),
      ye && ye(`Handshake: KEX algorithm: ${X[be]}`),
      Ee &&
        (!te.kex.length || X[be] !== te.kex[0]) &&
        (ne._skipNextInboundPacket = !0);
    const lt = le.lists.serverHostKey.array;
    for (
      ye && ye(`Handshake: (local) Host key format: ${lt}`),
        ye && ye(`Handshake: (remote) Host key format: ${te.serverHostKey}`),
        ne._server
          ? ((he = lt), (X = te.serverHostKey))
          : ((he = te.serverHostKey), (X = lt)),
        be = 0;
      be < X.length && he.indexOf(X[be]) === -1;
      ++be
    );
    if (be === X.length)
      return (
        ye && ye("Handshake: No matching host key format"),
        O(
          ne,
          "Handshake failed: no matching host key format",
          "handshake",
          g.KEY_EXCHANGE_FAILED,
        )
      );
    (M.serverHostKey = X[be]), ye && ye(`Handshake: Host key format: ${X[be]}`);
    const Lt = le.lists.cs.cipher.array;
    for (
      ye && ye(`Handshake: (local) C->S cipher: ${Lt}`),
        ye && ye(`Handshake: (remote) C->S cipher: ${te.cs.cipher}`),
        ne._server
          ? ((he = Lt), (X = te.cs.cipher))
          : ((he = te.cs.cipher), (X = Lt)),
        be = 0;
      be < X.length && he.indexOf(X[be]) === -1;
      ++be
    );
    if (be === X.length)
      return (
        ye && ye("Handshake: No matching C->S cipher"),
        O(
          ne,
          "Handshake failed: no matching C->S cipher",
          "handshake",
          g.KEY_EXCHANGE_FAILED,
        )
      );
    (M.cs.cipher = X[be]), ye && ye(`Handshake: C->S Cipher: ${X[be]}`);
    const We = le.lists.sc.cipher.array;
    for (
      ye && ye(`Handshake: (local) S->C cipher: ${We}`),
        ye && ye(`Handshake: (remote) S->C cipher: ${te.sc.cipher}`),
        ne._server
          ? ((he = We), (X = te.sc.cipher))
          : ((he = te.sc.cipher), (X = We)),
        be = 0;
      be < X.length && he.indexOf(X[be]) === -1;
      ++be
    );
    if (be === X.length)
      return (
        ye && ye("Handshake: No matching S->C cipher"),
        O(
          ne,
          "Handshake failed: no matching S->C cipher",
          "handshake",
          g.KEY_EXCHANGE_FAILED,
        )
      );
    (M.sc.cipher = X[be]), ye && ye(`Handshake: S->C cipher: ${X[be]}`);
    const bt = le.lists.cs.mac.array;
    if (
      (ye && ye(`Handshake: (local) C->S MAC: ${bt}`),
      ye && ye(`Handshake: (remote) C->S MAC: ${te.cs.mac}`),
      y[M.cs.cipher].authLen > 0)
    )
      (M.cs.mac = ""), ye && ye("Handshake: C->S MAC: <implicit>");
    else {
      for (
        ne._server
          ? ((he = bt), (X = te.cs.mac))
          : ((he = te.cs.mac), (X = bt)),
          be = 0;
        be < X.length && he.indexOf(X[be]) === -1;
        ++be
      );
      if (be === X.length)
        return (
          ye && ye("Handshake: No matching C->S MAC"),
          O(
            ne,
            "Handshake failed: no matching C->S MAC",
            "handshake",
            g.KEY_EXCHANGE_FAILED,
          )
        );
      (M.cs.mac = X[be]), ye && ye(`Handshake: C->S MAC: ${X[be]}`);
    }
    const wt = le.lists.sc.mac.array;
    if (
      (ye && ye(`Handshake: (local) S->C MAC: ${wt}`),
      ye && ye(`Handshake: (remote) S->C MAC: ${te.sc.mac}`),
      y[M.sc.cipher].authLen > 0)
    )
      (M.sc.mac = ""), ye && ye("Handshake: S->C MAC: <implicit>");
    else {
      for (
        ne._server
          ? ((he = wt), (X = te.sc.mac))
          : ((he = te.sc.mac), (X = wt)),
          be = 0;
        be < X.length && he.indexOf(X[be]) === -1;
        ++be
      );
      if (be === X.length)
        return (
          ye && ye("Handshake: No matching S->C MAC"),
          O(
            ne,
            "Handshake failed: no matching S->C MAC",
            "handshake",
            g.KEY_EXCHANGE_FAILED,
          )
        );
      (M.sc.mac = X[be]), ye && ye(`Handshake: S->C MAC: ${X[be]}`);
    }
    const ct = le.lists.cs.compress.array;
    for (
      ye && ye(`Handshake: (local) C->S compression: ${ct}`),
        ye && ye(`Handshake: (remote) C->S compression: ${te.cs.compress}`),
        ne._server
          ? ((he = ct), (X = te.cs.compress))
          : ((he = te.cs.compress), (X = ct)),
        be = 0;
      be < X.length && he.indexOf(X[be]) === -1;
      ++be
    );
    if (be === X.length)
      return (
        ye && ye("Handshake: No matching C->S compression"),
        O(
          ne,
          "Handshake failed: no matching C->S compression",
          "handshake",
          g.KEY_EXCHANGE_FAILED,
        )
      );
    (M.cs.compress = X[be]), ye && ye(`Handshake: C->S compression: ${X[be]}`);
    const ze = le.lists.sc.compress.array;
    for (
      ye && ye(`Handshake: (local) S->C compression: ${ze}`),
        ye && ye(`Handshake: (remote) S->C compression: ${te.sc.compress}`),
        ne._server
          ? ((he = ze), (X = te.sc.compress))
          : ((he = te.sc.compress), (X = ze)),
        be = 0;
      be < X.length && he.indexOf(X[be]) === -1;
      ++be
    );
    if (be === X.length)
      return (
        ye && ye("Handshake: No matching S->C compression"),
        O(
          ne,
          "Handshake failed: no matching S->C compression",
          "handshake",
          g.KEY_EXCHANGE_FAILED,
        )
      );
    (M.sc.compress = X[be]),
      ye && ye(`Handshake: S->C compression: ${X[be]}`),
      (M.cs.lang = ""),
      (M.sc.lang = ""),
      ne._kex &&
        (ne._kexinit || W(ne),
        (ne._decipher._onPayload = N.bind(ne, { firstPacket: !1 }))),
      (ne._kex = x(M, ne, Y)),
      (ne._kex.remoteExtInfoEnabled = Qe),
      ne._kex.start();
  }
  const x = (() => {
      function ne(te) {
        let ie = 0,
          X = te.length;
        for (; te[ie] === 0; ) ++ie, --X;
        let he;
        return (
          te[ie] & 128
            ? ((he = Buffer.allocUnsafe(1 + X)),
              (he[0] = 0),
              te.copy(he, 1, ie),
              (te = he))
            : X !== te.length &&
              ((he = Buffer.allocUnsafe(X)), te.copy(he, 0, ie), (te = he)),
          te
        );
      }
      class Y {
        constructor(ie, X, he) {
          (this._protocol = X),
            (this.sessionID = X._kex ? X._kex.sessionID : void 0),
            (this.negotiated = ie),
            (this.remoteExtInfoEnabled = !1),
            (this._step = 1),
            (this._public = null),
            (this._dh = null),
            (this._sentNEWKEYS = !1),
            (this._receivedNEWKEYS = !1),
            (this._finished = !1),
            (this._hostVerified = !1),
            (this._kexinit = X._kexinit),
            (this._remoteKexinit = he),
            (this._identRaw = X._identRaw),
            (this._remoteIdentRaw = X._remoteIdentRaw),
            (this._hostKey = void 0),
            (this._dhData = void 0),
            (this._sig = void 0);
        }
        finish(ie) {
          if (this._finished) return !1;
          this._finished = !0;
          const X = this._protocol._server,
            he = this.negotiated,
            be = this.convertPublicKey(this._dhData);
          let ye = this.computeSecret(this._dhData);
          if (ye instanceof Error)
            return (
              (ye.message = `Error while computing DH secret (${this.type}): ${ye.message}`),
              (ye.level = "handshake"),
              O(this._protocol, ye, g.KEY_EXCHANGE_FAILED)
            );
          const Qe = r(this.hashName);
          V(Qe, X ? this._remoteIdentRaw : this._identRaw),
            V(Qe, X ? this._identRaw : this._remoteIdentRaw),
            V(Qe, X ? this._remoteKexinit : this._kexinit),
            V(Qe, X ? this._kexinit : this._remoteKexinit);
          const lt = X ? this._hostKey.getPublicSSH() : this._hostKey;
          if ((V(Qe, lt), this.type === "groupex")) {
            const ze = this.getDHParams(),
              dt = Buffer.allocUnsafe(4);
            H(dt, this._minBits, 0),
              Qe.update(dt),
              H(dt, this._prefBits, 0),
              Qe.update(dt),
              H(dt, this._maxBits, 0),
              Qe.update(dt),
              V(Qe, ze.prime),
              V(Qe, ze.generator);
          }
          V(Qe, X ? be : this.getPublicKey());
          const Lt = X ? this.getPublicKey() : be;
          V(Qe, Lt), V(Qe, ye);
          const We = Qe.digest();
          if (X) {
            let ze;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                ze = "sha256";
                break;
              case "rsa-sha2-512":
                ze = "sha512";
                break;
            }
            this._protocol._debug &&
              this._protocol._debug("Generating signature ...");
            let dt = this._hostKey.sign(We, ze);
            if (dt instanceof Error)
              return O(
                this._protocol,
                `Handshake failed: signature generation failed for ${this._hostKey.type} host key: ${dt.message}`,
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
            if (((dt = w(dt, this._hostKey.type)), dt === !1))
              return O(
                this._protocol,
                `Handshake failed: signature conversion failed for ${this._hostKey.type} host key`,
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
            const ht = this.negotiated.serverHostKey,
              an = Buffer.byteLength(ht),
              $n = 4 + an + 4 + dt.length;
            let Wt = this._protocol._packetRW.write.allocStartKEX;
            const Jt = this._protocol._packetRW.write.alloc(
              1 + 4 + lt.length + 4 + Lt.length + 4 + $n,
              !0,
            );
            if (
              ((Jt[Wt] = v.KEXDH_REPLY),
              H(Jt, lt.length, ++Wt),
              Jt.set(lt, (Wt += 4)),
              H(Jt, Lt.length, (Wt += lt.length)),
              Jt.set(Lt, (Wt += 4)),
              H(Jt, $n, (Wt += Lt.length)),
              H(Jt, an, (Wt += 4)),
              Jt.utf8Write(ht, (Wt += 4), an),
              H(Jt, dt.length, (Wt += an)),
              Jt.set(dt, (Wt += 4)),
              this._protocol._debug)
            ) {
              let Zt;
              switch (this.type) {
                case "group":
                  Zt = "KEXDH_REPLY";
                  break;
                case "groupex":
                  Zt = "KEXDH_GEX_REPLY";
                  break;
                default:
                  Zt = "KEXECDH_REPLY";
              }
              this._protocol._debug(`Outbound: Sending ${Zt}`);
            }
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(Jt, !0),
            );
          } else {
            S.init(this._sig, 0);
            const ze = S.readString(!0);
            if (!ze)
              return O(
                this._protocol,
                "Malformed packet while reading signature",
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
            if (ze !== he.serverHostKey)
              return O(
                this._protocol,
                `Wrong signature type: ${ze}, expected: ${he.serverHostKey}`,
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
            let dt = S.readString();
            if ((S.clear(), dt === void 0))
              return O(
                this._protocol,
                "Malformed packet while reading signature",
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
            if (!(dt = j(dt, ze)))
              return O(
                this._protocol,
                "Malformed signature",
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
            let ht;
            {
              S.init(this._hostKey, 0);
              const Wt = S.readString(!0),
                Jt = this._hostKey.slice(S.pos());
              if ((S.clear(), (ht = A(Jt, Wt)), ht instanceof Error))
                return (
                  (ht.level = "handshake"),
                  O(this._protocol, ht, g.KEY_EXCHANGE_FAILED)
                );
            }
            let an;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                an = "sha256";
                break;
              case "rsa-sha2-512":
                an = "sha512";
                break;
            }
            this._protocol._debug &&
              this._protocol._debug("Verifying signature ...");
            const $n = ht.verify(We, dt, an);
            if ($n !== !0)
              return (
                $n instanceof Error
                  ? this._protocol._debug &&
                    this._protocol._debug(
                      `Signature verification failed: ${$n.stack}`,
                    )
                  : this._protocol._debug &&
                    this._protocol._debug("Signature verification failed"),
                O(
                  this._protocol,
                  "Handshake failed: signature verification failed",
                  "handshake",
                  g.KEY_EXCHANGE_FAILED,
                )
              );
            this._protocol._debug &&
              this._protocol._debug("Verified signature");
          }
          (X || !ie) && re(this);
          let bt, wt;
          const ct = (ze) => {
            if (bt)
              return (
                re(this),
                (bt.outbound.seqno = this._protocol._cipher.outSeqno),
                this._protocol._cipher.free(),
                (this._protocol._cipher = _(bt)),
                (this._protocol._packetRW.write = wt),
                (bt = void 0),
                (wt = void 0),
                this._protocol._onHandshakeComplete(he),
                !1
              );
            this.sessionID || (this.sessionID = We);
            {
              const ni = Buffer.allocUnsafe(4 + ye.length);
              H(ni, ye.length, 0), ni.set(ye, 4), (ye = ni);
            }
            const dt = y[he.cs.cipher],
              ht = y[he.sc.cipher],
              an = B(dt.ivLen, this.hashName, ye, We, this.sessionID, "A"),
              $n = B(ht.ivLen, this.hashName, ye, We, this.sessionID, "B"),
              Wt = B(dt.keyLen, this.hashName, ye, We, this.sessionID, "C"),
              Jt = B(ht.keyLen, this.hashName, ye, We, this.sessionID, "D");
            let Zt, jr;
            dt.authLen ||
              ((Zt = R[he.cs.mac]),
              (jr = B(Zt.len, this.hashName, ye, We, this.sessionID, "E")));
            let Nn, Vr;
            ht.authLen ||
              ((Nn = R[he.sc.mac]),
              (Vr = B(Nn.len, this.hashName, ye, We, this.sessionID, "F")));
            const Vi = {
              inbound: {
                onPayload: this._protocol._onPayload,
                seqno: this._protocol._decipher.inSeqno,
                decipherInfo: X ? dt : ht,
                decipherIV: X ? an : $n,
                decipherKey: X ? Wt : Jt,
                macInfo: X ? Zt : Nn,
                macKey: X ? jr : Vr,
              },
              outbound: {
                onWrite: this._protocol._onWrite,
                seqno: this._protocol._cipher.outSeqno,
                cipherInfo: X ? ht : dt,
                cipherIV: X ? $n : an,
                cipherKey: X ? Jt : Wt,
                macInfo: X ? Nn : Zt,
                macKey: X ? Vr : jr,
              },
            };
            this._protocol._decipher.free(),
              (bt = Vi),
              (this._protocol._decipher = E(Vi));
            const On = { read: void 0, write: void 0 };
            switch (he.cs.compress) {
              case "zlib":
                X ? (On.read = new Z()) : (On.write = new z(this._protocol));
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  X ? (On.read = new Z()) : (On.write = new z(this._protocol));
                  break;
                }
              default:
                X ? (On.read = new q()) : (On.write = new J(this._protocol));
            }
            switch (he.sc.compress) {
              case "zlib":
                X ? (On.write = new z(this._protocol)) : (On.read = new Z());
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  X ? (On.write = new z(this._protocol)) : (On.read = new Z());
                  break;
                }
              default:
                X ? (On.write = new J(this._protocol)) : (On.read = new q());
            }
            return (
              this._protocol._packetRW.read.cleanup(),
              this._protocol._packetRW.write.cleanup(),
              (this._protocol._packetRW.read = On.read),
              (wt = On.write),
              (this._public = null),
              (this._dh = null),
              (this._kexinit = this._protocol._kexinit = void 0),
              (this._remoteKexinit = void 0),
              (this._identRaw = void 0),
              (this._remoteIdentRaw = void 0),
              (this._hostKey = void 0),
              (this._dhData = void 0),
              (this._sig = void 0),
              ze ? !1 : ct()
            );
          };
          if (((X || ie) && (this.finish = ct), !X)) return ct(ie);
        }
        start() {
          if (!this._protocol._server) {
            if (this._protocol._debug) {
              let be;
              switch (this.type) {
                case "group":
                  be = "KEXDH_INIT";
                  break;
                default:
                  be = "KEXECDH_INIT";
              }
              this._protocol._debug(`Outbound: Sending ${be}`);
            }
            const ie = this.getPublicKey();
            let X = this._protocol._packetRW.write.allocStartKEX;
            const he = this._protocol._packetRW.write.alloc(
              1 + 4 + ie.length,
              !0,
            );
            (he[X] = v.KEXDH_INIT),
              H(he, ie.length, ++X),
              he.set(ie, (X += 4)),
              this._protocol._cipher.encrypt(
                this._protocol._packetRW.write.finalize(he, !0),
              );
          }
        }
        getPublicKey() {
          this.generateKeys();
          const ie = this._public;
          if (ie) return this.convertPublicKey(ie);
        }
        convertPublicKey(ie) {
          let X,
            he = 0,
            be = ie.length;
          for (; ie[he] === 0; ) ++he, --be;
          return ie[he] & 128
            ? ((X = Buffer.allocUnsafe(1 + be)),
              (X[0] = 0),
              ie.copy(X, 1, he),
              X)
            : (be !== ie.length &&
                ((X = Buffer.allocUnsafe(be)), ie.copy(X, 0, he), (ie = X)),
              ie);
        }
        computeSecret(ie) {
          this.generateKeys();
          try {
            return ne(this._dh.computeSecret(ie));
          } catch (X) {
            return X;
          }
        }
        parse(ie) {
          const X = ie[0];
          switch (this._step) {
            case 1:
              if (this._protocol._server) {
                if (X !== v.KEXDH_INIT)
                  return O(
                    this._protocol,
                    `Received packet ${X} instead of ${v.KEXDH_INIT}`,
                    "handshake",
                    g.KEY_EXCHANGE_FAILED,
                  );
                this._protocol._debug &&
                  this._protocol._debug("Received DH Init"),
                  S.init(ie, 1);
                const he = S.readString();
                if ((S.clear(), he === void 0))
                  return O(
                    this._protocol,
                    "Received malformed KEX*_INIT",
                    "handshake",
                    g.KEY_EXCHANGE_FAILED,
                  );
                this._dhData = he;
                let be =
                  this._protocol._hostKeys[this.negotiated.serverHostKey];
                Array.isArray(be) && (be = be[0]),
                  (this._hostKey = be),
                  this.finish();
              } else {
                if (X !== v.KEXDH_REPLY)
                  return O(
                    this._protocol,
                    `Received packet ${X} instead of ${v.KEXDH_REPLY}`,
                    "handshake",
                    g.KEY_EXCHANGE_FAILED,
                  );
                this._protocol._debug &&
                  this._protocol._debug("Received DH Reply"),
                  S.init(ie, 1);
                let he, be, ye;
                if (
                  (he = S.readString()) === void 0 ||
                  (be = S.readString()) === void 0 ||
                  (ye = S.readString()) === void 0
                )
                  return (
                    S.clear(),
                    O(
                      this._protocol,
                      "Received malformed KEX*_REPLY",
                      "handshake",
                      g.KEY_EXCHANGE_FAILED,
                    )
                  );
                S.clear(), S.init(he, 0);
                const Qe = S.readString(!0);
                if ((S.clear(), Qe === void 0))
                  return O(
                    this._protocol,
                    "Received malformed host public key",
                    "handshake",
                    g.KEY_EXCHANGE_FAILED,
                  );
                if (Qe !== this.negotiated.serverHostKey)
                  switch (this.negotiated.serverHostKey) {
                    case "rsa-sha2-256":
                    case "rsa-sha2-512":
                      if (Qe === "ssh-rsa") break;
                    default:
                      return O(
                        this._protocol,
                        "Host key does not match negotiated type",
                        "handshake",
                        g.KEY_EXCHANGE_FAILED,
                      );
                  }
                (this._hostKey = he), (this._dhData = be), (this._sig = ye);
                let lt = !1,
                  Lt;
                if (
                  (this._protocol._hostVerifier === void 0
                    ? ((Lt = !0),
                      this._protocol._debug &&
                        this._protocol._debug(
                          "Host accepted by default (no verification)",
                        ))
                    : (Lt = this._protocol._hostVerifier(he, (We) => {
                        if (!lt) {
                          if (((lt = !0), We === !1))
                            return (
                              this._protocol._debug &&
                                this._protocol._debug(
                                  "Host denied (verification failed)",
                                ),
                              O(
                                this._protocol,
                                "Host denied (verification failed)",
                                "handshake",
                                g.KEY_EXCHANGE_FAILED,
                              )
                            );
                          this._protocol._debug &&
                            this._protocol._debug("Host accepted (verified)"),
                            (this._hostVerified = !0),
                            this._receivedNEWKEYS ? this.finish() : re(this);
                        }
                      })),
                  Lt === void 0)
                ) {
                  ++this._step;
                  return;
                }
                if (((lt = !0), Lt === !1))
                  return (
                    this._protocol._debug &&
                      this._protocol._debug(
                        "Host denied (verification failed)",
                      ),
                    O(
                      this._protocol,
                      "Host denied (verification failed)",
                      "handshake",
                      g.KEY_EXCHANGE_FAILED,
                    )
                  );
                this._protocol._debug &&
                  this._protocol._debug("Host accepted (verified)"),
                  (this._hostVerified = !0),
                  re(this);
              }
              ++this._step;
              break;
            case 2:
              return X !== v.NEWKEYS
                ? O(
                    this._protocol,
                    `Received packet ${X} instead of ${v.NEWKEYS}`,
                    "handshake",
                    g.KEY_EXCHANGE_FAILED,
                  )
                : (this._protocol._debug &&
                    this._protocol._debug("Inbound: NEWKEYS"),
                  (this._receivedNEWKEYS = !0),
                  ++this._step,
                  this.finish(!this._protocol._server && !this._hostVerified));
            default:
              return O(
                this._protocol,
                `Received unexpected packet ${X} after NEWKEYS`,
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
          }
        }
      }
      class M extends Y {
        constructor(ie, ...X) {
          super(...X),
            (this.type = "25519"),
            (this.hashName = ie),
            (this._keys = null);
        }
        generateKeys() {
          this._keys || (this._keys = s("x25519"));
        }
        getPublicKey() {
          return (
            this.generateKeys(),
            this._keys.publicKey
              .export({ type: "spki", format: "der" })
              .slice(-32)
          );
        }
        convertPublicKey(ie) {
          let X,
            he = 0,
            be = ie.length;
          for (; ie[he] === 0; ) ++he, --be;
          return (
            ie.length === 32 ||
              (be !== ie.length &&
                ((X = Buffer.allocUnsafe(be)), ie.copy(X, 0, he), (ie = X))),
            ie
          );
        }
        computeSecret(ie) {
          this.generateKeys();
          try {
            const X = new c.Writer();
            return (
              X.startSequence(),
              X.startSequence(),
              X.writeOID("1.3.101.110"),
              X.endSequence(),
              X.startSequence(c.BitString),
              X.writeByte(0),
              X._ensure(ie.length),
              ie.copy(X._buf, X._offset, 0, ie.length),
              (X._offset += ie.length),
              X.endSequence(),
              X.endSequence(),
              ne(
                a({
                  privateKey: this._keys.privateKey,
                  publicKey: i({ key: X.buffer, type: "spki", format: "der" }),
                }),
              )
            );
          } catch (X) {
            return X;
          }
        }
      }
      class oe extends Y {
        constructor(ie, X, ...he) {
          super(...he),
            (this.type = "ecdh"),
            (this.curveName = ie),
            (this.hashName = X);
        }
        generateKeys() {
          this._dh ||
            ((this._dh = n(this.curveName)),
            (this._public = this._dh.generateKeys()));
        }
      }
      class Ee extends Y {
        constructor(ie, ...X) {
          super(...X),
            (this.type = "groupex"),
            (this.hashName = ie),
            (this._prime = null),
            (this._generator = null),
            (this._minBits = G),
            (this._prefBits = ce(this.negotiated)),
            this._protocol._compatFlags & l.BUG_DHGEX_LARGE &&
              (this._prefBits = Math.min(this._prefBits, 4096)),
            (this._maxBits = L);
        }
        start() {
          if (this._protocol._server) return;
          this._protocol._debug &&
            this._protocol._debug("Outbound: Sending KEXDH_GEX_REQUEST");
          let ie = this._protocol._packetRW.write.allocStartKEX;
          const X = this._protocol._packetRW.write.alloc(1 + 4 + 4 + 4, !0);
          (X[ie] = v.KEXDH_GEX_REQUEST),
            H(X, this._minBits, ++ie),
            H(X, this._prefBits, (ie += 4)),
            H(X, this._maxBits, (ie += 4)),
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(X, !0),
            );
        }
        generateKeys() {
          !this._dh &&
            this._prime &&
            this._generator &&
            ((this._dh = e(this._prime, this._generator)),
            (this._public = this._dh.generateKeys()));
        }
        setDHParams(ie, X) {
          if (!Buffer.isBuffer(ie)) throw new Error("Invalid prime value");
          if (!Buffer.isBuffer(X)) throw new Error("Invalid generator value");
          (this._prime = ie), (this._generator = X);
        }
        getDHParams() {
          if (this._dh)
            return {
              prime: ne(this._dh.getPrime()),
              generator: ne(this._dh.getGenerator()),
            };
        }
        parse(ie) {
          const X = ie[0];
          switch (this._step) {
            case 1: {
              if (this._protocol._server)
                return X !== v.KEXDH_GEX_REQUEST
                  ? O(
                      this._protocol,
                      `Received packet ${X} instead of ` + v.KEXDH_GEX_REQUEST,
                      "handshake",
                      g.KEY_EXCHANGE_FAILED,
                    )
                  : O(
                      this._protocol,
                      "Group exchange not implemented for server",
                      "handshake",
                      g.KEY_EXCHANGE_FAILED,
                    );
              if (X !== v.KEXDH_GEX_GROUP)
                return O(
                  this._protocol,
                  `Received packet ${X} instead of ${v.KEXDH_GEX_GROUP}`,
                  "handshake",
                  g.KEY_EXCHANGE_FAILED,
                );
              this._protocol._debug &&
                this._protocol._debug("Received DH GEX Group"),
                S.init(ie, 1);
              let he, be;
              if (
                (he = S.readString()) === void 0 ||
                (be = S.readString()) === void 0
              )
                return (
                  S.clear(),
                  O(
                    this._protocol,
                    "Received malformed KEXDH_GEX_GROUP",
                    "handshake",
                    g.KEY_EXCHANGE_FAILED,
                  )
                );
              S.clear(), this.setDHParams(he, be), this.generateKeys();
              const ye = this.getPublicKey();
              this._protocol._debug &&
                this._protocol._debug("Outbound: Sending KEXDH_GEX_INIT");
              let Qe = this._protocol._packetRW.write.allocStartKEX;
              const lt = this._protocol._packetRW.write.alloc(
                1 + 4 + ye.length,
                !0,
              );
              (lt[Qe] = v.KEXDH_GEX_INIT),
                H(lt, ye.length, ++Qe),
                lt.set(ye, (Qe += 4)),
                this._protocol._cipher.encrypt(
                  this._protocol._packetRW.write.finalize(lt, !0),
                ),
                ++this._step;
              break;
            }
            case 2:
              if (this._protocol._server)
                return X !== v.KEXDH_GEX_INIT
                  ? O(
                      this._protocol,
                      `Received packet ${X} instead of ${v.KEXDH_GEX_INIT}`,
                      "handshake",
                      g.KEY_EXCHANGE_FAILED,
                    )
                  : (this._protocol._debug &&
                      this._protocol._debug("Received DH GEX Init"),
                    O(
                      this._protocol,
                      "Group exchange not implemented for server",
                      "handshake",
                      g.KEY_EXCHANGE_FAILED,
                    ));
              if (X !== v.KEXDH_GEX_REPLY)
                return O(
                  this._protocol,
                  `Received packet ${X} instead of ${v.KEXDH_GEX_REPLY}`,
                  "handshake",
                  g.KEY_EXCHANGE_FAILED,
                );
              this._protocol._debug &&
                this._protocol._debug("Received DH GEX Reply"),
                (this._step = 1),
                (ie[0] = v.KEXDH_REPLY),
                (this.parse = Y.prototype.parse),
                this.parse(ie);
          }
        }
      }
      class le extends Y {
        constructor(ie, X, ...he) {
          super(...he),
            (this.type = "group"),
            (this.groupName = ie),
            (this.hashName = X);
        }
        start() {
          if (!this._protocol._server) {
            this._protocol._debug &&
              this._protocol._debug("Outbound: Sending KEXDH_INIT");
            const ie = this.getPublicKey();
            let X = this._protocol._packetRW.write.allocStartKEX;
            const he = this._protocol._packetRW.write.alloc(
              1 + 4 + ie.length,
              !0,
            );
            (he[X] = v.KEXDH_INIT),
              H(he, ie.length, ++X),
              he.set(ie, (X += 4)),
              this._protocol._cipher.encrypt(
                this._protocol._packetRW.write.finalize(he, !0),
              );
          }
        }
        generateKeys() {
          this._dh ||
            ((this._dh = t(this.groupName)),
            (this._public = this._dh.generateKeys()));
        }
        getDHParams() {
          if (this._dh)
            return {
              prime: ne(this._dh.getPrime()),
              generator: ne(this._dh.getGenerator()),
            };
        }
      }
      return (te, ...ie) => {
        if (typeof te != "object" || te === null)
          throw new Error("Invalid negotiated argument");
        const X = te.kex;
        if (typeof X == "string") {
          switch (((ie = [te, ...ie]), X)) {
            case "curve25519-sha256":
            case "curve25519-sha256@libssh.org":
              if (!f) break;
              return new M("sha256", ...ie);
            case "ecdh-sha2-nistp256":
              return new oe("prime256v1", "sha256", ...ie);
            case "ecdh-sha2-nistp384":
              return new oe("secp384r1", "sha384", ...ie);
            case "ecdh-sha2-nistp521":
              return new oe("secp521r1", "sha512", ...ie);
            case "diffie-hellman-group1-sha1":
              return new le("modp2", "sha1", ...ie);
            case "diffie-hellman-group14-sha1":
              return new le("modp14", "sha1", ...ie);
            case "diffie-hellman-group14-sha256":
              return new le("modp14", "sha256", ...ie);
            case "diffie-hellman-group15-sha512":
              return new le("modp15", "sha512", ...ie);
            case "diffie-hellman-group16-sha512":
              return new le("modp16", "sha512", ...ie);
            case "diffie-hellman-group17-sha512":
              return new le("modp17", "sha512", ...ie);
            case "diffie-hellman-group18-sha512":
              return new le("modp18", "sha512", ...ie);
            case "diffie-hellman-group-exchange-sha1":
              return new Ee("sha1", ...ie);
            case "diffie-hellman-group-exchange-sha256":
              return new Ee("sha256", ...ie);
          }
          throw new Error(`Unsupported key exchange algorithm: ${X}`);
        }
        throw new Error(`Invalid key exchange type: ${X}`);
      };
    })(),
    T = (() => {
      const ne = [
        "kex",
        "serverHostKey",
        ["cs", "cipher"],
        ["sc", "cipher"],
        ["cs", "mac"],
        ["sc", "mac"],
        ["cs", "compress"],
        ["sc", "compress"],
        ["cs", "lang"],
        ["sc", "lang"],
      ];
      return class {
        constructor(M) {
          if (typeof M != "object" || M === null)
            throw new TypeError("Argument must be an object");
          const oe = {
            kex: void 0,
            serverHostKey: void 0,
            cs: { cipher: void 0, mac: void 0, compress: void 0, lang: void 0 },
            sc: { cipher: void 0, mac: void 0, compress: void 0, lang: void 0 },
            all: void 0,
          };
          let Ee = 0;
          for (const ie of ne) {
            let X, he, be, ye;
            if (typeof ie == "string") (X = oe), (he = M[ie]), (be = ye = ie);
            else {
              const lt = ie[0];
              (X = oe[lt]),
                (ye = ie[1]),
                (he = M[lt][ye]),
                (be = `${lt}.${ye}`);
            }
            const Qe = { array: void 0, buffer: void 0 };
            if (Buffer.isBuffer(he))
              (Qe.array = ("" + he).split(",")),
                (Qe.buffer = he),
                (Ee += 4 + he.length);
            else {
              if (
                (typeof he == "string" && (he = he.split(",")),
                Array.isArray(he))
              )
                (Qe.array = he), (Qe.buffer = Buffer.from(he.join(",")));
              else throw new TypeError(`Invalid \`${be}\` type: ${typeof he}`);
              Ee += 4 + Qe.buffer.length;
            }
            X[ye] = Qe;
          }
          const le = Buffer.allocUnsafe(Ee);
          oe.all = le;
          let te = 0;
          for (const ie of ne) {
            let X;
            typeof ie == "string"
              ? (X = oe[ie].buffer)
              : (X = oe[ie[0]][ie[1]].buffer),
              (te = H(le, X.length, te)),
              le.set(X, te),
              (te += X.length);
          }
          (this.totalSize = Ee), (this.lists = oe);
        }
        copyAllTo(M, oe) {
          const Ee = this.lists.all;
          if (typeof oe != "number")
            throw new TypeError(`Invalid offset value: ${typeof oe}`);
          if (M.length - oe < Ee.length)
            throw new Error("Insufficient space to copy list");
          return M.set(Ee, oe), Ee.length;
        }
      };
    })(),
    V = (() => {
      const ne = Buffer.allocUnsafe(4);
      return (Y, M) => {
        H(ne, M.length, 0), Y.update(ne), Y.update(M);
      };
    })();
  function B(ne, Y, M, oe, Ee, le) {
    let te;
    if (ne) {
      let ie = r(Y).update(M).update(oe).update(le).update(Ee).digest();
      for (; ie.length < ne; ) {
        const X = r(Y).update(M).update(oe).update(ie).digest(),
          he = Buffer.allocUnsafe(ie.length + X.length);
        he.set(ie, 0), he.set(X, ie.length), (ie = he);
      }
      ie.length === ne ? (te = ie) : (te = new Q(ie.buffer, ie.byteOffset, ne));
    } else te = k;
    return te;
  }
  function N(ne, Y) {
    if (Y.length === 0) {
      this._debug && this._debug("Inbound: Skipping empty packet payload");
      return;
    }
    if (this._skipNextInboundPacket) {
      this._skipNextInboundPacket = !1;
      return;
    }
    Y = this._packetRW.read.read(Y);
    const M = Y[0];
    switch (M) {
      case v.DISCONNECT:
      case v.IGNORE:
      case v.UNIMPLEMENTED:
      case v.DEBUG:
        return U || (U = wk()), U[M](this, Y);
      case v.KEXINIT:
        return ne.firstPacket
          ? ((ne.firstPacket = !1), F(this, Y))
          : O(
              this,
              "Received extra KEXINIT during handshake",
              "handshake",
              g.KEY_EXCHANGE_FAILED,
            );
      default:
        if (M < 20 || M > 49)
          return O(
            this,
            `Received unexpected packet type ${M}`,
            "handshake",
            g.KEY_EXCHANGE_FAILED,
          );
    }
    return this._kex.parse(Y);
  }
  function ce(ne) {
    const Y = y[ne.cs.cipher],
      M = y[ne.sc.cipher],
      oe =
        Math.max(
          0,
          Y.sslName === "des-ede3-cbc" ? 14 : Y.keyLen,
          Y.blockLen,
          Y.ivLen,
          M.sslName === "des-ede3-cbc" ? 14 : M.keyLen,
          M.blockLen,
          M.ivLen,
        ) * 8;
    return oe <= 112 ? 2048 : oe <= 128 ? 3072 : oe <= 192 ? 7680 : 8192;
  }
  function re(ne) {
    if (!ne._sentNEWKEYS) {
      ne._protocol._debug && ne._protocol._debug("Outbound: Sending NEWKEYS");
      const Y = ne._protocol._packetRW.write.allocStartKEX,
        M = ne._protocol._packetRW.write.alloc(1, !0);
      (M[Y] = v.NEWKEYS),
        ne._protocol._cipher.encrypt(
          ne._protocol._packetRW.write.finalize(M, !0),
        ),
        (ne._sentNEWKEYS = !0);
    }
  }
  return (
    (eg = {
      KexInit: T,
      kexinit: W,
      onKEXPayload: N,
      DEFAULT_KEXINIT_CLIENT: new T({
        kex: u.concat(["ext-info-c"]),
        serverHostKey: d,
        cs: { cipher: p, mac: h, compress: m, lang: [] },
        sc: { cipher: p, mac: h, compress: m, lang: [] },
      }),
      DEFAULT_KEXINIT_SERVER: new T({
        kex: u,
        serverHostKey: d,
        cs: { cipher: p, mac: h, compress: m, lang: [] },
        sc: { cipher: p, mac: h, compress: m, lang: [] },
      }),
      HANDLERS: { [v.KEXINIT]: F },
    }),
    eg
  );
}
const cne = "ssh2",
  lne = "1.14.0",
  une = "Brian White <mscdex@mscdex.net>",
  fne = "SSH2 client and server modules written in pure JavaScript for node.js",
  dne = "./lib/index.js",
  pne = { node: ">=10.16.0" },
  hne = { asn1: "^0.2.6", "bcrypt-pbkdf": "^1.0.2" },
  mne = { "@mscdex/eslint-config": "^1.1.0", eslint: "^7.32.0" },
  gne = { "cpu-features": "~0.0.8", nan: "^2.17.0" },
  vne = {
    install: "node install.js",
    rebuild: "node install.js",
    test: "node test/test.js",
    lint: "eslint --cache --report-unused-disable-directives --ext=.js .eslintrc.js examples lib test",
    "lint:fix": "npm run lint -- --fix",
  },
  yne = ["ssh", "ssh2", "sftp", "secure", "shell", "exec", "remote", "client"],
  bne = [
    { type: "MIT", url: "http://github.com/mscdex/ssh2/raw/master/LICENSE" },
  ],
  _ne = { type: "git", url: "http://github.com/mscdex/ssh2.git" },
  Ene = {
    name: cne,
    version: lne,
    author: une,
    description: fne,
    main: dne,
    engines: pne,
    dependencies: hne,
    devDependencies: mne,
    optionalDependencies: gne,
    scripts: vne,
    keywords: yne,
    licenses: bne,
    repository: _ne,
  },
  { inspect: xk } = wr,
  { bindingAvailable: wne, NullCipher: xne, NullDecipher: Ane } = eo(),
  {
    COMPAT_CHECKS: Sne,
    DISCONNECT_REASON: Ak,
    eddsaSupported: Ine,
    MESSAGE: et,
    SIGNALS: WA,
    TERMINAL_MODE: H0,
  } = es(),
  {
    DEFAULT_KEXINIT_CLIENT: $ne,
    DEFAULT_KEXINIT_SERVER: Cne,
    KexInit: zA,
    kexinit: Sk,
    onKEXPayload: Rne,
  } = i1(),
  { parseKey: KA } = to,
  kne = wk(),
  {
    bufferCopy: Tf,
    bufferFill: Tne,
    bufferSlice: Ik,
    convertSignature: VA,
    sendPacket: tt,
    writeUInt32BE: fe,
  } = Ki(),
  {
    PacketReader: Nne,
    PacketWriter: One,
    ZlibPacketReader: $k,
    ZlibPacketWriter: Ck,
  } = _k,
  Pne = Ene.version,
  Dne = new Map(Object.values(Ak).map((e) => [e, 1])),
  Rk = Buffer.from(`SSH-2.0-ssh2js${Pne}`),
  Lne = Buffer.from(`${Rk}\r
`),
  Bne = 8192,
  Une = 1024,
  YA = Buffer.from([
    et.GLOBAL_REQUEST,
    0,
    0,
    0,
    21,
    107,
    101,
    101,
    112,
    97,
    108,
    105,
    118,
    101,
    64,
    111,
    112,
    101,
    110,
    115,
    115,
    104,
    46,
    99,
    111,
    109,
    1,
  ]),
  Fne = Buffer.from([H0.TTY_OP_END]);
function tg() {}
let jne = class {
  constructor(t) {
    const n = t.onWrite;
    if (typeof n != "function") throw new Error("Missing onWrite function");
    this._onWrite = (p) => {
      n(p);
    };
    const r = t.onError;
    if (typeof r != "function") throw new Error("Missing onError function");
    this._onError = (p) => {
      r(p);
    };
    const i = t.debug;
    this._debug =
      typeof i == "function"
        ? (p) => {
            i(p);
          }
        : void 0;
    const a = t.onHeader;
    this._onHeader =
      typeof a == "function"
        ? (...p) => {
            a(...p);
          }
        : tg;
    const s = t.onPacket;
    this._onPacket =
      typeof s == "function"
        ? () => {
            s();
          }
        : tg;
    let o = t.onHandshakeComplete;
    typeof o != "function" && (o = tg);
    let c;
    (this._onHandshakeComplete = (...p) => {
      this._debug && this._debug("Handshake completed"),
        c === void 0 ? (c = !0) : (c = !1);
      const h = this._queue;
      if (h) {
        (this._queue = void 0),
          this._debug &&
            this._debug(`Draining outbound queue (${h.length}) ...`);
        for (let m = 0; m < h.length; ++m) {
          const g = h[m];
          let v = this._packetRW.write.finalize(g);
          if (v === g) {
            const y = this._cipher.allocPacket(g.length);
            y.set(g, 5), (v = y);
          }
          tt(this, v);
        }
        this._debug && this._debug("... finished draining outbound queue");
      }
      c && this._server && this._kex.remoteExtInfoEnabled && zne(this), o(...p);
    }),
      (this._queue = void 0);
    const l = t.messageHandlers;
    typeof l == "object" && l !== null
      ? (this._handlers = l)
      : (this._handlers = {}),
      (this._onPayload = Gne.bind(this)),
      (this._server = !!t.server),
      (this._banner = void 0);
    let f;
    if (this._server) {
      if (typeof t.hostKeys != "object" || t.hostKeys === null)
        throw new Error("Missing server host key(s)");
      (this._hostKeys = t.hostKeys),
        typeof t.greeting == "string" &&
          t.greeting.length &&
          (f =
            t.greeting.slice(-2) ===
            `\r
`
              ? t.greeting
              : `${t.greeting}\r
`),
        typeof t.banner == "string" &&
          t.banner.length &&
          (this._banner =
            t.banner.slice(-2) ===
            `\r
`
              ? t.banner
              : `${t.banner}\r
`);
    } else this._hostKeys = void 0;
    let u = t.offer;
    typeof u != "object" || u === null
      ? (u = this._server ? Cne : $ne)
      : u.constructor !== zA &&
        (this._server || (u.kex = u.kex.concat(["ext-info-c"])),
        (u = new zA(u))),
      (this._kex = void 0),
      (this._kexinit = void 0),
      (this._offer = u),
      (this._cipher = new xne(0, this._onWrite)),
      (this._decipher = void 0),
      (this._skipNextInboundPacket = !1),
      (this._packetRW = { read: new Nne(), write: new One(this) }),
      (this._hostVerifier =
        !this._server && typeof t.hostVerifier == "function"
          ? t.hostVerifier
          : void 0),
      (this._parse = Hne),
      (this._buffer = void 0),
      (this._authsQueue = []),
      (this._authenticated = !1),
      (this._remoteIdentRaw = void 0);
    let d;
    if (typeof t.ident == "string")
      (this._identRaw = Buffer.from(`SSH-2.0-${t.ident}`)),
        (d = Buffer.allocUnsafe(this._identRaw.length + 2)),
        d.set(this._identRaw, 0),
        (d[d.length - 2] = 13),
        (d[d.length - 1] = 10);
    else if (Buffer.isBuffer(t.ident)) {
      const p = Buffer.allocUnsafe(8 + t.ident.length);
      p.latin1Write("SSH-2.0-", 0, 8),
        p.set(t.ident, 8),
        (this._identRaw = p),
        (d = Buffer.allocUnsafe(p.length + 2)),
        d.set(p, 0),
        (d[d.length - 2] = 13),
        (d[d.length - 1] = 10);
    } else (this._identRaw = Rk), (d = Lne);
    (this._compatFlags = 0),
      this._debug &&
        (wne
          ? this._debug("Custom crypto binding available")
          : this._debug("Custom crypto binding not available")),
      this._debug &&
        this._debug(`Local ident: ${xk(this._identRaw.toString())}`),
      (this.start = () => {
        (this.start = void 0), f && this._onWrite(f), this._onWrite(d);
      });
  }
  _destruct(t) {
    this._packetRW.read.cleanup(),
      this._packetRW.write.cleanup(),
      this._cipher && this._cipher.free(),
      this._decipher && this._decipher.free(),
      (typeof t != "string" || t.length === 0) && (t = "fatal error"),
      (this.parse = () => {
        throw new Error(`Instance unusable after ${t}`);
      }),
      (this._onWrite = () => {
        throw new Error(`Instance unusable after ${t}`);
      }),
      (this._destruct = void 0);
  }
  cleanup() {
    this._destruct && this._destruct();
  }
  parse(t, n, r) {
    for (; n < r; ) n = this._parse(t, n, r);
  }
  disconnect(t) {
    let r = this._packetRW.write.allocStartKEX;
    const i = this._packetRW.write.alloc(13, !0),
      a = r + 13;
    Dne.has(t) || (t = Ak.PROTOCOL_ERROR),
      (i[r] = et.DISCONNECT),
      fe(i, t, ++r),
      i.fill(0, (r += 4), a),
      this._debug && this._debug(`Outbound: Sending DISCONNECT (${t})`),
      tt(this, this._packetRW.write.finalize(i, !0), !0);
  }
  ping() {
    const t = this._packetRW.write.allocStart,
      n = this._packetRW.write.alloc(YA.length);
    n.set(YA, t),
      this._debug &&
        this._debug(
          "Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)",
        ),
      tt(this, this._packetRW.write.finalize(n));
  }
  rekey() {
    this._kexinit === void 0
      ? (this._debug && this._debug("Outbound: Initiated explicit rekey"),
        (this._queue = []),
        Sk(this))
      : this._debug && this._debug("Outbound: Ignoring rekey during handshake");
  }
  requestSuccess(t) {
    let n = this._packetRW.write.allocStart,
      r;
    Buffer.isBuffer(t)
      ? ((r = this._packetRW.write.alloc(1 + t.length)),
        (r[n] = et.REQUEST_SUCCESS),
        r.set(t, ++n))
      : ((r = this._packetRW.write.alloc(1)), (r[n] = et.REQUEST_SUCCESS)),
      this._debug && this._debug("Outbound: Sending REQUEST_SUCCESS"),
      tt(this, this._packetRW.write.finalize(r));
  }
  requestFailure() {
    const t = this._packetRW.write.allocStart,
      n = this._packetRW.write.alloc(1);
    (n[t] = et.REQUEST_FAILURE),
      this._debug && this._debug("Outbound: Sending REQUEST_FAILURE"),
      tt(this, this._packetRW.write.finalize(n));
  }
  channelSuccess(t) {
    let n = this._packetRW.write.allocStart;
    const r = this._packetRW.write.alloc(1 + 4);
    (r[n] = et.CHANNEL_SUCCESS),
      fe(r, t, ++n),
      this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${t})`),
      tt(this, this._packetRW.write.finalize(r));
  }
  channelFailure(t) {
    let n = this._packetRW.write.allocStart;
    const r = this._packetRW.write.alloc(1 + 4);
    (r[n] = et.CHANNEL_FAILURE),
      fe(r, t, ++n),
      this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${t})`),
      tt(this, this._packetRW.write.finalize(r));
  }
  channelEOF(t) {
    let n = this._packetRW.write.allocStart;
    const r = this._packetRW.write.alloc(1 + 4);
    (r[n] = et.CHANNEL_EOF),
      fe(r, t, ++n),
      this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${t})`),
      tt(this, this._packetRW.write.finalize(r));
  }
  channelClose(t) {
    let n = this._packetRW.write.allocStart;
    const r = this._packetRW.write.alloc(1 + 4);
    (r[n] = et.CHANNEL_CLOSE),
      fe(r, t, ++n),
      this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${t})`),
      tt(this, this._packetRW.write.finalize(r));
  }
  channelWindowAdjust(t, n) {
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + 4);
    (i[r] = et.CHANNEL_WINDOW_ADJUST),
      fe(i, t, ++r),
      fe(i, n, (r += 4)),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${t}, ${n})`),
      tt(this, this._packetRW.write.finalize(i));
  }
  channelData(t, n) {
    const r = Buffer.isBuffer(n),
      i = r ? n.length : Buffer.byteLength(n);
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 4 + i);
    (s[a] = et.CHANNEL_DATA),
      fe(s, t, ++a),
      fe(s, i, (a += 4)),
      r ? s.set(n, (a += 4)) : s.utf8Write(n, (a += 4), i),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_DATA (r:${t}, ${i})`),
      tt(this, this._packetRW.write.finalize(s));
  }
  channelExtData(t, n, r) {
    const i = Buffer.isBuffer(n),
      a = i ? n.length : Buffer.byteLength(n);
    let s = this._packetRW.write.allocStart;
    const o = this._packetRW.write.alloc(1 + 4 + 4 + 4 + a);
    (o[s] = et.CHANNEL_EXTENDED_DATA),
      fe(o, t, ++s),
      fe(o, r, (s += 4)),
      fe(o, a, (s += 4)),
      i ? o.set(n, (s += 4)) : o.utf8Write(n, (s += 4), a),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${t})`),
      tt(this, this._packetRW.write.finalize(o));
  }
  channelOpenConfirm(t, n, r, i) {
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);
    (s[a] = et.CHANNEL_OPEN_CONFIRMATION),
      fe(s, t, ++a),
      fe(s, n, (a += 4)),
      fe(s, r, (a += 4)),
      fe(s, i, (a += 4)),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${t}, l:${n})`,
        ),
      tt(this, this._packetRW.write.finalize(s));
  }
  channelOpenFail(t, n, r) {
    typeof r != "string" && (r = "");
    const i = Buffer.byteLength(r);
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 4 + 4 + i + 4);
    (s[a] = et.CHANNEL_OPEN_FAILURE),
      fe(s, t, ++a),
      fe(s, n, (a += 4)),
      fe(s, i, (a += 4)),
      (a += 4),
      i && (s.utf8Write(r, a, i), (a += i)),
      fe(s, 0, a),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${t})`),
      tt(this, this._packetRW.write.finalize(s));
  }
  service(t) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const n = Buffer.byteLength(t);
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + n);
    (i[r] = et.SERVICE_REQUEST),
      fe(i, n, ++r),
      i.utf8Write(t, (r += 4), n),
      this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${t})`),
      tt(this, this._packetRW.write.finalize(i));
  }
  authPassword(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.byteLength(t),
      a = Buffer.byteLength(n),
      s = r ? Buffer.byteLength(r) : 0;
    let o = this._packetRW.write.allocStart;
    const c = this._packetRW.write.alloc(
      1 + 4 + i + 4 + 14 + 4 + 8 + 1 + 4 + a + (r ? 4 + s : 0),
    );
    (c[o] = et.USERAUTH_REQUEST),
      fe(c, i, ++o),
      c.utf8Write(t, (o += 4), i),
      fe(c, 14, (o += i)),
      c.utf8Write("ssh-connection", (o += 4), 14),
      fe(c, 8, (o += 14)),
      c.utf8Write("password", (o += 4), 8),
      (c[(o += 8)] = r ? 1 : 0),
      fe(c, a, ++o),
      Buffer.isBuffer(n)
        ? Tf(n, c, 0, a, (o += 4))
        : c.utf8Write(n, (o += 4), a),
      r
        ? (fe(c, s, (o += a)),
          Buffer.isBuffer(r)
            ? Tf(r, c, 0, s, (o += 4))
            : c.utf8Write(r, (o += 4), s),
          this._debug &&
            this._debug(
              "Outbound: Sending USERAUTH_REQUEST (changed password)",
            ))
        : this._debug &&
          this._debug("Outbound: Sending USERAUTH_REQUEST (password)"),
      this._authsQueue.push("password"),
      tt(this, this._packetRW.write.finalize(c));
  }
  authPK(t, n, r, i) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    if (((n = KA(n)), n instanceof Error)) throw new Error("Invalid key");
    const a = n.type;
    (n = n.getPublicSSH()),
      typeof r == "function" && ((i = r), (r = void 0)),
      r || (r = a);
    const s = Buffer.byteLength(t),
      o = Buffer.byteLength(r),
      c = n.length,
      l = this._kex.sessionID,
      f = l.length,
      u = (i ? 4 + f : 0) + 1 + 4 + s + 4 + 14 + 4 + 9 + 1 + 4 + o + 4 + c;
    let d, p;
    if (
      (i
        ? ((d = Buffer.allocUnsafe(u)),
          (p = 0),
          fe(d, f, p),
          d.set(l, (p += 4)),
          (p += f))
        : ((d = this._packetRW.write.alloc(u)),
          (p = this._packetRW.write.allocStart)),
      (d[p] = et.USERAUTH_REQUEST),
      fe(d, s, ++p),
      d.utf8Write(t, (p += 4), s),
      fe(d, 14, (p += s)),
      d.utf8Write("ssh-connection", (p += 4), 14),
      fe(d, 9, (p += 14)),
      d.utf8Write("publickey", (p += 4), 9),
      (d[(p += 9)] = i ? 1 : 0),
      fe(d, o, ++p),
      d.utf8Write(r, (p += 4), o),
      fe(d, c, (p += o)),
      d.set(n, (p += 4)),
      !i)
    ) {
      this._authsQueue.push("publickey"),
        this._debug &&
          this._debug(
            "Outbound: Sending USERAUTH_REQUEST (publickey -- check)",
          ),
        tt(this, this._packetRW.write.finalize(d));
      return;
    }
    i(d, (h) => {
      if (((h = VA(h, a)), h === !1))
        throw new Error("Error while converting handshake signature");
      const m = h.length;
      (p = this._packetRW.write.allocStart),
        (d = this._packetRW.write.alloc(
          1 + 4 + s + 4 + 14 + 4 + 9 + 1 + 4 + o + 4 + c + 4 + 4 + o + 4 + m,
        )),
        (d[p] = et.USERAUTH_REQUEST),
        fe(d, s, ++p),
        d.utf8Write(t, (p += 4), s),
        fe(d, 14, (p += s)),
        d.utf8Write("ssh-connection", (p += 4), 14),
        fe(d, 9, (p += 14)),
        d.utf8Write("publickey", (p += 4), 9),
        (d[(p += 9)] = 1),
        fe(d, o, ++p),
        d.utf8Write(r, (p += 4), o),
        fe(d, c, (p += o)),
        d.set(n, (p += 4)),
        fe(d, 4 + o + 4 + m, (p += c)),
        fe(d, o, (p += 4)),
        d.utf8Write(r, (p += 4), o),
        fe(d, m, (p += o)),
        d.set(h, (p += 4)),
        this._authsQueue.push("publickey"),
        this._debug &&
          this._debug("Outbound: Sending USERAUTH_REQUEST (publickey)"),
        tt(this, this._packetRW.write.finalize(d));
    });
  }
  authHostbased(t, n, r, i, a, s) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    if (((n = KA(n)), n instanceof Error)) throw new Error("Invalid key");
    const o = n.type;
    (n = n.getPublicSSH()),
      typeof a == "function" && ((s = a), (a = void 0)),
      a || (a = o);
    const c = Buffer.byteLength(t),
      l = Buffer.byteLength(a),
      f = n.length,
      u = this._kex.sessionID,
      d = u.length,
      p = Buffer.byteLength(r),
      h = Buffer.byteLength(i),
      m = Buffer.allocUnsafe(
        4 + d + 1 + 4 + c + 4 + 14 + 4 + 9 + 4 + l + 4 + f + 4 + p + 4 + h,
      );
    let g = 0;
    fe(m, d, g),
      m.set(u, (g += 4)),
      (m[(g += d)] = et.USERAUTH_REQUEST),
      fe(m, c, ++g),
      m.utf8Write(t, (g += 4), c),
      fe(m, 14, (g += c)),
      m.utf8Write("ssh-connection", (g += 4), 14),
      fe(m, 9, (g += 14)),
      m.utf8Write("hostbased", (g += 4), 9),
      fe(m, l, (g += 9)),
      m.utf8Write(a, (g += 4), l),
      fe(m, f, (g += l)),
      m.set(n, (g += 4)),
      fe(m, p, (g += f)),
      m.utf8Write(r, (g += 4), p),
      fe(m, h, (g += p)),
      m.utf8Write(i, (g += 4), h),
      s(m, (v) => {
        if (((v = VA(v, o)), !v))
          throw new Error("Error while converting handshake signature");
        const y = v.length,
          _ = m.length - d - 4;
        g = this._packetRW.write.allocStart;
        const E = this._packetRW.write.alloc(_ + 4 + 4 + l + 4 + y);
        Tf(m, E, 4 + d, m.length, g),
          fe(E, 4 + l + 4 + y, (g += _)),
          fe(E, l, (g += 4)),
          E.utf8Write(a, (g += 4), l),
          fe(E, y, (g += l)),
          E.set(v, (g += 4)),
          this._authsQueue.push("hostbased"),
          this._debug &&
            this._debug("Outbound: Sending USERAUTH_REQUEST (hostbased)"),
          tt(this, this._packetRW.write.finalize(E));
      });
  }
  authKeyboard(t) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const n = Buffer.byteLength(t);
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + n + 4 + 14 + 4 + 20 + 4 + 4);
    (i[r] = et.USERAUTH_REQUEST),
      fe(i, n, ++r),
      i.utf8Write(t, (r += 4), n),
      fe(i, 14, (r += n)),
      i.utf8Write("ssh-connection", (r += 4), 14),
      fe(i, 20, (r += 14)),
      i.utf8Write("keyboard-interactive", (r += 4), 20),
      fe(i, 0, (r += 20)),
      fe(i, 0, (r += 4)),
      this._authsQueue.push("keyboard-interactive"),
      this._debug &&
        this._debug(
          "Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)",
        ),
      tt(this, this._packetRW.write.finalize(i));
  }
  authNone(t) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const n = Buffer.byteLength(t);
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + n + 4 + 14 + 4 + 4);
    (i[r] = et.USERAUTH_REQUEST),
      fe(i, n, ++r),
      i.utf8Write(t, (r += 4), n),
      fe(i, 14, (r += n)),
      i.utf8Write("ssh-connection", (r += 4), 14),
      fe(i, 4, (r += 14)),
      i.utf8Write("none", (r += 4), 4),
      this._authsQueue.push("none"),
      this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (none)"),
      tt(this, this._packetRW.write.finalize(i));
  }
  authInfoRes(t) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let n = 0,
      r;
    if (t) {
      r = new Array(t.length);
      for (let s = 0; s < t.length; ++s) {
        const o = Buffer.byteLength(t[s]);
        (r[s] = o), (n += 4 + o);
      }
    }
    let i = this._packetRW.write.allocStart;
    const a = this._packetRW.write.alloc(1 + 4 + n);
    if (((a[i] = et.USERAUTH_INFO_RESPONSE), t)) {
      fe(a, t.length, ++i), (i += 4);
      for (let s = 0; s < t.length; ++s) {
        const o = r[s];
        fe(a, o, i), (i += 4), o && (a.utf8Write(t[s], i, o), (i += o));
      }
    } else fe(a, 0, ++i);
    this._debug && this._debug("Outbound: Sending USERAUTH_INFO_RESPONSE"),
      tt(this, this._packetRW.write.finalize(a));
  }
  tcpipForward(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.byteLength(t);
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + i + 4);
    (s[a] = et.GLOBAL_REQUEST),
      fe(s, 13, ++a),
      s.utf8Write("tcpip-forward", (a += 4), 13),
      (s[(a += 13)] = r === void 0 || r === !0 ? 1 : 0),
      fe(s, i, ++a),
      s.utf8Write(t, (a += 4), i),
      fe(s, n, (a += i)),
      this._debug &&
        this._debug("Outbound: Sending GLOBAL_REQUEST (tcpip-forward)"),
      tt(this, this._packetRW.write.finalize(s));
  }
  cancelTcpipForward(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.byteLength(t);
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + i + 4);
    (s[a] = et.GLOBAL_REQUEST),
      fe(s, 20, ++a),
      s.utf8Write("cancel-tcpip-forward", (a += 4), 20),
      (s[(a += 20)] = r === void 0 || r === !0 ? 1 : 0),
      fe(s, i, ++a),
      s.utf8Write(t, (a += 4), i),
      fe(s, n, (a += i)),
      this._debug &&
        this._debug("Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)"),
      tt(this, this._packetRW.write.finalize(s));
  }
  openssh_streamLocalForward(t, n) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = this._packetRW.write.allocStart;
    const a = this._packetRW.write.alloc(1 + 4 + 31 + 1 + 4 + r);
    (a[i] = et.GLOBAL_REQUEST),
      fe(a, 31, ++i),
      a.utf8Write("streamlocal-forward@openssh.com", (i += 4), 31),
      (a[(i += 31)] = n === void 0 || n === !0 ? 1 : 0),
      fe(a, r, ++i),
      a.utf8Write(t, (i += 4), r),
      this._debug &&
        this._debug(
          "Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)",
        ),
      tt(this, this._packetRW.write.finalize(a));
  }
  openssh_cancelStreamLocalForward(t, n) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = this._packetRW.write.allocStart;
    const a = this._packetRW.write.alloc(1 + 4 + 38 + 1 + 4 + r);
    (a[i] = et.GLOBAL_REQUEST),
      fe(a, 38, ++i),
      a.utf8Write("cancel-streamlocal-forward@openssh.com", (i += 4), 38),
      (a[(i += 38)] = n === void 0 || n === !0 ? 1 : 0),
      fe(a, r, ++i),
      a.utf8Write(t, (i += 4), r),
      this._debug &&
        this._debug(
          "Outbound: Sending GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)",
        ),
      tt(this, this._packetRW.write.finalize(a));
  }
  directTcpip(t, n, r, i) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const a = Buffer.byteLength(i.srcIP),
      s = Buffer.byteLength(i.dstIP);
    let o = this._packetRW.write.allocStart;
    const c = this._packetRW.write.alloc(
      1 + 4 + 12 + 4 + 4 + 4 + 4 + a + 4 + 4 + s + 4,
    );
    (c[o] = et.CHANNEL_OPEN),
      fe(c, 12, ++o),
      c.utf8Write("direct-tcpip", (o += 4), 12),
      fe(c, t, (o += 12)),
      fe(c, n, (o += 4)),
      fe(c, r, (o += 4)),
      fe(c, s, (o += 4)),
      c.utf8Write(i.dstIP, (o += 4), s),
      fe(c, i.dstPort, (o += s)),
      fe(c, a, (o += 4)),
      c.utf8Write(i.srcIP, (o += 4), a),
      fe(c, i.srcPort, (o += a)),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_OPEN (r:${t}, direct-tcpip)`),
      tt(this, this._packetRW.write.finalize(c));
  }
  openssh_directStreamLocal(t, n, r, i) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const a = Buffer.byteLength(i.socketPath);
    let s = this._packetRW.write.allocStart;
    const o = this._packetRW.write.alloc(
      1 + 4 + 30 + 4 + 4 + 4 + 4 + a + 4 + 4,
    );
    (o[s] = et.CHANNEL_OPEN),
      fe(o, 30, ++s),
      o.utf8Write("direct-streamlocal@openssh.com", (s += 4), 30),
      fe(o, t, (s += 30)),
      fe(o, n, (s += 4)),
      fe(o, r, (s += 4)),
      fe(o, a, (s += 4)),
      o.utf8Write(i.socketPath, (s += 4), a),
      Tne(o, 0, (s += a), s + 8),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${t}, direct-streamlocal@openssh.com)`,
        ),
      tt(this, this._packetRW.write.finalize(o));
  }
  openssh_noMoreSessions(t) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let n = this._packetRW.write.allocStart;
    const r = this._packetRW.write.alloc(1 + 4 + 28 + 1);
    (r[n] = et.GLOBAL_REQUEST),
      fe(r, 28, ++n),
      r.utf8Write("no-more-sessions@openssh.com", (n += 4), 28),
      (r[(n += 28)] = t === void 0 || t === !0 ? 1 : 0),
      this._debug &&
        this._debug(
          "Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)",
        ),
      tt(this, this._packetRW.write.finalize(r));
  }
  session(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let i = this._packetRW.write.allocStart;
    const a = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);
    (a[i] = et.CHANNEL_OPEN),
      fe(a, 7, ++i),
      a.utf8Write("session", (i += 4), 7),
      fe(a, t, (i += 7)),
      fe(a, n, (i += 4)),
      fe(a, r, (i += 4)),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_OPEN (r:${t}, session)`),
      tt(this, this._packetRW.write.finalize(a));
  }
  windowChange(t, n, r, i, a) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let s = this._packetRW.write.allocStart;
    const o = this._packetRW.write.alloc(1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4);
    (o[s] = et.CHANNEL_REQUEST),
      fe(o, t, ++s),
      fe(o, 13, (s += 4)),
      o.utf8Write("window-change", (s += 4), 13),
      (o[(s += 13)] = 0),
      fe(o, r, ++s),
      fe(o, n, (s += 4)),
      fe(o, a, (s += 4)),
      fe(o, i, (s += 4)),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${t}, window-change)`,
        ),
      tt(this, this._packetRW.write.finalize(o));
  }
  pty(t, n, r, i, a, s, o, c) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    (!s || !s.length) && (s = "vt100"),
      o &&
        !Buffer.isBuffer(o) &&
        !Array.isArray(o) &&
        typeof o == "object" &&
        o !== null &&
        (o = Wne(o)),
      (!o || !o.length) && (o = Fne);
    const l = s.length,
      f = o.length;
    let u = this._packetRW.write.allocStart;
    const d = this._packetRW.write.alloc(
      1 + 4 + 4 + 7 + 1 + 4 + l + 4 + 4 + 4 + 4 + 4 + f,
    );
    if (
      ((d[u] = et.CHANNEL_REQUEST),
      fe(d, t, ++u),
      fe(d, 7, (u += 4)),
      d.utf8Write("pty-req", (u += 4), 7),
      (d[(u += 7)] = c === void 0 || c === !0 ? 1 : 0),
      fe(d, l, ++u),
      d.utf8Write(s, (u += 4), l),
      fe(d, r, (u += l)),
      fe(d, n, (u += 4)),
      fe(d, a, (u += 4)),
      fe(d, i, (u += 4)),
      fe(d, f, (u += 4)),
      (u += 4),
      Array.isArray(o))
    )
      for (let p = 0; p < f; ++p) d[u++] = o[p];
    else Buffer.isBuffer(o) && d.set(o, u);
    this._debug &&
      this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${t}, pty-req)`),
      tt(this, this._packetRW.write.finalize(d));
  }
  shell(t, n) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);
    (i[r] = et.CHANNEL_REQUEST),
      fe(i, t, ++r),
      fe(i, 5, (r += 4)),
      i.utf8Write("shell", (r += 4), 5),
      (i[(r += 5)] = n === void 0 || n === !0 ? 1 : 0),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${t}, shell)`),
      tt(this, this._packetRW.write.finalize(i));
  }
  exec(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.isBuffer(n),
      a = i ? n.length : Buffer.byteLength(n);
    let s = this._packetRW.write.allocStart;
    const o = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + a);
    (o[s] = et.CHANNEL_REQUEST),
      fe(o, t, ++s),
      fe(o, 4, (s += 4)),
      o.utf8Write("exec", (s += 4), 4),
      (o[(s += 4)] = r === void 0 || r === !0 ? 1 : 0),
      fe(o, a, ++s),
      i ? o.set(n, (s += 4)) : o.utf8Write(n, (s += 4), a),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${t}, exec: ${n})`),
      tt(this, this._packetRW.write.finalize(o));
  }
  signal(t, n) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const r = n;
    if (
      ((n = n.toUpperCase()),
      n.slice(0, 3) === "SIG" && (n = n.slice(3)),
      WA[n] !== 1)
    )
      throw new Error(`Invalid signal: ${r}`);
    const i = n.length;
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 4 + 6 + 1 + 4 + i);
    (s[a] = et.CHANNEL_REQUEST),
      fe(s, t, ++a),
      fe(s, 6, (a += 4)),
      s.utf8Write("signal", (a += 4), 6),
      (s[(a += 6)] = 0),
      fe(s, i, ++a),
      s.utf8Write(n, (a += 4), i),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${t}, signal: ${n})`),
      tt(this, this._packetRW.write.finalize(s));
  }
  env(t, n, r, i) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const a = Buffer.byteLength(n),
      s = Buffer.isBuffer(r),
      o = s ? r.length : Buffer.byteLength(r);
    let c = this._packetRW.write.allocStart;
    const l = this._packetRW.write.alloc(1 + 4 + 4 + 3 + 1 + 4 + a + 4 + o);
    (l[c] = et.CHANNEL_REQUEST),
      fe(l, t, ++c),
      fe(l, 3, (c += 4)),
      l.utf8Write("env", (c += 4), 3),
      (l[(c += 3)] = i === void 0 || i === !0 ? 1 : 0),
      fe(l, a, ++c),
      l.utf8Write(n, (c += 4), a),
      fe(l, o, (c += a)),
      s ? l.set(r, (c += 4)) : l.utf8Write(r, (c += 4), o),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${t}, env: ${n}=${r})`,
        ),
      tt(this, this._packetRW.write.finalize(l));
  }
  x11Forward(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const i = n.protocol,
      a = n.cookie,
      s = Buffer.isBuffer(i),
      o = s ? i.length : Buffer.byteLength(i),
      c = Buffer.isBuffer(a),
      l = c ? a.length : Buffer.byteLength(a);
    let f = this._packetRW.write.allocStart;
    const u = this._packetRW.write.alloc(
      1 + 4 + 4 + 7 + 1 + 1 + 4 + o + 4 + l + 4,
    );
    (u[f] = et.CHANNEL_REQUEST),
      fe(u, t, ++f),
      fe(u, 7, (f += 4)),
      u.utf8Write("x11-req", (f += 4), 7),
      (u[(f += 7)] = r === void 0 || r === !0 ? 1 : 0),
      (u[++f] = n.single ? 1 : 0),
      fe(u, o, ++f),
      s ? u.set(i, (f += 4)) : u.utf8Write(i, (f += 4), o),
      fe(u, l, (f += o)),
      c ? u.set(a, (f += 4)) : u.latin1Write(a, (f += 4), l),
      fe(u, n.screen || 0, (f += l)),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${t}, x11-req)`),
      tt(this, this._packetRW.write.finalize(u));
  }
  subsystem(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.byteLength(n);
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + i);
    (s[a] = et.CHANNEL_REQUEST),
      fe(s, t, ++a),
      fe(s, 9, (a += 4)),
      s.utf8Write("subsystem", (a += 4), 9),
      (s[(a += 9)] = r === void 0 || r === !0 ? 1 : 0),
      fe(s, i, ++a),
      s.utf8Write(n, (a += 4), i),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${t}, subsystem: ${n})`,
        ),
      tt(this, this._packetRW.write.finalize(s));
  }
  openssh_agentForward(t, n) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);
    (i[r] = et.CHANNEL_REQUEST),
      fe(i, t, ++r),
      fe(i, 26, (r += 4)),
      i.utf8Write("auth-agent-req@openssh.com", (r += 4), 26),
      (i[(r += 26)] = n === void 0 || n === !0 ? 1 : 0),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${t}, auth-agent-req@openssh.com)`,
        ),
      tt(this, this._packetRW.write.finalize(i));
  }
  openssh_hostKeysProve(t) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let n = 0;
    const r = [];
    for (const s of t) {
      const o = s.getPublicSSH();
      (n += 4 + o.length), r.push(o);
    }
    let i = this._packetRW.write.allocStart;
    const a = this._packetRW.write.alloc(1 + 4 + 29 + 1 + n);
    (a[i] = et.GLOBAL_REQUEST),
      fe(a, 29, ++i),
      a.utf8Write("hostkeys-prove-00@openssh.com", (i += 4), 29),
      (a[(i += 29)] = 1),
      ++i;
    for (const s of r)
      fe(a, s.length, i), Tf(s, a, 0, s.length, (i += 4)), (i += s.length);
    this._debug &&
      this._debug(
        "Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)",
      ),
      tt(this, this._packetRW.write.finalize(a));
  }
  serviceAccept(t) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const n = Buffer.byteLength(t);
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + n);
    if (
      ((i[r] = et.SERVICE_ACCEPT),
      fe(i, n, ++r),
      i.utf8Write(t, (r += 4), n),
      this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${t})`),
      tt(this, this._packetRW.write.finalize(i)),
      this._server && this._banner && t === "ssh-userauth")
    ) {
      const a = this._banner;
      this._banner = void 0;
      const s = Buffer.byteLength(a);
      r = this._packetRW.write.allocStart;
      const o = this._packetRW.write.alloc(1 + 4 + s + 4);
      (o[r] = et.USERAUTH_BANNER),
        fe(o, s, ++r),
        o.utf8Write(a, (r += 4), s),
        fe(o, 0, (r += s)),
        this._debug && this._debug("Outbound: Sending USERAUTH_BANNER"),
        tt(this, this._packetRW.write.finalize(o));
    }
  }
  forwardedTcpip(t, n, r, i) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const a = Buffer.byteLength(i.boundAddr),
      s = Buffer.byteLength(i.remoteAddr);
    let o = this._packetRW.write.allocStart;
    const c = this._packetRW.write.alloc(
      1 + 4 + 15 + 4 + 4 + 4 + 4 + a + 4 + 4 + s + 4,
    );
    (c[o] = et.CHANNEL_OPEN),
      fe(c, 15, ++o),
      c.utf8Write("forwarded-tcpip", (o += 4), 15),
      fe(c, t, (o += 15)),
      fe(c, n, (o += 4)),
      fe(c, r, (o += 4)),
      fe(c, a, (o += 4)),
      c.utf8Write(i.boundAddr, (o += 4), a),
      fe(c, i.boundPort, (o += a)),
      fe(c, s, (o += 4)),
      c.utf8Write(i.remoteAddr, (o += 4), s),
      fe(c, i.remotePort, (o += s)),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_OPEN (r:${t}, forwarded-tcpip)`),
      tt(this, this._packetRW.write.finalize(c));
  }
  x11(t, n, r, i) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const a = Buffer.byteLength(i.originAddr);
    let s = this._packetRW.write.allocStart;
    const o = this._packetRW.write.alloc(1 + 4 + 3 + 4 + 4 + 4 + 4 + a + 4);
    (o[s] = et.CHANNEL_OPEN),
      fe(o, 3, ++s),
      o.utf8Write("x11", (s += 4), 3),
      fe(o, t, (s += 3)),
      fe(o, n, (s += 4)),
      fe(o, r, (s += 4)),
      fe(o, a, (s += 4)),
      o.utf8Write(i.originAddr, (s += 4), a),
      fe(o, i.originPort, (s += a)),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_OPEN (r:${t}, x11)`),
      tt(this, this._packetRW.write.finalize(o));
  }
  openssh_authAgent(t, n, r) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    let i = this._packetRW.write.allocStart;
    const a = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);
    (a[i] = et.CHANNEL_OPEN),
      fe(a, 22, ++i),
      a.utf8Write("auth-agent@openssh.com", (i += 4), 22),
      fe(a, t, (i += 22)),
      fe(a, n, (i += 4)),
      fe(a, r, (i += 4)),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${t}, auth-agent@openssh.com)`,
        ),
      tt(this, this._packetRW.write.finalize(a));
  }
  openssh_forwardedStreamLocal(t, n, r, i) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const a = Buffer.byteLength(i.socketPath);
    let s = this._packetRW.write.allocStart;
    const o = this._packetRW.write.alloc(1 + 4 + 33 + 4 + 4 + 4 + 4 + a + 4);
    (o[s] = et.CHANNEL_OPEN),
      fe(o, 33, ++s),
      o.utf8Write("forwarded-streamlocal@openssh.com", (s += 4), 33),
      fe(o, t, (s += 33)),
      fe(o, n, (s += 4)),
      fe(o, r, (s += 4)),
      fe(o, a, (s += 4)),
      o.utf8Write(i.socketPath, (s += 4), a),
      fe(o, 0, (s += a)),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${t}, forwarded-streamlocal@openssh.com)`,
        ),
      tt(this, this._packetRW.write.finalize(o));
  }
  exitStatus(t, n) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);
    (i[r] = et.CHANNEL_REQUEST),
      fe(i, t, ++r),
      fe(i, 11, (r += 4)),
      i.utf8Write("exit-status", (r += 4), 11),
      (i[(r += 11)] = 0),
      fe(i, n, ++r),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${t}, exit-status: ${n})`,
        ),
      tt(this, this._packetRW.write.finalize(i));
  }
  exitSignal(t, n, r, i) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const a = n;
    if (typeof a != "string" || !a) throw new Error(`Invalid signal: ${a}`);
    let s = n.toUpperCase();
    if ((s.slice(0, 3) === "SIG" && (s = s.slice(3)), WA[s] !== 1))
      throw new Error(`Invalid signal: ${a}`);
    const o = Buffer.byteLength(s),
      c = i ? Buffer.byteLength(i) : 0;
    let l = this._packetRW.write.allocStart;
    const f = this._packetRW.write.alloc(
      1 + 4 + 4 + 11 + 1 + 4 + o + 1 + 4 + c + 4,
    );
    (f[l] = et.CHANNEL_REQUEST),
      fe(f, t, ++l),
      fe(f, 11, (l += 4)),
      f.utf8Write("exit-signal", (l += 4), 11),
      (f[(l += 11)] = 0),
      fe(f, o, ++l),
      f.utf8Write(s, (l += 4), o),
      (f[(l += o)] = r ? 1 : 0),
      fe(f, c, ++l),
      (l += 4),
      c && (f.utf8Write(i, l, c), (l += c)),
      fe(f, 0, l),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${t}, exit-signal: ${n})`,
        ),
      tt(this, this._packetRW.write.finalize(f));
  }
  authFailure(t, n) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    if (this._authsQueue.length === 0) throw new Error("No auth in progress");
    let r;
    if ((typeof t == "boolean" && ((n = t), (t = void 0)), t)) {
      r = [];
      for (let o = 0; o < t.length; ++o)
        t[o].toLowerCase() !== "none" && r.push(t[o]);
      r = r.join(",");
    } else r = "";
    const i = r.length;
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + i + 1);
    (s[a] = et.USERAUTH_FAILURE),
      fe(s, i, ++a),
      s.utf8Write(r, (a += 4), i),
      (s[(a += i)] = n === !0 ? 1 : 0),
      this._authsQueue.shift(),
      this._debug && this._debug("Outbound: Sending USERAUTH_FAILURE"),
      tt(this, this._packetRW.write.finalize(s));
  }
  authSuccess() {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    if (this._authsQueue.length === 0) throw new Error("No auth in progress");
    const t = this._packetRW.write.allocStart,
      n = this._packetRW.write.alloc(1);
    (n[t] = et.USERAUTH_SUCCESS),
      this._authsQueue.shift(),
      (this._authenticated = !0),
      this._debug && this._debug("Outbound: Sending USERAUTH_SUCCESS"),
      tt(this, this._packetRW.write.finalize(n)),
      this._kex.negotiated.cs.compress === "zlib@openssh.com" &&
        (this._packetRW.read = new $k()),
      this._kex.negotiated.sc.compress === "zlib@openssh.com" &&
        (this._packetRW.write = new Ck(this));
  }
  authPKOK(t, n) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    if (this._authsQueue.length === 0 || this._authsQueue[0] !== "publickey")
      throw new Error('"publickey" auth not in progress');
    const r = Buffer.byteLength(t),
      i = n.length;
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + r + 4 + i);
    (s[a] = et.USERAUTH_PK_OK),
      fe(s, r, ++a),
      s.utf8Write(t, (a += 4), r),
      fe(s, i, (a += r)),
      s.set(n, (a += 4)),
      this._authsQueue.shift(),
      this._debug && this._debug("Outbound: Sending USERAUTH_PK_OK"),
      tt(this, this._packetRW.write.finalize(s));
  }
  authPasswdChg(t) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const n = Buffer.byteLength(t);
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + n + 4);
    (i[r] = et.USERAUTH_PASSWD_CHANGEREQ),
      fe(i, n, ++r),
      i.utf8Write(t, (r += 4), n),
      fe(i, 0, (r += n)),
      this._debug && this._debug("Outbound: Sending USERAUTH_PASSWD_CHANGEREQ"),
      tt(this, this._packetRW.write.finalize(i));
  }
  authInfoReq(t, n, r) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    let i = 0;
    const a = t ? Buffer.byteLength(t) : 0,
      s = n ? Buffer.byteLength(n) : 0;
    for (let l = 0; l < r.length; ++l)
      i += 4 + Buffer.byteLength(r[l].prompt) + 1;
    let o = this._packetRW.write.allocStart;
    const c = this._packetRW.write.alloc(1 + 4 + a + 4 + s + 4 + 4 + i);
    (c[o] = et.USERAUTH_INFO_REQUEST),
      fe(c, a, ++o),
      (o += 4),
      t && (c.utf8Write(t, o, a), (o += a)),
      fe(c, s, o),
      (o += 4),
      n && (c.utf8Write(n, o, s), (o += s)),
      fe(c, 0, o),
      fe(c, r.length, (o += 4)),
      (o += 4);
    for (let l = 0; l < r.length; ++l) {
      const f = r[l],
        u = Buffer.byteLength(f.prompt);
      fe(c, u, o),
        (o += 4),
        u && (c.utf8Write(f.prompt, o, u), (o += u)),
        (c[o++] = f.echo ? 1 : 0);
    }
    this._debug && this._debug("Outbound: Sending USERAUTH_INFO_REQUEST"),
      tt(this, this._packetRW.write.finalize(c));
  }
};
const Mne = /^SSH-(2\.0|1\.99)-([^ ]+)(?: (.*))?$/;
function Hne(e, t, n) {
  let r, i;
  this._buffer
    ? ((r = Buffer.allocUnsafe(this._buffer.length + (n - t))),
      r.set(this._buffer, 0),
      t === 0
        ? r.set(e, this._buffer.length)
        : r.set(
            new Uint8Array(e.buffer, e.byteOffset + t, n - t),
            this._buffer.length,
          ),
      (i = this._buffer.length),
      (t = 0))
    : ((r = e), (i = 0));
  const a = t;
  let s = t,
    o = t,
    c = !1,
    l = 0,
    f = 0;
  for (; t < r.length; ++t) {
    const u = r[t];
    if (u === 13) {
      c = !0;
      continue;
    }
    if (u === 10) {
      if (
        o > s &&
        o - s > 4 &&
        r[s] === 83 &&
        r[s + 1] === 83 &&
        r[s + 2] === 72 &&
        r[s + 3] === 45
      ) {
        const d = r.latin1Slice(a, o + 1),
          p = s === a ? d : d.slice(s - a),
          h = Mne.exec(p);
        if (!h) throw new Error("Invalid identification string");
        const m = {
          greeting: s === a ? "" : d.slice(0, s - a),
          identRaw: p,
          versions: { protocol: h[1], software: h[2] },
          comments: h[3],
        };
        return (
          (this._remoteIdentRaw = Buffer.from(p)),
          this._debug && this._debug(`Remote ident: ${xk(p)}`),
          (this._compatFlags = Qne(m)),
          (this._buffer = void 0),
          (this._decipher = new Ane(0, Rne.bind(this, { firstPacket: !0 }))),
          (this._parse = qne),
          this._onHeader(m),
          this._destruct ? (Sk(this), t + 1 - i) : n
        );
      }
      if (this._server) throw new Error("Greetings from clients not permitted");
      if (++f > Une) throw new Error("Max greeting lines exceeded");
      (c = !1), (s = t + 1), (l = 0);
    } else {
      if (c) throw new Error("Invalid header: expected newline");
      if (++l >= Bne) throw new Error("Header line too long");
    }
    o = t;
  }
  return this._buffer || (this._buffer = Ik(r, a)), t - i;
}
function qne(e, t, n) {
  return this._decipher.decrypt(e, t, n);
}
function Gne(e) {
  if ((this._onPacket(), e.length === 0)) {
    this._debug && this._debug("Inbound: Skipping empty packet payload");
    return;
  }
  e = this._packetRW.read.read(e);
  const t = e[0];
  t === et.USERAUTH_SUCCESS &&
    !this._server &&
    !this._authenticated &&
    ((this._authenticated = !0),
    this._kex.negotiated.cs.compress === "zlib@openssh.com" &&
      (this._packetRW.write = new Ck(this)),
    this._kex.negotiated.sc.compress === "zlib@openssh.com" &&
      (this._packetRW.read = new $k()));
  const n = kne[t];
  if (n === void 0) {
    this._debug && this._debug(`Inbound: Unsupported message type: ${t}`);
    return;
  }
  return n(this, e);
}
function Qne(e) {
  const t = e.versions.software;
  let n = 0;
  for (const r of Sne)
    typeof r[0] == "string"
      ? t === r[0] && (n |= r[1])
      : r[0].test(t) && (n |= r[1]);
  return n;
}
function Wne(e) {
  const t = Object.keys(e),
    n = Buffer.allocUnsafe(5 * t.length + 1);
  let r = 0;
  for (let i = 0; i < t.length; ++i) {
    const a = t[i];
    if (a === "TTY_OP_END") continue;
    const s = H0[a];
    if (s === void 0) continue;
    const o = e[a];
    typeof o == "number" &&
      isFinite(o) &&
      ((n[r++] = s),
      (n[r++] = o >>> 24),
      (n[r++] = o >>> 16),
      (n[r++] = o >>> 8),
      (n[r++] = o));
  }
  return (n[r++] = H0.TTY_OP_END), r < n.length ? Ik(n, 0, r) : n;
}
function zne(e) {
  let t =
    "ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521rsa-sha2-512,rsa-sha2-256,ssh-rsa,ssh-dss";
  Ine && (t = `ssh-ed25519,${t}`);
  const n = Buffer.byteLength(t);
  let r = e._packetRW.write.allocStart;
  const i = e._packetRW.write.alloc(1 + 4 + 4 + 15 + 4 + n);
  (i[r] = et.EXT_INFO),
    fe(i, 1, ++r),
    fe(i, 15, (r += 4)),
    i.utf8Write("server-sig-algs", (r += 4), 15),
    fe(i, n, (r += 15)),
    i.utf8Write(t, (r += 4), n),
    e._debug && e._debug("Outbound: Sending EXT_INFO"),
    tt(e, e._packetRW.write.finalize(i));
}
var kk = jne,
  Su = {};
const Ld = gc,
  { inspect: Kne } = wr;
function XA(e) {
  let t = "",
    n = e.length;
  const r = e[0] === "-" ? 1 : 0;
  for (; n >= r + 4; n -= 3) t = `_${e.slice(n - 3, n)}${t}`;
  return `${e.slice(0, n)}${t}`;
}
function JA(e, t) {
  if (
    (Ld(typeof t == "string", "`thing` has to be of type string"),
    Array.isArray(e))
  ) {
    const n = e.length;
    return (
      Ld(n > 0, "At least one expected value needs to be specified"),
      (e = e.map((r) => String(r))),
      n > 2
        ? `one of ${t} ${e.slice(0, n - 1).join(", ")}, or ` + e[n - 1]
        : n === 2
        ? `one of ${t} ${e[0]} or ${e[1]}`
        : `of ${t} ${e[0]}`
    );
  }
  return `of ${t} ${String(e)}`;
}
Su.ERR_INTERNAL_ASSERTION = class Tk extends Error {
  constructor(t) {
    super(), Error.captureStackTrace(this, Tk);
    const n = `This is caused by either a bug in ssh2 or incorrect usage of ssh2 internals.
Please open an issue with this stack trace at https://github.com/mscdex/ssh2/issues
`;
    this.message =
      t === void 0
        ? n
        : `${t}
${n}`;
  }
};
const Vne = 2 ** 32,
  ZA = (() => {
    try {
      return new Function("return 2n ** 32n")();
    } catch {}
  })();
Su.ERR_OUT_OF_RANGE = class Nk extends RangeError {
  constructor(t, n, r, i) {
    super(),
      Error.captureStackTrace(this, Nk),
      Ld(n, 'Missing "range" argument');
    let a = i ? t : `The value of "${t}" is out of range.`,
      s;
    Number.isInteger(r) && Math.abs(r) > Vne
      ? (s = XA(String(r)))
      : typeof r == "bigint"
      ? ((s = String(r)), (r > ZA || r < -ZA) && (s = XA(s)), (s += "n"))
      : (s = Kne(r)),
      (a += ` It must be ${n}. Received ${s}`),
      (this.message = a);
  }
};
let Ok = class Pk extends TypeError {
  constructor(t, n, r) {
    super(),
      Error.captureStackTrace(this, Pk),
      Ld(typeof t == "string", "'name' must be a string");
    let i;
    typeof n == "string" && n.startsWith("not ")
      ? ((i = "must not be"), (n = n.replace(/^not /, "")))
      : (i = "must be");
    let a;
    if (t.endsWith(" argument")) a = `The ${t} ${i} ${JA(n, "type")}`;
    else {
      const s = t.includes(".") ? "property" : "argument";
      a = `The "${t}" ${s} ${i} ${JA(n, "type")}`;
    }
    (a += `. Received type ${typeof r}`), (this.message = a);
  }
};
Su.ERR_INVALID_ARG_TYPE = Ok;
Su.validateNumber = function (t, n) {
  if (typeof t != "number") throw new Ok(n, "number", t);
};
const Yne = Hi,
  Oa = Xt,
  { constants: Tr } = Oa,
  { Readable: Dk, Writable: a1 } = Kr,
  { inherits: Lk, isDate: q0 } = wr,
  Xne = Buffer[Symbol.species],
  {
    bufferCopy: Aa,
    bufferSlice: uc,
    makeBufferParser: Jne,
    writeUInt32BE: _e,
  } = Ki(),
  aa = {
    SIZE: 1,
    UIDGID: 2,
    PERMISSIONS: 4,
    ACMODTIME: 8,
    EXTENDED: 2147483648,
  },
  ut = Buffer.alloc(28),
  Dt = {
    OK: 0,
    EOF: 1,
    NO_SUCH_FILE: 2,
    PERMISSION_DENIED: 3,
    FAILURE: 4,
    BAD_MESSAGE: 5,
    NO_CONNECTION: 6,
    CONNECTION_LOST: 7,
    OP_UNSUPPORTED: 8,
  },
  Zne = new Map(Object.values(Dt).map((e) => [e, 1])),
  ere = {
    [Dt.OK]: "No error",
    [Dt.EOF]: "End of file",
    [Dt.NO_SUCH_FILE]: "No such file or directory",
    [Dt.PERMISSION_DENIED]: "Permission denied",
    [Dt.FAILURE]: "Failure",
    [Dt.BAD_MESSAGE]: "Bad message",
    [Dt.NO_CONNECTION]: "No connection",
    [Dt.CONNECTION_LOST]: "Connection lost",
    [Dt.OP_UNSUPPORTED]: "Operation unsupported",
  },
  st = {
    INIT: 1,
    OPEN: 3,
    CLOSE: 4,
    READ: 5,
    WRITE: 6,
    LSTAT: 7,
    FSTAT: 8,
    SETSTAT: 9,
    FSETSTAT: 10,
    OPENDIR: 11,
    READDIR: 12,
    REMOVE: 13,
    MKDIR: 14,
    RMDIR: 15,
    REALPATH: 16,
    STAT: 17,
    RENAME: 18,
    READLINK: 19,
    SYMLINK: 20,
    EXTENDED: 200,
  },
  Pr = {
    VERSION: 2,
    STATUS: 101,
    HANDLE: 102,
    DATA: 103,
    NAME: 104,
    ATTRS: 105,
    EXTENDED: 201,
  },
  nt = { READ: 1, WRITE: 2, APPEND: 4, CREAT: 8, TRUNC: 16, EXCL: 32 },
  eS = 2 * 1024,
  Vt = 2 ** 32 - 1,
  tre = Buffer.from([0, 0, 0, 5, st.INIT, 0, 0, 0, 3]),
  nre = Buffer.from([0, 0, 0, 5, Pr.VERSION, 0, 0, 0, 3]),
  rre = /^SSH-2.0-(?:OpenSSH|dropbear)/,
  ng = 256 * 1024,
  me = Jne(),
  ire = {
    readable: !1,
    writable: !1,
    push: (e) => {},
    once: () => {},
    on: () => {},
    emit: () => {},
    end: () => {},
  };
function Bk() {}
let are = class extends Yne {
  constructor(t, n, r) {
    super(), (typeof r != "object" || !r) && (r = {});
    const i = t._protocol._remoteIdentRaw;
    (this.server = !!r.server),
      (this._debug = typeof r.debug == "function" ? r.debug : void 0),
      (this._isOpenSSH = i && rre.test(i)),
      (this._version = -1),
      (this._extensions = {}),
      (this._biOpt = r.biOpt),
      (this._pktLenBytes = 0),
      (this._pktLen = 0),
      (this._pktPos = 0),
      (this._pktType = 0),
      (this._pktData = void 0),
      (this._writeReqid = -1),
      (this._requests = {}),
      (this._maxInPktLen = ng),
      (this._maxOutPktLen = 34e3),
      (this._maxReadLen = (this._isOpenSSH ? ng : 34e3) - eS),
      (this._maxWriteLen = (this._isOpenSSH ? ng : 34e3) - eS),
      (this.maxOpenHandles = void 0),
      (this._client = t),
      (this._protocol = t._protocol),
      (this._callbacks = []),
      (this._hasX11 = !1),
      (this._exit = {
        code: void 0,
        signal: void 0,
        dump: void 0,
        desc: void 0,
      }),
      (this._waitWindow = !1),
      (this._chunkcb = void 0),
      (this._buffer = []),
      (this.type = n.type),
      (this.subtype = void 0),
      (this.incoming = n.incoming),
      (this.outgoing = n.outgoing),
      (this.stderr = ire),
      (this.readable = !0);
  }
  push(t) {
    if (t === null) {
      if ((Hk(this), !this.readable)) return;
      (this.readable = !1), this.emit("end");
      return;
    }
    let n = 0;
    for (; n < t.length; ) {
      if (this._pktLenBytes < 4) {
        let s = Math.min(4 - this._pktLenBytes, t.length - n);
        for (this._pktLenBytes += s; s--; )
          this._pktLen = (this._pktLen << 8) + t[n++];
        if (this._pktLenBytes < 4) return;
        if (this._pktLen === 0) return Bt(this, "Invalid packet length");
        if (this._pktLen > this._maxInPktLen) {
          const o = this._maxInPktLen;
          return Bt(
            this,
            `Packet length ${this._pktLen} exceeds max length of ${o}`,
          );
        }
        if (n >= t.length) return;
      }
      if (this._pktPos < this._pktLen) {
        const s = Math.min(this._pktLen - this._pktPos, t.length - n);
        if (
          (n !== 0 || s !== t.length
            ? s === this._pktLen
              ? (this._pkt = new Xne(t.buffer, t.byteOffset + n, s))
              : (this._pkt || (this._pkt = Buffer.allocUnsafe(this._pktLen)),
                this._pkt.set(
                  new Uint8Array(t.buffer, t.byteOffset + n, s),
                  this._pktPos,
                ))
            : s === this._pktLen
            ? (this._pkt = t)
            : (this._pkt || (this._pkt = Buffer.allocUnsafe(this._pktLen)),
              this._pkt.set(t, this._pktPos)),
          (n += s),
          (this._pktPos += s),
          this._pktPos < this._pktLen)
        )
          return;
      }
      const r = this._pkt[0],
        i = this._pkt;
      (this._pktLen = 0),
        (this._pktLenBytes = 0),
        (this._pkt = void 0),
        (this._pktPos = 0);
      const a = this.server ? ure[r] : lre[r];
      if (!a) return Bt(this, `Unknown packet type ${r}`);
      if (this._version === -1) {
        if (this.server) {
          if (r !== st.INIT) return Bt(this, `Expected INIT packet, got ${r}`);
        } else if (r !== Pr.VERSION)
          return Bt(this, `Expected VERSION packet, got ${r}`);
      }
      if (a(this, i) === !1) return;
    }
  }
  end() {
    this.destroy();
  }
  destroy() {
    (this.outgoing.state === "open" || this.outgoing.state === "eof") &&
      ((this.outgoing.state = "closing"),
      this._protocol.channelClose(this.outgoing.id));
  }
  _init() {
    (this._init = Bk), this.server || Tt(this, tre);
  }
  createReadStream(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    return new va(this, t, n);
  }
  createWriteStream(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    return new ti(this, t, n);
  }
  open(t, n, r, i) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    typeof r == "function" && ((i = r), (r = void 0));
    const a = typeof n == "number" ? n : jk(n);
    if (a === null) throw new Error(`Unknown flags string: ${n}`);
    let s = 0,
      o = 0;
    (typeof r == "string" || typeof r == "number") && (r = { mode: r }),
      typeof r == "object" &&
        r !== null &&
        ((r = ds(r)), (s = r.flags), (o = r.nb));
    const c = Buffer.byteLength(t);
    let l = 9;
    const f = Buffer.allocUnsafe(4 + 1 + 4 + 4 + c + 4 + 4 + o);
    _e(f, f.length - 4, 0), (f[4] = st.OPEN);
    const u = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(f, u, 5),
      _e(f, c, l),
      f.utf8Write(t, (l += 4), c),
      _e(f, a, (l += c)),
      _e(f, s, (l += 4)),
      o &&
        ((l += 4),
        o === ut.length ? f.set(ut, l) : Aa(ut, f, 0, o, l),
        (l += o)),
      (this._requests[u] = { cb: i });
    const d = Tt(this, f);
    this._debug &&
      this._debug(`SFTP: Outbound: ${d ? "Buffered" : "Sending"} OPEN`);
  }
  close(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    const r = t.length;
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.CLOSE);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.set(t, (i += 4)),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} CLOSE`);
  }
  read(t, n, r, i, a, s) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    if (!Buffer.isBuffer(n)) throw new Error("buffer is not a Buffer");
    if (r >= n.length) throw new Error("offset is out of bounds");
    if (r + i > n.length) throw new Error("length extends beyond buffer");
    if (a === null) throw new Error("null position currently unsupported");
    Uk(this, t, n, r, i, a, s);
  }
  readData(t, n, r, i, a, s) {
    this.read(t, n, r, i, a, s);
  }
  write(t, n, r, i, a, s) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    if (!Buffer.isBuffer(n)) throw new Error("buffer is not a Buffer");
    if (r > n.length) throw new Error("offset is out of bounds");
    if (r + i > n.length) throw new Error("length extends beyond buffer");
    if (a === null) throw new Error("null position currently unsupported");
    if (!i) {
      s && process.nextTick(s, void 0, 0);
      return;
    }
    const o = this._maxWriteLen,
      c = Math.max(i - o, 0),
      l = a;
    c && (i = o);
    const f = t.length;
    let u = 9;
    const d = Buffer.allocUnsafe(4 + 1 + 4 + 4 + f + 8 + 4 + i);
    _e(d, d.length - 4, 0), (d[4] = st.WRITE);
    const p = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(d, p, 5), _e(d, f, u), d.set(t, (u += 4)), (u += f);
    for (let m = 7; m >= 0; --m) (d[u + m] = a & 255), (a /= 256);
    _e(d, i, (u += 8)),
      Aa(n, d, r, r + i, (u += 4)),
      (this._requests[p] = {
        cb: (m) => {
          m
            ? typeof s == "function" && s(m)
            : c
            ? this.write(t, n, r + i, c, l + i, s)
            : typeof s == "function" && s(void 0, r + i);
        },
      });
    const h = Tt(this, d);
    if (this._debug) {
      const m = h ? "Sent" : "Buffered";
      this._debug(`SFTP: Outbound: ${m} WRITE (id:${p})`);
    }
  }
  writeData(t, n, r, i, a, s) {
    this.write(t, n, r, i, a, s);
  }
  fastGet(t, n, r, i) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    tS(this, Oa, t, n, r, i);
  }
  fastPut(t, n, r, i) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    tS(Oa, this, t, n, r, i);
  }
  readFile(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let i;
    if (
      (typeof r == "function"
        ? (i = r)
        : typeof n == "function" && ((i = n), (n = void 0)),
      typeof n == "string")
    )
      n = { encoding: n, flag: "r" };
    else if (!n) n = { encoding: null, flag: "r" };
    else if (typeof n != "object") throw new TypeError("Bad arguments");
    const a = n.encoding;
    if (a && !Buffer.isEncoding(a)) throw new Error(`Unknown encoding: ${a}`);
    let s,
      o,
      c,
      l = 0,
      f,
      u = 0;
    const d = n.flag || "r",
      p = () => {
        s === 0
          ? ((o = Buffer.allocUnsafe(8192)), this.read(f, o, 0, 8192, u, h))
          : this.read(f, o, l, s - l, u, h);
      },
      h = (g, v) => {
        let y;
        if (g) {
          if (((y = g.code === Dt.EOF), !y))
            return this.close(f, () => i && i(g));
        } else y = !1;
        if (y || (s === 0 && v === 0)) return m();
        (u += v),
          (l += v),
          s !== 0 ? (l === s ? m() : p()) : (c.push(uc(o, 0, v)), p());
      };
    h._wantEOFError = !0;
    const m = () => {
      this.close(
        f,
        (g) => (
          s === 0 ? (o = Buffer.concat(c, l)) : l < s && (o = uc(o, 0, l)),
          a && (o = o.toString(a)),
          i && i(g, o)
        ),
      );
    };
    this.open(t, d, 438, (g, v) => {
      if (g) return i && i(g);
      f = v;
      const y = (_, E) => {
        if (_) {
          this.stat(t, (R, A) => {
            if (R)
              return this.close(f, () => {
                i && i(_);
              });
            y(null, A);
          });
          return;
        }
        if (((s = E.size || 0), s === 0)) return (c = []), p();
        (o = Buffer.allocUnsafe(s)), p();
      };
      this.fstat(f, y);
    });
  }
  writeFile(t, n, r, i) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let a;
    if (
      (typeof i == "function"
        ? (a = i)
        : typeof r == "function" && ((a = r), (r = void 0)),
      typeof r == "string")
    )
      r = { encoding: r, mode: 438, flag: "w" };
    else if (!r) r = { encoding: "utf8", mode: 438, flag: "w" };
    else if (typeof r != "object") throw new TypeError("Bad arguments");
    if (r.encoding && !Buffer.isEncoding(r.encoding))
      throw new Error(`Unknown encoding: ${r.encoding}`);
    const s = r.flag || "w";
    this.open(t, s, r.mode, (o, c) => {
      if (o) a && a(o);
      else {
        const l = Buffer.isBuffer(n)
            ? n
            : Buffer.from("" + n, r.encoding || "utf8"),
          f = /a/.test(s) ? null : 0;
        if (f === null) {
          const u = (d, p) => {
            if (d) {
              this.stat(t, (h, m) => {
                if (h)
                  return this.close(c, () => {
                    a && a(d);
                  });
                u(null, m);
              });
              return;
            }
            G0(this, c, l, 0, l.length, p.size, a);
          };
          this.fstat(c, u);
          return;
        }
        G0(this, c, l, 0, l.length, f, a);
      }
    });
  }
  appendFile(t, n, r, i) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let a;
    if (
      (typeof i == "function"
        ? (a = i)
        : typeof r == "function" && ((a = r), (r = void 0)),
      typeof r == "string")
    )
      r = { encoding: r, mode: 438, flag: "a" };
    else if (!r) r = { encoding: "utf8", mode: 438, flag: "a" };
    else if (typeof r != "object") throw new TypeError("Bad arguments");
    r.flag || (r = Object.assign({ flag: "a" }, r)), this.writeFile(t, n, r, a);
  }
  exists(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    this.stat(t, (r) => {
      n && n(!r);
    });
  }
  unlink(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.REMOVE);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} REMOVE`);
  }
  rename(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.byteLength(t),
      a = Buffer.byteLength(n);
    let s = 9;
    const o = Buffer.allocUnsafe(4 + 1 + 4 + 4 + i + 4 + a);
    _e(o, o.length - 4, 0), (o[4] = st.RENAME);
    const c = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(o, c, 5),
      _e(o, i, s),
      o.utf8Write(t, (s += 4), i),
      _e(o, a, (s += i)),
      o.utf8Write(n, (s += 4), a),
      (this._requests[c] = { cb: r });
    const l = Tt(this, o);
    this._debug &&
      this._debug(`SFTP: Outbound: ${l ? "Buffered" : "Sending"} RENAME`);
  }
  mkdir(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let i = 0,
      a = 0;
    typeof n == "function" && ((r = n), (n = void 0)),
      typeof n == "object" &&
        n !== null &&
        ((n = ds(n)), (i = n.flags), (a = n.nb));
    const s = Buffer.byteLength(t);
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + s + 4 + a);
    _e(c, c.length - 4, 0), (c[4] = st.MKDIR);
    const l = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(c, l, 5),
      _e(c, s, o),
      c.utf8Write(t, (o += 4), s),
      _e(c, i, (o += s)),
      a &&
        ((o += 4),
        a === ut.length ? c.set(ut, o) : Aa(ut, c, 0, a, o),
        (o += a)),
      (this._requests[l] = { cb: r });
    const f = Tt(this, c);
    this._debug &&
      this._debug(`SFTP: Outbound: ${f ? "Buffered" : "Sending"} MKDIR`);
  }
  rmdir(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.RMDIR);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} RMDIR`);
  }
  readdir(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    typeof n == "function" && ((r = n), (n = {})),
      (typeof n != "object" || n === null) && (n = {});
    const i = !(n && n.full);
    if (!Buffer.isBuffer(t) && typeof t != "string")
      throw new Error("missing directory handle or path");
    if (typeof t == "string") {
      const f = [];
      let u = 0;
      const d = (p, h) => {
        if (p) return r(p);
        this.readdir(h, n, (m, g) => {
          const v = m && m.code === Dt.EOF;
          if (m && !v) return this.close(h, () => r(m));
          if (v)
            return this.close(h, (y) => {
              if (y) return r(y);
              r(void 0, f);
            });
          for (let y = 0; y < g.length; ++y, ++u) f[u] = g[y];
          d(void 0, h);
        });
      };
      return this.opendir(t, d);
    }
    const a = t.length;
    let s = 9;
    const o = Buffer.allocUnsafe(4 + 1 + 4 + 4 + a);
    _e(o, o.length - 4, 0), (o[4] = st.READDIR);
    const c = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(o, c, 5),
      _e(o, a, s),
      o.set(t, (s += 4)),
      (this._requests[c] = {
        cb: i
          ? (f, u) => {
              if (typeof r == "function") {
                if (f) return r(f);
                for (let d = u.length - 1; d >= 0; --d)
                  (u[d].filename === "." || u[d].filename === "..") &&
                    u.splice(d, 1);
                r(void 0, u);
              }
            }
          : r,
      });
    const l = Tt(this, o);
    this._debug &&
      this._debug(`SFTP: Outbound: ${l ? "Buffered" : "Sending"} READDIR`);
  }
  fstat(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    const r = t.length;
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.FSTAT);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.set(t, (i += 4)),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} FSTAT`);
  }
  stat(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.STAT);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} STAT`);
  }
  lstat(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.LSTAT);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} LSTAT`);
  }
  opendir(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.OPENDIR);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} OPENDIR`);
  }
  setstat(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let i = 0,
      a = 0;
    typeof n == "object" && n !== null
      ? ((n = ds(n)), (i = n.flags), (a = n.nb))
      : typeof n == "function" && (r = n);
    const s = Buffer.byteLength(t);
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + s + 4 + a);
    _e(c, c.length - 4, 0), (c[4] = st.SETSTAT);
    const l = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(c, l, 5),
      _e(c, s, o),
      c.utf8Write(t, (o += 4), s),
      _e(c, i, (o += s)),
      a &&
        ((o += 4),
        a === ut.length ? c.set(ut, o) : Aa(ut, c, 0, a, o),
        (o += a)),
      (this._requests[l] = { cb: r });
    const f = Tt(this, c);
    this._debug &&
      this._debug(`SFTP: Outbound: ${f ? "Buffered" : "Sending"} SETSTAT`);
  }
  fsetstat(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    let i = 0,
      a = 0;
    typeof n == "object" && n !== null
      ? ((n = ds(n)), (i = n.flags), (a = n.nb))
      : typeof n == "function" && (r = n);
    const s = t.length;
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + s + 4 + a);
    _e(c, c.length - 4, 0), (c[4] = st.FSETSTAT);
    const l = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(c, l, 5),
      _e(c, s, o),
      c.set(t, (o += 4)),
      _e(c, i, (o += s)),
      a &&
        ((o += 4),
        a === ut.length ? c.set(ut, o) : Aa(ut, c, 0, a, o),
        (o += a)),
      (this._requests[l] = { cb: r });
    const f = Tt(this, c);
    this._debug &&
      this._debug(`SFTP: Outbound: ${f ? "Buffered" : "Sending"} FSETSTAT`);
  }
  futimes(t, n, r, i) {
    return this.fsetstat(t, { atime: To(n), mtime: To(r) }, i);
  }
  utimes(t, n, r, i) {
    return this.setstat(t, { atime: To(n), mtime: To(r) }, i);
  }
  fchown(t, n, r, i) {
    return this.fsetstat(t, { uid: n, gid: r }, i);
  }
  chown(t, n, r, i) {
    return this.setstat(t, { uid: n, gid: r }, i);
  }
  fchmod(t, n, r) {
    return this.fsetstat(t, { mode: n }, r);
  }
  chmod(t, n, r) {
    return this.setstat(t, { mode: n }, r);
  }
  readlink(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.READLINK);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = {
        cb: (c, l) => {
          if (typeof n == "function") {
            if (c) return n(c);
            if (!l || !l.length)
              return n(new Error("Response missing link info"));
            n(void 0, l[0].filename);
          }
        },
      });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} READLINK`);
  }
  symlink(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.byteLength(n),
      a = Buffer.byteLength(t);
    let s = 9;
    const o = Buffer.allocUnsafe(4 + 1 + 4 + 4 + i + 4 + a);
    _e(o, o.length - 4, 0), (o[4] = st.SYMLINK);
    const c = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(o, c, 5),
      this._isOpenSSH
        ? (_e(o, a, s),
          o.utf8Write(t, (s += 4), a),
          _e(o, i, (s += a)),
          o.utf8Write(n, (s += 4), i))
        : (_e(o, i, s),
          o.utf8Write(n, (s += 4), i),
          _e(o, a, (s += i)),
          o.utf8Write(t, (s += 4), a)),
      (this._requests[c] = { cb: r });
    const l = Tt(this, o);
    this._debug &&
      this._debug(`SFTP: Outbound: ${l ? "Buffered" : "Sending"} SYMLINK`);
  }
  realpath(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.REALPATH);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = {
        cb: (c, l) => {
          if (typeof n == "function") {
            if (c) return n(c);
            if (!l || !l.length)
              return n(new Error("Response missing path info"));
            n(void 0, l[0].filename);
          }
        },
      });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} REALPATH`);
  }
  ext_openssh_rename(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const i = this._extensions["posix-rename@openssh.com"];
    if (!i || i !== "1")
      throw new Error("Server does not support this extended request");
    const a = Buffer.byteLength(t),
      s = Buffer.byteLength(n);
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + a + 4 + s);
    _e(c, c.length - 4, 0), (c[4] = st.EXTENDED);
    const l = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(c, l, 5),
      _e(c, 24, o),
      c.utf8Write("posix-rename@openssh.com", (o += 4), 24),
      _e(c, a, (o += 24)),
      c.utf8Write(t, (o += 4), a),
      _e(c, s, (o += a)),
      c.utf8Write(n, (o += 4), s),
      (this._requests[l] = { cb: r });
    const f = Tt(this, c);
    if (this._debug) {
      const u = f ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${u} posix-rename@openssh.com`);
    }
  }
  ext_openssh_statvfs(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = this._extensions["statvfs@openssh.com"];
    if (!r || r !== "2")
      throw new Error("Server does not support this extended request");
    const i = Buffer.byteLength(t);
    let a = 9;
    const s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + i);
    _e(s, s.length - 4, 0), (s[4] = st.EXTENDED);
    const o = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(s, o, 5),
      _e(s, 19, a),
      s.utf8Write("statvfs@openssh.com", (a += 4), 19),
      _e(s, i, (a += 19)),
      s.utf8Write(t, (a += 4), i),
      (this._requests[o] = { extended: "statvfs@openssh.com", cb: n });
    const c = Tt(this, s);
    if (this._debug) {
      const l = c ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${l} statvfs@openssh.com`);
    }
  }
  ext_openssh_fstatvfs(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = this._extensions["fstatvfs@openssh.com"];
    if (!r || r !== "2")
      throw new Error("Server does not support this extended request");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    const i = t.length;
    let a = 9;
    const s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + i);
    _e(s, s.length - 4, 0), (s[4] = st.EXTENDED);
    const o = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(s, o, 5),
      _e(s, 20, a),
      s.utf8Write("fstatvfs@openssh.com", (a += 4), 20),
      _e(s, i, (a += 20)),
      s.set(t, (a += 4)),
      (this._requests[o] = { extended: "fstatvfs@openssh.com", cb: n });
    const c = Tt(this, s);
    if (this._debug) {
      const l = c ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${l} fstatvfs@openssh.com`);
    }
  }
  ext_openssh_hardlink(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["hardlink@openssh.com"] !== "1")
      throw new Error("Server does not support this extended request");
    const a = Buffer.byteLength(t),
      s = Buffer.byteLength(n);
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + a + 4 + s);
    _e(c, c.length - 4, 0), (c[4] = st.EXTENDED);
    const l = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(c, l, 5),
      _e(c, 20, o),
      c.utf8Write("hardlink@openssh.com", (o += 4), 20),
      _e(c, a, (o += 20)),
      c.utf8Write(t, (o += 4), a),
      _e(c, s, (o += a)),
      c.utf8Write(n, (o += 4), s),
      (this._requests[l] = { cb: r });
    const f = Tt(this, c);
    if (this._debug) {
      const u = f ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${u} hardlink@openssh.com`);
    }
  }
  ext_openssh_fsync(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["fsync@openssh.com"] !== "1")
      throw new Error("Server does not support this extended request");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    const i = t.length;
    let a = 9;
    const s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + i);
    _e(s, s.length - 4, 0), (s[4] = st.EXTENDED);
    const o = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(s, o, 5),
      _e(s, 17, a),
      s.utf8Write("fsync@openssh.com", (a += 4), 17),
      _e(s, i, (a += 17)),
      s.set(t, (a += 4)),
      (this._requests[o] = { cb: n });
    const c = Tt(this, s);
    this._debug &&
      this._debug(
        `SFTP: Outbound: ${c ? "Buffered" : "Sending"} fsync@openssh.com`,
      );
  }
  ext_openssh_lsetstat(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["lsetstat@openssh.com"] !== "1")
      throw new Error("Server does not support this extended request");
    let a = 0,
      s = 0;
    typeof n == "object" && n !== null
      ? ((n = ds(n)), (a = n.flags), (s = n.nb))
      : typeof n == "function" && (r = n);
    const o = Buffer.byteLength(t);
    let c = 9;
    const l = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + o + 4 + s);
    _e(l, l.length - 4, 0), (l[4] = st.EXTENDED);
    const f = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(l, f, 5),
      _e(l, 20, c),
      l.utf8Write("lsetstat@openssh.com", (c += 4), 20),
      _e(l, o, (c += 20)),
      l.utf8Write(t, (c += 4), o),
      _e(l, a, (c += o)),
      s &&
        ((c += 4),
        s === ut.length ? l.set(ut, c) : Aa(ut, l, 0, s, c),
        (c += s)),
      (this._requests[f] = { cb: r });
    const u = Tt(this, l);
    if (this._debug) {
      const d = u ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${d} lsetstat@openssh.com`);
    }
  }
  ext_openssh_expandPath(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["expand-path@openssh.com"] !== "1")
      throw new Error("Server does not support this extended request");
    const i = Buffer.byteLength(t);
    let a = 9;
    const s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 23 + 4 + i);
    _e(s, s.length - 4, 0), (s[4] = st.EXTENDED);
    const o = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(s, o, 5),
      _e(s, 23, a),
      s.utf8Write("expand-path@openssh.com", (a += 4), 23),
      _e(s, i, (a += 20)),
      s.utf8Write(t, (a += 4), i),
      (this._requests[o] = {
        cb: (l, f) => {
          if (typeof n == "function") {
            if (l) return n(l);
            if (!f || !f.length)
              return n(new Error("Response missing expanded path"));
            n(void 0, f[0].filename);
          }
        },
      });
    const c = Tt(this, s);
    if (this._debug) {
      const l = c ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${l} expand-path@openssh.com`);
    }
  }
  ext_copy_data(t, n, r, i, a, s) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["copy-data"] !== "1")
      throw new Error("Server does not support this extended request");
    if (!Buffer.isBuffer(t)) throw new Error("Source handle is not a Buffer");
    if (!Buffer.isBuffer(i))
      throw new Error("Destination handle is not a Buffer");
    let c = 0;
    const l = Buffer.allocUnsafe(
      4 + 1 + 4 + 4 + 9 + 4 + t.length + 8 + 8 + 4 + i.length + 8,
    );
    _e(l, l.length - 4, c), (c += 4), (l[c] = st.EXTENDED), ++c;
    const f = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(l, f, c),
      (c += 4),
      _e(l, 9, c),
      (c += 4),
      l.utf8Write("copy-data", c, 9),
      (c += 9),
      _e(l, t.length, c),
      (c += 4),
      l.set(t, c),
      (c += t.length);
    for (let d = 7; d >= 0; --d) (l[c + d] = n & 255), (n /= 256);
    c += 8;
    for (let d = 7; d >= 0; --d) (l[c + d] = r & 255), (r /= 256);
    (c += 8), _e(l, i.length, c), (c += 4), l.set(i, c), (c += i.length);
    for (let d = 7; d >= 0; --d) (l[c + d] = a & 255), (a /= 256);
    this._requests[f] = { cb: s };
    const u = Tt(this, l);
    if (this._debug) {
      const d = u ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${d} copy-data`);
    }
  }
  ext_home_dir(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["home-directory"] !== "1")
      throw new Error("Server does not support this extended request");
    if (typeof t != "string") throw new TypeError("username is not a string");
    let i = 0;
    const a = Buffer.byteLength(t),
      s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 14 + 4 + a);
    _e(s, s.length - 4, i), (i += 4), (s[i] = st.EXTENDED), ++i;
    const o = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(s, o, i),
      (i += 4),
      _e(s, 14, i),
      (i += 4),
      s.utf8Write("home-directory", i, 14),
      (i += 14),
      _e(s, a, i),
      (i += 4),
      s.utf8Write(t, i, a),
      (i += a),
      (this._requests[o] = {
        cb: (l, f) => {
          if (typeof n == "function") {
            if (l) return n(l);
            if (!f || !f.length)
              return n(new Error("Response missing home directory"));
            n(void 0, f[0].filename);
          }
        },
      });
    const c = Tt(this, s);
    if (this._debug) {
      const l = c ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${l} home-directory`);
    }
  }
  ext_users_groups(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["users-groups-by-id@openssh.com"] !== "1")
      throw new Error("Server does not support this extended request");
    if (!Array.isArray(t)) throw new TypeError("uids is not an array");
    for (const l of t)
      if (!Number.isInteger(l) || l < 0 || l > 2 ** 32 - 1)
        throw new Error("uid values must all be 32-bit unsigned integers");
    if (!Array.isArray(n)) throw new TypeError("gids is not an array");
    for (const l of n)
      if (!Number.isInteger(l) || l < 0 || l > 2 ** 32 - 1)
        throw new Error("gid values must all be 32-bit unsigned integers");
    let a = 0;
    const s = Buffer.allocUnsafe(
      4 + 1 + 4 + 4 + 30 + 4 + 4 * t.length + 4 + 4 * n.length,
    );
    _e(s, s.length - 4, a), (a += 4), (s[a] = st.EXTENDED), ++a;
    const o = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(s, o, a),
      (a += 4),
      _e(s, 30, a),
      (a += 4),
      s.utf8Write("users-groups-by-id@openssh.com", a, 30),
      (a += 30),
      _e(s, 4 * t.length, a),
      (a += 4);
    for (const l of t) _e(s, l, a), (a += 4);
    _e(s, 4 * n.length, a), (a += 4);
    for (const l of n) _e(s, l, a), (a += 4);
    this._requests[o] = { extended: "users-groups-by-id@openssh.com", cb: r };
    const c = Tt(this, s);
    if (this._debug) {
      const l = c ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${l} users-groups-by-id@openssh.com`);
    }
  }
  handle(t, n) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (!Buffer.isBuffer(n)) throw new Error("handle is not a Buffer");
    const r = n.length;
    if (r > 256) throw new Error("handle too large (> 256 bytes)");
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0),
      (a[4] = Pr.HANDLE),
      _e(a, t, 5),
      _e(a, r, i),
      r && a.set(n, (i += 4));
    const s = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${s ? "Buffered" : "Sending"} HANDLE`);
  }
  status(t, n, r) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (!Zne.has(n)) throw new Error(`Bad status code: ${n}`);
    r || (r = "");
    const i = Buffer.byteLength(r);
    let a = 9;
    const s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + i + 4);
    _e(s, s.length - 4, 0),
      (s[4] = Pr.STATUS),
      _e(s, t, 5),
      _e(s, n, a),
      _e(s, i, (a += 4)),
      (a += 4),
      i && (s.utf8Write(r, a, i), (a += i)),
      _e(s, 0, a);
    const o = Tt(this, s);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} STATUS`);
  }
  data(t, n, r) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    const i = Buffer.isBuffer(n);
    if (!i && typeof n != "string")
      throw new Error("data is not a Buffer or string");
    let a;
    !i && !r && ((r = void 0), (a = !0));
    const s = i ? n.length : Buffer.byteLength(n, r);
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + s);
    _e(c, c.length - 4, 0),
      (c[4] = Pr.DATA),
      _e(c, t, 5),
      _e(c, s, o),
      s &&
        (i
          ? c.set(n, (o += 4))
          : a
          ? c.utf8Write(n, (o += 4), s)
          : c.write(n, (o += 4), s, r));
    const l = Tt(this, c);
    this._debug &&
      this._debug(`SFTP: Outbound: ${l ? "Buffered" : "Sending"} DATA`);
  }
  name(t, n) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (!Array.isArray(n)) {
      if (typeof n != "object" || n === null)
        throw new Error("names is not an object or array");
      n = [n];
    }
    const r = n.length;
    let i = 0,
      a;
    const s = [];
    for (let f = 0; f < r; ++f) {
      const u = n[f],
        d =
          !u || !u.filename || typeof u.filename != "string" ? "" : u.filename;
      i += 4 + Buffer.byteLength(d);
      const p =
        !u || !u.longname || typeof u.longname != "string" ? "" : u.longname;
      if (
        ((i += 4 + Buffer.byteLength(p)),
        typeof u.attrs == "object" && u.attrs !== null)
      ) {
        if (((a = ds(u.attrs)), (i += 4 + a.nb), a.nb)) {
          let h;
          a.nb === ut.length
            ? (h = new Uint8Array(ut))
            : ((h = new Uint8Array(a.nb)), Aa(ut, h, 0, a.nb, 0)),
            (a.bytes = h);
        }
        s.push(a);
      } else (i += 4), s.push(null);
    }
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + i);
    _e(c, c.length - 4, 0),
      (c[4] = Pr.NAME),
      _e(c, t, 5),
      _e(c, r, o),
      (o += 4);
    for (let f = 0; f < r; ++f) {
      const u = n[f];
      {
        const p =
            !u || !u.filename || typeof u.filename != "string"
              ? ""
              : u.filename,
          h = Buffer.byteLength(p);
        _e(c, h, o), (o += 4), h && (c.utf8Write(p, o, h), (o += h));
      }
      {
        const p =
            !u || !u.longname || typeof u.longname != "string"
              ? ""
              : u.longname,
          h = Buffer.byteLength(p);
        _e(c, h, o), (o += 4), h && (c.utf8Write(p, o, h), (o += h));
      }
      const d = s[f];
      d
        ? (_e(c, d.flags, o),
          (o += 4),
          d.flags && d.bytes && (c.set(d.bytes, o), (o += d.nb)))
        : (_e(c, 0, o), (o += 4));
    }
    const l = Tt(this, c);
    this._debug &&
      this._debug(`SFTP: Outbound: ${l ? "Buffered" : "Sending"} NAME`);
  }
  attrs(t, n) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (typeof n != "object" || n === null)
      throw new Error("attrs is not an object");
    n = ds(n);
    const r = n.flags,
      i = n.nb;
    let a = 9;
    const s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + i);
    _e(s, s.length - 4, 0),
      (s[4] = Pr.ATTRS),
      _e(s, t, 5),
      _e(s, r, a),
      i &&
        ((a += 4),
        i === ut.length ? s.set(ut, a) : Aa(ut, s, 0, i, a),
        (a += i));
    const o = Tt(this, s);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} ATTRS`);
  }
};
function sre(e) {
  try {
    return Buffer.allocUnsafe(e);
  } catch (t) {
    return t;
  }
}
function Uk(e, t, n, r, i, a, s, o) {
  const c = e._maxReadLen,
    l = Math.max(i - c, 0);
  l && (i = c);
  const f = t.length;
  let u = 9,
    d = a;
  const p = Buffer.allocUnsafe(4 + 1 + 4 + 4 + f + 8 + 4);
  _e(p, p.length - 4, 0), (p[4] = st.READ);
  const h = (e._writeReqid = (e._writeReqid + 1) & Vt);
  _e(p, h, 5), _e(p, f, u), p.set(t, (u += 4)), (u += f);
  for (let v = 7; v >= 0; --v) (p[u + v] = d & 255), (d /= 256);
  _e(p, i, (u += 8)), typeof s != "function" && (s = Bk);
  const m = o || {
    nb: 0,
    position: a,
    off: r,
    origOff: r,
    len: void 0,
    overflow: void 0,
    cb: (v, y, _) => {
      const E = m.len,
        R = m.overflow;
      if (v) {
        if (s._wantEOFError || v.code !== Dt.EOF) return s(v);
      } else {
        if (_ > E) return s(new Error("Received more data than requested"));
        if (_ === E && R) {
          (m.nb += _),
            (m.position += _),
            (m.off += _),
            Uk(e, t, n, m.off, R, m.position, s, m);
          return;
        }
      }
      (_ = _ || 0),
        m.origOff === 0 && n.length === m.nb
          ? (y = n)
          : (y = uc(n, m.origOff, m.origOff + m.nb + _)),
        s(void 0, m.nb + _, y, m.position);
    },
    buffer: void 0,
  };
  (m.len = i),
    (m.overflow = l),
    (m.buffer = uc(n, r, r + i)),
    (e._requests[h] = m);
  const g = Tt(e, p);
  e._debug && e._debug(`SFTP: Outbound: ${g ? "Buffered" : "Sending"} READ`);
}
function tS(e, t, n, r, i, a) {
  let s = 64,
    o = 32768,
    c,
    l,
    f;
  typeof i == "function"
    ? (a = i)
    : typeof i == "object" &&
      i !== null &&
      (typeof i.concurrency == "number" &&
        i.concurrency > 0 &&
        !isNaN(i.concurrency) &&
        (s = i.concurrency),
      typeof i.chunkSize == "number" &&
        i.chunkSize > 0 &&
        !isNaN(i.chunkSize) &&
        (o = i.chunkSize),
      typeof i.fileSize == "number" &&
        i.fileSize > 0 &&
        !isNaN(i.fileSize) &&
        (f = i.fileSize),
      typeof i.step == "function" && (c = i.step),
      (typeof i.mode == "string" || typeof i.mode == "number") &&
        (l = s1(i.mode)));
  let u,
    d = 0,
    p = 0,
    h = !1,
    m,
    g,
    v,
    y = o * s;
  function _(E) {
    if (h) return;
    h = !0;
    let R = 0,
      A;
    m || g
      ? ((A = () => {
          --R === 0 && a(E);
        }),
        m && (e === Oa || e.outgoing.state === "open") && ++R,
        g && (t === Oa || t.outgoing.state === "open") && ++R,
        m && (e === Oa || e.outgoing.state === "open") && e.close(m, A),
        g && (t === Oa || t.outgoing.state === "open") && t.close(g, A))
      : a(E);
  }
  e.open(n, "r", (E, R) => {
    if (E) return _(E);
    (m = R), f === void 0 ? e.fstat(m, A) : A(null, { size: f });
    function A(I, S) {
      if (I) {
        if (e !== Oa) {
          e.stat(n, (w, O) => {
            if (w) return _(I);
            A(null, O);
          });
          return;
        }
        return _(I);
      }
      (u = S.size),
        t.open(r, "w", (w, O) => {
          if (w) return _(w);
          if (((g = O), u <= 0)) return _();
          for (; y > u; ) {
            if (s === 1) {
              y = u;
              break;
            }
            (y -= o), --s;
          }
          if (((v = sre(y)), v instanceof Error)) return _(v);
          l !== void 0
            ? t.fchmod(g, l, function J(Z) {
                if (Z) {
                  t.chmod(r, l, (z) => J());
                  return;
                }
                q();
              })
            : q();
          function Q(J, Z, z, U, G, L) {
            if (J) return _(J);
            (G = G || 0), t.write(g, v, G, Z, U, k);
            function k(W) {
              if (W) return _(W);
              if (((p += Z), c && c(p, Z, u), Z < L)) return H(G, U + Z, L - Z);
              if (p === u) {
                t.close(g, (x) => {
                  if (((g = void 0), x)) return _(x);
                  e.close(m, (T) => {
                    if (((m = void 0), T)) return _(T);
                    a();
                  });
                });
                return;
              }
              if (d >= u) return;
              const F = d + o > u ? u - d : o;
              H(G, d, F), (d += F);
            }
          }
          function j(J, Z, z) {
            return (U, G, L) => {
              Q(U, G, L, Z, J, z);
            };
          }
          function H(J, Z, z) {
            e.read(m, v, J, z, Z, j(J, Z, z));
          }
          function q() {
            let J = 0,
              Z = 0;
            for (; d < u && J < s; ) {
              const z = d + o > u ? u - d : o;
              H(Z, d, z), (Z += z), (d += z), ++J;
            }
          }
        });
    }
  });
}
function G0(e, t, n, r, i, a, s) {
  const o = typeof s == "function" ? s : void 0;
  e.write(t, n, r, i, a, (c, l) => {
    if (c)
      return e.close(t, () => {
        o && o(c);
      });
    l === i
      ? e.close(t, o)
      : ((r += l), (i -= l), (a += l), G0(e, t, n, r, i, a, o));
  });
}
class Fk {
  constructor(t) {
    (this.mode = t && t.mode),
      (this.uid = t && t.uid),
      (this.gid = t && t.gid),
      (this.size = t && t.size),
      (this.atime = t && t.atime),
      (this.mtime = t && t.mtime),
      (this.extended = t && t.extended);
  }
  isDirectory() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFDIR;
  }
  isFile() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFREG;
  }
  isBlockDevice() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFBLK;
  }
  isCharacterDevice() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFCHR;
  }
  isSymbolicLink() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFLNK;
  }
  isFIFO() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFIFO;
  }
  isSocket() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFSOCK;
  }
}
function ds(e) {
  let t = 0,
    n = 0;
  if (typeof e == "object" && e !== null) {
    if (typeof e.size == "number") {
      t |= aa.SIZE;
      const r = e.size;
      (ut[n++] = r / 72057594037927940),
        (ut[n++] = r / 281474976710656),
        (ut[n++] = r / 1099511627776),
        (ut[n++] = r / 4294967296),
        (ut[n++] = r / 16777216),
        (ut[n++] = r / 65536),
        (ut[n++] = r / 256),
        (ut[n++] = r);
    }
    if (typeof e.uid == "number" && typeof e.gid == "number") {
      t |= aa.UIDGID;
      const r = e.uid,
        i = e.gid;
      (ut[n++] = r >>> 24),
        (ut[n++] = r >>> 16),
        (ut[n++] = r >>> 8),
        (ut[n++] = r),
        (ut[n++] = i >>> 24),
        (ut[n++] = i >>> 16),
        (ut[n++] = i >>> 8),
        (ut[n++] = i);
    }
    if (typeof e.mode == "number" || typeof e.mode == "string") {
      const r = s1(e.mode);
      (t |= aa.PERMISSIONS),
        (ut[n++] = r >>> 24),
        (ut[n++] = r >>> 16),
        (ut[n++] = r >>> 8),
        (ut[n++] = r);
    }
    if (
      (typeof e.atime == "number" || q0(e.atime)) &&
      (typeof e.mtime == "number" || q0(e.mtime))
    ) {
      const r = To(e.atime),
        i = To(e.mtime);
      (t |= aa.ACMODTIME),
        (ut[n++] = r >>> 24),
        (ut[n++] = r >>> 16),
        (ut[n++] = r >>> 8),
        (ut[n++] = r),
        (ut[n++] = i >>> 24),
        (ut[n++] = i >>> 16),
        (ut[n++] = i >>> 8),
        (ut[n++] = i);
    }
  }
  return { flags: t, nb: n };
}
function To(e) {
  if (typeof e == "number" && e === e) return e;
  if (q0(e)) return parseInt(e.getTime() / 1e3, 10);
  throw new Error(`Cannot parse time: ${e}`);
}
function s1(e) {
  if (typeof e == "number" && e === e) return e;
  if (typeof e == "string") return s1(parseInt(e, 8));
  throw new Error(`Cannot parse mode: ${e}`);
}
const Q0 = {
  r: nt.READ,
  "r+": nt.READ | nt.WRITE,
  w: nt.TRUNC | nt.CREAT | nt.WRITE,
  wx: nt.TRUNC | nt.CREAT | nt.WRITE | nt.EXCL,
  xw: nt.TRUNC | nt.CREAT | nt.WRITE | nt.EXCL,
  "w+": nt.TRUNC | nt.CREAT | nt.READ | nt.WRITE,
  "wx+": nt.TRUNC | nt.CREAT | nt.READ | nt.WRITE | nt.EXCL,
  "xw+": nt.TRUNC | nt.CREAT | nt.READ | nt.WRITE | nt.EXCL,
  a: nt.APPEND | nt.CREAT | nt.WRITE,
  ax: nt.APPEND | nt.CREAT | nt.WRITE | nt.EXCL,
  xa: nt.APPEND | nt.CREAT | nt.WRITE | nt.EXCL,
  "a+": nt.APPEND | nt.CREAT | nt.READ | nt.WRITE,
  "ax+": nt.APPEND | nt.CREAT | nt.READ | nt.WRITE | nt.EXCL,
  "xa+": nt.APPEND | nt.CREAT | nt.READ | nt.WRITE | nt.EXCL,
};
function jk(e) {
  const t = Q0[e];
  return t !== void 0 ? t : null;
}
const ore = (() => {
  const e = Object.keys(Q0);
  return (t) => {
    for (let n = 0; n < e.length; ++n) {
      const r = e[n];
      if (Q0[r] === t) return r;
    }
    return null;
  };
})();
function No(e) {
  const t = me.readUInt32BE();
  if (t === void 0) return;
  const n = new Fk();
  if (t & aa.SIZE) {
    const r = me.readUInt64BE(e);
    if (r === void 0) return;
    n.size = r;
  }
  if (t & aa.UIDGID) {
    const r = me.readUInt32BE(),
      i = me.readUInt32BE();
    if (i === void 0) return;
    (n.uid = r), (n.gid = i);
  }
  if (t & aa.PERMISSIONS) {
    const r = me.readUInt32BE();
    if (r === void 0) return;
    n.mode = r;
  }
  if (t & aa.ACMODTIME) {
    const r = me.readUInt32BE(),
      i = me.readUInt32BE();
    if (i === void 0) return;
    (n.atime = r), (n.mtime = i);
  }
  if (t & aa.EXTENDED) {
    const r = me.readUInt32BE();
    if (r === void 0) return;
    const i = {};
    for (let a = 0; a < r; ++a) {
      const s = me.readString(!0),
        o = me.readString();
      if (o === void 0) return;
      i[s] = o;
    }
    n.extended = i;
  }
  return n;
}
function Tt(e, t) {
  const n = Mk(e, t);
  return n !== void 0 ? (e._buffer.push(n), !1) : !0;
}
function Mk(e, t) {
  const n = e.outgoing;
  if (n.state !== "open") return;
  if (n.window === 0) return (e._waitWindow = !0), (e._chunkcb = nS), t;
  let r;
  const i = t.length;
  let a = 0;
  for (; i - a > 0 && n.window > 0; ) {
    const s = Math.min(i - a, n.window, n.packetSize);
    (n.window -= s),
      n.window === 0 && ((e._waitWindow = !0), (e._chunkcb = nS)),
      a === 0 && s === i
        ? e._protocol.channelData(e.outgoing.id, t)
        : e._protocol.channelData(e.outgoing.id, uc(t, a, a + s)),
      (a += s);
  }
  return i - a > 0 && (a > 0 ? (r = uc(t, a, i)) : (r = t)), r;
}
function nS() {
  this._chunkcb = void 0;
  const e = this._buffer;
  let t = 0;
  for (; t < e.length; ) {
    const n = e[t],
      r = Mk(this, n);
    if (r !== void 0) {
      r !== n && (e[t] = r), t > 0 && (this._buffer = e.slice(t));
      return;
    }
    ++t;
  }
  t > 0 && (this._buffer = []);
}
function Bt(e, t, n) {
  const r = new Error(t);
  return (
    (r.level = "sftp-protocol"),
    !n && e._debug && e._debug(`SFTP: Inbound: ${t}`),
    e.emit("error", r),
    e.destroy(),
    Hk(e),
    !1
  );
}
function Hk(e) {
  const t = Object.keys(e._requests);
  if (t.length === 0) return;
  const n = e._requests;
  e._requests = {};
  const r = new Error("No response from server");
  for (let i = 0; i < t.length; ++i) {
    const a = n[t[i]];
    typeof a.cb == "function" && a.cb(r);
  }
}
function cre(e, t) {
  let n = 9;
  const r = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 18);
  _e(r, r.length - 4, 0), (r[4] = st.EXTENDED);
  const i = (e._writeReqid = (e._writeReqid + 1) & Vt);
  _e(r, i, 5),
    _e(r, 18, n),
    r.utf8Write("limits@openssh.com", (n += 4), 18),
    (e._requests[i] = { extended: "limits@openssh.com", cb: t });
  const a = Tt(e, r);
  if (e._debug) {
    const s = a ? "Buffered" : "Sending";
    e._debug(`SFTP: Outbound: ${s} limits@openssh.com`);
  }
}
const lre = {
    [Pr.VERSION]: (e, t) => {
      if (e._version !== -1) return Bt(e, "Duplicate VERSION packet");
      const n = {};
      me.init(t, 1);
      let r = me.readUInt32BE();
      for (; me.avail(); ) {
        const i = me.readString(!0),
          a = me.readString(!0);
        if (a === void 0) {
          r = void 0;
          break;
        }
        n[i] = a;
      }
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed VERSION packet");
      if (e._debug) {
        const i = Object.keys(n);
        i.length
          ? e._debug(`SFTP: Inbound: Received VERSION (v${r}, exts:${i})`)
          : e._debug(`SFTP: Inbound: Received VERSION (v${r})`);
      }
      if (
        ((e._version = r), (e._extensions = n), n["limits@openssh.com"] === "1")
      )
        return cre(e, (i, a) => {
          i ||
            (a.maxPktLen > 0 && (e._maxOutPktLen = a.maxPktLen),
            a.maxReadLen > 0 && (e._maxReadLen = a.maxReadLen),
            a.maxWriteLen > 0 && (e._maxWriteLen = a.maxWriteLen),
            (e.maxOpenHandles =
              a.maxOpenHandles > 0 ? a.maxOpenHandles : 1 / 0)),
            e.emit("ready");
        });
      e.emit("ready");
    },
    [Pr.STATUS]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readUInt32BE(),
        i = me.readString(!0);
      if ((me.clear(), e._debug)) {
        const s = JSON.stringify(i);
        e._debug(`SFTP: Inbound: Received STATUS (id:${n}, ${r}, ${s})`);
      }
      const a = e._requests[n];
      if ((delete e._requests[n], a && typeof a.cb == "function")) {
        if (r === Dt.OK) {
          a.cb();
          return;
        }
        const s = new Error(i || ere[r] || "Unknown status");
        (s.code = r), a.cb(s);
      }
    },
    [Pr.HANDLE]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString();
      if ((me.clear(), r === void 0))
        return (
          n !== void 0 && delete e._requests[n],
          Bt(e, "Malformed HANDLE packet")
        );
      e._debug && e._debug(`SFTP: Inbound: Received HANDLE (id:${n})`);
      const i = e._requests[n];
      delete e._requests[n], i && typeof i.cb == "function" && i.cb(void 0, r);
    },
    [Pr.DATA]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE();
      let r;
      if (
        (n !== void 0 && ((r = e._requests[n]), delete e._requests[n]),
        r && typeof r.cb == "function")
      )
        if (r.buffer) {
          const i = me.readString(r.buffer);
          if ((me.clear(), i !== void 0)) {
            e._debug &&
              e._debug(`SFTP: Inbound: Received DATA (id:${n}, ${i})`),
              r.cb(void 0, r.buffer, i);
            return;
          }
        } else {
          const i = me.readString();
          if ((me.clear(), i !== void 0)) {
            e._debug &&
              e._debug(`SFTP: Inbound: Received DATA (id:${n}, ${i.length})`),
              r.cb(void 0, i);
            return;
          }
        }
      else {
        const i = me.skipString();
        if ((me.clear(), i !== void 0)) {
          e._debug && e._debug(`SFTP: Inbound: Received DATA (id:${n}, ${i})`);
          return;
        }
      }
      return Bt(e, "Malformed DATA packet");
    },
    [Pr.NAME]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE();
      let r;
      n !== void 0 && ((r = e._requests[n]), delete e._requests[n]);
      const i = me.readUInt32BE();
      if (i !== void 0) {
        let a = [];
        for (let s = 0; s < i; ++s) {
          const o = me.readString(!0),
            c = me.readString(!0),
            l = No(e._biOpt);
          if (l === void 0) {
            a = void 0;
            break;
          }
          a.push({ filename: o, longname: c, attrs: l });
        }
        if (a !== void 0) {
          e._debug &&
            e._debug(`SFTP: Inbound: Received NAME (id:${n}, ${a.length})`),
            me.clear(),
            r && typeof r.cb == "function" && r.cb(void 0, a);
          return;
        }
      }
      return me.clear(), Bt(e, "Malformed NAME packet");
    },
    [Pr.ATTRS]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE();
      let r;
      n !== void 0 && ((r = e._requests[n]), delete e._requests[n]);
      const i = No(e._biOpt);
      if ((me.clear(), i !== void 0)) {
        e._debug && e._debug(`SFTP: Inbound: Received ATTRS (id:${n})`),
          r && typeof r.cb == "function" && r.cb(void 0, i);
        return;
      }
      return Bt(e, "Malformed ATTRS packet");
    },
    [Pr.EXTENDED]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE();
      if (n !== void 0) {
        const r = e._requests[n];
        if (r)
          switch ((delete e._requests[n], r.extended)) {
            case "statvfs@openssh.com":
            case "fstatvfs@openssh.com": {
              const i = e._biOpt,
                a = {
                  f_bsize: me.readUInt64BE(i),
                  f_frsize: me.readUInt64BE(i),
                  f_blocks: me.readUInt64BE(i),
                  f_bfree: me.readUInt64BE(i),
                  f_bavail: me.readUInt64BE(i),
                  f_files: me.readUInt64BE(i),
                  f_ffree: me.readUInt64BE(i),
                  f_favail: me.readUInt64BE(i),
                  f_sid: me.readUInt64BE(i),
                  f_flag: me.readUInt64BE(i),
                  f_namemax: me.readUInt64BE(i),
                };
              if (a.f_namemax === void 0) break;
              e._debug &&
                e._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${n}, ${r.extended})`,
                ),
                me.clear(),
                typeof r.cb == "function" && r.cb(void 0, a);
              return;
            }
            case "limits@openssh.com": {
              const i = {
                maxPktLen: me.readUInt64BE(),
                maxReadLen: me.readUInt64BE(),
                maxWriteLen: me.readUInt64BE(),
                maxOpenHandles: me.readUInt64BE(),
              };
              if (i.maxOpenHandles === void 0) break;
              e._debug &&
                e._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${n}, ${r.extended})`,
                ),
                me.clear(),
                typeof r.cb == "function" && r.cb(void 0, i);
              return;
            }
            case "users-groups-by-id@openssh.com": {
              const i = me.readUInt32BE();
              if (i === void 0) break;
              const a = new Array(i);
              for (let c = 0; c < a.length; ++c) a[c] = me.readString(!0);
              const s = me.readUInt32BE();
              if (s === void 0) break;
              const o = new Array(s);
              for (let c = 0; c < o.length; ++c) o[c] = me.readString(!0);
              if (o.length > 0 && o[o.length - 1] === void 0) break;
              e._debug &&
                e._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${n}, ${r.extended})`,
                ),
                me.clear(),
                typeof r.cb == "function" && r.cb(void 0, a, o);
              return;
            }
            default:
              e._debug &&
                e._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${n}, ???)`,
                ),
                me.clear(),
                typeof r.cb == "function" && r.cb();
              return;
          }
        else {
          e._debug &&
            e._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${n}, ???)`),
            me.clear();
          return;
        }
      }
      return me.clear(), Bt(e, "Malformed EXTENDED_REPLY packet");
    },
  },
  ure = {
    [st.INIT]: (e, t) => {
      if (e._version !== -1) return Bt(e, "Duplicate INIT packet");
      const n = {};
      me.init(t, 1);
      let r = me.readUInt32BE();
      for (; me.avail(); ) {
        const i = me.readString(!0),
          a = me.readString(!0);
        if (a === void 0) {
          r = void 0;
          break;
        }
        n[i] = a;
      }
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed INIT packet");
      if (e._debug) {
        const i = Object.keys(n);
        i.length
          ? e._debug(`SFTP: Inbound: Received INIT (v${r}, exts:${i})`)
          : e._debug(`SFTP: Inbound: Received INIT (v${r})`);
      }
      Tt(e, nre), (e._version = r), (e._extensions = n), e.emit("ready");
    },
    [st.OPEN]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0),
        i = me.readUInt32BE(),
        a = No(e._biOpt);
      if ((me.clear(), a === void 0)) return Bt(e, "Malformed OPEN packet");
      e._debug && e._debug(`SFTP: Inbound: Received OPEN (id:${n})`),
        e.emit("OPEN", n, r, i, a) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.CLOSE]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString();
      if ((me.clear(), r === void 0 || r.length > 256))
        return Bt(e, "Malformed CLOSE packet");
      e._debug && e._debug(`SFTP: Inbound: Received CLOSE (id:${n})`),
        e.emit("CLOSE", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.READ]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(),
        i = me.readUInt64BE(e._biOpt),
        a = me.readUInt32BE();
      if ((me.clear(), a === void 0 || r.length > 256))
        return Bt(e, "Malformed READ packet");
      e._debug && e._debug(`SFTP: Inbound: Received READ (id:${n})`),
        e.emit("READ", n, r, i, a) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.WRITE]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(),
        i = me.readUInt64BE(e._biOpt),
        a = me.readString();
      if ((me.clear(), a === void 0 || r.length > 256))
        return Bt(e, "Malformed WRITE packet");
      e._debug && e._debug(`SFTP: Inbound: Received WRITE (id:${n})`),
        e.emit("WRITE", n, r, i, a) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.LSTAT]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed LSTAT packet");
      e._debug && e._debug(`SFTP: Inbound: Received LSTAT (id:${n})`),
        e.emit("LSTAT", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.FSTAT]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString();
      if ((me.clear(), r === void 0 || r.length > 256))
        return Bt(e, "Malformed FSTAT packet");
      e._debug && e._debug(`SFTP: Inbound: Received FSTAT (id:${n})`),
        e.emit("FSTAT", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.SETSTAT]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0),
        i = No(e._biOpt);
      if ((me.clear(), i === void 0)) return Bt(e, "Malformed SETSTAT packet");
      e._debug && e._debug(`SFTP: Inbound: Received SETSTAT (id:${n})`),
        e.emit("SETSTAT", n, r, i) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.FSETSTAT]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(),
        i = No(e._biOpt);
      if ((me.clear(), i === void 0 || r.length > 256))
        return Bt(e, "Malformed FSETSTAT packet");
      e._debug && e._debug(`SFTP: Inbound: Received FSETSTAT (id:${n})`),
        e.emit("FSETSTAT", n, r, i) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.OPENDIR]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed OPENDIR packet");
      e._debug && e._debug(`SFTP: Inbound: Received OPENDIR (id:${n})`),
        e.emit("OPENDIR", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.READDIR]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString();
      if ((me.clear(), r === void 0 || r.length > 256))
        return Bt(e, "Malformed READDIR packet");
      e._debug && e._debug(`SFTP: Inbound: Received READDIR (id:${n})`),
        e.emit("READDIR", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.REMOVE]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed REMOVE packet");
      e._debug && e._debug(`SFTP: Inbound: Received REMOVE (id:${n})`),
        e.emit("REMOVE", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.MKDIR]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0),
        i = No(e._biOpt);
      if ((me.clear(), i === void 0)) return Bt(e, "Malformed MKDIR packet");
      e._debug && e._debug(`SFTP: Inbound: Received MKDIR (id:${n})`),
        e.emit("MKDIR", n, r, i) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.RMDIR]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed RMDIR packet");
      e._debug && e._debug(`SFTP: Inbound: Received RMDIR (id:${n})`),
        e.emit("RMDIR", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.REALPATH]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed REALPATH packet");
      e._debug && e._debug(`SFTP: Inbound: Received REALPATH (id:${n})`),
        e.emit("REALPATH", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.STAT]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed STAT packet");
      e._debug && e._debug(`SFTP: Inbound: Received STAT (id:${n})`),
        e.emit("STAT", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.RENAME]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0),
        i = me.readString(!0);
      if ((me.clear(), i === void 0)) return Bt(e, "Malformed RENAME packet");
      e._debug && e._debug(`SFTP: Inbound: Received RENAME (id:${n})`),
        e.emit("RENAME", n, r, i) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.READLINK]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed READLINK packet");
      e._debug && e._debug(`SFTP: Inbound: Received READLINK (id:${n})`),
        e.emit("READLINK", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.SYMLINK]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0),
        i = me.readString(!0);
      if ((me.clear(), i === void 0)) return Bt(e, "Malformed SYMLINK packet");
      e._debug && e._debug(`SFTP: Inbound: Received SYMLINK (id:${n})`);
      let a;
      e._isOpenSSH
        ? (a = e.emit("SYMLINK", n, i, r))
        : (a = e.emit("SYMLINK", n, r, i)),
        a || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.EXTENDED]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if (r === void 0) return me.clear(), Bt(e, "Malformed EXTENDED packet");
      let i;
      me.avail() && (i = me.readRaw()),
        me.clear(),
        e._debug && e._debug(`SFTP: Inbound: Received EXTENDED (id:${n})`),
        e.emit("EXTENDED", n, r, i) || e.status(n, Dt.OP_UNSUPPORTED);
    },
  },
  { ERR_INVALID_ARG_TYPE: fre, ERR_OUT_OF_RANGE: Xf, validateNumber: dre } = Su,
  rS = 128;
let yr;
const W0 = [];
function pre(e) {
  W0.length > 0 ? (yr = W0.pop()) : (yr = Buffer.allocUnsafe(e)), (yr.used = 0);
}
function z0(e, t) {
  if (!Number.isSafeInteger(e))
    throw (
      (dre(e, t),
      Number.isInteger(e)
        ? new Xf(t, ">= 0 and <= 2 ** 53 - 1", e)
        : new Xf(t, "an integer", e))
    );
  if (e < 0) throw new Xf(t, ">= 0 and <= 2 ** 53 - 1", e);
}
function rg(e) {
  return (e + 7) & -8;
}
function va(e, t, n) {
  if (n === void 0) n = {};
  else if (typeof n == "string") n = { encoding: n };
  else {
    if (n === null || typeof n != "object")
      throw new TypeError('"options" argument must be a string or an object');
    n = Object.create(n);
  }
  if (
    (n.highWaterMark === void 0 && (n.highWaterMark = 64 * 1024),
    (n.emitClose = !1),
    (n.autoDestroy = !1),
    Dk.call(this, n),
    (this.path = t),
    (this.flags = n.flags === void 0 ? "r" : n.flags),
    (this.mode = n.mode === void 0 ? 438 : n.mode),
    (this.start = n.start),
    (this.end = n.end),
    (this.autoClose = n.autoClose === void 0 ? !0 : n.autoClose),
    (this.pos = 0),
    (this.bytesRead = 0),
    (this.isClosed = !1),
    (this.handle = n.handle === void 0 ? null : n.handle),
    (this.sftp = e),
    (this._opening = !1),
    this.start !== void 0 && (z0(this.start, "start"), (this.pos = this.start)),
    this.end === void 0)
  )
    this.end = 1 / 0;
  else if (
    this.end !== 1 / 0 &&
    (z0(this.end, "end"), this.start !== void 0 && this.start > this.end)
  )
    throw new Xf("start", `<= "end" (here: ${this.end})`, this.start);
  this.on("end", function () {
    this.autoClose && this.destroy();
  }),
    Buffer.isBuffer(this.handle) || this.open();
}
Lk(va, Dk);
va.prototype.open = function () {
  this._opening ||
    ((this._opening = !0),
    this.sftp.open(this.path, this.flags, this.mode, (e, t) => {
      if (((this._opening = !1), e)) {
        this.emit("error", e), this.autoClose && this.destroy();
        return;
      }
      (this.handle = t), this.emit("open", t), this.emit("ready"), this.read();
    }));
};
va.prototype._read = function (e) {
  if (!Buffer.isBuffer(this.handle))
    return this.once("open", () => this._read(e));
  if (this.destroyed) return;
  (!yr || yr.length - yr.used < rS) &&
    pre(this.readableHighWaterMark || this._readableState.highWaterMark);
  const t = yr;
  let n = Math.min(yr.length - yr.used, e);
  const r = yr.used;
  if (
    (this.end !== void 0 && (n = Math.min(this.end - this.pos + 1, n)), n <= 0)
  )
    return this.push(null);
  this.sftp.read(this.handle, yr, yr.used, n, this.pos, (i, a) => {
    if (i) {
      this.emit("error", i), this.autoClose && this.destroy();
      return;
    }
    let s = null;
    if (r + n === t.used && t === yr) t.used = rg(t.used + a - n);
    else {
      const o = (r + n) & -8,
        c = rg(r + a);
      o - c >= rS && W0.push(t.slice(c, o));
    }
    a > 0 && ((this.bytesRead += a), (s = t.slice(r, r + a))),
      (this.pos += a),
      this.push(s);
  }),
    (yr.used = rg(yr.used + n));
};
va.prototype._destroy = function (e, t) {
  if (this._opening && !Buffer.isBuffer(this.handle)) {
    this.once("open", iS.bind(null, this, t, e));
    return;
  }
  iS(this, t, e), (this.handle = null), (this._opening = !1);
};
function iS(e, t, n) {
  if (!e.handle) return r();
  e.sftp.close(e.handle, r);
  function r(i) {
    (i = i || n), t(i), (e.isClosed = !0), i || e.emit("close");
  }
}
va.prototype.close = function (e) {
  this.destroy(null, e);
};
Object.defineProperty(va.prototype, "pending", {
  get() {
    return this.handle === null;
  },
  configurable: !0,
});
function ti(e, t, n) {
  if (n === void 0) n = {};
  else if (typeof n == "string") n = { encoding: n };
  else {
    if (n === null || typeof n != "object")
      throw new TypeError('"options" argument must be a string or an object');
    n = Object.create(n);
  }
  (n.emitClose = !1),
    (n.autoDestroy = !1),
    a1.call(this, n),
    (this.path = t),
    (this.flags = n.flags === void 0 ? "w" : n.flags),
    (this.mode = n.mode === void 0 ? 438 : n.mode),
    (this.start = n.start),
    (this.autoClose = n.autoClose === void 0 ? !0 : n.autoClose),
    (this.pos = 0),
    (this.bytesWritten = 0),
    (this.isClosed = !1),
    (this.handle = n.handle === void 0 ? null : n.handle),
    (this.sftp = e),
    (this._opening = !1),
    this.start !== void 0 && (z0(this.start, "start"), (this.pos = this.start)),
    n.encoding && this.setDefaultEncoding(n.encoding),
    this.on("finish", function () {
      this._writableState.finalCalled || (this.autoClose && this.destroy());
    }),
    Buffer.isBuffer(this.handle) || this.open();
}
Lk(ti, a1);
ti.prototype._final = function (e) {
  this.autoClose && this.destroy(), e();
};
ti.prototype.open = function () {
  this._opening ||
    ((this._opening = !0),
    this.sftp.open(this.path, this.flags, this.mode, (e, t) => {
      if (((this._opening = !1), e)) {
        this.emit("error", e), this.autoClose && this.destroy();
        return;
      }
      this.handle = t;
      const n = (r) => {
        if (r) {
          this.sftp.chmod(this.path, this.mode, (i) => n());
          return;
        }
        if (this.flags[0] === "a") {
          const i = (a, s) => {
            if (a) {
              this.sftp.stat(this.path, (o, c) => {
                if (o) {
                  this.destroy(), this.emit("error", a);
                  return;
                }
                i(null, c);
              });
              return;
            }
            (this.pos = s.size), this.emit("open", t), this.emit("ready");
          };
          this.sftp.fstat(t, i);
          return;
        }
        this.emit("open", t), this.emit("ready");
      };
      this.sftp.fchmod(t, this.mode, n);
    }));
};
ti.prototype._write = function (e, t, n) {
  if (!Buffer.isBuffer(e)) {
    const r = new fre("data", "Buffer", e);
    return this.emit("error", r);
  }
  if (!Buffer.isBuffer(this.handle))
    return this.once("open", function () {
      this._write(e, t, n);
    });
  this.sftp.write(this.handle, e, 0, e.length, this.pos, (r, i) => {
    if (r) return this.autoClose && this.destroy(), n(r);
    (this.bytesWritten += i), n();
  }),
    (this.pos += e.length);
};
ti.prototype._writev = function (e, t) {
  if (!Buffer.isBuffer(this.handle))
    return this.once("open", function () {
      this._writev(e, t);
    });
  const n = this.sftp,
    r = this.handle;
  let i = e.length;
  const a = (s, o) => {
    if (s) return this.destroy(), t(s);
    (this.bytesWritten += o), --i === 0 && t();
  };
  for (let s = 0; s < e.length; ++s) {
    const o = e[s].chunk;
    n.write(r, o, 0, o.length, this.pos, a), (this.pos += o.length);
  }
};
typeof a1.prototype.destroy != "function" &&
  (ti.prototype.destroy = va.prototype.destroy);
ti.prototype._destroy = va.prototype._destroy;
ti.prototype.close = function (e) {
  if (e) {
    if (this.isClosed) {
      process.nextTick(e);
      return;
    }
    this.on("close", e);
  }
  this.autoClose || this.on("finish", this.destroy.bind(this)), this.end();
};
ti.prototype.destroySoon = ti.prototype.end;
Object.defineProperty(ti.prototype, "pending", {
  get() {
    return this.handle === null;
  },
  configurable: !0,
});
var Zp = {
  flagsToString: ore,
  OPEN_MODE: nt,
  SFTP: are,
  Stats: Fk,
  STATUS_CODE: Dt,
  stringToFlags: jk,
};
const { Duplex: hre, Readable: mre, Writable: gre } = Kr,
  {
    CHANNEL_EXTENDED_DATATYPE: { STDERR: aS },
  } = es(),
  { bufferSlice: Bd } = Ki(),
  vre = 32 * 1024,
  Iu = 2 * 1024 * 1024,
  o1 = Iu / 2;
class yre extends mre {
  constructor(t, n) {
    super(n), (this._channel = t);
  }
  _read(t) {
    this._channel._waitChanDrain &&
      ((this._channel._waitChanDrain = !1),
      this._channel.incoming.window <= o1 && c1(this._channel));
  }
}
class bre extends gre {
  constructor(t) {
    super({ highWaterMark: Iu }), (this._channel = t);
  }
  _write(t, n, r) {
    const i = this._channel,
      a = i._client._protocol,
      s = i.outgoing,
      o = s.packetSize,
      c = s.id;
    let l = s.window;
    const f = t.length;
    let u = 0;
    if (s.state === "open") {
      for (; f - u > 0 && l > 0; ) {
        let d = f - u;
        d > l && (d = l),
          d > o && (d = o),
          u === 0 && d === f
            ? a.channelExtData(c, t, aS)
            : a.channelExtData(c, Bd(t, u, u + d), aS),
          (u += d),
          (l -= d);
      }
      if (((s.window = l), f - u > 0)) {
        l === 0 && (i._waitWindow = !0),
          u > 0 ? (i._chunkErr = Bd(t, u, f)) : (i._chunkErr = t),
          (i._chunkcbErr = r);
        return;
      }
      r();
    }
  }
}
let _re = class extends hre {
  constructor(t, n, r) {
    const i = {
      highWaterMark: Iu,
      allowHalfOpen: !r || (r && r.allowHalfOpen !== !1),
      emitClose: !1,
    };
    super(i), (this.allowHalfOpen = i.allowHalfOpen);
    const a = !!(r && r.server);
    (this.server = a),
      (this.type = n.type),
      (this.subtype = void 0),
      (this.incoming = n.incoming),
      (this.outgoing = n.outgoing),
      (this._callbacks = []),
      (this._client = t),
      (this._hasX11 = !1),
      (this._exit = {
        code: void 0,
        signal: void 0,
        dump: void 0,
        desc: void 0,
      }),
      (this.stdin = this.stdout = this),
      a ? (this.stderr = new bre(this)) : (this.stderr = new yre(this, i)),
      (this._waitWindow = !1),
      (this._waitChanDrain = !1),
      (this._chunk = void 0),
      (this._chunkcb = void 0),
      (this._chunkErr = void 0),
      (this._chunkcbErr = void 0),
      this.on("finish", sS).on("prefinish", sS),
      this.on("end", oS).on("close", oS);
  }
  _read(t) {
    this._waitChanDrain &&
      ((this._waitChanDrain = !1), this.incoming.window <= o1 && c1(this));
  }
  _write(t, n, r) {
    const i = this._client._protocol,
      a = this.outgoing,
      s = a.packetSize,
      o = a.id;
    let c = a.window;
    const l = t.length;
    let f = 0;
    if (a.state === "open") {
      for (; l - f > 0 && c > 0; ) {
        let u = l - f;
        u > c && (u = c),
          u > s && (u = s),
          f === 0 && u === l
            ? i.channelData(o, t)
            : i.channelData(o, Bd(t, f, f + u)),
          (f += u),
          (c -= u);
      }
      if (((a.window = c), l - f > 0)) {
        c === 0 && (this._waitWindow = !0),
          f > 0 ? (this._chunk = Bd(t, f, l)) : (this._chunk = t),
          (this._chunkcb = r);
        return;
      }
      r();
    }
  }
  eof() {
    this.outgoing.state === "open" &&
      ((this.outgoing.state = "eof"),
      this._client._protocol.channelEOF(this.outgoing.id));
  }
  close() {
    (this.outgoing.state === "open" || this.outgoing.state === "eof") &&
      ((this.outgoing.state = "closing"),
      this._client._protocol.channelClose(this.outgoing.id));
  }
  destroy() {
    return this.end(), this.close(), this;
  }
  setWindow(t, n, r, i) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    this.type === "session" &&
      (this.subtype === "shell" || this.subtype === "exec") &&
      this.writable &&
      this.outgoing.state === "open" &&
      this._client._protocol.windowChange(this.outgoing.id, t, n, r, i);
  }
  signal(t) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    this.type === "session" &&
      this.writable &&
      this.outgoing.state === "open" &&
      this._client._protocol.signal(this.outgoing.id, t);
  }
  exit(t, n, r) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    this.type === "session" &&
      this.writable &&
      this.outgoing.state === "open" &&
      (typeof t == "number"
        ? this._client._protocol.exitStatus(this.outgoing.id, t)
        : this._client._protocol.exitSignal(this.outgoing.id, t, n, r));
  }
};
function sS() {
  this.eof(),
    (this.server || !this.allowHalfOpen) && this.close(),
    (this.writable = !1);
}
function oS() {
  this.readable = !1;
}
function c1(e) {
  if (e.outgoing.state === "closed") return;
  const t = Iu - e.incoming.window;
  t <= 0 ||
    ((e.incoming.window += t),
    e._client._protocol.channelWindowAdjust(e.outgoing.id, t));
}
var qk = {
  Channel: _re,
  MAX_WINDOW: Iu,
  PACKET_SIZE: vre,
  windowAdjust: c1,
  WINDOW_THRESHOLD: o1,
};
const { SFTP: Ere } = Zp,
  Xc = 2 ** 32 - 1;
function Gk(e, t, n, r) {
  if ((e._chanMgr.remove(t), typeof r != "function")) return;
  let i;
  n instanceof Error
    ? (i = n)
    : typeof n == "object" && n !== null
    ? ((i = new Error(`(SSH) Channel open failure: ${n.description}`)),
      (i.reason = n.reason))
    : ((i = new Error(
        "(SSH) Channel open failure: server closed channel unexpectedly",
      )),
      (i.reason = "")),
    r(i);
}
function Qk(e, t, n, r, i) {
  if (typeof n == "function") {
    Gk(e, t, r, n);
    return;
  }
  if (
    typeof n != "object" ||
    n === null ||
    (n.incoming && n.incoming.state === "closed") ||
    (e._chanMgr.remove(t), n.server && n.constructor.name === "Session")
  )
    return;
  (n.incoming.state = "closed"),
    n.readable && n.push(null),
    n.server
      ? n.stderr.writable && n.stderr.end()
      : n.stderr.readable && n.stderr.push(null),
    n.constructor !== Ere &&
      (n.outgoing.state === "open" || n.outgoing.state === "eof") &&
      !i &&
      n.close(),
    n.outgoing.state === "closing" && (n.outgoing.state = "closed");
  const a = n._readableState,
    s = n._writableState;
  s && !s.ending && !s.finished && !i && n.end();
  const o = n._callbacks;
  n._callbacks = [];
  for (let c = 0; c < o.length; ++c) o[c](!0);
  if (n.server)
    !n.readable || n.destroyed || (a && a.endEmitted)
      ? n.emit("close")
      : n.once("end", () => n.emit("close"));
  else {
    let c;
    switch (n.type) {
      case "direct-streamlocal@openssh.com":
      case "direct-tcpip":
        c = () => n.emit("close");
        break;
      default: {
        const f = n._exit;
        c = () => {
          f.code === null
            ? n.emit("close", f.code, f.signal, f.dump, f.desc)
            : n.emit("close", f.code);
        };
      }
    }
    !n.readable || n.destroyed || (a && a.endEmitted) ? c() : n.once("end", c);
    const l = n.stderr._readableState;
    !n.stderr.readable || n.stderr.destroyed || (l && l.endEmitted)
      ? n.stderr.emit("close")
      : n.stderr.once("end", () => n.stderr.emit("close"));
  }
}
let wre = class {
  constructor(t) {
    (this._client = t),
      (this._channels = {}),
      (this._cur = -1),
      (this._count = 0);
  }
  add(t) {
    let n;
    if (this._cur < Xc) n = ++this._cur;
    else if (this._count === 0) (this._cur = 0), (n = 0);
    else {
      const r = this._channels;
      for (let i = 0; i < Xc; ++i)
        if (r[i] === void 0) {
          n = i;
          break;
        }
    }
    return n === void 0
      ? -1
      : ((this._channels[n] = t || !0), ++this._count, n);
  }
  update(t, n) {
    if (typeof t != "number" || t < 0 || t >= Xc || !isFinite(t))
      throw new Error(`Invalid channel id: ${t}`);
    n && this._channels[t] && (this._channels[t] = n);
  }
  get(t) {
    if (typeof t != "number" || t < 0 || t >= Xc || !isFinite(t))
      throw new Error(`Invalid channel id: ${t}`);
    return this._channels[t];
  }
  remove(t) {
    if (typeof t != "number" || t < 0 || t >= Xc || !isFinite(t))
      throw new Error(`Invalid channel id: ${t}`);
    this._channels[t] &&
      (delete this._channels[t], this._count && --this._count);
  }
  cleanup(t) {
    const n = this._channels;
    (this._channels = {}), (this._cur = -1), (this._count = 0);
    const r = Object.keys(n),
      i = this._client;
    for (let a = 0; a < r.length; ++a) {
      const s = +r[a],
        o = n[s];
      Qk(i, s, o._channel || o, t, !0);
    }
  }
};
const ig = (() => {
  const e = Object.prototype.toString;
  return (t) => e.call(t) === "[object RegExp]";
})();
function xre(e, t, n) {
  if (Array.isArray(e) && e.length > 0) {
    for (let r = 0; r < e.length; ++r)
      if (n.indexOf(e[r]) === -1)
        throw new Error(`Unsupported algorithm: ${e[r]}`);
    return e;
  }
  if (typeof e == "object" && e !== null) {
    const r = Object.keys(e);
    let i = t;
    for (let a = 0; a < r.length; ++a) {
      const s = r[a];
      let o = e[s];
      switch (s) {
        case "append":
          if ((Array.isArray(o) || (o = [o]), Array.isArray(o)))
            for (let c = 0; c < o.length; ++c) {
              const l = o[c];
              if (typeof l == "string") {
                if (!l || i.indexOf(l) !== -1) continue;
                if (n.indexOf(l) === -1)
                  throw new Error(`Unsupported algorithm: ${l}`);
                i === t && (i = i.slice()), i.push(l);
              } else if (ig(l))
                for (let f = 0; f < n.length; ++f) {
                  const u = n[f];
                  if (l.test(u)) {
                    if (i.indexOf(u) !== -1) continue;
                    i === t && (i = i.slice()), i.push(u);
                  }
                }
            }
          break;
        case "prepend":
          if ((Array.isArray(o) || (o = [o]), Array.isArray(o)))
            for (let c = o.length; c >= 0; --c) {
              const l = o[c];
              if (typeof l == "string") {
                if (!l || i.indexOf(l) !== -1) continue;
                if (n.indexOf(l) === -1)
                  throw new Error(`Unsupported algorithm: ${l}`);
                i === t && (i = i.slice()), i.unshift(l);
              } else if (ig(l))
                for (let f = n.length; f >= 0; --f) {
                  const u = n[f];
                  if (l.test(u)) {
                    if (i.indexOf(u) !== -1) continue;
                    i === t && (i = i.slice()), i.unshift(u);
                  }
                }
            }
          break;
        case "remove":
          if ((Array.isArray(o) || (o = [o]), Array.isArray(o)))
            for (let c = 0; c < o.length; ++c) {
              const l = o[c];
              if (typeof l == "string") {
                if (!l) continue;
                const f = i.indexOf(l);
                if (f === -1) continue;
                i === t && (i = i.slice()), i.splice(f, 1);
              } else if (ig(l))
                for (let f = 0; f < i.length; ++f)
                  l.test(i[f]) &&
                    (i === t && (i = i.slice()), i.splice(f, 1), --f);
            }
          break;
      }
    }
    return i;
  }
  return t;
}
var Wk = {
  ChannelManager: wre,
  generateAlgorithmList: xre,
  onChannelOpenFailure: Gk,
  onCHANNEL_CLOSE: Qk,
  isWritable: (e) =>
    e && e.writable && e._readableState && e._readableState.ended === !1,
};
const { createHash: Are, getHashes: Sre, randomFillSync: Ire } = pr,
  { Socket: $re } = ha,
  { lookup: Cre } = RT,
  Rre = Hi,
  kre = Sre(),
  {
    COMPAT: zk,
    CHANNEL_EXTENDED_DATATYPE: { STDERR: Tre },
    CHANNEL_OPEN_FAILURE: Jc,
    DEFAULT_CIPHER: cS,
    DEFAULT_COMPRESSION: lS,
    DEFAULT_KEX: uS,
    DEFAULT_MAC: fS,
    DEFAULT_SERVER_HOST_KEY: dS,
    DISCONNECT_REASON: pS,
    DISCONNECT_REASON_BY_VALUE: Nre,
    SUPPORTED_CIPHER: Ore,
    SUPPORTED_COMPRESSION: Pre,
    SUPPORTED_KEX: Dre,
    SUPPORTED_MAC: Lre,
    SUPPORTED_SERVER_HOST_KEY: Bre,
  } = es(),
  { init: Ure } = eo(),
  Fre = kk,
  { parseKey: Jf } = to,
  { SFTP: jre } = Zp,
  {
    bufferCopy: hS,
    makeBufferParser: Kk,
    makeError: Mre,
    readUInt32BE: Hre,
    sigSSHToASN1: qre,
    writeUInt32BE: ag,
  } = Ki(),
  { AgentContext: mS, createAgent: gS, isAgent: vS } = vk,
  {
    Channel: Vk,
    MAX_WINDOW: Ud,
    PACKET_SIZE: Fd,
    windowAdjust: yS,
    WINDOW_THRESHOLD: bS,
  } = qk,
  {
    ChannelManager: Gre,
    generateAlgorithmList: Zc,
    isWritable: Pn,
    onChannelOpenFailure: Qre,
    onCHANNEL_CLOSE: Wre,
  } = Wk,
  Nf = Kk(),
  Of = Kk(),
  cl = /^OpenSSH_(?:(?![0-4])\d)|(?:\d{2,})/,
  K0 = (e) => {};
let zre = class extends Rre {
  constructor() {
    super(),
      (this.config = {
        host: void 0,
        port: void 0,
        localAddress: void 0,
        localPort: void 0,
        forceIPv4: void 0,
        forceIPv6: void 0,
        keepaliveCountMax: void 0,
        keepaliveInterval: void 0,
        readyTimeout: void 0,
        ident: void 0,
        username: void 0,
        password: void 0,
        privateKey: void 0,
        tryKeyboard: void 0,
        agent: void 0,
        allowAgentFwd: void 0,
        authHandler: void 0,
        hostHashAlgo: void 0,
        hostHashCb: void 0,
        strictVendor: void 0,
        debug: void 0,
      }),
      (this._agent = void 0),
      (this._readyTimeout = void 0),
      (this._chanMgr = void 0),
      (this._callbacks = void 0),
      (this._forwarding = void 0),
      (this._forwardingUnix = void 0),
      (this._acceptX11 = void 0),
      (this._agentFwdEnabled = void 0),
      (this._remoteVer = void 0),
      (this._protocol = void 0),
      (this._sock = void 0),
      (this._resetKA = void 0);
  }
  connect(t) {
    if (this._sock && Pn(this._sock))
      return (
        this.once("close", () => {
          this.connect(t);
        }),
        this.end(),
        this
      );
    (this.config.host = t.hostname || t.host || "localhost"),
      (this.config.port = t.port || 22),
      (this.config.localAddress =
        typeof t.localAddress == "string" ? t.localAddress : void 0),
      (this.config.localPort =
        typeof t.localPort == "string" || typeof t.localPort == "number"
          ? t.localPort
          : void 0),
      (this.config.forceIPv4 = t.forceIPv4 || !1),
      (this.config.forceIPv6 = t.forceIPv6 || !1),
      (this.config.keepaliveCountMax =
        typeof t.keepaliveCountMax == "number" && t.keepaliveCountMax >= 0
          ? t.keepaliveCountMax
          : 3),
      (this.config.keepaliveInterval =
        typeof t.keepaliveInterval == "number" && t.keepaliveInterval > 0
          ? t.keepaliveInterval
          : 0),
      (this.config.readyTimeout =
        typeof t.readyTimeout == "number" && t.readyTimeout >= 0
          ? t.readyTimeout
          : 2e4),
      (this.config.ident =
        typeof t.ident == "string" || Buffer.isBuffer(t.ident)
          ? t.ident
          : void 0);
    const n = {
      kex: void 0,
      serverHostKey: void 0,
      cs: { cipher: void 0, mac: void 0, compress: void 0, lang: [] },
      sc: void 0,
    };
    let r = !0;
    if (
      (typeof t.algorithms == "object" &&
        t.algorithms !== null &&
        ((n.kex = Zc(t.algorithms.kex, uS, Dre)),
        n.kex !== uS && (r = !1),
        (n.serverHostKey = Zc(t.algorithms.serverHostKey, dS, Bre)),
        n.serverHostKey !== dS && (r = !1),
        (n.cs.cipher = Zc(t.algorithms.cipher, cS, Ore)),
        n.cs.cipher !== cS && (r = !1),
        (n.cs.mac = Zc(t.algorithms.hmac, fS, Lre)),
        n.cs.mac !== fS && (r = !1),
        (n.cs.compress = Zc(t.algorithms.compress, lS, Pre)),
        n.cs.compress !== lS && (r = !1),
        r || (n.sc = n.cs)),
      typeof t.username == "string")
    )
      this.config.username = t.username;
    else if (typeof t.user == "string") this.config.username = t.user;
    else throw new Error("Invalid username");
    (this.config.password =
      typeof t.password == "string" ? t.password : void 0),
      (this.config.privateKey =
        typeof t.privateKey == "string" || Buffer.isBuffer(t.privateKey)
          ? t.privateKey
          : void 0),
      (this.config.localHostname =
        typeof t.localHostname == "string" ? t.localHostname : void 0),
      (this.config.localUsername =
        typeof t.localUsername == "string" ? t.localUsername : void 0),
      (this.config.tryKeyboard = t.tryKeyboard === !0),
      typeof t.agent == "string" && t.agent.length
        ? (this.config.agent = gS(t.agent))
        : vS(t.agent)
        ? (this.config.agent = t.agent)
        : (this.config.agent = void 0),
      (this.config.allowAgentFwd =
        t.agentForward === !0 && this.config.agent !== void 0);
    let i = (this.config.authHandler =
      typeof t.authHandler == "function" || Array.isArray(t.authHandler)
        ? t.authHandler
        : void 0);
    this.config.strictVendor =
      typeof t.strictVendor == "boolean" ? t.strictVendor : !0;
    const a = (this.config.debug =
      typeof t.debug == "function" ? t.debug : void 0);
    if (t.agentForward === !0 && !this.config.allowAgentFwd)
      throw new Error(
        "You must set a valid agent path to allow agent forwarding",
      );
    let s = (this._callbacks = []);
    (this._chanMgr = new Gre(this)),
      (this._forwarding = {}),
      (this._forwardingUnix = {}),
      (this._acceptX11 = 0),
      (this._agentFwdEnabled = !1),
      (this._agent = this.config.agent ? this.config.agent : void 0),
      (this._remoteVer = void 0);
    let o;
    if (this.config.privateKey) {
      if (((o = Jf(this.config.privateKey, t.passphrase)), o instanceof Error))
        throw new Error(`Cannot parse privateKey: ${o.message}`);
      if ((Array.isArray(o) && (o = o[0]), o.getPrivatePEM() === null))
        throw new Error(
          "privateKey value does not contain a (valid) private key",
        );
    }
    let c;
    if (typeof t.hostVerifier == "function") {
      const U = t.hostVerifier;
      let G;
      kre.indexOf(t.hostHash) !== -1 && (G = Are(t.hostHash)),
        (c = (L, k) => {
          G && (G.update(L), (L = G.digest("hex")));
          const W = U(L, k);
          W !== void 0 && k(W);
        });
    }
    const l = (this._sock = t.sock || new $re());
    let f = !1,
      u = !1;
    this._protocol && this._protocol.cleanup();
    const d = a
      ? (U, G, L) => {
          a(`Debug output from server: ${JSON.stringify(L)}`);
        }
      : void 0;
    let p;
    const h = (this._protocol = new Fre({
      ident: this.config.ident,
      offer: r ? void 0 : n,
      onWrite: (U) => {
        Pn(l) && l.write(U);
      },
      onError: (U) => {
        U.level === "handshake" && clearTimeout(this._readyTimeout),
          h._destruct || l.removeAllListeners("data"),
          this.emit("error", U);
        try {
          l.end();
        } catch {}
      },
      onHeader: (U) => {
        (u = !0),
          (this._remoteVer = U.versions.software),
          U.greeting && this.emit("greeting", U.greeting);
      },
      onHandshakeComplete: (U) => {
        this.emit("handshake", U), f || ((f = !0), h.service("ssh-userauth"));
      },
      debug: a,
      hostVerifier: c,
      messageHandlers: {
        DEBUG: d,
        DISCONNECT: (U, G, L) => {
          if (G !== pS.BY_APPLICATION) {
            L ||
              ((L = Nre[G]),
              L === void 0 && (L = `Unexpected disconnection reason: ${G}`));
            const k = new Error(L);
            (k.code = G), this.emit("error", k);
          }
          l.end();
        },
        SERVICE_ACCEPT: (U, G) => {
          G === "ssh-userauth" && J();
        },
        EXT_INFO: (U, G) => {
          if (p === void 0) {
            for (const L of G)
              if (L.name === "server-sig-algs") {
                p = L.algs;
                return;
              }
            p = null;
          }
        },
        USERAUTH_BANNER: (U, G) => {
          this.emit("banner", G);
        },
        USERAUTH_SUCCESS: (U) => {
          E(), clearTimeout(this._readyTimeout), this.emit("ready");
        },
        USERAUTH_FAILURE: (U, G, L) => {
          if (S.keyAlgos) {
            const k = S.keyAlgos[0][0];
            if (
              (a && a(`Client: ${S.type} (${k}) auth failed`),
              S.keyAlgos.shift(),
              S.keyAlgos.length)
            ) {
              const [W, F] = S.keyAlgos[0];
              switch (S.type) {
                case "agent":
                  h.authPK(S.username, S.agentCtx.currentKey(), W);
                  return;
                case "publickey":
                  h.authPK(S.username, S.key, W);
                  return;
                case "hostbased":
                  h.authHostbased(
                    S.username,
                    S.key,
                    S.localHostname,
                    S.localUsername,
                    W,
                    (x, T) => {
                      const V = S.key.sign(x, F);
                      if (V instanceof Error)
                        return (
                          (V.message = `Error while signing with key: ${V.message}`),
                          (V.level = "client-authentication"),
                          this.emit("error", V),
                          J()
                        );
                      T(V);
                    },
                  );
                  return;
              }
            } else S.keyAlgos = void 0;
          }
          if (S.type === "agent") {
            const k = S.agentCtx.pos();
            return a && a(`Client: Agent key #${k + 1} failed`), Z();
          }
          a && a(`Client: ${S.type} auth failed`), (w = L), (O = G), J();
        },
        USERAUTH_PASSWD_CHANGEREQ: (U, G) => {
          S.type === "password" &&
            this.emit("change password", G, (L) => {
              h.authPassword(this.config.username, this.config.password, L);
            });
        },
        USERAUTH_PK_OK: (U) => {
          let G, L;
          if ((S.keyAlgos && ([G, L] = S.keyAlgos[0]), S.type === "agent")) {
            const k = S.agentCtx.currentKey();
            h.authPK(S.username, k, G, (W, F) => {
              const x = { hash: L };
              S.agentCtx.sign(k, W, x, (T, V) => {
                if (T) (T.level = "agent"), this.emit("error", T);
                else return F(V);
                Z();
              });
            });
          } else
            S.type === "publickey" &&
              h.authPK(S.username, S.key, G, (k, W) => {
                const F = S.key.sign(k, L);
                if (F instanceof Error)
                  return (
                    (F.message = `Error signing data with key: ${F.message}`),
                    (F.level = "client-authentication"),
                    this.emit("error", F),
                    J()
                  );
                W(F);
              });
        },
        USERAUTH_INFO_REQUEST: (U, G, L, k) => {
          if (S.type === "keyboard-interactive") {
            if ((Array.isArray(k) ? k.length : 0) === 0) {
              a && a("Client: Sending automatic USERAUTH_INFO_RESPONSE"),
                h.authInfoRes();
              return;
            }
            S.prompt(G, L, "", k, (F) => {
              h.authInfoRes(F);
            });
          }
        },
        REQUEST_SUCCESS: (U, G) => {
          s.length && s.shift()(!1, G);
        },
        REQUEST_FAILURE: (U) => {
          s.length && s.shift()(!0);
        },
        GLOBAL_REQUEST: (U, G, L, k) => {
          switch (G) {
            case "hostkeys-00@openssh.com":
              Jre(this, k, (W, F) => {
                W || this.emit("hostkeys", F);
              }),
                L && h.requestSuccess();
              break;
            default:
              L && h.requestFailure();
          }
        },
        CHANNEL_OPEN: (U, G) => {
          Yre(this, G);
        },
        CHANNEL_OPEN_CONFIRMATION: (U, G) => {
          const L = this._chanMgr.get(G.recipient);
          if (typeof L != "function") return;
          const k = L.type === "sftp",
            F = {
              type: k ? "session" : L.type,
              incoming: {
                id: G.recipient,
                window: Ud,
                packetSize: Fd,
                state: "open",
              },
              outgoing: {
                id: G.sender,
                window: G.window,
                packetSize: G.packetSize,
                state: "open",
              },
            },
            x = k ? new jre(this, F, { debug: a }) : new Vk(this, F);
          this._chanMgr.update(G.recipient, x), L(void 0, x);
        },
        CHANNEL_OPEN_FAILURE: (U, G, L, k) => {
          const W = this._chanMgr.get(G);
          if (typeof W != "function") return;
          Qre(this, G, { reason: L, description: k }, W);
        },
        CHANNEL_DATA: (U, G, L) => {
          const k = this._chanMgr.get(G);
          if (
            !(typeof k != "object" || k === null) &&
            k.incoming.window !== 0
          ) {
            if (((k.incoming.window -= L.length), k.push(L) === !1)) {
              k._waitChanDrain = !0;
              return;
            }
            k.incoming.window <= bS && yS(k);
          }
        },
        CHANNEL_EXTENDED_DATA: (U, G, L, k) => {
          if (k !== Tre) return;
          const W = this._chanMgr.get(G);
          if (
            !(typeof W != "object" || W === null) &&
            W.incoming.window !== 0
          ) {
            if (((W.incoming.window -= L.length), !W.stderr.push(L))) {
              W._waitChanDrain = !0;
              return;
            }
            W.incoming.window <= bS && yS(W);
          }
        },
        CHANNEL_WINDOW_ADJUST: (U, G, L) => {
          const k = this._chanMgr.get(G);
          typeof k != "object" ||
            k === null ||
            ((k.outgoing.window += L),
            k._waitWindow &&
              ((k._waitWindow = !1),
              k._chunk
                ? k._write(k._chunk, null, k._chunkcb)
                : k._chunkcb
                ? k._chunkcb()
                : k._chunkErr
                ? k.stderr._write(k._chunkErr, null, k._chunkcbErr)
                : k._chunkcbErr && k._chunkcbErr()));
        },
        CHANNEL_SUCCESS: (U, G) => {
          const L = this._chanMgr.get(G);
          typeof L != "object" ||
            L === null ||
            (this._resetKA(), L._callbacks.length && L._callbacks.shift()(!1));
        },
        CHANNEL_FAILURE: (U, G) => {
          const L = this._chanMgr.get(G);
          typeof L != "object" ||
            L === null ||
            (this._resetKA(), L._callbacks.length && L._callbacks.shift()(!0));
        },
        CHANNEL_REQUEST: (U, G, L, k, W) => {
          const F = this._chanMgr.get(G);
          if (typeof F != "object" || F === null) return;
          const x = F._exit;
          if (x.code === void 0) {
            switch (L) {
              case "exit-status":
                F.emit("exit", (x.code = W));
                return;
              case "exit-signal":
                F.emit(
                  "exit",
                  (x.code = null),
                  (x.signal = `SIG${W.signal}`),
                  (x.dump = W.coreDumped),
                  (x.desc = W.errorMessage),
                );
                return;
            }
            k && U.channelFailure(F.outgoing.id);
          }
        },
        CHANNEL_EOF: (U, G) => {
          const L = this._chanMgr.get(G);
          typeof L != "object" ||
            L === null ||
            (L.incoming.state === "open" &&
              ((L.incoming.state = "eof"),
              L.readable && L.push(null),
              L.stderr.readable && L.stderr.push(null)));
        },
        CHANNEL_CLOSE: (U, G) => {
          Wre(this, G, this._chanMgr.get(G));
        },
      },
    }));
    l.pause();
    const m = this.config.keepaliveInterval,
      g = this.config.keepaliveCountMax;
    let v = 0,
      y;
    const _ = () => {
      if (++v > g) {
        if ((clearInterval(y), l.readable)) {
          const U = new Error("Keepalive timeout");
          (U.level = "client-timeout"), this.emit("error", U), l.destroy();
        }
        return;
      }
      Pn(l) ? (s.push(E), h.ping()) : clearInterval(y);
    };
    function E() {
      m > 0 && ((v = 0), clearInterval(y), Pn(l) && (y = setInterval(_, m)));
    }
    this._resetKA = E;
    const R = (() => {
        let U = !1;
        return () => {
          if (!U && ((U = !0), I && !u)) {
            const G = Mre("Connection lost before handshake", "protocol", !0);
            this.emit("error", G);
          }
        };
      })(),
      A = (() => {
        let U = !1;
        return () => {
          U ||
            ((U = !0),
            (I = !0),
            a && a("Socket connected"),
            this.emit("connect"),
            Ure.then(() => {
              h.start(),
                l.on("data", (G) => {
                  try {
                    h.parse(G, 0, G.length);
                  } catch (L) {
                    this.emit("error", L);
                    try {
                      Pn(l) && l.end();
                    } catch {}
                  }
                }),
                l.stderr &&
                  typeof l.stderr.resume == "function" &&
                  l.stderr.resume(),
                l.resume();
            }).catch((G) => {
              this.emit("error", G);
              try {
                Pn(l) && l.end();
              } catch {}
            }));
        };
      })();
    let I = !1;
    l.on("connect", A)
      .on("timeout", () => {
        this.emit("timeout");
      })
      .on("error", (U) => {
        a && a(`Socket error: ${U.message}`),
          clearTimeout(this._readyTimeout),
          (U.level = "client-socket"),
          this.emit("error", U);
      })
      .on("end", () => {
        a && a("Socket ended"),
          R(),
          h.cleanup(),
          clearTimeout(this._readyTimeout),
          clearInterval(y),
          this.emit("end");
      })
      .on("close", () => {
        a && a("Socket closed"),
          R(),
          h.cleanup(),
          clearTimeout(this._readyTimeout),
          clearInterval(y),
          this.emit("close");
        const U = s;
        s = this._callbacks = [];
        const G = new Error("No response from server");
        for (let L = 0; L < U.length; ++L) U[L](G);
        this._chanMgr.cleanup(G);
      });
    let S,
      w = null,
      O = null;
    const Q = ["none"];
    this.config.password !== void 0 && Q.push("password"),
      o !== void 0 && Q.push("publickey"),
      this._agent !== void 0 && Q.push("agent"),
      this.config.tryKeyboard && Q.push("keyboard-interactive"),
      o !== void 0 &&
        this.config.localHostname !== void 0 &&
        this.config.localUsername !== void 0 &&
        Q.push("hostbased"),
      Array.isArray(i) ? (i = SS(i)) : typeof i != "function" && (i = SS(Q));
    let j = !1;
    const H = (U) => {
      if (!j) {
        if (((j = !0), U === !1)) {
          const G = new Error("All configured authentication methods failed");
          (G.level = "client-authentication"),
            this.emit("error", G),
            this.end();
          return;
        }
        if (typeof U == "string") {
          const G = U;
          if (Q.indexOf(G) === -1)
            return q(`Authentication method not allowed: ${G}`);
          const L = this.config.username;
          switch (G) {
            case "password":
              U = { type: G, username: L, password: this.config.password };
              break;
            case "publickey":
              U = { type: G, username: L, key: o };
              break;
            case "hostbased":
              U = {
                type: G,
                username: L,
                key: o,
                localHostname: this.config.localHostname,
                localUsername: this.config.localUsername,
              };
              break;
            case "agent":
              U = { type: G, username: L, agentCtx: new mS(this._agent) };
              break;
            case "keyboard-interactive":
              U = {
                type: G,
                username: L,
                prompt: (...k) => this.emit("keyboard-interactive", ...k),
              };
              break;
            case "none":
              U = { type: G, username: L };
              break;
            default:
              return q(`Skipping unsupported authentication method: ${U}`);
          }
        } else {
          if (typeof U != "object" || U === null)
            return q(`Skipping invalid authentication attempt: ${U}`);
          {
            const G = U.username;
            if (typeof G != "string")
              return q(`Skipping invalid authentication attempt: ${U}`);
            const L = U.type;
            switch (L) {
              case "password": {
                const { password: k } = U;
                if (typeof k != "string" && !Buffer.isBuffer(k))
                  return q("Skipping invalid password auth attempt");
                U = { type: L, username: G, password: k };
                break;
              }
              case "publickey": {
                const k = Jf(U.key, U.passphrase);
                if (k instanceof Error)
                  return q("Skipping invalid key auth attempt");
                if (!k.isPrivateKey()) return q("Skipping non-private key");
                U = { type: L, username: G, key: k };
                break;
              }
              case "hostbased": {
                const { localHostname: k, localUsername: W } = U,
                  F = Jf(U.key, U.passphrase);
                if (
                  F instanceof Error ||
                  typeof k != "string" ||
                  typeof W != "string"
                )
                  return q("Skipping invalid hostbased auth attempt");
                if (!F.isPrivateKey()) return q("Skipping non-private key");
                U = {
                  type: L,
                  username: G,
                  key: F,
                  localHostname: k,
                  localUsername: W,
                };
                break;
              }
              case "agent": {
                let k = U.agent;
                if (typeof k == "string" && k.length) k = gS(k);
                else if (!vS(k)) return q(`Skipping invalid agent: ${U.agent}`);
                U = { type: L, username: G, agentCtx: new mS(k) };
                break;
              }
              case "keyboard-interactive": {
                const { prompt: k } = U;
                if (typeof k != "function")
                  return q(
                    "Skipping invalid keyboard-interactive auth attempt",
                  );
                U = { type: L, username: G, prompt: k };
                break;
              }
              case "none":
                U = { type: L, username: G };
                break;
              default:
                return q(`Skipping unsupported authentication method: ${U}`);
            }
          }
        }
        S = U;
        try {
          const G = S.username;
          switch (S.type) {
            case "password":
              h.authPassword(G, S.password);
              break;
            case "publickey": {
              let L;
              if (((S.keyAlgos = sg(this, S.key, p)), S.keyAlgos))
                if (S.keyAlgos.length) L = S.keyAlgos[0][0];
                else
                  return q(
                    "Skipping key authentication (no mutual hash algorithm)",
                  );
              h.authPK(G, S.key, L);
              break;
            }
            case "hostbased": {
              let L, k;
              if (((S.keyAlgos = sg(this, S.key, p)), S.keyAlgos))
                if (S.keyAlgos.length) [L, k] = S.keyAlgos[0];
                else
                  return q(
                    "Skipping hostbased authentication (no mutual hash algorithm)",
                  );
              h.authHostbased(
                G,
                S.key,
                S.localHostname,
                S.localUsername,
                L,
                (W, F) => {
                  const x = S.key.sign(W, k);
                  if (x instanceof Error)
                    return (
                      (x.message = `Error while signing with key: ${x.message}`),
                      (x.level = "client-authentication"),
                      this.emit("error", x),
                      J()
                    );
                  F(x);
                },
              );
              break;
            }
            case "agent":
              S.agentCtx.init((L) => {
                if (L) return (L.level = "agent"), this.emit("error", L), J();
                Z();
              });
              break;
            case "keyboard-interactive":
              h.authKeyboard(G);
              break;
            case "none":
              h.authNone(G);
              break;
          }
        } finally {
          j = !1;
        }
      }
    };
    function q(U) {
      a && a(U), process.nextTick(J);
    }
    function J() {
      j = !1;
      const U = i(O, w, H);
      j || U === void 0 || H(U);
    }
    const Z = () => {
        if (S.type === "agent") {
          const U = S.agentCtx.nextKey();
          if (U === !1)
            a && a("Agent: No more keys left to try"),
              a && a("Client: agent auth failed"),
              J();
          else {
            const G = S.agentCtx.pos();
            let L;
            if (((S.keyAlgos = sg(this, U, p)), S.keyAlgos))
              if (S.keyAlgos.length) L = S.keyAlgos[0][0];
              else {
                a &&
                  a(`Agent: Skipping key #${G + 1} (no mutual hash algorithm)`),
                  Z();
                return;
              }
            a && a(`Agent: Trying key #${G + 1}`), h.authPK(S.username, U, L);
          }
        }
      },
      z = () => {
        this.config.readyTimeout > 0 &&
          (this._readyTimeout = setTimeout(() => {
            const U = new Error("Timed out while waiting for handshake");
            (U.level = "client-timeout"), this.emit("error", U), l.destroy();
          }, this.config.readyTimeout));
      };
    if (t.sock) z(), (typeof l.connecting == "boolean" && l.connecting) || A();
    else {
      let U = this.config.host;
      const G = this.config.forceIPv4,
        L = this.config.forceIPv6;
      a && a(`Client: Trying ${U} on port ${this.config.port} ...`);
      const k = () => {
        z(),
          l.connect({
            host: U,
            port: this.config.port,
            localAddress: this.config.localAddress,
            localPort: this.config.localPort,
          }),
          l.setMaxListeners(0),
          l.setTimeout(typeof t.timeout == "number" ? t.timeout : 0);
      };
      (!G && !L) || (G && L)
        ? k()
        : Cre(U, G ? 4 : 6, (W, F, x) => {
            if (W) {
              const T = G ? "IPv4" : "IPv6",
                V = new Error(
                  `Error while looking up ${T} address for '${U}': ${W}`,
                );
              clearTimeout(this._readyTimeout),
                (V.level = "client-dns"),
                this.emit("error", V),
                this.emit("close");
              return;
            }
            (U = F), k();
          });
    }
    return this;
  }
  end() {
    return (
      this._sock &&
        Pn(this._sock) &&
        (this._protocol.disconnect(pS.BY_APPLICATION), this._sock.end()),
      this
    );
  }
  destroy() {
    return this._sock && Pn(this._sock) && this._sock.destroy(), this;
  }
  exec(t, n, r) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    typeof n == "function" && ((r = n), (n = {}));
    const i = { allowHalfOpen: n.allowHalfOpen !== !1 };
    return (
      yo(this, "session", i, (a, s) => {
        if (a) {
          r(a);
          return;
        }
        const o = [];
        function c(l) {
          if (l) {
            s.close(), r(l);
            return;
          }
          o.length && o.shift()();
        }
        (this.config.allowAgentFwd === !0 ||
          (n && n.agentForward === !0 && this._agent !== void 0)) &&
          o.push(() => wS(s, c)),
          typeof n == "object" &&
            n !== null &&
            (typeof n.env == "object" && n.env !== null && xS(s, n.env),
            ((typeof n.pty == "object" && n.pty !== null) || n.pty === !0) &&
              o.push(() => ES(s, n.pty, c)),
            ((typeof n.x11 == "object" && n.x11 !== null) ||
              n.x11 === "number" ||
              n.x11 === !0) &&
              o.push(() => _S(s, n.x11, c))),
          o.push(() => Vre(s, t, n, r)),
          o.shift()();
      }),
      this
    );
  }
  shell(t, n, r) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    return (
      typeof t == "function"
        ? ((r = t), (t = n = void 0))
        : typeof n == "function" && ((r = n), (n = void 0)),
      t && (t.x11 !== void 0 || t.env !== void 0) && ((n = t), (t = void 0)),
      yo(this, "session", (i, a) => {
        if (i) {
          r(i);
          return;
        }
        const s = [];
        function o(c) {
          if (c) {
            a.close(), r(c);
            return;
          }
          s.length && s.shift()();
        }
        (this.config.allowAgentFwd === !0 ||
          (n && n.agentForward === !0 && this._agent !== void 0)) &&
          s.push(() => wS(a, o)),
          t !== !1 && s.push(() => ES(a, t, o)),
          typeof n == "object" &&
            n !== null &&
            (typeof n.env == "object" && n.env !== null && xS(a, n.env),
            ((typeof n.x11 == "object" && n.x11 !== null) ||
              n.x11 === "number" ||
              n.x11 === !0) &&
              s.push(() => _S(a, n.x11, o))),
          s.push(() => Kre(a, r)),
          s.shift()();
      }),
      this
    );
  }
  subsys(t, n) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    return (
      yo(this, "session", (r, i) => {
        if (r) {
          n(r);
          return;
        }
        AS(i, t, (a, s) => {
          if (a) {
            n(a);
            return;
          }
          n(void 0, s);
        });
      }),
      this
    );
  }
  forwardIn(t, n, r) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    const i = typeof r == "function";
    return (
      i &&
        this._callbacks.push((a, s) => {
          if (a) {
            r(a !== !0 ? a : new Error(`Unable to bind to ${t}:${n}`));
            return;
          }
          let o = n;
          n === 0 &&
            s &&
            s.length >= 4 &&
            ((o = Hre(s, 0)),
            this._protocol._compatFlags & zk.DYN_RPORT_BUG || (n = o)),
            (this._forwarding[`${t}:${n}`] = o),
            r(void 0, o);
        }),
      this._protocol.tcpipForward(t, n, i),
      this
    );
  }
  unforwardIn(t, n, r) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    const i = typeof r == "function";
    return (
      i &&
        this._callbacks.push((a) => {
          if (a) {
            r(a !== !0 ? a : new Error(`Unable to unbind from ${t}:${n}`));
            return;
          }
          delete this._forwarding[`${t}:${n}`], r();
        }),
      this._protocol.cancelTcpipForward(t, n, i),
      this
    );
  }
  forwardOut(t, n, r, i, a) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    const s = { srcIP: t, srcPort: n, dstIP: r, dstPort: i };
    return (
      typeof a != "function" && (a = K0), yo(this, "direct-tcpip", s, a), this
    );
  }
  openssh_noMoreSessions(t) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    const n = typeof t == "function";
    return !this.config.strictVendor ||
      (this.config.strictVendor && cl.test(this._remoteVer))
      ? (n &&
          this._callbacks.push((r) => {
            if (r) {
              t(r !== !0 ? r : new Error("Unable to disable future sessions"));
              return;
            }
            t();
          }),
        this._protocol.openssh_noMoreSessions(n),
        this)
      : n
      ? (process.nextTick(
          t,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version",
          ),
        ),
        this)
      : this;
  }
  openssh_forwardInStreamLocal(t, n) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    const r = typeof n == "function";
    return !this.config.strictVendor ||
      (this.config.strictVendor && cl.test(this._remoteVer))
      ? (r &&
          this._callbacks.push((i) => {
            if (i) {
              n(i !== !0 ? i : new Error(`Unable to bind to ${t}`));
              return;
            }
            (this._forwardingUnix[t] = !0), n();
          }),
        this._protocol.openssh_streamLocalForward(t, r),
        this)
      : r
      ? (process.nextTick(
          n,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version",
          ),
        ),
        this)
      : this;
  }
  openssh_unforwardInStreamLocal(t, n) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    const r = typeof n == "function";
    return !this.config.strictVendor ||
      (this.config.strictVendor && cl.test(this._remoteVer))
      ? (r &&
          this._callbacks.push((i) => {
            if (i) {
              n(i !== !0 ? i : new Error(`Unable to unbind from ${t}`));
              return;
            }
            delete this._forwardingUnix[t], n();
          }),
        this._protocol.openssh_cancelStreamLocalForward(t, r),
        this)
      : r
      ? (process.nextTick(
          n,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version",
          ),
        ),
        this)
      : this;
  }
  openssh_forwardOutStreamLocal(t, n) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    return (
      typeof n != "function" && (n = K0),
      !this.config.strictVendor ||
      (this.config.strictVendor && cl.test(this._remoteVer))
        ? (yo(this, "direct-streamlocal@openssh.com", { socketPath: t }, n),
          this)
        : (process.nextTick(
            n,
            new Error(
              "strictVendor enabled and server is not OpenSSH or compatible version",
            ),
          ),
          this)
    );
  }
  sftp(t) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    return (
      yo(this, "sftp", (n, r) => {
        if (n) {
          t(n);
          return;
        }
        AS(r, "sftp", (i, a) => {
          if (i) {
            t(i);
            return;
          }
          function s() {
            r.removeListener("ready", o),
              r.removeListener("error", c),
              r.removeListener("exit", l),
              r.removeListener("close", l);
          }
          function o() {
            s(), t(void 0, r);
          }
          function c(f) {
            s(), t(f);
          }
          function l(f, u) {
            s();
            let d;
            typeof f == "number"
              ? (d = `Received exit code ${f} while establishing SFTP session`)
              : u !== void 0
              ? (d = `Received signal ${u} while establishing SFTP session`)
              : (d = "Received unexpected SFTP session termination");
            const p = new Error(d);
            (p.code = f), (p.signal = u), t(p);
          }
          r.on("ready", o).on("error", c).on("exit", l).on("close", l),
            r._init();
        });
      }),
      this
    );
  }
  setNoDelay(t) {
    return (
      this._sock &&
        typeof this._sock.setNoDelay == "function" &&
        this._sock.setNoDelay(t),
      this
    );
  }
};
function yo(e, t, n, r) {
  const i = Ud,
    a = Fd;
  typeof n == "function" && ((r = n), (n = {}));
  const s = (c, l) => {
    r(c, l);
  };
  s.type = t;
  const o = e._chanMgr.add(s);
  if (o === -1) {
    r(new Error("No free channels available"));
    return;
  }
  switch (t) {
    case "session":
    case "sftp":
      e._protocol.session(o, i, a);
      break;
    case "direct-tcpip":
      e._protocol.directTcpip(o, i, a, n);
      break;
    case "direct-streamlocal@openssh.com":
      e._protocol.openssh_directStreamLocal(o, i, a, n);
      break;
    default:
      throw new Error(`Unsupported channel type: ${t}`);
  }
}
function _S(e, t, n) {
  const r = {
    single: !1,
    protocol: "MIT-MAGIC-COOKIE-1",
    cookie: void 0,
    screen: 0,
  };
  typeof t == "function"
    ? (n = t)
    : typeof t == "object" &&
      t !== null &&
      (typeof t.single == "boolean" && (r.single = t.single),
      typeof t.screen == "number" && (r.screen = t.screen),
      typeof t.protocol == "string" && (r.protocol = t.protocol),
      typeof t.cookie == "string"
        ? (r.cookie = t.cookie)
        : Buffer.isBuffer(t.cookie) &&
          (r.cookie = t.cookie.hexSlice(0, t.cookie.length))),
    r.cookie === void 0 && (r.cookie = Xre());
  const i = typeof n == "function";
  if (e.outgoing.state !== "open") {
    i && n(new Error("Channel is not open"));
    return;
  }
  i &&
    e._callbacks.push((a) => {
      if (a) {
        n(a !== !0 ? a : new Error("Unable to request X11"));
        return;
      }
      (e._hasX11 = !0),
        ++e._client._acceptX11,
        e.once("close", () => {
          e._client._acceptX11 && --e._client._acceptX11;
        }),
        n();
    }),
    e._client._protocol.x11Forward(e.outgoing.id, r, i);
}
function ES(e, t, n) {
  let r = 24,
    i = 80,
    a = 640,
    s = 480,
    o = "vt100",
    c = null;
  typeof t == "function"
    ? (n = t)
    : typeof t == "object" &&
      t !== null &&
      (typeof t.rows == "number" && (r = t.rows),
      typeof t.cols == "number" && (i = t.cols),
      typeof t.width == "number" && (a = t.width),
      typeof t.height == "number" && (s = t.height),
      typeof t.term == "string" && (o = t.term),
      typeof t.modes == "object" && (c = t.modes));
  const l = typeof n == "function";
  if (e.outgoing.state !== "open") {
    l && n(new Error("Channel is not open"));
    return;
  }
  l &&
    e._callbacks.push((f) => {
      if (f) {
        n(f !== !0 ? f : new Error("Unable to request a pseudo-terminal"));
        return;
      }
      n();
    }),
    e._client._protocol.pty(e.outgoing.id, r, i, s, a, o, c, l);
}
function wS(e, t) {
  const n = typeof t == "function";
  if (e.outgoing.state !== "open") {
    n && t(new Error("Channel is not open"));
    return;
  }
  if (e._client._agentFwdEnabled) {
    n && t(!1);
    return;
  }
  (e._client._agentFwdEnabled = !0),
    e._callbacks.push((r) => {
      if (r) {
        (e._client._agentFwdEnabled = !1),
          n &&
            t(r !== !0 ? r : new Error("Unable to request agent forwarding"));
        return;
      }
      n && t();
    }),
    e._client._protocol.openssh_agentForward(e.outgoing.id, !0);
}
function Kre(e, t) {
  if (e.outgoing.state !== "open") {
    t(new Error("Channel is not open"));
    return;
  }
  e._callbacks.push((n) => {
    if (n) {
      t(n !== !0 ? n : new Error("Unable to open shell"));
      return;
    }
    (e.subtype = "shell"), t(void 0, e);
  }),
    e._client._protocol.shell(e.outgoing.id, !0);
}
function Vre(e, t, n, r) {
  if (e.outgoing.state !== "open") {
    r(new Error("Channel is not open"));
    return;
  }
  e._callbacks.push((i) => {
    if (i) {
      r(i !== !0 ? i : new Error("Unable to exec"));
      return;
    }
    (e.subtype = "exec"),
      (e.allowHalfOpen = n.allowHalfOpen !== !1),
      r(void 0, e);
  }),
    e._client._protocol.exec(e.outgoing.id, t, !0);
}
function xS(e, t) {
  if (e.outgoing.state !== "open") return;
  const n = Object.keys(t || {});
  for (let r = 0; r < n.length; ++r) {
    const i = n[r],
      a = t[i];
    e._client._protocol.env(e.outgoing.id, i, a, !1);
  }
}
function AS(e, t, n) {
  if (e.outgoing.state !== "open") {
    n(new Error("Channel is not open"));
    return;
  }
  e._callbacks.push((r) => {
    if (r) {
      n(r !== !0 ? r : new Error(`Unable to start subsystem: ${t}`));
      return;
    }
    (e.subtype = "subsystem"), n(void 0, e);
  }),
    e._client._protocol.subsystem(e.outgoing.id, t, !0);
}
function Yre(e, t) {
  let n = -1,
    r;
  const i = () => {
      const c = {
          type: t.type,
          incoming: { id: n, window: Ud, packetSize: Fd, state: "open" },
          outgoing: {
            id: t.sender,
            window: t.window,
            packetSize: t.packetSize,
            state: "open",
          },
        },
        l = new Vk(e, c);
      return (
        e._chanMgr.update(n, l),
        e._protocol.channelOpenConfirm(t.sender, n, Ud, Fd),
        l
      );
    },
    a = () => {
      r === void 0 &&
        (n === -1 ? (r = Jc.RESOURCE_SHORTAGE) : (r = Jc.CONNECT_FAILED)),
        n !== -1 && e._chanMgr.remove(n),
        e._protocol.channelOpenFail(t.sender, r, "");
    },
    s = () => (
      (n = e._chanMgr.add()),
      n === -1 &&
        ((r = Jc.RESOURCE_SHORTAGE),
        e.config.debug &&
          e.config.debug(
            "Client: Automatic rejection of incoming channel open: no channels available",
          )),
      n !== -1
    ),
    o = t.data;
  switch (t.type) {
    case "forwarded-tcpip": {
      const c = e._forwarding[`${o.destIP}:${o.destPort}`];
      if (c !== void 0 && s()) {
        o.destPort === 0 && (o.destPort = c), e.emit("tcp connection", o, i, a);
        return;
      }
      break;
    }
    case "forwarded-streamlocal@openssh.com":
      if (e._forwardingUnix[o.socketPath] !== void 0 && s()) {
        e.emit("unix connection", o, i, a);
        return;
      }
      break;
    case "auth-agent@openssh.com":
      if (
        e._agentFwdEnabled &&
        typeof e._agent.getStream == "function" &&
        s()
      ) {
        e._agent.getStream((c, l) => {
          if (c) return a();
          const f = i();
          f.pipe(l).pipe(f);
        });
        return;
      }
      break;
    case "x11":
      if (e._acceptX11 !== 0 && s()) {
        e.emit("x11", o, i, a);
        return;
      }
      break;
    default:
      (r = Jc.UNKNOWN_CHANNEL_TYPE),
        e.config.debug &&
          e.config.debug(
            `Client: Automatic rejection of unsupported incoming channel open type: ${t.type}`,
          );
  }
  r === void 0 &&
    ((r = Jc.ADMINISTRATIVELY_PROHIBITED),
    e.config.debug &&
      e.config.debug(
        "Client: Automatic rejection of unexpected incoming channel open for: " +
          t.type,
      )),
    a();
}
const Xre = (() => {
  const e = Buffer.allocUnsafe(16);
  return () => (Ire(e, 0, 16), e.hexSlice(0, 16));
})();
function SS(e) {
  if (!Array.isArray(e)) throw new Error("authList must be an array");
  let t = 0;
  return (n, r, i) => (t === e.length ? !1 : e[t++]);
}
function Jre(e, t, n) {
  if (!e._sock || !Pn(e._sock)) return;
  if ((typeof n != "function" && (n = K0), !Array.isArray(t)))
    throw new TypeError("Invalid keys argument type");
  const r = [];
  for (const i of t) {
    const a = Jf(i);
    if (a instanceof Error) throw a;
    r.push(a);
  }
  if (
    !e.config.strictVendor ||
    (e.config.strictVendor && cl.test(e._remoteVer))
  ) {
    e._callbacks.push((i, a) => {
      if (i) {
        n(i !== !0 ? i : new Error("Server failed to prove supplied keys"));
        return;
      }
      const s = [];
      let o = 0;
      for (Nf.init(a, 0); Nf.avail() && o !== r.length; ) {
        const c = r[o++],
          l = c.getPublicSSH(),
          f = Nf.readString();
        Of.init(f, 0);
        const u = Of.readString(!0);
        let d = Of.readString(),
          p;
        if (u !== c.type)
          if (c.type === "ssh-rsa")
            switch (u) {
              case "rsa-sha2-256":
                p = "sha256";
                break;
              case "rsa-sha2-512":
                p = "sha512";
                break;
              default:
                continue;
            }
          else continue;
        const h = e._protocol._kex.sessionID,
          m = Buffer.allocUnsafe(4 + 29 + 4 + h.length + 4 + l.length);
        let g = 0;
        ag(m, 29, g),
          m.utf8Write("hostkeys-prove-00@openssh.com", (g += 4), 29),
          ag(m, h.length, (g += 29)),
          hS(h, m, 0, h.length, (g += 4)),
          ag(m, l.length, (g += h.length)),
          hS(l, m, 0, l.length, (g += 4)),
          (d = qre(d, u)) && c.verify(m, d, p) === !0 && s.push(c);
      }
      Of.clear(), Nf.clear(), n(null, s);
    }),
      e._protocol.openssh_hostKeysProve(r);
    return;
  }
  process.nextTick(
    n,
    new Error(
      "strictVendor enabled and server is not OpenSSH or compatible version",
    ),
  );
}
function sg(e, t, n) {
  switch (t.type) {
    case "ssh-rsa":
      if (
        (e._protocol._compatFlags & zk.IMPLY_RSA_SHA2_SIGALGS &&
          (Array.isArray(n)
            ? (n = ["rsa-sha2-256", "rsa-sha2-512", ...n])
            : (n = ["rsa-sha2-256", "rsa-sha2-512"])),
        Array.isArray(n))
      ) {
        if (n.indexOf("rsa-sha2-256") !== -1)
          return [["rsa-sha2-256", "sha256"]];
        if (n.indexOf("rsa-sha2-512") !== -1)
          return [["rsa-sha2-512", "sha512"]];
        if (n.indexOf("ssh-rsa") === -1) return [];
      }
      return [["ssh-rsa", "sha1"]];
  }
}
var Yk = zre;
(function (e) {
  const { Agent: t } = Ws,
    { Agent: n } = pI,
    { connect: r } = CT;
  let i;
  for (const o of [t, n]) {
    class c extends o {
      constructor(f, u) {
        super(u),
          (this._connectCfg = f),
          (this._defaultSrcIP = (u && u.srcIP) || "localhost");
      }
      createConnection(f, u) {
        const d = (f && f.localAddress) || this._defaultSrcIP,
          p = (f && f.localPort) || 0,
          h = f.host,
          m = f.port;
        i === void 0 && (i = Yk);
        const g = new i();
        let v = !1;
        g.on("ready", () => {
          g.forwardOut(d, p, h, m, (y, _) => {
            if (((v = !0), y)) return g.end(), u(y);
            _.once("close", () => g.end()), u(null, s(_, o, f));
          });
        })
          .on("error", u)
          .on("close", () => {
            v || u(new Error("Unexpected connection close"));
          })
          .connect(this._connectCfg);
      }
    }
    e[o === t ? "SSHTTPAgent" : "SSHTTPSAgent"] = c;
  }
  function a() {}
  function s(o, c, l) {
    if (c === t)
      return (
        (o.setKeepAlive = a),
        (o.setNoDelay = a),
        (o.setTimeout = a),
        (o.ref = a),
        (o.unref = a),
        (o.destroySoon = o.destroy),
        o
      );
    l.socket = o;
    const f = r(l),
      u = (() => {
        let d = !1;
        return () => {
          d || ((d = !0), o.isPaused() && o.resume());
        };
      })();
    return f.on("end", u).on("close", u), f;
  }
})(yk);
var l1 = { exports: {} };
const { Server: Zre } = ha,
  $u = Hi,
  { listenerCount: lr } = $u,
  {
    CHANNEL_OPEN_FAILURE: bo,
    DEFAULT_CIPHER: eie,
    DEFAULT_COMPRESSION: tie,
    DEFAULT_KEX: nie,
    DEFAULT_MAC: rie,
    DEFAULT_SERVER_HOST_KEY: iie,
    DISCONNECT_REASON: _o,
    DISCONNECT_REASON_BY_VALUE: aie,
    SUPPORTED_CIPHER: sie,
    SUPPORTED_COMPRESSION: oie,
    SUPPORTED_KEX: cie,
    SUPPORTED_MAC: lie,
    SUPPORTED_SERVER_HOST_KEY: uie,
  } = es(),
  { init: fie } = eo(),
  { KexInit: die } = i1(),
  { parseKey: IS } = to,
  pie = kk,
  { SFTP: hie } = Zp,
  { writeUInt32BE: mie } = Ki(),
  {
    Channel: Eo,
    MAX_WINDOW: Ra,
    PACKET_SIZE: ka,
    windowAdjust: gie,
    WINDOW_THRESHOLD: vie,
  } = qk,
  {
    ChannelManager: yie,
    generateAlgorithmList: el,
    isWritable: Pf,
    onChannelOpenFailure: bie,
    onCHANNEL_CLOSE: _ie,
  } = Wk,
  Eie = 10;
class fc extends $u {
  constructor(t, n, r, i, a) {
    super(),
      (this.username = this.user = n),
      (this.service = r),
      (this.method = i),
      (this._initialResponse = !1),
      (this._finalResponse = !1),
      (this._multistep = !1),
      (this._cbfinal = (s, o, c) => {
        this._finalResponse || ((this._finalResponse = !0), a(this, s, o, c));
      }),
      (this._protocol = t);
  }
  accept() {
    this._cleanup && this._cleanup(),
      (this._initialResponse = !0),
      this._cbfinal(!0);
  }
  reject(t, n) {
    this._cleanup && this._cleanup(),
      (this._initialResponse = !0),
      this._cbfinal(!1, t, n);
  }
}
class $S extends fc {
  constructor(t, n, r, i, a, s) {
    super(t, n, r, i, s),
      (this._multistep = !0),
      (this._cb = void 0),
      (this._onInfoResponse = (o) => {
        const c = this._cb;
        c && ((this._cb = void 0), c(o));
      }),
      (this.submethods = a),
      this.on("abort", () => {
        this._cb && this._cb(new Error("Authentication request aborted"));
      });
  }
  prompt(t, n, r, i) {
    Array.isArray(t) || (t = [t]),
      typeof n == "function"
        ? ((i = n), (n = r = void 0))
        : typeof r == "function"
        ? ((i = r), (r = void 0))
        : typeof i != "function" && (i = void 0);
    for (let a = 0; a < t.length; ++a)
      typeof t[a] == "string" && (t[a] = { prompt: t[a], echo: !0 });
    (this._cb = i),
      (this._initialResponse = !0),
      this._protocol.authInfoReq(n, r, t);
  }
}
class wie extends fc {
  constructor(t, n, r, i, a, s) {
    super(t, n, r, i, s),
      (this.key = { algo: a.keyAlgo, data: a.key }),
      (this.hashAlgo = a.hashAlgo),
      (this.signature = a.signature),
      (this.blob = a.blob);
  }
  accept() {
    this.signature
      ? fc.prototype.accept.call(this)
      : ((this._initialResponse = !0),
        this._protocol.authPKOK(this.key.algo, this.key.data));
  }
}
class xie extends fc {
  constructor(t, n, r, i, a, s) {
    super(t, n, r, i, s),
      (this.key = { algo: a.keyAlgo, data: a.key }),
      (this.hashAlgo = a.hashAlgo),
      (this.signature = a.signature),
      (this.blob = a.blob),
      (this.localHostname = a.localHostname),
      (this.localUsername = a.localUsername);
  }
}
class CS extends fc {
  constructor(t, n, r, i, a, s) {
    super(t, n, r, i, s), (this.password = a), (this._changeCb = void 0);
  }
  requestChange(t, n) {
    if (this._changeCb) throw new Error("Change request already in progress");
    if (typeof t != "string")
      throw new Error("prompt argument must be a string");
    if (typeof n != "function")
      throw new Error("Callback argument must be a function");
    (this._changeCb = n), this._protocol.authPasswdChg(t);
  }
}
class Sa extends $u {
  constructor(t, n, r) {
    super(),
      (this.type = "session"),
      (this.subtype = void 0),
      (this.server = !0),
      (this._ending = !1),
      (this._channel = void 0),
      (this._chanInfo = {
        type: "session",
        incoming: { id: r, window: Ra, packetSize: ka, state: "open" },
        outgoing: {
          id: n.sender,
          window: n.window,
          packetSize: n.packetSize,
          state: "open",
        },
      });
  }
}
class fi extends $u {
  constructor(t, n) {
    if ((super(), typeof t != "object" || t === null))
      throw new Error("Missing configuration object");
    const r = Object.create(null),
      i = [],
      a = t.hostKeys;
    if (!Array.isArray(a)) throw new Error("hostKeys must be an array");
    const s =
        typeof t.algorithms == "object" && t.algorithms !== null
          ? t.algorithms
          : {},
      o = el(s.serverHostKey, iie, uie);
    for (let d = 0; d < a.length; ++d) {
      let p;
      if (
        (Buffer.isBuffer(a[d]) || typeof a[d] == "string"
          ? (p = IS(a[d]))
          : (p = IS(a[d].key, a[d].passphrase)),
        p instanceof Error)
      )
        throw new Error(`Cannot parse privateKey: ${p.message}`);
      if ((Array.isArray(p) && (p = p[0]), p.getPrivatePEM() === null))
        throw new Error("privateKey value contains an invalid private key");
      if (!i.includes(p.type))
        if (p.type === "ssh-rsa") {
          let h = o.indexOf("ssh-rsa");
          const m = o.indexOf("rsa-sha2-256"),
            g = o.indexOf("rsa-sha2-512");
          h === -1 && (h = 1 / 0),
            [h, m, g].sort(Aie).forEach((v) => {
              if (v === -1) return;
              let y;
              switch (v) {
                case h:
                  y = "ssh-rsa";
                  break;
                case m:
                  y = "rsa-sha2-256";
                  break;
                case g:
                  y = "rsa-sha2-512";
                  break;
                default:
                  return;
              }
              (r[y] = p), i.push(y);
            });
        } else (r[p.type] = p), i.push(p.type);
    }
    const c = {
      kex: el(s.kex, nie, cie),
      serverHostKey: i,
      cs: {
        cipher: el(s.cipher, eie, sie),
        mac: el(s.hmac, rie, lie),
        compress: el(s.compress, tie, oie),
        lang: [],
      },
      sc: void 0,
    };
    (c.sc = c.cs), typeof n == "function" && this.on("connection", n);
    const l = typeof t.debug == "function" ? t.debug : void 0,
      f = t.ident ? Buffer.from(t.ident) : void 0,
      u = new die(c);
    (this._srv = new Zre((d) => {
      if (this._connections >= this.maxConnections) {
        d.destroy();
        return;
      }
      ++this._connections,
        d.once("close", () => {
          --this._connections;
        });
      let p;
      if (l) {
        const h = `[${process.hrtime().join(".")}] `;
        p = (m) => {
          l(`${h}${m}`);
        };
      }
      new Xk(d, r, f, u, p, this, t);
    })
      .on("error", (d) => {
        this.emit("error", d);
      })
      .on("listening", () => {
        this.emit("listening");
      })
      .on("close", () => {
        this.emit("close");
      })),
      (this._connections = 0),
      (this.maxConnections = 1 / 0);
  }
  injectSocket(t) {
    this._srv.emit("connection", t);
  }
  listen(...t) {
    return this._srv.listen(...t), this;
  }
  address() {
    return this._srv.address();
  }
  getConnections(t) {
    return this._srv.getConnections(t), this;
  }
  close(t) {
    return this._srv.close(t), this;
  }
  ref() {
    return this._srv.ref(), this;
  }
  unref() {
    return this._srv.unref(), this;
  }
}
fi.KEEPALIVE_CLIENT_INTERVAL = 15e3;
fi.KEEPALIVE_CLIENT_COUNT_MAX = 3;
class Xk extends $u {
  constructor(t, n, r, i, a, s, o) {
    super();
    let c = 0,
      l = !1,
      f = [],
      u,
      d,
      p;
    const h = [];
    (this._sock = t),
      (this._chanMgr = new yie(this)),
      (this._debug = a),
      (this.noMoreSessions = !1),
      (this.authenticated = !1);
    function m(I) {}
    this.on("error", m);
    const g = a
        ? (I, S, w) => {
            a(`Debug output from client: ${JSON.stringify(w)}`);
          }
        : void 0,
      v =
        typeof o.keepaliveInterval == "number" &&
        isFinite(o.keepaliveInterval) &&
        o.keepaliveInterval > 0
          ? o.keepaliveInterval
          : typeof fi.KEEPALIVE_CLIENT_INTERVAL == "number" &&
            isFinite(fi.KEEPALIVE_CLIENT_INTERVAL) &&
            fi.KEEPALIVE_CLIENT_INTERVAL > 0
          ? fi.KEEPALIVE_CLIENT_INTERVAL
          : -1,
      y =
        typeof o.keepaliveCountMax == "number" &&
        isFinite(o.keepaliveCountMax) &&
        o.keepaliveCountMax >= 0
          ? o.keepaliveCountMax
          : typeof fi.KEEPALIVE_CLIENT_COUNT_MAX == "number" &&
            isFinite(fi.KEEPALIVE_CLIENT_COUNT_MAX) &&
            fi.KEEPALIVE_CLIENT_COUNT_MAX >= 0
          ? fi.KEEPALIVE_CLIENT_COUNT_MAX
          : -1;
    let _ = 0;
    v !== -1 &&
      y !== -1 &&
      (this.once("ready", () => {
        const I = () => {
          clearInterval(d);
        };
        this.on("close", I).on("end", I),
          (d = setInterval(() => {
            if (++_ > y) {
              clearInterval(d);
              const S = new Error("Keepalive timeout");
              (S.level = "client-timeout"), this.emit("error", S), this.end();
            } else E.ping();
          }, v));
      }),
      (p = () => {
        d && d.refresh(), (_ = 0);
      }));
    const E = (this._protocol = new pie({
      server: !0,
      hostKeys: n,
      ident: r,
      offer: i,
      onPacket: p,
      greeting: o.greeting,
      banner: o.banner,
      onWrite: (I) => {
        Pf(t) && t.write(I);
      },
      onError: (I) => {
        E._destruct || t.removeAllListeners("data"), this.emit("error", I);
        try {
          t.end();
        } catch {}
      },
      onHeader: (I) => {
        this.removeListener("error", m);
        const S = {
          ip: t.remoteAddress,
          family: t.remoteFamily,
          port: t.remotePort,
          header: I,
        };
        if (!s.emit("connection", this, S)) {
          E.disconnect(_o.BY_APPLICATION), t.end();
          return;
        }
        I.greeting && this.emit("greeting", I.greeting);
      },
      onHandshakeComplete: (I) => {
        ++c > 1 && this.emit("rekey"), this.emit("handshake", I);
      },
      debug: a,
      messageHandlers: {
        DEBUG: g,
        DISCONNECT: (I, S, w) => {
          if (S !== _o.BY_APPLICATION) {
            w ||
              ((w = aie[S]),
              w === void 0 && (w = `Unexpected disconnection reason: ${S}`));
            const O = new Error(w);
            (O.code = S), this.emit("error", O);
          }
          t.end();
        },
        CHANNEL_OPEN: (I, S) => {
          if (
            (S.type === "session" && this.noMoreSessions) ||
            !this.authenticated
          ) {
            const Z = bo.ADMINISTRATIVELY_PROHIBITED;
            return E.channelOpenFail(S.sender, Z);
          }
          let w = -1,
            O,
            Q = !1,
            j;
          const H = () => {
              Q ||
                ((Q = !0),
                O === void 0 &&
                  (w === -1
                    ? (O = bo.RESOURCE_SHORTAGE)
                    : (O = bo.CONNECT_FAILED)),
                w !== -1 && this._chanMgr.remove(w),
                E.channelOpenFail(S.sender, O, ""));
            },
            q = () => (
              (w = this._chanMgr.add()),
              w === -1 &&
                ((O = bo.RESOURCE_SHORTAGE),
                a &&
                  a(
                    "Automatic rejection of incoming channel open: no channels available",
                  )),
              w !== -1
            ),
            J = S.data;
          switch (S.type) {
            case "session":
              if (lr(this, "session") && q()) {
                (j = () => {
                  if (Q) return;
                  Q = !0;
                  const Z = new Sa(this, S, w);
                  return (
                    this._chanMgr.update(w, Z),
                    E.channelOpenConfirm(S.sender, w, Ra, ka),
                    Z
                  );
                }),
                  this.emit("session", j, H);
                return;
              }
              break;
            case "direct-tcpip":
              if (lr(this, "tcpip") && q()) {
                (j = () => {
                  if (Q) return;
                  Q = !0;
                  const Z = {
                      type: void 0,
                      incoming: {
                        id: w,
                        window: Ra,
                        packetSize: ka,
                        state: "open",
                      },
                      outgoing: {
                        id: S.sender,
                        window: S.window,
                        packetSize: S.packetSize,
                        state: "open",
                      },
                    },
                    z = new Eo(this, Z, { server: !0 });
                  return (
                    this._chanMgr.update(w, z),
                    E.channelOpenConfirm(S.sender, w, Ra, ka),
                    z
                  );
                }),
                  this.emit("tcpip", j, H, J);
                return;
              }
              break;
            case "direct-streamlocal@openssh.com":
              if (lr(this, "openssh.streamlocal") && q()) {
                (j = () => {
                  if (Q) return;
                  Q = !0;
                  const Z = {
                      type: void 0,
                      incoming: {
                        id: w,
                        window: Ra,
                        packetSize: ka,
                        state: "open",
                      },
                      outgoing: {
                        id: S.sender,
                        window: S.window,
                        packetSize: S.packetSize,
                        state: "open",
                      },
                    },
                    z = new Eo(this, Z, { server: !0 });
                  return (
                    this._chanMgr.update(w, z),
                    E.channelOpenConfirm(S.sender, w, Ra, ka),
                    z
                  );
                }),
                  this.emit("openssh.streamlocal", j, H, J);
                return;
              }
              break;
            default:
              (O = bo.UNKNOWN_CHANNEL_TYPE),
                a &&
                  a(
                    `Automatic rejection of unsupported incoming channel open type: ${S.type}`,
                  );
          }
          O === void 0 &&
            ((O = bo.ADMINISTRATIVELY_PROHIBITED),
            a &&
              a(
                `Automatic rejection of unexpected incoming channel open for: ${S.type}`,
              )),
            H();
        },
        CHANNEL_OPEN_CONFIRMATION: (I, S) => {
          const w = this._chanMgr.get(S.recipient);
          if (typeof w != "function") return;
          const O = {
              type: w.type,
              incoming: {
                id: S.recipient,
                window: Ra,
                packetSize: ka,
                state: "open",
              },
              outgoing: {
                id: S.sender,
                window: S.window,
                packetSize: S.packetSize,
                state: "open",
              },
            },
            Q = new Eo(this, O, { server: !0 });
          this._chanMgr.update(S.recipient, Q), w(void 0, Q);
        },
        CHANNEL_OPEN_FAILURE: (I, S, w, O) => {
          const Q = this._chanMgr.get(S);
          if (typeof Q != "function") return;
          bie(this, S, { reason: w, description: O }, Q);
        },
        CHANNEL_DATA: (I, S, w) => {
          let O = this._chanMgr.get(S);
          if (
            !(typeof O != "object" || O === null) &&
            !(O.constructor === Sa && ((O = O._channel), !O)) &&
            O.incoming.window !== 0
          ) {
            if (((O.incoming.window -= w.length), O.push(w) === !1)) {
              O._waitChanDrain = !0;
              return;
            }
            O.incoming.window <= vie && gie(O);
          }
        },
        CHANNEL_EXTENDED_DATA: (I, S, w, O) => {},
        CHANNEL_WINDOW_ADJUST: (I, S, w) => {
          let O = this._chanMgr.get(S);
          typeof O != "object" ||
            O === null ||
            (O.constructor === Sa && ((O = O._channel), !O)) ||
            ((O.outgoing.window += w),
            O._waitWindow &&
              ((O._waitWindow = !1),
              O._chunk
                ? O._write(O._chunk, null, O._chunkcb)
                : O._chunkcb
                ? O._chunkcb()
                : O._chunkErr
                ? O.stderr._write(O._chunkErr, null, O._chunkcbErr)
                : O._chunkcbErr && O._chunkcbErr()));
        },
        CHANNEL_SUCCESS: (I, S) => {
          let w = this._chanMgr.get(S);
          typeof w != "object" ||
            w === null ||
            (w.constructor === Sa && ((w = w._channel), !w)) ||
            (w._callbacks.length && w._callbacks.shift()(!1));
        },
        CHANNEL_FAILURE: (I, S) => {
          let w = this._chanMgr.get(S);
          typeof w != "object" ||
            w === null ||
            (w.constructor === Sa && ((w = w._channel), !w)) ||
            (w._callbacks.length && w._callbacks.shift()(!0));
        },
        CHANNEL_REQUEST: (I, S, w, O, Q) => {
          const j = this._chanMgr.get(S);
          if (typeof j != "object" || j === null) return;
          let H = !1,
            q,
            J;
          if (j.constructor !== Sa) {
            O && E.channelFailure(j.outgoing.id);
            return;
          }
          if (
            (O &&
              (w !== "shell" &&
                w !== "exec" &&
                w !== "subsystem" &&
                (q = () => {
                  H ||
                    j._ending ||
                    j._channel ||
                    ((H = !0), E.channelSuccess(j._chanInfo.outgoing.id));
                }),
              (J = () => {
                H ||
                  j._ending ||
                  j._channel ||
                  ((H = !0), E.channelFailure(j._chanInfo.outgoing.id));
              })),
            j._ending)
          ) {
            J && J();
            return;
          }
          switch (w) {
            case "env":
              if (lr(j, "env")) {
                j.emit("env", q, J, { key: Q.name, val: Q.value });
                return;
              }
              break;
            case "pty-req":
              if (lr(j, "pty")) {
                j.emit("pty", q, J, Q);
                return;
              }
              break;
            case "window-change":
              lr(j, "window-change")
                ? j.emit("window-change", q, J, Q)
                : J && J();
              break;
            case "x11-req":
              if (lr(j, "x11")) {
                j.emit("x11", q, J, Q);
                return;
              }
              break;
            case "signal":
              if (lr(j, "signal")) {
                j.emit("signal", q, J, { name: Q });
                return;
              }
              break;
            case "auth-agent-req@openssh.com":
              if (lr(j, "auth-agent")) {
                j.emit("auth-agent", q, J);
                return;
              }
              break;
            case "shell":
              if (lr(j, "shell")) {
                (q = () => {
                  if (H || j._ending || j._channel) return;
                  (H = !0), O && E.channelSuccess(j._chanInfo.outgoing.id);
                  const Z = new Eo(this, j._chanInfo, { server: !0 });
                  return (Z.subtype = j.subtype = w), (j._channel = Z), Z;
                }),
                  j.emit("shell", q, J);
                return;
              }
              break;
            case "exec":
              if (lr(j, "exec")) {
                (q = () => {
                  if (H || j._ending || j._channel) return;
                  (H = !0), O && E.channelSuccess(j._chanInfo.outgoing.id);
                  const Z = new Eo(this, j._chanInfo, { server: !0 });
                  return (Z.subtype = j.subtype = w), (j._channel = Z), Z;
                }),
                  j.emit("exec", q, J, { command: Q });
                return;
              }
              break;
            case "subsystem": {
              let Z = Q === "sftp";
              if (
                ((q = () => {
                  if (H || j._ending || j._channel) return;
                  (H = !0), O && E.channelSuccess(j._chanInfo.outgoing.id);
                  let z;
                  return (
                    Z
                      ? (z = new hie(this, j._chanInfo, {
                          server: !0,
                          debug: a,
                        }))
                      : ((z = new Eo(this, j._chanInfo, { server: !0 })),
                        (z.subtype = j.subtype = `${w}:${Q}`)),
                    (j._channel = z),
                    z
                  );
                }),
                Q === "sftp")
              ) {
                if (lr(j, "sftp")) {
                  j.emit("sftp", q, J);
                  return;
                }
                Z = !1;
              }
              if (lr(j, "subsystem")) {
                j.emit("subsystem", q, J, { name: Q });
                return;
              }
              break;
            }
          }
          a && a(`Automatic rejection of incoming channel request: ${w}`),
            J && J();
        },
        CHANNEL_EOF: (I, S) => {
          let w = this._chanMgr.get(S);
          typeof w != "object" ||
            w === null ||
            (w.constructor === Sa &&
              (w._ending || ((w._ending = !0), w.emit("eof"), w.emit("end")),
              (w = w._channel),
              !w)) ||
            (w.incoming.state === "open" &&
              ((w.incoming.state = "eof"), w.readable && w.push(null)));
        },
        CHANNEL_CLOSE: (I, S) => {
          let w = this._chanMgr.get(S);
          typeof w != "object" ||
            w === null ||
            (w.constructor === Sa &&
              ((w._ending = !0), w.emit("close"), (w = w._channel), !w)) ||
            _ie(this, S, w);
        },
        SERVICE_REQUEST: (I, S) => {
          if (c === 0 || l || this.authenticated || S !== "ssh-userauth") {
            E.disconnect(_o.SERVICE_NOT_AVAILABLE), t.end();
            return;
          }
          (l = !0), E.serviceAccept(S);
        },
        USERAUTH_REQUEST: (I, S, w, O, Q) => {
          if (
            c === 0 ||
            this.authenticated ||
            (u && (u.username !== S || u.service !== w)) ||
            (O !== "password" &&
              O !== "publickey" &&
              O !== "hostbased" &&
              O !== "keyboard-interactive" &&
              O !== "none") ||
            f.length === Eie
          ) {
            E.disconnect(_o.PROTOCOL_ERROR), t.end();
            return;
          } else if (w !== "ssh-connection") {
            E.disconnect(_o.SERVICE_NOT_AVAILABLE), t.end();
            return;
          }
          let j;
          switch (O) {
            case "keyboard-interactive":
              j = new $S(E, S, w, O, Q, R);
              break;
            case "publickey":
              j = new wie(E, S, w, O, Q, R);
              break;
            case "hostbased":
              j = new xie(E, S, w, O, Q, R);
              break;
            case "password":
              if (u && u instanceof CS && u._changeCb) {
                const H = u._changeCb;
                (u._changeCb = void 0), H(Q.newPassword);
                return;
              }
              j = new CS(E, S, w, O, Q, R);
              break;
            case "none":
              j = new fc(E, S, w, O, R);
              break;
          }
          if (u)
            if (u._initialResponse)
              u._multistep &&
                !u._finalResponse &&
                (u._cleanup && u._cleanup(), u.emit("abort"));
            else return f.push(j);
          (u = j),
            lr(this, "authentication")
              ? this.emit("authentication", u)
              : u.reject();
        },
        USERAUTH_INFO_RESPONSE: (I, S) => {
          u && u instanceof $S && u._onInfoResponse(S);
        },
        GLOBAL_REQUEST: (I, S, w, O) => {
          const Q = { type: null, buf: null };
          function j(H, q) {
            (Q.type = H), (Q.buf = q), A();
          }
          if (
            (w && h.push(Q),
            (S === "tcpip-forward" ||
              S === "cancel-tcpip-forward" ||
              S === "no-more-sessions@openssh.com" ||
              S === "streamlocal-forward@openssh.com" ||
              S === "cancel-streamlocal-forward@openssh.com") &&
              lr(this, "request") &&
              this.authenticated)
          ) {
            let H, q;
            if (w) {
              let J = !1;
              (H = (Z) => {
                if (J) return;
                J = !0;
                let z;
                S === "tcpip-forward" &&
                  O.bindPort === 0 &&
                  typeof Z == "number" &&
                  ((z = Buffer.allocUnsafe(4)), mie(z, Z, 0)),
                  j("SUCCESS", z);
              }),
                (q = () => {
                  J || ((J = !0), j("FAILURE"));
                });
            }
            if (S === "no-more-sessions@openssh.com") {
              (this.noMoreSessions = !0), H && H();
              return;
            }
            this.emit("request", H, q, S, O);
          } else w && j("FAILURE");
        },
      },
    }));
    t.pause(),
      fie
        .then(() => {
          E.start(),
            t.on("data", (I) => {
              try {
                E.parse(I, 0, I.length);
              } catch (S) {
                this.emit("error", S);
                try {
                  Pf(t) && t.end();
                } catch {}
              }
            }),
            t.resume();
        })
        .catch((I) => {
          this.emit("error", I);
          try {
            Pf(t) && t.end();
          } catch {}
        }),
      t
        .on("error", (I) => {
          (I.level = "socket"), this.emit("error", I);
        })
        .once("end", () => {
          a && a("Socket ended"), E.cleanup(), this.emit("end");
        })
        .once("close", () => {
          a && a("Socket closed"), E.cleanup(), this.emit("close");
          const I = new Error("No response from server");
          this._chanMgr.cleanup(I);
        });
    const R = (I, S, w, O) => {
      u === I &&
        !this.authenticated &&
        (S
          ? ((u = void 0),
            (this.authenticated = !0),
            E.authSuccess(),
            (f = []),
            this.emit("ready"))
          : (E.authFailure(w, O),
            f.length &&
              ((u = f.pop()),
              lr(this, "authentication")
                ? this.emit("authentication", u)
                : u.reject())));
    };
    function A() {
      for (; h.length > 0 && h[0].type; ) {
        const I = h.shift();
        I.type === "SUCCESS" && E.requestSuccess(I.buf),
          I.type === "FAILURE" && E.requestFailure();
      }
    }
  }
  end() {
    return (
      this._sock &&
        Pf(this._sock) &&
        (this._protocol.disconnect(_o.BY_APPLICATION), this._sock.end()),
      this
    );
  }
  x11(t, n, r) {
    return og(this, "x11", { originAddr: t, originPort: n }, r), this;
  }
  forwardOut(t, n, r, i, a) {
    return (
      og(
        this,
        "forwarded-tcpip",
        { boundAddr: t, boundPort: n, remoteAddr: r, remotePort: i },
        a,
      ),
      this
    );
  }
  openssh_forwardOutStreamLocal(t, n) {
    return (
      og(this, "forwarded-streamlocal@openssh.com", { socketPath: t }, n), this
    );
  }
  rekey(t) {
    let n;
    try {
      this._protocol.rekey();
    } catch (r) {
      n = r;
    }
    typeof t == "function" &&
      (n ? process.nextTick(t, n) : this.once("rekey", t));
  }
  setNoDelay(t) {
    return (
      this._sock &&
        typeof this._sock.setNoDelay == "function" &&
        this._sock.setNoDelay(t),
      this
    );
  }
}
function og(e, t, n, r) {
  const i = Ra,
    a = ka;
  typeof n == "function" && ((r = n), (n = {}));
  const s = (c, l) => {
    r(c, l);
  };
  s.type = t;
  const o = e._chanMgr.add(s);
  if (o === -1) {
    r(new Error("No free channels available"));
    return;
  }
  switch (t) {
    case "forwarded-tcpip":
      e._protocol.forwardedTcpip(o, i, a, n);
      break;
    case "x11":
      e._protocol.x11(o, i, a, n);
      break;
    case "forwarded-streamlocal@openssh.com":
      e._protocol.openssh_forwardedStreamLocal(o, i, a, n);
      break;
    default:
      throw new Error(`Unsupported channel type: ${t}`);
  }
}
function Aie(e, t) {
  return e - t;
}
l1.exports = fi;
l1.exports.IncomingClient = Xk;
var Sie = l1.exports;
const {
    createCipheriv: Iie,
    generateKeyPair: $ie,
    generateKeyPairSync: Cie,
    getCurves: Rie,
    randomBytes: RS,
  } = pr,
  { Ber: vn } = Yp,
  kie = rk.pbkdf,
  { CIPHER_INFO: Tie } = eo(),
  Nie = 16,
  Oie = 16,
  Pie = Rie(),
  Die = new Map(Object.entries(Tie));
function kS(e, t) {
  if (typeof e != "string") throw new TypeError("Key type must be a string");
  const n = { type: "spki", format: "der" },
    r = { type: "pkcs8", format: "der" };
  switch (e.toLowerCase()) {
    case "rsa": {
      if (typeof t != "object" || t === null)
        throw new TypeError("Missing options object for RSA key");
      const i = t.bits;
      if (!Number.isInteger(i))
        throw new TypeError("RSA bits must be an integer");
      if (i <= 0 || i > 16384)
        throw new RangeError("RSA bits must be non-zero and <= 16384");
      return [
        "rsa",
        { modulusLength: i, publicKeyEncoding: n, privateKeyEncoding: r },
      ];
    }
    case "ecdsa": {
      if (typeof t != "object" || t === null)
        throw new TypeError("Missing options object for ECDSA key");
      if (!Number.isInteger(t.bits))
        throw new TypeError("ECDSA bits must be an integer");
      let i;
      switch (t.bits) {
        case 256:
          i = "prime256v1";
          break;
        case 384:
          i = "secp384r1";
          break;
        case 521:
          i = "secp521r1";
          break;
        default:
          throw new Error("ECDSA bits must be 256, 384, or 521");
      }
      if (!Pie.includes(i)) throw new Error("Unsupported ECDSA bits value");
      return [
        "ec",
        { namedCurve: i, publicKeyEncoding: n, privateKeyEncoding: r },
      ];
    }
    case "ed25519":
      return ["ed25519", { publicKeyEncoding: n, privateKeyEncoding: r }];
    default:
      throw new Error(`Unsupported key type: ${e}`);
  }
}
function Lie(e, t, n) {
  switch (e) {
    case "rsa": {
      let r = new vn.Reader(n);
      if ((r.readSequence(), r.readInt() !== 0))
        throw new Error("Unsupported version in RSA private key");
      if ((r.readSequence(), r.readOID() !== "1.2.840.113549.1.1.1"))
        throw new Error("Bad RSA private OID");
      if (r.readByte() !== vn.Null)
        throw new Error("Malformed RSA private key (expected null)");
      if (r.readByte() !== 0)
        throw new Error(
          "Malformed RSA private key (expected zero-length null)",
        );
      if (
        ((r = new vn.Reader(r.readString(vn.OctetString, !0))),
        r.readSequence(),
        r.readInt() !== 0)
      )
        throw new Error("Unsupported version in RSA private key");
      const i = r.readString(vn.Integer, !0),
        a = r.readString(vn.Integer, !0),
        s = r.readString(vn.Integer, !0),
        o = r.readString(vn.Integer, !0),
        c = r.readString(vn.Integer, !0);
      r.readString(vn.Integer, !0), r.readString(vn.Integer, !0);
      const l = r.readString(vn.Integer, !0),
        f = Buffer.from("ssh-rsa"),
        u = Buffer.allocUnsafe(
          4 +
            f.length +
            4 +
            i.length +
            4 +
            a.length +
            4 +
            s.length +
            4 +
            l.length +
            4 +
            o.length +
            4 +
            c.length,
        );
      let d = 0;
      u.writeUInt32BE(f.length, (d += 0)),
        u.set(f, (d += 4)),
        u.writeUInt32BE(i.length, (d += f.length)),
        u.set(i, (d += 4)),
        u.writeUInt32BE(a.length, (d += i.length)),
        u.set(a, (d += 4)),
        u.writeUInt32BE(s.length, (d += a.length)),
        u.set(s, (d += 4)),
        u.writeUInt32BE(l.length, (d += s.length)),
        u.set(l, (d += 4)),
        u.writeUInt32BE(o.length, (d += l.length)),
        u.set(o, (d += 4)),
        u.writeUInt32BE(c.length, (d += o.length)),
        u.set(c, (d += 4));
      const p = Buffer.allocUnsafe(4 + f.length + 4 + a.length + 4 + i.length);
      return (
        (d = 0),
        p.writeUInt32BE(f.length, (d += 0)),
        p.set(f, (d += 4)),
        p.writeUInt32BE(a.length, (d += f.length)),
        p.set(a, (d += 4)),
        p.writeUInt32BE(i.length, (d += a.length)),
        p.set(i, (d += 4)),
        { sshName: f.toString(), priv: u, pub: p }
      );
    }
    case "ec": {
      let r = new vn.Reader(t);
      if (
        (r.readSequence(),
        r.readSequence(),
        r.readOID() !== "1.2.840.10045.2.1")
      )
        throw new Error("Bad ECDSA public OID");
      r.readOID();
      let i = r.readString(vn.BitString, !0);
      {
        let d = 0;
        for (; d < i.length && i[d] === 0; ++d);
        d > 0 && (i = i.slice(d));
      }
      if (((r = new vn.Reader(n)), r.readSequence(), r.readInt() !== 0))
        throw new Error("Unsupported version in ECDSA private key");
      if ((r.readSequence(), r.readOID() !== "1.2.840.10045.2.1"))
        throw new Error("Bad ECDSA private OID");
      const a = r.readOID();
      let s;
      switch (a) {
        case "1.2.840.10045.3.1.7":
          s = "nistp256";
          break;
        case "1.3.132.0.34":
          s = "nistp384";
          break;
        case "1.3.132.0.35":
          s = "nistp521";
          break;
        default:
          throw new Error("Unsupported curve in ECDSA private key");
      }
      if (
        ((r = new vn.Reader(r.readString(vn.OctetString, !0))),
        r.readSequence(),
        r.readInt() !== 1)
      )
        throw new Error("Unsupported version in ECDSA private key");
      const o = Buffer.concat([
          Buffer.from([0]),
          r.readString(vn.OctetString, !0),
        ]),
        c = Buffer.from(`ecdsa-sha2-${s}`);
      s = Buffer.from(s);
      const l = Buffer.allocUnsafe(
        4 + c.length + 4 + s.length + 4 + i.length + 4 + o.length,
      );
      let f = 0;
      l.writeUInt32BE(c.length, (f += 0)),
        l.set(c, (f += 4)),
        l.writeUInt32BE(s.length, (f += c.length)),
        l.set(s, (f += 4)),
        l.writeUInt32BE(i.length, (f += s.length)),
        l.set(i, (f += 4)),
        l.writeUInt32BE(o.length, (f += i.length)),
        l.set(o, (f += 4));
      const u = Buffer.allocUnsafe(4 + c.length + 4 + s.length + 4 + i.length);
      return (
        (f = 0),
        u.writeUInt32BE(c.length, (f += 0)),
        u.set(c, (f += 4)),
        u.writeUInt32BE(s.length, (f += c.length)),
        u.set(s, (f += 4)),
        u.writeUInt32BE(i.length, (f += s.length)),
        u.set(i, (f += 4)),
        { sshName: c.toString(), priv: l, pub: u }
      );
    }
    case "ed25519": {
      let r = new vn.Reader(t);
      if ((r.readSequence(), r.readSequence(), r.readOID() !== "1.3.101.112"))
        throw new Error("Bad ED25519 public OID");
      let i = r.readString(vn.BitString, !0);
      {
        let f = 0;
        for (; f < i.length && i[f] === 0; ++f);
        f > 0 && (i = i.slice(f));
      }
      if (((r = new vn.Reader(n)), r.readSequence(), r.readInt() !== 0))
        throw new Error("Unsupported version in ED25519 private key");
      if ((r.readSequence(), r.readOID() !== "1.3.101.112"))
        throw new Error("Bad ED25519 private OID");
      r = new vn.Reader(r.readString(vn.OctetString, !0));
      const a = r.readString(vn.OctetString, !0),
        s = Buffer.from("ssh-ed25519"),
        o = Buffer.allocUnsafe(
          4 + s.length + 4 + i.length + 4 + (a.length + i.length),
        );
      let c = 0;
      o.writeUInt32BE(s.length, (c += 0)),
        o.set(s, (c += 4)),
        o.writeUInt32BE(i.length, (c += s.length)),
        o.set(i, (c += 4)),
        o.writeUInt32BE(a.length + i.length, (c += i.length)),
        o.set(a, (c += 4)),
        o.set(i, (c += a.length));
      const l = Buffer.allocUnsafe(4 + s.length + 4 + i.length);
      return (
        (c = 0),
        l.writeUInt32BE(s.length, (c += 0)),
        l.set(s, (c += 4)),
        l.writeUInt32BE(i.length, (c += s.length)),
        l.set(i, (c += 4)),
        { sshName: s.toString(), priv: o, pub: l }
      );
    }
  }
}
function TS(e, t, n, r) {
  let i = "new",
    a,
    s = "";
  if (
    typeof r == "object" &&
    r !== null &&
    (typeof r.comment == "string" && r.comment && (s = r.comment),
    typeof r.format == "string" && r.format && (i = r.format),
    r.passphrase)
  ) {
    let o;
    if (typeof r.passphrase == "string") o = Buffer.from(r.passphrase);
    else if (Buffer.isBuffer(r.passphrase)) o = r.passphrase;
    else throw new Error("Invalid passphrase");
    if (r.cipher === void 0) throw new Error("Missing cipher name");
    const c = Die.get(r.cipher);
    if (c === void 0) throw new Error("Invalid cipher name");
    if (i === "new") {
      let l = Oie;
      if (r.rounds !== void 0) {
        if (!Number.isInteger(r.rounds))
          throw new TypeError("rounds must be an integer");
        r.rounds > 0 && (l = r.rounds);
      }
      const f = Buffer.allocUnsafe(c.keyLen + c.ivLen),
        u = RS(Nie);
      if (kie(o, o.length, u, u.length, f, f.length, l) !== 0)
        return new Error("Failed to generate information to encrypt key");
      const p = Buffer.allocUnsafe(4 + u.length + 4);
      {
        let h = 0;
        p.writeUInt32BE(u.length, (h += 0)),
          p.set(u, (h += 4)),
          p.writeUInt32BE(l, (h += u.length));
      }
      a = {
        cipher: c,
        cipherName: r.cipher,
        kdfName: "bcrypt",
        kdfOptions: p,
        key: f.slice(0, c.keyLen),
        iv: f.slice(c.keyLen),
      };
    }
  }
  switch (i) {
    case "new": {
      let o = `-----BEGIN OPENSSH PRIVATE KEY-----
`,
        c;
      const l = Buffer.from(a ? a.cipherName : "none"),
        f = Buffer.from(a ? a.kdfName : "none"),
        u = a ? a.kdfOptions : Buffer.alloc(0),
        d = a ? a.cipher.blockLen : 8,
        p = Lie(e, t, n),
        h = RS(4),
        m = Buffer.from(s),
        g = 4 + 4 + p.priv.length + 4 + m.length;
      let v = [];
      for (let A = 1; (g + v.length) % d; ++A) v.push(A & 255);
      v = Buffer.from(v);
      let y = Buffer.allocUnsafe(g + v.length),
        _;
      {
        let A = 0;
        y.set(h, (A += 0)),
          y.set(h, (A += 4)),
          y.set(p.priv, (A += 4)),
          y.writeUInt32BE(m.length, (A += p.priv.length)),
          y.set(m, (A += 4)),
          y.set(v, (A += m.length));
      }
      if (a) {
        const A = { authTagLength: a.cipher.authLen },
          I = Iie(a.cipher.sslName, a.key, a.iv, A);
        I.setAutoPadding(!1),
          (y = Buffer.concat([I.update(y), I.final()])),
          a.cipher.authLen > 0 ? (_ = I.getAuthTag()) : (_ = Buffer.alloc(0)),
          a.key.fill(0),
          a.iv.fill(0);
      } else _ = Buffer.alloc(0);
      const E = Buffer.from("openssh-key-v1\0"),
        R = Buffer.allocUnsafe(
          E.length +
            4 +
            l.length +
            4 +
            f.length +
            4 +
            u.length +
            4 +
            4 +
            p.pub.length +
            4 +
            y.length +
            _.length,
        );
      {
        let A = 0;
        R.set(E, (A += 0)),
          R.writeUInt32BE(l.length, (A += E.length)),
          R.set(l, (A += 4)),
          R.writeUInt32BE(f.length, (A += l.length)),
          R.set(f, (A += 4)),
          R.writeUInt32BE(u.length, (A += f.length)),
          R.set(u, (A += 4)),
          R.writeUInt32BE(1, (A += u.length)),
          R.writeUInt32BE(p.pub.length, (A += 4)),
          R.set(p.pub, (A += 4)),
          R.writeUInt32BE(y.length, (A += p.pub.length)),
          R.set(y, (A += 4)),
          R.set(_, (A += y.length));
      }
      {
        const A = R.base64Slice(0, R.length);
        let I = A.replace(
          /.{64}/g,
          `$&
`,
        );
        A.length & 63 &&
          (I += `
`),
          (o += I);
      }
      {
        const A = p.pub.base64Slice(0, p.pub.length);
        c = `${p.sshName} ${A}${s ? ` ${s}` : ""}`;
      }
      return (
        (o += `-----END OPENSSH PRIVATE KEY-----
`),
        { private: o, public: c }
      );
    }
    default:
      throw new Error("Invalid output key format");
  }
}
function Bie() {}
var Uie = {
  generateKeyPair: (e, t, n) => {
    typeof t == "function" && ((n = t), (t = void 0)),
      typeof n != "function" && (n = Bie);
    const r = kS(e, t);
    $ie(...r, (i, a, s) => {
      if (i) return n(i);
      let o;
      try {
        o = TS(r[0], a, s, t);
      } catch (c) {
        return n(c);
      }
      n(null, o);
    });
  },
  generateKeyPairSync: (e, t) => {
    const n = kS(e, t),
      { publicKey: r, privateKey: i } = Cie(...n);
    return TS(n[0], r, i, t);
  },
};
const {
    AgentProtocol: Fie,
    BaseAgent: jie,
    createAgent: Mie,
    CygwinAgent: Hie,
    OpenSSHAgent: qie,
    PageantAgent: Gie,
  } = vk,
  { SSHTTPAgent: Qie, SSHTTPSAgent: Wie } = yk,
  { parseKey: zie } = to,
  {
    flagsToString: Kie,
    OPEN_MODE: Vie,
    STATUS_CODE: Yie,
    stringToFlags: Xie,
  } = Zp;
var Jie = {
  AgentProtocol: Fie,
  BaseAgent: jie,
  createAgent: Mie,
  Client: Yk,
  CygwinAgent: Hie,
  HTTPAgent: Qie,
  HTTPSAgent: Wie,
  OpenSSHAgent: qie,
  PageantAgent: Gie,
  Server: Sie,
  utils: {
    parseKey: zie,
    ...Uie,
    sftp: {
      flagsToString: Kie,
      OPEN_MODE: Vie,
      STATUS_CODE: Yie,
      stringToFlags: Xie,
    },
  },
};
const NS = fI.homedir();
function OS(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected a string, got ${typeof e}`);
  return NS ? e.replace(/^~(?=$|\/|\\)/, NS) : e;
}
let Rs = [];
function cg(e) {
  return (
    Rs.find((t) => t.uuid === e) || {
      uuid: e,
      client: null,
      hostname: null,
      serverLabel: null,
    }
  );
}
function lg(e, t) {
  const n = Rs.findIndex((r) => r.uuid === e);
  n !== -1
    ? (Rs[n] = { ...Rs[n], ...t })
    : Rs.push({
        uuid: e,
        client: null,
        hostname: null,
        serverLabel: null,
        ...t,
      });
}
function Zie({
  host: e,
  username: t,
  port: n = 22,
  password: r,
  privateKeyPath: i,
  privateKeyPassphrase: a,
}) {
  return new Promise((s, o) => {
    const c = new Jie.Client();
    c.on("ready", () => {
      console.log("[SSH CLIENT] Connected!"),
        c.forwardIn("", Number(rt.port()), (f) => {
          f && (console.error(`[SSH CLIENT] ${f}`), o(f)),
            console.log(
              `[SSH CLIENT] Listening for connections on server on port ${rt.port()}!`,
            ),
            s(c);
        });
    }),
      c.on("error", (f) => {
        console.log(`[SSH CLIENT] ${f}`), o(f);
      }),
      c.on("end", () => console.log("[SSH CLIENT] Disconnected!")),
      c.on("tcp connection", (f, u) => {
        console.log("[SSH CLIENT] TCP connection incoming", f);
        const d = new ha.Socket();
        d.connect(Number(rt.port()), "localhost", function () {
          const p = u();
          console.log(
            "[SSH CLIENT] Accepted remote connection. Forwarding packets...",
          ),
            d.pipe(p).pipe(d);
        });
      }),
      console.log(`[SSH CLIENT] Connecting to SSH (${t}@${e}:${n})...`);
    let l = null;
    r ||
      (l = i
        ? require("fs").readFileSync(OS(i))
        : require("fs").readFileSync(OS("~/.ssh/id_rsa"))),
      c.connect({
        host: e,
        username: t,
        port: n,
        password: r || void 0,
        privateKey: l,
        passphrase: a || void 0,
        readyTimeout: 5e3,
      });
  });
}
const Tl = {
  getConnectedServers: function () {
    return Rs.filter((e) => e.client).map((e) => e.uuid);
  },
  disconnectAll() {
    this.getConnectedServers().forEach((e) => this.disconnect(e));
  },
  disconnect: function (e) {
    const t = cg(e);
    t.client
      ? (console.log("[SSH CLIENT] Disconnecting."),
        t.client.end(),
        lg(e, { client: null, hostname: null, serverLabel: null }))
      : console.log("[SSH CLIENT] Not connected");
  },
  connect: function (e) {
    console.log("[SSH CLIENT] Preparing to connect to SSH...");
    const t = cg(e.uuid);
    return (
      t.client &&
        (console.log(
          "[SSH CLIENT] SSH was already connected... Disconnecting.",
        ),
        this.disconnect(t.uuid)),
      new Promise((n, r) => {
        Zie(e).then(
          (i) => {
            i.exec("hostname", (a, s) =>
              s.on("data", (o) =>
                lg(e.uuid, {
                  hostname: o.toString().replace(
                    `
`,
                    "",
                  ),
                }),
              ),
            ),
              lg(e.uuid, { client: i, serverLabel: e.label }),
              n(cg(e.uuid));
          },
          (i) => r(i),
        );
      })
    );
  },
};
var Jk = { exports: {} },
  ug = { exports: {} },
  PS;
function eae() {
  return (
    PS ||
      ((PS = 1),
      (function (e, t) {
        (function (n, r) {
          e.exports = r();
        })(Tn, function () {
          function n(m) {
            return !isNaN(parseFloat(m)) && isFinite(m);
          }
          function r(m) {
            return m.charAt(0).toUpperCase() + m.substring(1);
          }
          function i(m) {
            return function () {
              return this[m];
            };
          }
          var a = ["isConstructor", "isEval", "isNative", "isToplevel"],
            s = ["columnNumber", "lineNumber"],
            o = ["fileName", "functionName", "source"],
            c = ["args"],
            l = ["evalOrigin"],
            f = a.concat(s, o, c, l);
          function u(m) {
            if (m)
              for (var g = 0; g < f.length; g++)
                m[f[g]] !== void 0 && this["set" + r(f[g])](m[f[g]]);
          }
          (u.prototype = {
            getArgs: function () {
              return this.args;
            },
            setArgs: function (m) {
              if (Object.prototype.toString.call(m) !== "[object Array]")
                throw new TypeError("Args must be an Array");
              this.args = m;
            },
            getEvalOrigin: function () {
              return this.evalOrigin;
            },
            setEvalOrigin: function (m) {
              if (m instanceof u) this.evalOrigin = m;
              else if (m instanceof Object) this.evalOrigin = new u(m);
              else
                throw new TypeError(
                  "Eval Origin must be an Object or StackFrame",
                );
            },
            toString: function () {
              var m = this.getFileName() || "",
                g = this.getLineNumber() || "",
                v = this.getColumnNumber() || "",
                y = this.getFunctionName() || "";
              return this.getIsEval()
                ? m
                  ? "[eval] (" + m + ":" + g + ":" + v + ")"
                  : "[eval]:" + g + ":" + v
                : y
                ? y + " (" + m + ":" + g + ":" + v + ")"
                : m + ":" + g + ":" + v;
            },
          }),
            (u.fromString = function (g) {
              var v = g.indexOf("("),
                y = g.lastIndexOf(")"),
                _ = g.substring(0, v),
                E = g.substring(v + 1, y).split(","),
                R = g.substring(y + 1);
              if (R.indexOf("@") === 0)
                var A = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(R, ""),
                  I = A[1],
                  S = A[2],
                  w = A[3];
              return new u({
                functionName: _,
                args: E || void 0,
                fileName: I,
                lineNumber: S || void 0,
                columnNumber: w || void 0,
              });
            });
          for (var d = 0; d < a.length; d++)
            (u.prototype["get" + r(a[d])] = i(a[d])),
              (u.prototype["set" + r(a[d])] = (function (m) {
                return function (g) {
                  this[m] = !!g;
                };
              })(a[d]));
          for (var p = 0; p < s.length; p++)
            (u.prototype["get" + r(s[p])] = i(s[p])),
              (u.prototype["set" + r(s[p])] = (function (m) {
                return function (g) {
                  if (!n(g)) throw new TypeError(m + " must be a Number");
                  this[m] = Number(g);
                };
              })(s[p]));
          for (var h = 0; h < o.length; h++)
            (u.prototype["get" + r(o[h])] = i(o[h])),
              (u.prototype["set" + r(o[h])] = (function (m) {
                return function (g) {
                  this[m] = String(g);
                };
              })(o[h]));
          return u;
        });
      })(ug)),
    ug.exports
  );
}
(function (e, t) {
  (function (n, r) {
    e.exports = r(eae());
  })(Tn, function (r) {
    var i = /(^|@)\S+:\d+/,
      a = /^\s*at .*(\S+:\d+|\(native\))/m,
      s = /^(eval@)?(\[native code])?$/;
    return {
      parse: function (c) {
        if (typeof c.stacktrace < "u" || typeof c["opera#sourceloc"] < "u")
          return this.parseOpera(c);
        if (c.stack && c.stack.match(a)) return this.parseV8OrIE(c);
        if (c.stack) return this.parseFFOrSafari(c);
        throw new Error("Cannot parse given Error object");
      },
      extractLocation: function (c) {
        if (c.indexOf(":") === -1) return [c];
        var l = /(.+?)(?::(\d+))?(?::(\d+))?$/,
          f = l.exec(c.replace(/[()]/g, ""));
        return [f[1], f[2] || void 0, f[3] || void 0];
      },
      parseV8OrIE: function (c) {
        var l = c.stack
          .split(
            `
`,
          )
          .filter(function (f) {
            return !!f.match(a);
          }, this);
        return l.map(function (f) {
          f.indexOf("(eval ") > -1 &&
            (f = f
              .replace(/eval code/g, "eval")
              .replace(/(\(eval at [^()]*)|(,.*$)/g, ""));
          var u = f
              .replace(/^\s+/, "")
              .replace(/\(eval code/g, "(")
              .replace(/^.*?\s+/, ""),
            d = u.match(/ (\(.+\)$)/);
          u = d ? u.replace(d[0], "") : u;
          var p = this.extractLocation(d ? d[1] : u),
            h = (d && u) || void 0,
            m = ["eval", "<anonymous>"].indexOf(p[0]) > -1 ? void 0 : p[0];
          return new r({
            functionName: h,
            fileName: m,
            lineNumber: p[1],
            columnNumber: p[2],
            source: f,
          });
        }, this);
      },
      parseFFOrSafari: function (c) {
        var l = c.stack
          .split(
            `
`,
          )
          .filter(function (f) {
            return !f.match(s);
          }, this);
        return l.map(function (f) {
          if (
            (f.indexOf(" > eval") > -1 &&
              (f = f.replace(
                / line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,
                ":$1",
              )),
            f.indexOf("@") === -1 && f.indexOf(":") === -1)
          )
            return new r({ functionName: f });
          var u = /((.*".+"[^@]*)?[^@]*)(?:@)/,
            d = f.match(u),
            p = d && d[1] ? d[1] : void 0,
            h = this.extractLocation(f.replace(u, ""));
          return new r({
            functionName: p,
            fileName: h[0],
            lineNumber: h[1],
            columnNumber: h[2],
            source: f,
          });
        }, this);
      },
      parseOpera: function (c) {
        return !c.stacktrace ||
          (c.message.indexOf(`
`) > -1 &&
            c.message.split(`
`).length >
              c.stacktrace.split(`
`).length)
          ? this.parseOpera9(c)
          : c.stack
          ? this.parseOpera11(c)
          : this.parseOpera10(c);
      },
      parseOpera9: function (c) {
        for (
          var l = /Line (\d+).*script (?:in )?(\S+)/i,
            f = c.message.split(`
`),
            u = [],
            d = 2,
            p = f.length;
          d < p;
          d += 2
        ) {
          var h = l.exec(f[d]);
          h &&
            u.push(new r({ fileName: h[2], lineNumber: h[1], source: f[d] }));
        }
        return u;
      },
      parseOpera10: function (c) {
        for (
          var l = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,
            f = c.stacktrace.split(`
`),
            u = [],
            d = 0,
            p = f.length;
          d < p;
          d += 2
        ) {
          var h = l.exec(f[d]);
          h &&
            u.push(
              new r({
                functionName: h[3] || void 0,
                fileName: h[2],
                lineNumber: h[1],
                source: f[d],
              }),
            );
        }
        return u;
      },
      parseOpera11: function (c) {
        var l = c.stack
          .split(
            `
`,
          )
          .filter(function (f) {
            return !!f.match(i) && !f.match(/^Error created at/);
          }, this);
        return l.map(function (f) {
          var u = f.split("@"),
            d = this.extractLocation(u.pop()),
            p = u.shift() || "",
            h =
              p
                .replace(/<anonymous function(: (\w+))?>/, "$2")
                .replace(/\([^)]*\)/g, "") || void 0,
            m;
          p.match(/\(([^)]*)\)/) && (m = p.replace(/^[^(]+\(([^)]*)\)$/, "$1"));
          var g =
            m === void 0 || m === "[arguments not available]"
              ? void 0
              : m.split(",");
          return new r({
            functionName: h,
            args: g,
            fileName: d[0],
            lineNumber: d[1],
            columnNumber: d[2],
            source: f,
          });
        }, this);
      },
    };
  });
})(Jk);
var tae = Jk.exports;
const nae = Wl(tae),
  rae = "Ray",
  iae = "2.7.5",
  aae = "dist-electron/main/index.js",
  sae = "Ray app",
  oae = { name: "Spatie", email: "info@spatie.be" },
  cae = "MIT",
  lae = { env: { VITE_DEV_SERVER_URL: "http://127.0.0.1:7777/" } },
  uae = {
    dev: "vite --logLevel info",
    bundle: "tsc && vite build",
    build: "electron-builder",
    "build:m1": "electron-builder --config=electron-builder-m1.json5",
    preview: "vite preview",
    pree2e: "vite build --mode=test",
    e2e: "playwright test",
    storybook: "storybook dev -p 6006",
    "build-storybook": "storybook build",
    postinstall: "electron-builder install-app-deps",
  },
  fae = {
    "@electron/notarize": "^2.1.0",
    "@flareapp/flare-client": "^3.0.5",
    "@flareapp/flare-react": "^3.0.5",
    "@flareapp/vite-plugin-sourcemap-uploader": "^1.0.2",
    "@playwright/test": "^1.36.2",
    "@storybook/addon-essentials": "^7.1.1",
    "@storybook/addon-interactions": "^7.1.1",
    "@storybook/addon-links": "^7.1.1",
    "@storybook/blocks": "^7.1.1",
    "@storybook/react": "^7.1.1",
    "@storybook/react-vite": "^7.1.1",
    "@storybook/testing-library": "^0.2.0",
    "@types/canvas-confetti": "^1.6.0",
    "@types/cors": "^2.8.13",
    "@types/dompurify": "^3.0.2",
    "@types/prettier": "^2.7.3",
    "@types/react": "^18.0.28",
    "@types/react-dom": "^18.0.11",
    "@types/ssh2": "^1.11.13",
    "@vitejs/plugin-react": "^4.0.1",
    autoprefixer: "^10.4.14",
    "body-parser": "^1.20.2",
    "canvas-confetti": "^1.6.0",
    cors: "^2.8.5",
    dompurify: "^3.0.5",
    dotenv: "^16.3.1",
    electron: "^25.3.2",
    "electron-builder": "^24.6.3",
    "electron-devtools-installer": "^3.2.0",
    "electron-log": "^5.0.0-beta.24",
    "electron-store": "^8.1.0",
    "electron-updater": "^6.1.1",
    "error-stack-parser": "^2.1.4",
    express: "^4.18.2",
    "highlight.js": "^11.8.0",
    "highlightjs-blade": "^0.1.0",
    postcss: "^8.4.27",
    prettier: "^2.8.8",
    "prop-types": "^15.8.1",
    react: "^18.2.0",
    "react-dom": "^18.2.0",
    "react-inspector": "^6.0.2",
    "react-select": "^5.7.4",
    "react-virtuoso": "^4.4.2",
    sass: "^1.64.1",
    "sql-formatter": "^12.2.4",
    ssh2: "^1.14.0",
    storybook: "^7.1.1",
    tailwindcss: "^3.3.3",
    typescript: "^5.0.2",
    untildify: "^5.0.0",
    vite: "^4.4.7",
    "vite-plugin-electron": "^0.12.0",
    "vite-plugin-electron-renderer": "^0.14.1",
  },
  dae = { node: "^20.0.0" },
  pae = { "@mdx-js/rollup": "^2.3.0", "cpu-features": "0.0.8" },
  fg = {
    name: rae,
    version: iae,
    main: aae,
    description: sae,
    author: oae,
    license: cae,
    private: !0,
    debug: lae,
    scripts: uae,
    devDependencies: fae,
    engines: dae,
    dependencies: pae,
  };
var V0 = { exports: {} },
  dg = { exports: {} },
  DS;
function Zk() {
  return (
    DS ||
      ((DS = 1),
      (function (e) {
        let t = {};
        try {
          t = require("electron");
        } catch {}
        t.ipcRenderer && n(t), (e.exports = n);
        function n({ contextBridge: r, ipcRenderer: i }) {
          if (!i) return;
          i.on("__ELECTRON_LOG_IPC__", (s, o) => {
            window.postMessage({ cmd: "message", ...o });
          }),
            i
              .invoke("__ELECTRON_LOG__", { cmd: "getOptions" })
              .catch((s) =>
                console.error(
                  new Error(
                    `electron-log isn't initialized in the main process. Please call log.initialize() before. ${s.message}`,
                  ),
                ),
              );
          const a = {
            sendToMain(s) {
              try {
                i.send("__ELECTRON_LOG__", s);
              } catch (o) {
                console.error("electronLog.sendToMain ", o, "data:", s),
                  i.send("__ELECTRON_LOG__", {
                    cmd: "errorHandler",
                    error: {
                      message: o == null ? void 0 : o.message,
                      stack: o == null ? void 0 : o.stack,
                    },
                    errorName: "sendToMain",
                  });
              }
            },
            log(...s) {
              a.sendToMain({ data: s, level: "info" });
            },
          };
          for (const s of [
            "error",
            "warn",
            "info",
            "verbose",
            "debug",
            "silly",
          ])
            a[s] = (...o) => a.sendToMain({ data: o, level: s });
          if (r && process.contextIsolated)
            try {
              r.exposeInMainWorld("__electronLog", a);
            } catch {}
          typeof window == "object"
            ? (window.__electronLog = a)
            : (__electronLog = a);
        }
      })(dg)),
    dg.exports
  );
}
var pg = { exports: {} },
  hg,
  LS;
function hae() {
  if (LS) return hg;
  (LS = 1), (hg = e);
  function e(t) {
    return Object.defineProperties(n, {
      defaultLabel: { value: "", writable: !0 },
      labelPadding: { value: !0, writable: !0 },
      maxLabelLength: { value: 0, writable: !0 },
      labelLength: {
        get() {
          switch (typeof n.labelPadding) {
            case "boolean":
              return n.labelPadding ? n.maxLabelLength : 0;
            case "number":
              return n.labelPadding;
            default:
              return 0;
          }
        },
      },
    });
    function n(r) {
      n.maxLabelLength = Math.max(n.maxLabelLength, r.length);
      const i = {};
      for (const a of [...t.levels, "log"])
        i[a] = (...s) => t.logData(s, { level: a, scope: r });
      return i;
    }
  }
  return hg;
}
var mg, BS;
function eT() {
  if (BS) return mg;
  BS = 1;
  const e = hae(),
    n = class n {
      constructor({
        allowUnknownLevel: i = !1,
        errorHandler: a,
        eventLogger: s,
        initializeFn: o,
        isDev: c = !1,
        levels: l = ["error", "warn", "info", "verbose", "debug", "silly"],
        logId: f,
        transportFactories: u = {},
        variables: d,
      } = {}) {
        At(this, "errorHandler", null);
        At(this, "eventLogger", null);
        At(this, "functions", {});
        At(this, "hooks", []);
        At(this, "isDev", !1);
        At(this, "levels", null);
        At(this, "logId", null);
        At(this, "scope", null);
        At(this, "transports", {});
        At(this, "variables", {});
        (this.addLevel = this.addLevel.bind(this)),
          (this.create = this.create.bind(this)),
          (this.logData = this.logData.bind(this)),
          (this.processMessage = this.processMessage.bind(this)),
          (this.allowUnknownLevel = i),
          (this.initializeFn = o),
          (this.isDev = c),
          (this.levels = l),
          (this.logId = f),
          (this.transportFactories = u),
          (this.variables = d || {}),
          (this.scope = e(this)),
          this.addLevel("log", !1);
        for (const p of this.levels) this.addLevel(p, !1);
        (this.errorHandler = a),
          a == null || a.setOptions({ logFn: this.error }),
          (this.eventLogger = s),
          s == null || s.setOptions({ logger: this });
        for (const [p, h] of Object.entries(u)) this.transports[p] = h(this);
        n.instances[f] = this;
      }
      static getInstance({ logId: i }) {
        return this.instances[i] || this.instances.default;
      }
      addLevel(i, a = this.levels.length) {
        a !== !1 && this.levels.splice(a, 0, i),
          (this[i] = (...s) => this.logData(s, { level: i })),
          (this.functions[i] = this[i]);
      }
      catchErrors(i) {
        return (
          this.processMessage(
            {
              data: [
                "log.catchErrors is deprecated. Use log.errorHandler instead",
              ],
              level: "warn",
            },
            { transports: ["console"] },
          ),
          this.errorHandler.startCatching(i)
        );
      }
      create(i) {
        return (
          typeof i == "string" && (i = { logId: i }),
          new n({
            ...i,
            errorHandler: this.errorHandler,
            initializeFn: this.initializeFn,
            isDev: this.isDev,
            transportFactories: this.transportFactories,
            variables: { ...this.variables },
          })
        );
      }
      compareLevels(i, a, s = this.levels) {
        const o = s.indexOf(i),
          c = s.indexOf(a);
        return c === -1 || o === -1 ? !0 : c <= o;
      }
      initialize({ preload: i = !0, spyRendererConsole: a = !1 } = {}) {
        this.initializeFn({ logger: this, preload: i, spyRendererConsole: a });
      }
      logData(i, a = {}) {
        this.processMessage({ data: i, ...a });
      }
      processMessage(i, { transports: a = this.transports } = {}) {
        if (i.cmd === "errorHandler") {
          this.errorHandler.handle(i.error, {
            errorName: i.errorName,
            processType: "renderer",
            showDialog: !!i.showDialog,
          });
          return;
        }
        let s = i.level;
        this.allowUnknownLevel ||
          (s = this.levels.includes(i.level) ? i.level : "info");
        const o = {
          date: new Date(),
          ...i,
          level: s,
          variables: { ...this.variables, ...i.variables },
        };
        for (const [c, l] of this.transportEntries(a))
          if (
            !(typeof l != "function" || l.level === !1) &&
            this.compareLevels(l.level, i.level)
          )
            try {
              const f = this.hooks.reduce((u, d) => u && d(u, l, c), o);
              f && l({ ...f, data: [...f.data] });
            } catch (f) {
              this.processInternalErrorFn(f);
            }
      }
      processInternalErrorFn(i) {}
      transportEntries(i = this.transports) {
        return (Array.isArray(i) ? i : Object.entries(i))
          .map((s) => {
            switch (typeof s) {
              case "string":
                return this.transports[s] ? [s, this.transports[s]] : null;
              case "function":
                return [s.name, s];
              default:
                return Array.isArray(s) ? s : null;
            }
          })
          .filter(Boolean);
      }
    };
  At(n, "instances", {});
  let t = n;
  return (mg = t), mg;
}
var gg, US;
function mae() {
  if (US) return gg;
  US = 1;
  const e = console.error;
  class t {
    constructor({ logFn: r = null } = {}) {
      At(this, "logFn", null);
      At(this, "onError", null);
      At(this, "showDialog", !1);
      At(this, "preventDefault", !0);
      (this.handleError = this.handleError.bind(this)),
        (this.handleRejection = this.handleRejection.bind(this)),
        (this.startCatching = this.startCatching.bind(this)),
        (this.logFn = r);
    }
    handle(
      r,
      {
        logFn: i = this.logFn,
        errorName: a = "",
        onError: s = this.onError,
        showDialog: o = this.showDialog,
      } = {},
    ) {
      try {
        (s == null
          ? void 0
          : s({ error: r, errorName: a, processType: "renderer" })) !== !1 &&
          i({ error: r, errorName: a, showDialog: o });
      } catch {
        e(r);
      }
    }
    setOptions({ logFn: r, onError: i, preventDefault: a, showDialog: s }) {
      typeof r == "function" && (this.logFn = r),
        typeof i == "function" && (this.onError = i),
        typeof a == "boolean" && (this.preventDefault = a),
        typeof s == "boolean" && (this.showDialog = s);
    }
    startCatching({ onError: r, showDialog: i } = {}) {
      this.isActive ||
        ((this.isActive = !0),
        this.setOptions({ onError: r, showDialog: i }),
        window.addEventListener("error", (a) => {
          var s;
          this.preventDefault && ((s = a.preventDefault) == null || s.call(a)),
            this.handleError(a.error || a);
        }),
        window.addEventListener("unhandledrejection", (a) => {
          var s;
          this.preventDefault && ((s = a.preventDefault) == null || s.call(a)),
            this.handleRejection(a.reason || a);
        }));
    }
    handleError(r) {
      this.handle(r, { errorName: "Unhandled" });
    }
    handleRejection(r) {
      const i = r instanceof Error ? r : new Error(JSON.stringify(r));
      this.handle(i, { errorName: "Unhandled rejection" });
    }
  }
  return (gg = t), gg;
}
var vg, FS;
function gae() {
  if (FS) return vg;
  (FS = 1), (vg = t);
  const e = {
    error: console.error,
    warn: console.warn,
    info: console.info,
    verbose: console.info,
    debug: console.debug,
    silly: console.debug,
    log: console.log,
  };
  function t(n) {
    return Object.assign(r, {
      format: "{h}:{i}:{s}.{ms}{scope} › {text}",
      formatDataFn({
        data: i = [],
        date: a = new Date(),
        format: s = r.format,
        logId: o = n.logId,
        scope: c = n.scopeName,
        ...l
      }) {
        return typeof s == "function"
          ? s({ ...l, data: i, date: a, logId: o, scope: c })
          : (typeof s != "string" ||
              (i.unshift(s),
              typeof i[1] == "string" &&
                i[1].match(/%[1cdfiOos]/) &&
                (i = [`${i[0]} ${i[1]}`, ...i.slice(2)]),
              (i[0] = i[0]
                .replace(/\{(\w+)}/g, (f, u) => {
                  var d;
                  switch (u) {
                    case "level":
                      return l.level;
                    case "logId":
                      return o;
                    case "scope":
                      return c ? ` (${c})` : "";
                    case "text":
                      return "";
                    case "y":
                      return a.getFullYear().toString(10);
                    case "m":
                      return (a.getMonth() + 1).toString(10).padStart(2, "0");
                    case "d":
                      return a.getDate().toString(10).padStart(2, "0");
                    case "h":
                      return a.getHours().toString(10).padStart(2, "0");
                    case "i":
                      return a.getMinutes().toString(10).padStart(2, "0");
                    case "s":
                      return a.getSeconds().toString(10).padStart(2, "0");
                    case "ms":
                      return a.getMilliseconds().toString(10).padStart(3, "0");
                    case "iso":
                      return a.toISOString();
                    default:
                      return ((d = l.variables) == null ? void 0 : d[u]) || f;
                  }
                })
                .trim())),
            i);
      },
      writeFn({ level: i, data: a }) {
        const s = e[i] || e.info;
        setTimeout(() => s(...a));
      },
    });
    function r(i) {
      r.writeFn({ ...i, data: r.formatDataFn(i) });
    }
  }
  return vg;
}
var yg, jS;
function vae() {
  if (jS) return yg;
  (jS = 1), (yg = t);
  const e = new Set([Promise, WeakMap, WeakSet]);
  function t(n) {
    return Object.assign(r, {
      depth: 5,
      serializeFn(i, { depth: a = 5, seen: s = new WeakSet() } = {}) {
        return a < 1
          ? `[${typeof i}]`
          : s.has(i)
          ? i
          : ["function", "symbol"].includes(typeof i)
          ? i.toString()
          : Object(i) !== i
          ? i
          : e.has(i.constructor)
          ? `[${i.constructor.name}]`
          : Array.isArray(i)
          ? i.map((o) => r.serializeFn(o, { level: a - 1, seen: s }))
          : i instanceof Error
          ? i.stack
          : i instanceof Map
          ? new Map(
              Array.from(i).map(([o, c]) => [
                r.serializeFn(o, { level: a - 1, seen: s }),
                r.serializeFn(c, { level: a - 1, seen: s }),
              ]),
            )
          : i instanceof Set
          ? new Set(
              Array.from(i).map((o) =>
                r.serializeFn(o, { level: a - 1, seen: s }),
              ),
            )
          : (s.add(i),
            Object.fromEntries(
              Object.entries(i).map(([o, c]) => [
                o,
                r.serializeFn(c, { level: a - 1, seen: s }),
              ]),
            ));
      },
    });
    function r(i) {
      if (!window.__electronLog) {
        n.processMessage(
          {
            data: [
              "electron-log: logger isn't initialized in the main process",
            ],
            level: "error",
          },
          { transports: ["console"] },
        );
        return;
      }
      try {
        __electronLog.sendToMain(r.serializeFn(i, { depth: r.depth }));
      } catch (a) {
        n.transports.console({
          data: ["electronLog.transports.ipc", a, "data:", i.data],
          level: "error",
        });
      }
    }
  }
  return yg;
}
var MS;
function yae() {
  return (
    MS ||
      ((MS = 1),
      (function (e) {
        const t = eT(),
          n = mae(),
          r = gae(),
          i = vae();
        (e.exports = a()),
          (e.exports.Logger = t),
          (e.exports.default = e.exports);
        function a() {
          const s = new t({
            allowUnknownLevel: !0,
            errorHandler: new n(),
            initializeFn: () => {},
            logId: "default",
            transportFactories: { console: r, ipc: i },
            variables: { processType: "renderer" },
          });
          return (
            s.errorHandler.setOptions({
              logFn({ error: o, errorName: c, showDialog: l }) {
                s.transports.console({
                  data: [c, o].filter(Boolean),
                  level: "error",
                }),
                  s.transports.ipc({
                    cmd: "errorHandler",
                    error: {
                      cause: o == null ? void 0 : o.cause,
                      code: o == null ? void 0 : o.code,
                      name: o == null ? void 0 : o.name,
                      message: o == null ? void 0 : o.message,
                      stack: o == null ? void 0 : o.stack,
                    },
                    errorName: c,
                    logId: s.logId,
                    showDialog: l,
                  });
              },
            }),
            typeof window == "object" &&
              window.addEventListener("message", (o) => {
                const { cmd: c, logId: l, ...f } = o.data || {},
                  u = t.getInstance({ logId: l });
                c === "message" &&
                  u.processMessage(f, { transports: ["console"] });
              }),
            new Proxy(s, {
              get(o, c) {
                return typeof o[c] < "u"
                  ? o[c]
                  : (...l) => s.logData(l, { level: c });
              },
            })
          );
        }
      })(pg)),
    pg.exports
  );
}
var bg = { exports: {} },
  _g,
  HS;
function Cu() {
  if (HS) return _g;
  HS = 1;
  const e = Fr,
    t = pt;
  let n;
  try {
    n = require("electron");
  } catch {
    n = null;
  }
  _g = {
    getAppUserDataPath() {
      return f("userData");
    },
    getName: i,
    getPath: f,
    getVersion: o,
    getVersions() {
      return {
        app: `${i()} ${o()}`,
        electron: `Electron ${process.versions.electron}`,
        os: c(),
      };
    },
    isDev() {
      const p = r();
      return (p == null ? void 0 : p.isPackaged) !== void 0
        ? !p.isPackaged
        : typeof process.execPath == "string"
        ? t.basename(process.execPath).toLowerCase().startsWith("electron")
        : process.env.NODE_ENV === "development" ||
          process.env.ELECTRON_IS_DEV === "1";
    },
    isElectron() {
      return !!process.versions.electron;
    },
    onAppEvent(p, h) {
      var m;
      return (
        (m = n == null ? void 0 : n.app) == null || m.on(p, h),
        () => {
          var g;
          (g = n == null ? void 0 : n.app) == null || g.off(p, h);
        }
      );
    },
    onEveryWebContentsEvent(p, h) {
      var g, v;
      return (
        (g = n == null ? void 0 : n.webContents) == null ||
          g.getAllWebContents().forEach((y) => {
            y.on(p, h);
          }),
        (v = n == null ? void 0 : n.app) == null ||
          v.on("web-contents-created", m),
        () => {
          var y, _;
          (y = n == null ? void 0 : n.webContents) == null ||
            y.getAllWebContents().forEach((E) => {
              E.off(p, h);
            }),
            (_ = n == null ? void 0 : n.app) == null ||
              _.off("web-contents-created", m);
        }
      );
      function m(y, _) {
        _.on(p, h);
      }
    },
    onIpc(p, h) {
      var m;
      (m = s()) == null || m.on(p, h);
    },
    onIpcInvoke(p, h) {
      var m, g;
      (g = (m = s()) == null ? void 0 : m.handle) == null || g.call(m, p, h);
    },
    openUrl(p, h = console.error) {
      var m;
      (m = a("shell")) == null || m.openExternal(p).catch(h);
    },
    setPreloadFileForSessions({
      filePath: p,
      includeFutureSession: h = !0,
      sessions: m = [
        ((g) =>
          (g = n == null ? void 0 : n.session) == null
            ? void 0
            : g.defaultSession)(),
      ],
    }) {
      var y;
      for (const _ of m.filter(Boolean)) v(_);
      h &&
        ((y = n == null ? void 0 : n.app) == null ||
          y.on("session-created", (_) => {
            v(_);
          }));
      function v(_) {
        _.setPreloads([..._.getPreloads(), p]);
      }
    },
    sendIpc(p, h) {
      process.type === "browser"
        ? d(p, h)
        : process.type === "renderer" && u(p, h);
    },
    showErrorBox(p, h) {
      const m = a("dialog");
      m && m.showErrorBox(p, h);
    },
    whenAppReady() {
      var p;
      return (
        ((p = n == null ? void 0 : n.app) == null ? void 0 : p.whenReady()) ||
        Promise.resolve()
      );
    },
  };
  function r() {
    return a("app");
  }
  function i() {
    const p = r();
    return p ? ("name" in p ? p.name : p.getName()) : null;
  }
  function a(p) {
    return (n == null ? void 0 : n[p]) || null;
  }
  function s() {
    return process.type === "browser" && n != null && n.ipcMain
      ? n.ipcMain
      : process.type === "renderer" && n != null && n.ipcRenderer
      ? n.ipcRenderer
      : null;
  }
  function o() {
    const p = r();
    return p ? ("version" in p ? p.version : p.getVersion()) : null;
  }
  function c() {
    let p = e.type().replace("_", " "),
      h = e.release();
    return p === "Darwin" && ((p = "macOS"), (h = l())), `${p} ${h}`;
  }
  function l() {
    const p = Number(e.release().split(".")[0]);
    return p <= 19 ? `10.${p - 4}` : p - 9;
  }
  function f(p) {
    const h = r();
    if (!h) return null;
    try {
      return h.getPath(p);
    } catch {
      return null;
    }
  }
  function u(p, h) {
    var m;
    (m = s()) == null || m.send(p, h);
  }
  function d(p, h) {
    var m;
    (m = n == null ? void 0 : n.BrowserWindow) == null ||
      m.getAllWindows().forEach((g) => {
        var v;
        ((v = g.webContents) == null ? void 0 : v.isDestroyed()) === !1 &&
          g.webContents.send(p, h);
      });
  }
  return _g;
}
var Eg, qS;
function bae() {
  if (qS) return Eg;
  qS = 1;
  const e = Xt,
    t = Fr,
    n = pt,
    r = Cu(),
    i = Zk();
  Eg = {
    initialize({ logger: o, preload: c = !0, spyRendererConsole: l = !1 }) {
      r.whenAppReady()
        .then(() => {
          c && a(c), l && s(o);
        })
        .catch(o.warn);
    },
  };
  function a(o) {
    let c =
      typeof o == "string"
        ? o
        : n.resolve(__dirname, "../renderer/electron-log-preload.js");
    if (!e.existsSync(c)) {
      c = n.join(
        r.getAppUserDataPath() || t.tmpdir(),
        "electron-log-preload.js",
      );
      const l = `
      try {
        (${i.toString()})(require('electron'));
      } catch(e) {
        console.error(e);
      }
    `;
      e.writeFileSync(c, l, "utf8");
    }
    r.setPreloadFileForSessions({ filePath: c });
  }
  function s(o) {
    const c = ["verbose", "info", "warning", "error"];
    r.onEveryWebContentsEvent("console-message", (l, f, u) => {
      o.processMessage({
        data: [u],
        level: c[f],
        variables: { processType: "renderer" },
      });
    });
  }
  return Eg;
}
var wg, GS;
function eh() {
  if (GS) return wg;
  (GS = 1), (wg = { transform: e });
  function e({
    logger: t,
    message: n,
    transport: r,
    initialData: i = (n == null ? void 0 : n.data) || [],
    transforms: a = r == null ? void 0 : r.transforms,
  }) {
    return a.reduce(
      (s, o) =>
        typeof o == "function"
          ? o({ data: s, logger: t, message: n, transport: r })
          : s,
      i,
    );
  }
  return wg;
}
var xg, QS;
function tT() {
  if (QS) return xg;
  QS = 1;
  const { transform: e } = eh();
  xg = {
    concatFirstStringElements: t,
    formatScope: r,
    formatText: a,
    formatVariables: i,
    timeZoneFromOffset: n,
    format({
      message: s,
      logger: o,
      transport: c,
      data: l = s == null ? void 0 : s.data,
    }) {
      switch (typeof c.format) {
        case "string":
          return e({
            message: s,
            logger: o,
            transforms: [i, r, a],
            transport: c,
            initialData: [c.format, ...l],
          });
        case "function":
          return c.format({
            data: l,
            level: (s == null ? void 0 : s.level) || "info",
            logger: o,
            message: s,
            transport: c,
          });
        default:
          return l;
      }
    },
  };
  function t({ data: s }) {
    return typeof s[0] != "string" ||
      typeof s[1] != "string" ||
      s[0].match(/%[1cdfiOos]/)
      ? s
      : [`${s[0]} ${s[1]}`, ...s.slice(2)];
  }
  function n(s) {
    const o = Math.abs(s),
      c = s >= 0 ? "-" : "+",
      l = Math.floor(o / 60)
        .toString()
        .padStart(2, "0"),
      f = (o % 60).toString().padStart(2, "0");
    return `${c}${l}:${f}`;
  }
  function r({ data: s, logger: o, message: c }) {
    const { defaultLabel: l, labelLength: f } =
        (o == null ? void 0 : o.scope) || {},
      u = s[0];
    let d = c.scope;
    d || (d = l);
    let p;
    return (
      d === ""
        ? (p = f > 0 ? "".padEnd(f + 3) : "")
        : typeof d == "string"
        ? (p = ` (${d})`.padEnd(f + 3))
        : (p = ""),
      (s[0] = u.replace("{scope}", p)),
      s
    );
  }
  function i({ data: s, message: o }) {
    let c = s[0];
    if (typeof c != "string") return s;
    c = c.replace("{level}]", `${o.level}]`.padEnd(6, " "));
    const l = o.date || new Date();
    return (
      (s[0] = c
        .replace(/\{(\w+)}/g, (f, u) => {
          var d;
          switch (u) {
            case "level":
              return o.level || "info";
            case "logId":
              return o.logId;
            case "y":
              return l.getFullYear().toString(10);
            case "m":
              return (l.getMonth() + 1).toString(10).padStart(2, "0");
            case "d":
              return l.getDate().toString(10).padStart(2, "0");
            case "h":
              return l.getHours().toString(10).padStart(2, "0");
            case "i":
              return l.getMinutes().toString(10).padStart(2, "0");
            case "s":
              return l.getSeconds().toString(10).padStart(2, "0");
            case "ms":
              return l.getMilliseconds().toString(10).padStart(3, "0");
            case "z":
              return n(l.getTimezoneOffset());
            case "iso":
              return l.toISOString();
            default:
              return ((d = o.variables) == null ? void 0 : d[u]) || f;
          }
        })
        .trim()),
      s
    );
  }
  function a({ data: s }) {
    const o = s[0];
    if (typeof o != "string") return s;
    if (o.lastIndexOf("{text}") === o.length - 6)
      return (s[0] = o.replace(/\s?{text}/, "")), s[0] === "" && s.shift(), s;
    const l = o.split("{text}");
    let f = [];
    return (
      l[0] !== "" && f.push(l[0]),
      (f = f.concat(s.slice(1))),
      l[1] !== "" && f.push(l[1]),
      f
    );
  }
  return xg;
}
var Ag = { exports: {} },
  WS;
function u1() {
  return (
    WS ||
      ((WS = 1),
      (function (e) {
        const t = wr;
        e.exports = {
          serialize: r,
          maxDepth({
            data: i,
            transport: a,
            depth: s = (a == null ? void 0 : a.depth) ?? 6,
          }) {
            if (!i) return i;
            if (s < 1)
              return Array.isArray(i)
                ? "[array]"
                : typeof i == "object" && i
                ? "[object]"
                : i;
            if (Array.isArray(i))
              return i.map((c) =>
                e.exports.maxDepth({ data: c, depth: s - 1 }),
              );
            if (
              typeof i != "object" ||
              (i && typeof i.toISOString == "function")
            )
              return i;
            if (i === null) return null;
            if (i instanceof Error) return i;
            const o = {};
            for (const c in i)
              Object.prototype.hasOwnProperty.call(i, c) &&
                (o[c] = e.exports.maxDepth({ data: i[c], depth: s - 1 }));
            return o;
          },
          toJSON({ data: i }) {
            return JSON.parse(JSON.stringify(i, n()));
          },
          toString({ data: i, transport: a }) {
            const s = (a == null ? void 0 : a.inspectOptions) || {},
              o = i.map((c) => {
                if (c !== void 0)
                  try {
                    const l = JSON.stringify(c, n(), "  ");
                    return l === void 0 ? void 0 : JSON.parse(l);
                  } catch {
                    return c;
                  }
              });
            return t.formatWithOptions(s, ...o);
          },
        };
        function n(i = {}) {
          const a = new WeakSet();
          return function (s, o) {
            if (typeof o == "object" && o !== null) {
              if (a.has(o)) return;
              a.add(o);
            }
            return r(s, o, i);
          };
        }
        function r(i, a, s = {}) {
          const o = (s == null ? void 0 : s.serializeMapAndSet) !== !1;
          return a instanceof Error
            ? a.stack
            : a &&
                (typeof a == "function"
                  ? `[function] ${a.toString()}`
                  : o && a instanceof Map && Object.fromEntries
                  ? Object.fromEntries(a)
                  : o && a instanceof Set && Array.from
                  ? Array.from(a)
                  : a);
        }
      })(Ag)),
    Ag.exports
  );
}
var Sg, zS;
function f1() {
  if (zS) return Sg;
  (zS = 1),
    (Sg = {
      transformStyles: r,
      applyAnsiStyles({ data: i }) {
        return r(i, t, n);
      },
      removeStyles({ data: i }) {
        return r(i, () => "");
      },
    });
  const e = {
    unset: "\x1B[0m",
    black: "\x1B[30m",
    red: "\x1B[31m",
    green: "\x1B[32m",
    yellow: "\x1B[33m",
    blue: "\x1B[34m",
    magenta: "\x1B[35m",
    cyan: "\x1B[36m",
    white: "\x1B[37m",
  };
  function t(i) {
    const a = i.replace(/color:\s*(\w+).*/, "$1").toLowerCase();
    return e[a] || "";
  }
  function n(i) {
    return i + e.unset;
  }
  function r(i, a, s) {
    const o = {};
    return i.reduce((c, l, f, u) => {
      if (o[f]) return c;
      if (typeof l == "string") {
        let d = f,
          p = !1;
        (l = l.replace(/%[1cdfiOos]/g, (h) => {
          if (((d += 1), h !== "%c")) return h;
          const m = u[d];
          return typeof m == "string" ? ((o[d] = !0), (p = !0), a(m, l)) : h;
        })),
          p && s && (l = s(l));
      }
      return c.push(l), c;
    }, []);
  }
  return Sg;
}
var Ig, KS;
function _ae() {
  if (KS) return Ig;
  KS = 1;
  const { concatFirstStringElements: e, format: t } = tT(),
    { maxDepth: n, toJSON: r } = u1(),
    { applyAnsiStyles: i, removeStyles: a } = f1(),
    { transform: s } = eh(),
    o = {
      error: console.error,
      warn: console.warn,
      info: console.info,
      verbose: console.info,
      debug: console.debug,
      silly: console.debug,
      log: console.log,
    };
  Ig = f;
  const l = `%c{h}:{i}:{s}.{ms}{scope}%c ${
    process.platform === "win32" ? ">" : "›"
  } {text}`;
  Object.assign(f, { DEFAULT_FORMAT: l });
  function f(m) {
    return Object.assign(g, {
      format: l,
      level: "silly",
      transforms: [u, t, p, e, n, r],
      useStyles: process.env.FORCE_STYLES,
      writeFn({ message: v }) {
        (o[v.level] || o.info)(...v.data);
      },
    });
    function g(v) {
      const y = s({ logger: m, message: v, transport: g });
      g.writeFn({ message: { ...v, data: y } });
    }
  }
  function u({ data: m, message: g, transport: v }) {
    return v.format !== l ? m : [`color:${h(g.level)}`, "color:unset", ...m];
  }
  function d(m, g) {
    if (typeof m == "boolean") return m;
    const y = g === "error" || g === "warn" ? process.stderr : process.stdout;
    return y && y.isTTY;
  }
  function p(m) {
    const { message: g, transport: v } = m;
    return (d(v.useStyles, g.level) ? i : a)(m);
  }
  function h(m) {
    const g = { error: "red", warn: "yellow", info: "cyan", default: "unset" };
    return g[m] || g.default;
  }
  return Ig;
}
var $g, VS;
function nT() {
  if (VS) return $g;
  VS = 1;
  const e = Hi,
    t = Xt,
    n = Fr;
  class r extends e {
    constructor({
      path: o,
      writeOptions: c = { encoding: "utf8", flag: "a", mode: 438 },
      writeAsync: l = !1,
    }) {
      super();
      At(this, "asyncWriteQueue", []);
      At(this, "bytesWritten", 0);
      At(this, "hasActiveAsyncWriting", !1);
      At(this, "path", null);
      At(this, "initialSize");
      At(this, "writeOptions", null);
      At(this, "writeAsync", !1);
      (this.path = o), (this.writeOptions = c), (this.writeAsync = l);
    }
    get size() {
      return this.getSize();
    }
    clear() {
      try {
        return (
          t.writeFileSync(this.path, "", {
            mode: this.writeOptions.mode,
            flag: "w",
          }),
          this.reset(),
          !0
        );
      } catch (o) {
        return o.code === "ENOENT" ? !0 : (this.emit("error", o, this), !1);
      }
    }
    crop(o) {
      try {
        const c = i(this.path, o || 4096);
        this.clear(), this.writeLine(`[log cropped]${n.EOL}${c}`);
      } catch (c) {
        this.emit(
          "error",
          new Error(`Couldn't crop file ${this.path}. ${c.message}`),
          this,
        );
      }
    }
    getSize() {
      if (this.initialSize === void 0)
        try {
          const o = t.statSync(this.path);
          this.initialSize = o.size;
        } catch {
          this.initialSize = 0;
        }
      return this.initialSize + this.bytesWritten;
    }
    increaseBytesWrittenCounter(o) {
      this.bytesWritten += Buffer.byteLength(o, this.writeOptions.encoding);
    }
    isNull() {
      return !1;
    }
    nextAsyncWrite() {
      const o = this;
      if (this.hasActiveAsyncWriting || this.asyncWriteQueue.length === 0)
        return;
      const c = this.asyncWriteQueue.join("");
      (this.asyncWriteQueue = []),
        (this.hasActiveAsyncWriting = !0),
        t.writeFile(this.path, c, this.writeOptions, (l) => {
          (o.hasActiveAsyncWriting = !1),
            l
              ? o.emit(
                  "error",
                  new Error(`Couldn't write to ${o.path}. ${l.message}`),
                  this,
                )
              : o.increaseBytesWrittenCounter(c),
            o.nextAsyncWrite();
        });
    }
    reset() {
      (this.initialSize = void 0), (this.bytesWritten = 0);
    }
    toString() {
      return this.path;
    }
    writeLine(o) {
      if (((o += n.EOL), this.writeAsync)) {
        this.asyncWriteQueue.push(o), this.nextAsyncWrite();
        return;
      }
      try {
        t.writeFileSync(this.path, o, this.writeOptions),
          this.increaseBytesWrittenCounter(o);
      } catch (c) {
        this.emit(
          "error",
          new Error(`Couldn't write to ${this.path}. ${c.message}`),
          this,
        );
      }
    }
  }
  $g = r;
  function i(a, s) {
    const o = Buffer.alloc(s),
      c = t.statSync(a),
      l = Math.min(c.size, s),
      f = Math.max(0, c.size - s),
      u = t.openSync(a, "r"),
      d = t.readSync(u, o, 0, l, f);
    return t.closeSync(u), o.toString("utf8", 0, d);
  }
  return $g;
}
var Cg, YS;
function Eae() {
  if (YS) return Cg;
  YS = 1;
  const e = nT();
  class t extends e {
    clear() {}
    crop() {}
    getSize() {
      return 0;
    }
    isNull() {
      return !0;
    }
    writeLine() {}
  }
  return (Cg = t), Cg;
}
var Rg, XS;
function wae() {
  if (XS) return Rg;
  XS = 1;
  const e = Hi,
    t = Xt,
    n = pt,
    r = nT(),
    i = Eae();
  class a extends e {
    constructor() {
      super();
      At(this, "store", {});
      this.emitError = this.emitError.bind(this);
    }
    provide({ filePath: c, writeOptions: l, writeAsync: f = !1 }) {
      let u;
      try {
        if (((c = n.resolve(c)), this.store[c])) return this.store[c];
        u = this.createFile({ filePath: c, writeOptions: l, writeAsync: f });
      } catch (d) {
        (u = new i({ path: c })), this.emitError(d, u);
      }
      return u.on("error", this.emitError), (this.store[c] = u), u;
    }
    createFile({ filePath: c, writeOptions: l, writeAsync: f }) {
      return (
        this.testFileWriting(c),
        new r({ path: c, writeOptions: l, writeAsync: f })
      );
    }
    emitError(c, l) {
      this.emit("error", c, l);
    }
    testFileWriting(c) {
      t.mkdirSync(n.dirname(c), { recursive: !0 }),
        t.writeFileSync(c, "", { flag: "a" });
    }
  }
  return (Rg = a), Rg;
}
var kg, JS;
function xae() {
  if (JS) return kg;
  JS = 1;
  const e = Xt,
    t = pt;
  kg = { readPackageJson: n, tryReadJsonAt: r };
  function n() {
    return (
      r(require.main && require.main.filename) ||
      r(a()) ||
      r(process.resourcesPath, "app.asar") ||
      r(process.resourcesPath, "app") ||
      r(process.cwd()) || { name: null, version: null }
    );
  }
  function r(...s) {
    if (!s[0]) return null;
    try {
      const o = t.join(...s),
        c = i("package.json", o);
      if (!c) return null;
      const l = JSON.parse(e.readFileSync(c, "utf8")),
        f = l.productName || l.name;
      if (!f || f.toLowerCase() === "electron") return null;
      if (l.productName || l.name) return { name: f, version: l.version };
    } catch {
      return null;
    }
  }
  function i(s, o) {
    let c = o;
    for (;;) {
      const l = t.parse(c),
        f = l.root,
        u = l.dir;
      if (e.existsSync(t.join(c, s))) return t.resolve(t.join(c, s));
      if (c === f) return null;
      c = u;
    }
  }
  function a() {
    const s = process.argv.filter((c) => c.indexOf("--user-data-dir=") === 0);
    return s.length === 0 || typeof s[0] != "string"
      ? null
      : s[0].replace("--user-data-dir=", "");
  }
  return kg;
}
var Tg, ZS;
function Aae() {
  if (ZS) return Tg;
  ZS = 1;
  const e = Fr,
    t = pt,
    n = Cu(),
    r = xae();
  Tg = {
    getAppData: i,
    getLibraryDefaultDir: s,
    getLibraryTemplate: o,
    getNameAndVersion: c,
    getPathVariables: l,
    getUserData: f,
  };
  function i(u) {
    const d = n.getPath("appData");
    if (d) return d;
    const p = a();
    switch (u) {
      case "darwin":
        return t.join(p, "Library/Application Support");
      case "win32":
        return process.env.APPDATA || t.join(p, "AppData/Roaming");
      default:
        return process.env.XDG_CONFIG_HOME || t.join(p, ".config");
    }
  }
  function a() {
    return e.homedir ? e.homedir() : process.env.HOME;
  }
  function s(u, d) {
    return u === "darwin"
      ? t.join(a(), "Library/Logs", d)
      : t.join(f(u, d), "logs");
  }
  function o(u) {
    return u === "darwin"
      ? t.join(a(), "Library/Logs", "{appName}")
      : t.join(i(u), "{appName}", "logs");
  }
  function c() {
    let u = n.getName() || "",
      d = n.getVersion();
    if ((u.toLowerCase() === "electron" && ((u = ""), (d = "")), u && d))
      return { name: u, version: d };
    const p = r.readPackageJson();
    return (
      u || (u = p.name),
      d || (d = p.version),
      u || (u = "Electron"),
      { name: u, version: d }
    );
  }
  function l(u) {
    const d = c(),
      p = d.name,
      h = d.version;
    return {
      appData: i(u),
      appName: p,
      appVersion: h,
      electronDefaultDir: n.getPath("logs"),
      home: a(),
      libraryDefaultDir: s(u, p),
      libraryTemplate: o(u),
      temp: n.getPath("temp") || e.tmpdir(),
      userData: f(u, p),
    };
  }
  function f(u, d) {
    return n.getName() !== d
      ? t.join(i(u), d)
      : n.getPath("userData") || t.join(i(u), d);
  }
  return Tg;
}
var Ng, eI;
function Sae() {
  if (eI) return Ng;
  eI = 1;
  const e = Xt,
    t = pt,
    n = Fr,
    r = wae(),
    i = Aae(),
    { transform: a } = eh(),
    { removeStyles: s } = f1(),
    { format: o } = tT(),
    { toString: c } = u1();
  Ng = f;
  const l = new r();
  function f(d, p = l) {
    let h;
    return (
      p.listenerCount("error") < 1 &&
        p.on("error", (E, R) => {
          v(`Can't write to ${R}`, E);
        }),
      Object.assign(m, {
        fileName: u(d.variables.processType),
        format: "[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}]{scope} {text}",
        getFile: y,
        inspectOptions: { depth: 5 },
        level: "silly",
        maxSize: 1024 ** 2,
        readAllLogs: _,
        sync: !0,
        transforms: [s, o, c],
        writeOptions: { flag: "a", mode: 438, encoding: "utf8" },
        archiveLogFn(E) {
          const R = E.toString(),
            A = t.parse(R);
          try {
            e.renameSync(R, t.join(A.dir, `${A.name}.old${A.ext}`));
          } catch (I) {
            v("Could not rotate log", I);
            const S = Math.round(m.maxSize / 4);
            E.crop(Math.min(S, 256 * 1024));
          }
        },
        resolvePathFn(E) {
          return t.join(E.libraryDefaultDir, E.fileName);
        },
      })
    );
    function m(E) {
      const R = y(E);
      m.maxSize > 0 && R.size > m.maxSize && (m.archiveLogFn(R), R.reset());
      const I = a({ logger: d, message: E, transport: m });
      R.writeLine(I);
    }
    function g() {
      h ||
        ((h = i.getPathVariables(process.platform)),
        typeof m.archiveLog == "function" &&
          ((m.archiveLogFn = m.archiveLog),
          v("archiveLog is deprecated. Use archiveLogFn instead")),
        typeof m.resolvePath == "function" &&
          ((m.resolvePathFn = m.resolvePath),
          v("resolvePath is deprecated. Use resolvePathFn instead")));
    }
    function v(E, R = null, A = "error") {
      const I = [`electron-log.transports.file: ${E}`];
      R && I.push(R),
        d.transports.console({ data: I, date: new Date(), level: A });
    }
    function y(E) {
      g();
      const R = { ...h, fileName: m.fileName },
        A = m.resolvePathFn(R, E);
      return p.provide({
        filePath: A,
        writeAsync: !m.sync,
        writeOptions: m.writeOptions,
      });
    }
    function _({ fileFilter: E = (R) => R.endsWith(".log") } = {}) {
      const R = { ...h, fileName: m.fileName },
        A = t.dirname(m.resolvePathFn(R));
      return e
        .readdirSync(A)
        .map((I) => t.join(A, I))
        .filter(E)
        .map((I) => {
          try {
            return { path: I, lines: e.readFileSync(I, "utf8").split(n.EOL) };
          } catch {
            return null;
          }
        })
        .filter(Boolean);
    }
  }
  function u(d = process.type) {
    switch (d) {
      case "renderer":
        return "renderer.log";
      case "worker":
        return "worker.log";
      default:
        return "main.log";
    }
  }
  return Ng;
}
var Og, tI;
function Iae() {
  if (tI) return Og;
  tI = 1;
  const e = Ws,
    t = pI,
    { transform: n } = eh(),
    { removeStyles: r } = f1(),
    { toJSON: i, maxDepth: a } = u1();
  Og = s;
  function s(o) {
    return Object.assign(c, {
      client: { name: "electron-application" },
      depth: 6,
      level: !1,
      requestOptions: {},
      transforms: [r, i, a],
      makeBodyFn({ message: l }) {
        return JSON.stringify({
          client: c.client,
          data: l.data,
          date: l.date.getTime(),
          level: l.level,
          scope: l.scope,
          variables: l.variables,
        });
      },
      processErrorFn({ error: l }) {
        o.processMessage(
          { data: [`electron-log: can't POST ${c.url}`, l], level: "warn" },
          { transports: ["console", "file"] },
        );
      },
      sendRequestFn({ serverUrl: l, requestOptions: f, body: u }) {
        const p = (l.startsWith("https:") ? t : e).request(l, {
          method: "POST",
          ...f,
          headers: {
            "Content-Type": "application/json",
            "Content-Length": u.length,
            ...f.headers,
          },
        });
        return p.write(u), p.end(), p;
      },
    });
    function c(l) {
      if (!c.url) return;
      const f = c.makeBodyFn({
          logger: o,
          message: { ...l, data: n({ logger: o, message: l, transport: c }) },
          transport: c,
        }),
        u = c.sendRequestFn({
          serverUrl: c.url,
          requestOptions: c.requestOptions,
          body: Buffer.from(f, "utf8"),
        });
      u.on("error", (d) =>
        c.processErrorFn({
          error: d,
          logger: o,
          message: l,
          request: u,
          transport: c,
        }),
      );
    }
  }
  return Og;
}
var Pg, nI;
function $ae() {
  if (nI) return Pg;
  nI = 1;
  const e = Cu();
  class t {
    constructor({
      logFn: i = null,
      onError: a = null,
      showDialog: s = !0,
    } = {}) {
      At(this, "isActive", !1);
      At(this, "logFn", null);
      At(this, "onError", null);
      At(this, "showDialog", !0);
      (this.createIssue = this.createIssue.bind(this)),
        (this.handleError = this.handleError.bind(this)),
        (this.handleRejection = this.handleRejection.bind(this)),
        this.setOptions({ logFn: i, onError: a, showDialog: s }),
        (this.startCatching = this.startCatching.bind(this)),
        (this.stopCatching = this.stopCatching.bind(this));
    }
    handle(
      i,
      {
        logFn: a = this.logFn,
        onError: s = this.onError,
        processType: o = "browser",
        showDialog: c = this.showDialog,
        errorName: l = "",
      } = {},
    ) {
      i = n(i);
      try {
        if (typeof s == "function") {
          const f = e.getVersions(),
            u = this.createIssue;
          if (
            s({
              createIssue: u,
              error: i,
              errorName: l,
              processType: o,
              versions: f,
            }) === !1
          )
            return;
        }
        l ? a(l, i) : a(i),
          c &&
            !l.includes("rejection") &&
            e.showErrorBox(
              `A JavaScript error occurred in the ${o} process`,
              i.stack,
            );
      } catch {
        console.error(i);
      }
    }
    setOptions({ logFn: i, onError: a, showDialog: s }) {
      typeof i == "function" && (this.logFn = i),
        typeof a == "function" && (this.onError = a),
        typeof s == "boolean" && (this.showDialog = s);
    }
    startCatching({ onError: i, showDialog: a } = {}) {
      this.isActive ||
        ((this.isActive = !0),
        this.setOptions({ onError: i, showDialog: a }),
        process.on("uncaughtException", this.handleError),
        process.on("unhandledRejection", this.handleRejection));
    }
    stopCatching() {
      (this.isActive = !1),
        process.removeListener("uncaughtException", this.handleError),
        process.removeListener("unhandledRejection", this.handleRejection);
    }
    createIssue(i, a) {
      e.openUrl(`${i}?${new URLSearchParams(a).toString()}`);
    }
    handleError(i) {
      this.handle(i, { errorName: "Unhandled" });
    }
    handleRejection(i) {
      const a = i instanceof Error ? i : new Error(JSON.stringify(i));
      this.handle(a, { errorName: "Unhandled rejection" });
    }
  }
  function n(r) {
    if (r instanceof Error) return r;
    if (r && typeof r == "object") {
      if (r.message) return Object.assign(new Error(r.message), r);
      try {
        return new Error(JSON.stringify(r));
      } catch (i) {
        return new Error(`Couldn't normalize error ${String(r)}: ${i}`);
      }
    }
    return new Error(`Can't normalize error ${String(r)}`);
  }
  return (Pg = t), Pg;
}
var Dg, rI;
function Cae() {
  if (rI) return Dg;
  rI = 1;
  const e = Cu();
  class t {
    constructor(r = {}) {
      At(this, "disposers", []);
      At(this, "format", "{eventSource}#{eventName}:");
      At(this, "formatters", {
        app: {
          "certificate-error": ({ args: r }) =>
            this.arrayToObject(r.slice(1, 4), ["url", "error", "certificate"]),
          "child-process-gone": ({ args: r }) => (r.length === 1 ? r[0] : r),
          "render-process-gone": ({ args: [r, i] }) =>
            i && typeof i == "object"
              ? { ...i, ...this.getWebContentsDetails(r) }
              : [],
        },
        webContents: {
          "console-message": ({ args: [r, i, a, s] }) => {
            if (!(r < 3)) return { message: i, source: `${s}:${a}` };
          },
          "did-fail-load": ({ args: r }) =>
            this.arrayToObject(r, [
              "errorCode",
              "errorDescription",
              "validatedURL",
              "isMainFrame",
              "frameProcessId",
              "frameRoutingId",
            ]),
          "did-fail-provisional-load": ({ args: r }) =>
            this.arrayToObject(r, [
              "errorCode",
              "errorDescription",
              "validatedURL",
              "isMainFrame",
              "frameProcessId",
              "frameRoutingId",
            ]),
          "plugin-crashed": ({ args: r }) =>
            this.arrayToObject(r, ["name", "version"]),
          "preload-error": ({ args: r }) =>
            this.arrayToObject(r, ["preloadPath", "error"]),
        },
      });
      At(this, "events", {
        app: {
          "certificate-error": !0,
          "child-process-gone": !0,
          "render-process-gone": !0,
        },
        webContents: {
          "did-fail-load": !0,
          "did-fail-provisional-load": !0,
          "plugin-crashed": !0,
          "preload-error": !0,
          unresponsive: !0,
        },
      });
      At(this, "level", "error");
      At(this, "scope", "");
      this.setOptions(r);
    }
    setOptions({
      events: r,
      level: i,
      logger: a,
      format: s,
      formatters: o,
      scope: c,
    }) {
      typeof r == "object" && (this.events = r),
        typeof i == "string" && (this.level = i),
        typeof a == "object" && (this.logger = a),
        (typeof s == "string" || typeof s == "function") && (this.format = s),
        typeof o == "object" && (this.formatters = o),
        typeof c == "string" && (this.scope = c);
    }
    startLogging(r = {}) {
      this.setOptions(r), this.disposeListeners();
      for (const i of this.getEventNames(this.events.app))
        this.disposers.push(
          e.onAppEvent(i, (...a) => {
            this.handleEvent({
              eventSource: "app",
              eventName: i,
              handlerArgs: a,
            });
          }),
        );
      for (const i of this.getEventNames(this.events.webContents))
        this.disposers.push(
          e.onEveryWebContentsEvent(i, (...a) => {
            this.handleEvent({
              eventSource: "webContents",
              eventName: i,
              handlerArgs: a,
            });
          }),
        );
    }
    stopLogging() {
      this.disposeListeners();
    }
    arrayToObject(r, i) {
      const a = {};
      return (
        i.forEach((s, o) => {
          a[s] = r[o];
        }),
        r.length > i.length && (a.unknownArgs = r.slice(i.length)),
        a
      );
    }
    disposeListeners() {
      this.disposers.forEach((r) => r()), (this.disposers = []);
    }
    formatEventLog({ eventName: r, eventSource: i, handlerArgs: a }) {
      var d;
      const [s, ...o] = a;
      if (typeof this.format == "function")
        return this.format({ args: o, event: s, eventName: r, eventSource: i });
      const c = (d = this.formatters[i]) == null ? void 0 : d[r];
      let l = o;
      if (
        (typeof c == "function" &&
          (l = c({ args: o, event: s, eventName: r, eventSource: i })),
        !l)
      )
        return;
      const f = {};
      return (
        Array.isArray(l)
          ? (f.args = l)
          : typeof l == "object" && Object.assign(f, l),
        i === "webContents" &&
          Object.assign(
            f,
            this.getWebContentsDetails(s == null ? void 0 : s.sender),
          ),
        [
          this.format
            .replace("{eventSource}", i === "app" ? "App" : "WebContents")
            .replace("{eventName}", r),
          f,
        ]
      );
    }
    getEventNames(r) {
      return !r || typeof r != "object"
        ? []
        : Object.entries(r)
            .filter(([i, a]) => a)
            .map(([i]) => i);
    }
    getWebContentsDetails(r) {
      if (!(r != null && r.loadURL)) return {};
      try {
        return { webContents: { id: r.id, url: r.getURL() } };
      } catch {
        return {};
      }
    }
    handleEvent({ eventName: r, eventSource: i, handlerArgs: a }) {
      var o;
      const s = this.formatEventLog({
        eventName: r,
        eventSource: i,
        handlerArgs: a,
      });
      if (s) {
        const c = this.scope ? this.logger.scope(this.scope) : this.logger;
        (o = c == null ? void 0 : c[this.level]) == null || o.call(c, ...s);
      }
    }
  }
  return (Dg = t), Dg;
}
var iI;
function Rae() {
  return (
    iI ||
      ((iI = 1),
      (function (e) {
        const t = Cu(),
          { initialize: n } = bae(),
          r = _ae(),
          i = Sae(),
          a = Iae(),
          s = eT(),
          o = $ae(),
          c = Cae(),
          l = new s({
            errorHandler: new o(),
            eventLogger: new c(),
            initializeFn: n,
            isDev: t.isDev(),
            logId: "default",
            transportFactories: { console: r, file: i, remote: a },
            variables: { processType: "main" },
          });
        (l.processInternalErrorFn = (u) => {
          l.transports.console.writeFn({
            data: ["Unhandled electron-log error", u],
            level: "error",
          });
        }),
          (e.exports = l),
          (e.exports.Logger = s),
          (e.exports.default = e.exports),
          t.onIpc("__ELECTRON_LOG__", (u, d) => {
            d.scope && s.getInstance(d).scope(d.scope);
            const p = new Date(d.date);
            f({ ...d, date: p.getTime() ? p : new Date() });
          }),
          t.onIpcInvoke("__ELECTRON_LOG__", (u, { cmd: d = "", logId: p }) => {
            switch (d) {
              case "getOptions":
                return { levels: s.getInstance({ logId: p }).levels, logId: p };
              default:
                return f({ data: [`Unknown cmd '${d}'`], level: "error" }), {};
            }
          });
        function f(u) {
          var d;
          (d = s.getInstance(u)) == null || d.processMessage(u);
        }
      })(bg)),
    bg.exports
  );
}
const kae =
  typeof process > "u" ||
  process.type === "renderer" ||
  process.type === "worker";
kae ? (Zk(), (V0.exports = yae())) : (V0.exports = Rae());
var Tae = V0.exports;
const Gs = Wl(Tae),
  Lg = {
    key: "HQX4zyAHcakeRvCv25TDJVrqZW5fYNcE",
    reportingUrl: "https://flareapp.io/api/reports",
  };
function d1(e, t = {}) {
  const n = {
    notifier: `Ray node client v${fg.version}`,
    exception_class:
      e.constructor && e.constructor.name ? e.constructor.name : "undefined",
    seen_at: Math.round(Date.now() / 1e3),
    message: e.message,
    language: "javascript",
    context: t,
    stacktrace: Oae(e),
    sourcemap_version_id: fg.version,
    glows: [],
    solutions: [],
    application_path: "../..",
    application_version: fg.version,
  };
  Nae(n);
}
function Nae(e) {
  fetch(Lg.reportingUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      "X-Requested-With": "fetch",
      "x-api-token": Lg.key,
    },
    body: JSON.stringify({ ...e, key: Lg.key }),
  })
    .then((t) => {
      var n;
      if (
        (n = t.headers.get("content-type")) != null &&
        n.includes("application/json")
      )
        return t.json();
      throw new Error("Could not send error report to Flare.");
    })
    .then((t) => {
      Gs.debug("Error report sent to flare.");
    })
    .catch((t) => {
      Gs.error("Could not send error report to Flare.");
    });
}
function Oae(e) {
  return Pae(e)
    ? nae
        .parse(e)
        .map((t) => ({
          line_number: t.lineNumber || 1,
          column_number: t.columnNumber || 1,
          method: t.functionName || "Anonymous or unknown function",
          file: t.fileName || "Unknown file",
          code_snippet: { 0: "Could not read from file." },
          trimmed_column_number: null,
          class: "",
        }))
    : [
        {
          line_number: 0,
          column_number: 0,
          method: "unknown",
          file: "unknown",
          code_snippet: { 0: "Could not read from file: stacktrace missing" },
          trimmed_column_number: null,
          class: "unknown",
        },
      ];
}
function Pae(e) {
  return (
    !!e &&
    (!!e.stack || !!e.stacktrace || !!e["opera#sourceloc"]) &&
    typeof (e.stack || e.stacktrace || e["opera#sourceloc"]) == "string" &&
    e.stack !== `${e.name}: ${e.message}`
  );
}
function aI(e) {
  return kT
    .createHash("md5")
    .update(e || "", "utf8")
    .digest("hex");
}
const Df = {
    async getServers() {
      const e = rt.servers(),
        t = Dae();
      return e.map((n) => {
        var s, o;
        const r = aI(n.privateKeyPath),
          i =
            (n.privateKeyPath &&
              ((s = t.find((c) => c.account === `private_key_${r}`)) == null
                ? void 0
                : s.password)) ||
            void 0,
          a =
            ((o = t.find((c) => c.account === `ssh_password_${n.uuid}`)) == null
              ? void 0
              : o.password) || void 0;
        return { ...n, password: a, privateKeyPassphrase: i };
      });
    },
    updateServer(e) {
      const {
        uuid: t,
        label: n,
        host: r,
        username: i,
        port: a,
        needsCredentialsUpdate: s,
        privateKeyPath: o,
        password: c,
      } = e;
      return (
        rt.updateServer({
          uuid: t,
          label: n,
          host: r,
          username: i,
          port: a,
          needsCredentialsUpdate: s,
          privateKeyPath: o,
        }),
        c ? sI(`ssh_password_${e.uuid}`, c) : oI(`ssh_password_${e.uuid}`)
      );
    },
    updatePrivateKey({ privateKeyPath: e, privateKeyPassphrase: t }) {
      const n = aI(e);
      sI(`private_key_${n}`, t);
    },
    removeServer(e) {
      rt.removeServer(e.uuid), oI(`ssh_password_${e.uuid}`);
    },
  },
  p1 = new Mp({
    name: "ray-encrypted",
    watch: !0,
    encryptionKey: "this_only_obfuscates",
  });
function sI(e, t) {
  const n = xe.safeStorage.encryptString(t);
  p1.set(e, n.toString("latin1"));
}
function oI(e) {
  p1.delete(e);
}
function Dae() {
  return Object.entries(p1.store).map(([e, t]) => {
    try {
      const n = xe.safeStorage.decryptString(Buffer.from(t, "latin1"));
      return { account: e, password: n };
    } catch (n) {
      return d1(n), { account: e };
    }
  });
}
function Lae() {
  xe.ipcMain.handle("connect-ssh", async (e, t) => ({
    uuid: (await Tl.connect(t)).uuid,
  })),
    xe.ipcMain.on("disconnect-ssh", (e, t) => {
      var n, r;
      Tl.disconnect(t.uuid),
        (r =
          (n = Yt.find((i) => {
            var a;
            return ((a = i.remoteServer) == null ? void 0 : a.uuid) === t.uuid;
          })) == null
            ? void 0
            : n.window) == null || r.close();
    }),
    xe.ipcMain.on("update-server", (e, t) => Df.updateServer(t)),
    xe.ipcMain.handle("get-servers", () => Df.getServers()),
    xe.ipcMain.on("update-private-key-passphrase", (e, t) =>
      Df.updatePrivateKey(t),
    ),
    xe.ipcMain.on("remove-server", (e, t) => Df.removeServer(t)),
    xe.ipcMain.handle("is-server-connected", (e, t) =>
      Tl.getConnectedServers().includes(t),
    );
}
let rT = !1;
function Bae() {
  Lae(),
    xe.ipcMain.on("open-url", (e, t) => {
      L0(t);
    }),
    xe.ipcMain.on("open-editor", (e, { path: t, lineNumber: n = 1 }) => {
      const i = rt
        .editorString()
        .replace("%path", encodeURIComponent(t))
        .replace("%line", encodeURIComponent(n));
      xe.shell.openExternal(i);
    }),
    xe.ipcMain.handle(
      "flare-report",
      async (e, { report: t, id: n, groupUuid: r }) => {
        var i;
        try {
          const a = await fetch("https://flareapp.io/api/public-reports", {
            body: JSON.stringify({
              report: t,
              tabs: [
                "stackTraceTab",
                "requestTab",
                "appTab",
                "userTab",
                "contextTab",
                "debugTab",
              ],
            }),
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
          });
          if (
            (i = a.headers.get("content-type")) != null &&
            i.includes("application/json")
          ) {
            const s = await a.json(),
              o = Yt.find((u) => u.window.id === e.sender.id);
            if (!o) return;
            const c = o.screens.find((u) => u.groups.has(r));
            if (!c) return;
            const l = c.groups.get(r);
            if (!l) return;
            const f = l.items.find((u) => u.id === n);
            if (!f || f.type !== "exception") return;
            (f.meta = { ...f.meta, flare_response: s }), ts(o);
          }
        } catch (a) {
          console.error(a);
        }
      },
    ),
    xe.app.on("before-quit", () => {
      (rT = !0), Tl.disconnectAll();
      const e = Yt[0].window;
      e != null && e.isVisible() && nte(e.getBounds()),
        xe.globalShortcut.unregisterAll();
    });
}
let Oi = null;
function Uae() {
  if (Oi) return Oi.show();
  (Oi = new xe.BrowserWindow(Qp())),
    Oi.on("closed", () => (Oi = null)),
    Wp(Oi, { page: "servers" }),
    zp(Oi);
}
xe.ipcMain.on("open-servers-window", Uae);
let Yt = [];
function ts(e) {
  e.window.webContents.send("screen-updated", {
    screen: e.screens[e.activeScreenIndex],
    activeIndex: e.activeScreenIndex,
    amountOfScreens: e.screens.length,
  }),
    e.window.webContents.send("screens-updated", sT(e));
}
function iT({ windowName: e, projectName: t, hostname: n, remoteServer: r }) {
  var l;
  const i = Yt.length === 0,
    a = {
      ...Qp(),
      skipTaskbar: !1,
      icon: xe.nativeImage.createFromPath(
        Hp
          ? `${xe.app.getAppPath()}/resources/extraFiles/icon128x128.png`
          : pt.join(process.resourcesPath, "icon128x128.png"),
      ),
      show: !1,
      ...(i ? JR() : ZR()),
    },
    s = new xe.BrowserWindow(a);
  s.on("page-title-updated", (f) => f.preventDefault());
  const o = r ? r.serverLabel || n : void 0,
    c = {
      window: s,
      isPaused: !1,
      windowName: e,
      projectName: t,
      hostname: n,
      remoteServer: r,
      screens: [{ groups: new Map() }],
      activeScreenIndex: 0,
    };
  Yt.push(c),
    s == null ||
      s.on("close", (f) => {
        if (rT || !vs.autoUpdater.autoInstallOnAppQuit) return;
        r &&
          (Oi == null || Oi.webContents.send(`server-disconnected-${r.uuid}`),
          Tl.disconnect(r.uuid)),
          Yt.length === 1
            ? (f.preventDefault(), s.hide())
            : (Yt = Yt.filter((d) => d.windowName !== e));
      }),
    rt.shouldShowDockIcon() ||
      ((l = xe.app.dock) == null || l.hide(), s.setSkipTaskbar(!0)),
    Wp(s, {
      page: "main",
      windowName: e,
      projectName: t,
      remoteServerLabel: o,
    }),
    s.webContents.on("dom-ready", () => {
      ese(c), ts(c);
    }),
    zp(s, i);
}
xe.ipcMain.on("set-paused", (e, t) => {
  const n = Yt.find((r) => r.window.id === e.sender.id);
  n && ((n.isPaused = t), n.window.webContents.send("paused-changed", t));
});
xe.ipcMain.handle("get-paused", (e) => {
  const t = Yt.find((n) => n.window.id === e.sender.id);
  if (t) return t.isPaused;
});
xe.ipcMain.on("set-screen-index", (e, t) => {
  const n = Yt.find((r) => r.window.id === e.sender.id);
  n && ((n.activeScreenIndex = t), ts(n));
});
function th(e, t) {
  e.screens.at(-1).groups.size === 0 && e.screens.pop(),
    e.screens.push({ groups: new Map(), name: t }),
    (e.activeScreenIndex = e.screens.length - 1),
    ts(e);
}
function aT(e) {
  (e.screens = [{ groups: new Map(), name: "" }]),
    (e.activeScreenIndex = 0),
    ts(e);
}
xe.ipcMain.on("new-screen", (e) => {
  const t = Yt.find((n) => n.window.id === e.sender.id);
  t && th(t);
});
function sT(e) {
  return e.screens.map(({ name: t }, n) => ({ name: t, index: n }));
}
xe.ipcMain.handle("get-screens", (e) => {
  const t = Yt.find((n) => n.window.id === e.sender.id);
  return t ? sT(t) : [];
});
xe.ipcMain.on("set-collapsed", (e, { id: t, isCollapsed: n }) => {
  const r = Yt.find((s) => s.window.id === e.sender.id);
  if (!r) return [];
  const a = r.screens[r.activeScreenIndex].groups.get(t);
  a && ((a.collapsed = n), ts(r));
});
xe.ipcMain.on("toggle-collapsed", (e, { id: t }) => {
  const n = Yt.find((a) => a.window.id === e.sender.id);
  if (!n) return [];
  const i = n.screens[n.activeScreenIndex].groups.get(t);
  i && ((i.collapsed = !i.collapsed), ts(n));
});
const Fae = {
    log: (e) =>
      e.content.values.map((t, n) => {
        var r;
        return {
          type: "log",
          content: t.toString(),
          meta: {
            clipboard_data:
              (r = e.content.meta) == null ? void 0 : r[n].clipboard_data,
          },
        };
      }),
    mailable: (e) => ({
      type: "mailable",
      mailable_class: e.content.mailable_class,
      html: e.content.html,
      from: e.content.from,
      subject: e.content.subject,
      to: e.content.to,
      cc: e.content.cc,
      bcc: e.content.bcc,
    }),
    measure: (e) => ({
      type: "measure",
      name: e.content.name,
      is_new_timer: e.content.is_new_timer,
      total_time: e.content.total_time,
      max_memory_usage_during_total_time:
        e.content.max_memory_usage_during_total_time,
      time_since_last_call: e.content.time_since_last_call,
      max_memory_usage_since_last_call: e.content.time_since_last_call,
    }),
    trace: (e) => ({ type: "trace", frames: e.content.frames }),
    table: (e) => ({
      type: "table",
      values: e.content.values,
      label: e.content.label ?? "Table",
    }),
    carbon: (e) => ({
      type: "carbon",
      formatted: e.content.formatted,
      timestamp: e.content.timestamp,
      timezone: e.content.timezone,
    }),
    caller: (e) => ({ type: "caller", frame: e.content.frame }),
    eloquent_model: (e) => ({
      type: "eloquent_model",
      attributes: e.content.attributes,
      relations: e.content.relations,
      class_name: e.content.class_name,
    }),
    application_log: (e) => ({
      type: "application_log",
      value: e.content.value,
      context: e.content.context || void 0,
    }),
    custom: (e) => ({
      type: "custom",
      content: e.content.content,
      label: e.content.label,
    }),
    json: (e) => ({ type: "json", value: e.content.value }),
    json_string: (e) => ({ type: "json_string", value: e.content.value }),
    event: (e) => ({
      type: "event",
      name: e.content.name,
      event: e.content.event,
      payload: e.content.payload,
      class_based_event: e.content.class_based_event,
    }),
    job_event: (e) => ({
      type: "job_event",
      event_name: e.content.event_name,
      job: e.content.job,
      exception: e.content.exception,
    }),
    response: (e) => ({
      type: "response",
      status_code: e.content.status_code,
      headers: e.content.headers,
      content: e.content.content,
      json: e.content.json,
    }),
    executed_query: (e) => ({
      type: "executed_query",
      content: e.content.sql,
      connectionName: e.content.connection_name ?? "",
      duration: e.content.time,
      bindings: e.content.bindings,
    }),
    view: (e) => ({
      type: "view",
      view_path: e.content.view_path,
      view_path_relative_to_project_root:
        e.content.view_path_relative_to_project_root,
      data: e.content.data,
    }),
    exception: (e) => {
      const t = e.content.frames[0];
      return {
        type: "exception",
        class: e.content.class,
        message: e.content.message,
        frames: e.content.frames,
        meta: e.content.meta,
        lineNumber: t.line_number,
        fileName: t.file_name.substring(t.file_name.lastIndexOf("/") + 1),
        path: t.file_name,
      };
    },
    separator: () => ({ type: "separator" }),
    create_lock: (e) => ({ type: "lock", lockName: e.content.name }),
  },
  h1 = new Map();
function jae(e) {
  h1.set(e.name, e);
}
function Mae(e, t) {
  const n = h1.get(e);
  n && ((n.active = !1), (n.stop_execution = t));
}
function oT(e) {
  const t = h1.get(e);
  return (
    t || {
      name: e,
      active: !1,
      stop_execution: !1,
      displayed_on_group_uuid: "",
    }
  );
}
xe.ipcMain.on("deactivate-lock", (e, { lockName: t, stopExecution: n }) => {
  Mae(t, n);
});
xe.ipcMain.handle("get-lock", (e, t) => oT(t));
const Hae = {
  hide:
    () =>
    ({ screen: e, groupUuid: t }) => {
      if (!e.groups.has(t)) return;
      const n = e.groups.get(t);
      n.collapsed = !0;
    },
  remove:
    () =>
    ({ screen: e, groupUuid: t }) => {
      e.groups.has(t) && e.groups.delete(t);
    },
  notify:
    (e) =>
    ({ window: t }) => {
      const n = new xe.Notification({ title: "Ray", body: e.content.value });
      n.on("click", () => {
        t.window.show();
      }),
        n.show();
    },
  color:
    (e) =>
    ({ screen: t, groupUuid: n }) => {
      if (!t.groups.has(n)) return;
      const r = t.groups.get(n);
      r.color = e.content.color;
    },
  size:
    (e) =>
    ({ screen: t, groupUuid: n }) => {
      if (!t.groups.has(n)) return;
      t.groups.get(n).items.forEach((i) => (i.style.text = e.content.size));
    },
  label:
    (e) =>
    ({ screen: t, groupUuid: n }) => {
      if (!t.groups.has(n)) return;
      t.groups.get(n).items.forEach((i) => (i.label = e.content.label));
    },
  screen_color:
    (e) =>
    ({ screen: t }) => {
      t.color = e.content.color;
    },
  show_app:
    () =>
    ({ window: e }) => {
      e.window.show();
    },
  hide_app:
    () =>
    ({ window: e }) => {
      e.window.hide();
    },
  confetti:
    () =>
    ({ window: e }) => {
      e.window.webContents.send("shoot-confetti");
    },
  create_lock:
    (e) =>
    ({ groupUuid: t }) => {
      const n = {
        name: e.content.name,
        active: !0,
        stop_execution: !1,
        displayed_on_group_uuid: t,
      };
      jae(n);
    },
  expand:
    (e) =>
    ({ screen: t, groupUuid: n }) => {
      if (!t.groups.has(n)) return;
      t.groups.get(n).items.forEach((i) => (i.expand = e.content));
    },
};
function qae(e) {
  return { groupUuid: e.uuid, time: new Date().toTimeString().slice(0, 8) };
}
function Gae(e) {
  return {
    path: e.origin.file,
    lineNumber: e.origin.line_number,
    hostname: e.origin.hostname === Fr.hostname() ? void 0 : e.origin.hostname,
    fileName: e.origin
      ? e.origin.file.substring(e.origin.file.lastIndexOf("/") + 1)
      : "",
  };
}
function Qae(e, t) {
  const n = Fae[e.type],
    r = Hae[e.type];
  let i, a;
  if ((r && (i = r(e)), n)) {
    const s = Gae(e);
    let o = n(e);
    Array.isArray(o) || (o = [o]),
      (a = o.map((c) => ({
        id: Math.random(),
        style: { color: "gray", text: "" },
        ...t,
        ...s,
        ...c,
      })));
  }
  return i || a
    ? { action: i, items: a }
    : (console.error("Payload type not recognised:", e.type, e), {});
}
function cI(e, t) {
  return e.type === t;
}
function Wae(e, t) {
  let n = [],
    r = [];
  const i = qae(e);
  e.payloads.forEach((a) => {
    if (cI(a, "new_screen")) {
      th(t, a.content.name);
      return;
    }
    if (cI(a, "clear_all")) {
      aT(t);
      return;
    }
    const { items: s, action: o } = Qae(a, i);
    s && n.push(...s), o && r.push(o);
  }),
    Gee(n) && zae(n, t),
    r.length > 0 &&
      r.forEach((a) => {
        a({
          window: t,
          screen: t.screens[t.activeScreenIndex],
          groupUuid: e.uuid,
        });
      });
}
function zae(e, t) {
  const n = e[0].groupUuid,
    r = t.screens[t.activeScreenIndex];
  if (r.groups.has(n)) {
    r.groups.get(n).items = e;
    return;
  }
  r.groups.set(n, { uuid: n, items: e, collapsed: !1, color: "gray" });
  const a =
    t.screens.reduce((s, o) => s + o.groups.size, 0) - rt.historyLimit();
  a > 0 && Kae(t, a);
}
function Kae(e, t) {
  for (; t > 0; ) {
    console.log(e.screens);
    const n = e.screens[0].groups.size;
    if (n > t) {
      const r = e.screens[0].groups.entries();
      for (let i = 0; i < t; i++) {
        const a = r.next().value[0];
        console.log(`removing key ${i}`, a), e.screens[0].groups.delete(a);
      }
      t = 0;
      return;
    }
    if (e.screens.length === 1) {
      e.screens[0].groups.clear(), (t = 0);
      return;
    }
    e.screens.shift(), e.activeScreenIndex--, (t -= n);
  }
}
let er = null;
function dc() {
  if (er) return er.show();
  (er = new xe.BrowserWindow({ ...Qp(), minHeight: 600, minWidth: 400 })),
    er.on("closed", () => (er = null)),
    Wp(er, { page: "license" }),
    zp(er);
}
function cT() {
  er == null || er.close(), (er = null);
}
xe.ipcMain.on("openLicense", dc);
xe.ipcMain.on("closeLicense", cT);
const Vae = 10;
let Bg = fn.getAmountOfRequests(),
  lT = fn.getHasActiveLicense(),
  uT = fn.getIsLicenseOverlayLocked();
async function Yae() {
  Zae();
  const e = fn.getSignedLicense();
  if (e) {
    await dT(e);
    return;
  }
  pc(!1), dc();
}
function Xae() {
  Bg++, fn.setAmountOfRequests(Bg), !lT && Bg >= Vae && (hT(!0), dc());
}
function fT(e) {
  const t = new YR(e);
  if (
    (fn.store(t),
    er == null || er.webContents.send("setLicense", t),
    !t.isActive())
  ) {
    t.isValid() ||
      (gi("unexpected"),
      Gs.warn("Invalid license", { licenseResponse: e }),
      d1(new Error("Invalid license"), { licenseResponse: e })),
      t.isExpired() && gi("expired"),
      pc(!1),
      dc();
    return;
  }
  pc(!0), hT(!1), cT();
}
async function dT(e) {
  try {
    const t = await Gp.post(`/activations/${e.activation_code}/show`, {
      license_key: e.license_key,
    });
    fn.endGracePeriod(), Y0(null), gi(null), fT(t);
  } catch (t) {
    if ((t == null ? void 0 : t.status) === 404) {
      pc(!1), dc(), gi("notActivated");
      return;
    }
    (t == null ? void 0 : t.message) === "fetch failed" &&
      (gi("networkFailed"), Gs.debug(t));
    const n = fn.getGracePeriod();
    n.isInGracePeriod || fn.startGracePeriod(),
      n.hasGracePeriodExpired && (pc(!1), dc()),
      Y0(fn.getGracePeriod().endOfGracePeriod);
  }
}
async function Jae({ licenseKey: e }) {
  const t = Fr.hostname().trim(),
    n = fn.getSignedLicense();
  gi(null);
  try {
    n && (await pT());
    const r = await Gp.post("/activations", { license_key: e.trim(), name: t });
    fT(r);
  } catch (r) {
    (r == null ? void 0 : r.status) === 404 ||
    (r == null ? void 0 : r.status) === 422
      ? gi("invalid")
      : (gi("unexpected"),
        Gs.warn(r),
        d1(r, {
          request_data: { license_key: e.trim().slice(0, 5), name: t },
        }));
  }
}
async function pT() {
  await fn.delete(), Y0(null), pc(!1), gi(null);
}
function Zae() {
  xe.ipcMain.handle("decoupleLicense", pT),
    xe.ipcMain.handle("submit-license", (e, t) => Jae(t)),
    xe.ipcMain.handle("check-license", async (e) => {
      const t = fn.getSignedLicense();
      if (!t) {
        gi("notActivated");
        return;
      }
      return dT(t);
    });
}
function gi(e) {
  fn.setErrorMessage(e);
}
function Y0(e) {
  fn.setEndOfGracePeriod(e);
}
function pc(e) {
  (lT = e), fn.setHasActiveLicense(e);
}
function hT(e) {
  (uT = e),
    fn.setIsLicenseOverlayLocked(e),
    er && (e ? (er.closable = !1) : (er.closable = !0));
}
const Qs = dD();
Qs.use(kv.json({ limit: "4000mb" }));
Qs.use(kv.urlencoded({ limit: "4000mb", extended: !0 }));
Qs.use(kv.text({ limit: "4000mb" }));
Qs.use(kD());
let jo,
  lI = !1;
const Mo = {};
function uI(e, t) {
  if (!Mo[e]) return (Mo[e] = [t]);
  Mo[e].push(t);
}
function ese(e) {
  const t = Mo[e.windowName] ?? [];
  delete Mo[e.windowName], t.forEach((n) => gT(e, n));
}
function tse() {
  Qs.post("/", (e, t) => {
    tte(), Xae();
    let n;
    const r = rt.newWindow(),
      i = e.body.payloads[0].origin.hostname,
      a = e.body.meta.project_name;
    let s = `${i || "0"}-${a || "0"}`;
    const o = Rs.find((c) => c.hostname === i);
    if (!lI && !o) {
      if (Yt[0].isPaused) return;
      (Yt[0].projectName = a),
        (Yt[0].hostname = i),
        Yt[0].window.webContents.send("updateProjectName", a),
        (lI = !0);
    }
    if (r === "never") n = Yt[0];
    else {
      if (
        (r === "project"
          ? (n = Yt.find((c) => c.hostname === i && c.projectName === a))
          : r === "server" && (n = Yt.find((c) => c.hostname === i)),
        !n)
      )
        return (
          iT({ windowName: s, projectName: a, hostname: i, remoteServer: o }),
          uI(s, e.body),
          t.send("ok")
        );
      if (Mo[s]) return uI(s, e.body), t.send("ok");
    }
    gT(n, e.body), t.send("ok");
  }),
    Qs.get("/locks/:lockName", async (e, t) => {
      const n = e.params.lockName,
        r = oT(n);
      console.log(r), t.send(r);
    }),
    mT(),
    jo.on("listening", () => {
      const e = jo.address().port;
      console.info(`Listening on port ${e}...`);
    }),
    jo.on("error", (e) => {
      const t = e;
      t.code === "EADDRINUSE" && console.error(`port ${t.port} already in use`);
    });
}
function mT() {
  const e = rt.port();
  jo = (jo || Qs).listen(e);
}
function nse() {
  jo.close(() => mT());
}
function gT(e, t) {
  !e.isPaused && !uT && (Wae(t, e), ts(e));
}
let Ia;
function rse() {
  const e =
    process.env.NODE_ENV === "development"
      ? `${xe.app.getAppPath()}/resources/extraFiles/tray/trayTemplate@2x.png`
      : pt.join(process.resourcesPath, "tray/trayTemplate@2x.png");
  return (
    (Ia = new xe.Tray(xe.nativeImage.createFromPath(e))),
    Ia.setIgnoreDoubleClickEvents(!0),
    Ia.on("click", () =>
      xe.BrowserWindow.getAllWindows().forEach((t) => t.show()),
    ),
    Ia.on("right-click", function () {
      const t = [
        {
          label: "Show/Hide Ray",
          accelerator: "CmdOrCtrl+H",
          click: () => {
            const n = Yt.some(({ window: r }) => r.isFocused());
            xe.BrowserWindow.getAllWindows().forEach((r) =>
              n ? r.hide() : r.show(),
            );
          },
        },
        {
          label: "Reset to center of screen",
          accelerator: "CmdOrCtrl+Shift+R",
          click: () => {
            xe.BrowserWindow.getAllWindows().forEach((n) => {
              n == null || n.center(), n == null || n.show();
            });
          },
        },
        { label: "Preferences", accelerator: "CmdOrCtrl+,", click: WR },
        { role: "quit", accelerator: "CmdOrCtrl+Q" },
      ];
      Ia == null || Ia.popUpContextMenu(xe.Menu.buildFromTemplate(t));
    }),
    Ia
  );
}
function ise() {
  if (xe.app.runningUnderARM64Translation && Fr.platform() === "darwin") {
    const e = ["Download now", "No thanks"];
    xe.dialog
      .showMessageBox({
        title: "Rosetta",
        message:
          "It appears that you are running the Intel version of Ray in ARM64 Translation (Rosetta). The Apple Silicon version of the app is now available, and should bring huge performance improvements. Get it at https://myray.app",
        buttons: e,
      })
      .then((t) => {
        (t == null ? void 0 : t.response) !== void 0 &&
          e[t.response] === "Download now" &&
          xe.shell.openExternal(
            "https://spatie.be/products/ray/download/macosAppleSilicon/latest",
          );
      });
  }
}
function ase() {
  (Gs.transports.file.level = "debug"),
    (vs.autoUpdater.logger = Gs),
    vs.autoUpdater.on("update-downloaded", (e) => {
      const t = {
        type: "info",
        buttons: ["Restart", "Later"],
        title: "Application Update",
        message: process.platform === "win32" ? e.releaseNotes : e.releaseName,
        detail: `A new version (${e.version}) has been downloaded. Restart Ray to apply the updates.`,
      };
      xe.dialog.showMessageBox(t).then((n) => {
        n.response === 0 &&
          ((vs.autoUpdater.autoInstallOnAppQuit = !1),
          vs.autoUpdater.quitAndInstall());
      });
    }),
    vs.autoUpdater.checkForUpdatesAndNotify().then((e) => {
      !e ||
        !(
          (e == null ? void 0 : e.updateInfo.version) !== xe.app.getVersion()
        ) ||
        console.log(
          "A new version is available, it will be downloaded in the background.",
        );
    });
}
process.env.DIST_ELECTRON = Gl.join(__dirname, "../");
process.env.DIST = Gl.join(process.env.DIST_ELECTRON, "../dist");
process.env.PUBLIC = process.env.VITE_DEV_SERVER_URL
  ? Gl.join(process.env.DIST_ELECTRON, "../public")
  : process.env.DIST;
fI.release().startsWith("6.1") && xe.app.disableHardwareAcceleration();
process.platform === "win32" && xe.app.setAppUserModelId(xe.app.getName());
xe.app.requestSingleInstanceLock()
  ? xe.app.on("second-instance", () => {
      Yt[0].window.show();
    })
  : xe.app.quit();
xe.app.whenReady().then(async () => {
  Jee(),
    Bae(),
    ase(),
    await Yae(),
    iT({ windowName: 0 }),
    tse(),
    rse(),
    Vee(),
    qp(),
    ise();
});
xe.app.on("activate", () => {
  var e;
  (e = Yt[0]) == null || e.window.show();
});
